URL: https://developer.movementnetwork.xyz/learning-paths
Advanced Move
Advanced Move
Take your understanding of Move to the next level with advanced concepts. Learn about storage operations, resource management, and smart object design to build robust applications on the Movement ecosystem.
Take your understanding of Move to the next level with advanced concepts. Learn about storage operations, resource management, and smart object design to build robust applications on the Movement ecosystem.
1
2
3
4
1
2
3
4
1
1
2
2
3
3
4
4
Basic Concepts
Dive into the core principles of the Move Language. Learn the essential syntax, explore key data structures, and start mastering the fundamental concepts of the Move Language.
What you will learn:
Data Types
Functions
Resources
Conditionals and Loops
Constants and Error Handling
Generics Type & Phantom Type
Unit Test
Advanced Move
Take your understanding of Move to the next level with advanced concepts. Learn about storage operations, resource management, and smart object design to build robust applications on the Movement ecosystem.
What you will learn:
Local Storage & Global Storage Operations
Deploy & Call function on-chain
Writing/Reading resources to user accounts
Destroying a resource
Resource Groups
Events
Objects
Smart Vector
Smart Tables
Resources Account
Creating NFTs using Resource Accounts
NFT
Explore the world of digital assets by creating and managing NFTs. Learn how to mint NFTs, modify token metadata, manage collections, and enforce royalty rules using the Move language.
What you will learn:
Insight into Non-Fungible Tokens
Collection
Token Standard & Mint your NFT
Token Metadata & Modifying Data
Aptos Collection & Token V2
Managed Collection
Royalty & Property Map
Permission to mint NFTs
DeFi
Learn how to create and manage coins, swap tokens, and provide liquidity. Explore lending protocols, pool types, and liquidation processes in the DeFi space.
What you will learn:
What is Coin?
Initialize Coin
Transfer, Withdraw, Deposit & Burn Coin
What is DEX & Constant Product Formula
How to Create a Pool
Add Liquidity Pool using Constant Product Formula
Swap Token
What is lending & borrowing in Web3 Domain?
Types of Lending Pools
Isolated Pool
Main Pool
Leverage Pool
Liquidation
Basic Concepts
Dive into the core principles of the Move Language. Learn the essential syntax, explore key data structures, and start mastering the fundamental concepts of the Move Language.
What you will learn:
Data Types
Functions
Resources
Conditionals and Loops
Constants and Error Handling
Generics Type & Phantom Type
Unit Test
Basic Concepts
Dive into the core principles of the Move Language. Learn the essential syntax, explore key data structures, and start mastering the fundamental concepts of the Move Language.
What you will learn:
Data Types
Functions
Resources
Conditionals and Loops
Constants and Error Handling
Generics Type & Phantom Type
Unit Test
Basic Concepts
Dive into the core principles of the Move Language. Learn the essential syntax, explore key data structures, and start mastering the fundamental concepts of the Move Language.
Basic Concepts
Dive into the core principles of the Move Language. Learn the essential syntax, explore key data structures, and start mastering the fundamental concepts of the Move Language.
Basic Concepts
Basic Concepts
Dive into the core principles of the Move Language. Learn the essential syntax, explore key data structures, and start mastering the fundamental concepts of the Move Language.
Dive into the core principles of the Move Language. Learn the essential syntax, explore key data structures, and start mastering the fundamental concepts of the Move Language.
What you will learn:
Data Types
Functions
Resources
Conditionals and Loops
Constants and Error Handling
Generics Type & Phantom Type
Unit Test
What you will learn:
What you will learn:
Data Types
Functions
Resources
Conditionals and Loops
Constants and Error Handling
Generics Type & Phantom Type
Unit Test
Data Types
Data Types
Functions
Functions
Resources
Resources
Conditionals and Loops
Conditionals and Loops
Constants and Error Handling
Constants and Error Handling
Generics Type & Phantom Type
Generics Type & Phantom Type
Unit Test
Unit Test
Advanced Move
Take your understanding of Move to the next level with advanced concepts. Learn about storage operations, resource management, and smart object design to build robust applications on the Movement ecosystem.
What you will learn:
Local Storage & Global Storage Operations
Deploy & Call function on-chain
Writing/Reading resources to user accounts
Destroying a resource
Resource Groups
Events
Objects
Smart Vector
Smart Tables
Resources Account
Creating NFTs using Resource Accounts
Advanced Move
Take your understanding of Move to the next level with advanced concepts. Learn about storage operations, resource management, and smart object design to build robust applications on the Movement ecosystem.
What you will learn:
Local Storage & Global Storage Operations
Deploy & Call function on-chain
Writing/Reading resources to user accounts
Destroying a resource
Resource Groups
Events
Objects
Smart Vector
Smart Tables
Resources Account
Creating NFTs using Resource Accounts
Advanced Move
Take your understanding of Move to the next level with advanced concepts. Learn about storage operations, resource management, and smart object design to build robust applications on the Movement ecosystem.
Advanced Move
Take your understanding of Move to the next level with advanced concepts. Learn about storage operations, resource management, and smart object design to build robust applications on the Movement ecosystem.
Advanced Move
Advanced Move
Take your understanding of Move to the next level with advanced concepts. Learn about storage operations, resource management, and smart object design to build robust applications on the Movement ecosystem.
Take your understanding of Move to the next level with advanced concepts. Learn about storage operations, resource management, and smart object design to build robust applications on the Movement ecosystem.
What you will learn:
Local Storage & Global Storage Operations
Deploy & Call function on-chain
Writing/Reading resources to user accounts
Destroying a resource
Resource Groups
Events
Objects
Smart Vector
Smart Tables
Resources Account
Creating NFTs using Resource Accounts
What you will learn:
What you will learn:
Local Storage & Global Storage Operations
Deploy & Call function on-chain
Writing/Reading resources to user accounts
Destroying a resource
Resource Groups
Events
Objects
Smart Vector
Smart Tables
Resources Account
Creating NFTs using Resource Accounts
Local Storage & Global Storage Operations
Local Storage & Global Storage Operations
Deploy & Call function on-chain
Deploy & Call function on-chain
Writing/Reading resources to user accounts
Writing/Reading resources to user accounts
Destroying a resource
Destroying a resource
Resource Groups
Resource Groups
Events
Events
Objects
Objects
Smart Vector
Smart Vector
Smart Tables
Smart Tables
Resources Account
Resources Account
Creating NFTs using Resource Accounts
Creating NFTs using Resource Accounts
NFT
Explore the world of digital assets by creating and managing NFTs. Learn how to mint NFTs, modify token metadata, manage collections, and enforce royalty rules using the Move language.
What you will learn:
Insight into Non-Fungible Tokens
Collection
Token Standard & Mint your NFT
Token Metadata & Modifying Data
Aptos Collection & Token V2
Managed Collection
Royalty & Property Map
Permission to mint NFTs
NFT
Explore the world of digital assets by creating and managing NFTs. Learn how to mint NFTs, modify token metadata, manage collections, and enforce royalty rules using the Move language.
What you will learn:
Insight into Non-Fungible Tokens
Collection
Token Standard & Mint your NFT
Token Metadata & Modifying Data
Aptos Collection & Token V2
Managed Collection
Royalty & Property Map
Permission to mint NFTs
NFT
Explore the world of digital assets by creating and managing NFTs. Learn how to mint NFTs, modify token metadata, manage collections, and enforce royalty rules using the Move language.
NFT
Explore the world of digital assets by creating and managing NFTs. Learn how to mint NFTs, modify token metadata, manage collections, and enforce royalty rules using the Move language.
NFT
NFT
Explore the world of digital assets by creating and managing NFTs. Learn how to mint NFTs, modify token metadata, manage collections, and enforce royalty rules using the Move language.
Explore the world of digital assets by creating and managing NFTs. Learn how to mint NFTs, modify token metadata, manage collections, and enforce royalty rules using the Move language.
What you will learn:
Insight into Non-Fungible Tokens
Collection
Token Standard & Mint your NFT
Token Metadata & Modifying Data
Aptos Collection & Token V2
Managed Collection
Royalty & Property Map
Permission to mint NFTs
What you will learn:
What you will learn:
Insight into Non-Fungible Tokens
Collection
Token Standard & Mint your NFT
Token Metadata & Modifying Data
Aptos Collection & Token V2
Managed Collection
Royalty & Property Map
Permission to mint NFTs
Insight into Non-Fungible Tokens
Insight into Non-Fungible Tokens
Collection
Collection
Token Standard & Mint your NFT
Token Standard & Mint your NFT
Token Metadata & Modifying Data
Token Metadata & Modifying Data
Aptos Collection & Token V2
Aptos Collection & Token V2
Managed Collection
Managed Collection
Royalty & Property Map
Royalty & Property Map
Permission to mint NFTs
Permission to mint NFTs
DeFi
Learn how to create and manage coins, swap tokens, and provide liquidity. Explore lending protocols, pool types, and liquidation processes in the DeFi space.
What you will learn:
What is Coin?
Initialize Coin
Transfer, Withdraw, Deposit & Burn Coin
What is DEX & Constant Product Formula
How to Create a Pool
Add Liquidity Pool using Constant Product Formula
Swap Token
What is lending & borrowing in Web3 Domain?
Types of Lending Pools
Isolated Pool
Main Pool
Leverage Pool
Liquidation
DeFi
Learn how to create and manage coins, swap tokens, and provide liquidity. Explore lending protocols, pool types, and liquidation processes in the DeFi space.
What you will learn:
What is Coin?
Initialize Coin
Transfer, Withdraw, Deposit & Burn Coin
What is DEX & Constant Product Formula
How to Create a Pool
Add Liquidity Pool using Constant Product Formula
Swap Token
What is lending & borrowing in Web3 Domain?
Types of Lending Pools
Isolated Pool
Main Pool
Leverage Pool
Liquidation
DeFi
Learn how to create and manage coins, swap tokens, and provide liquidity. Explore lending protocols, pool types, and liquidation processes in the DeFi space.
DeFi
Learn how to create and manage coins, swap tokens, and provide liquidity. Explore lending protocols, pool types, and liquidation processes in the DeFi space.
DeFi
DeFi
Learn how to create and manage coins, swap tokens, and provide liquidity. Explore lending protocols, pool types, and liquidation processes in the DeFi space.
Learn how to create and manage coins, swap tokens, and provide liquidity. Explore lending protocols, pool types, and liquidation processes in the DeFi space.
What you will learn:
What is Coin?
Initialize Coin
Transfer, Withdraw, Deposit & Burn Coin
What is DEX & Constant Product Formula
How to Create a Pool
Add Liquidity Pool using Constant Product Formula
Swap Token
What is lending & borrowing in Web3 Domain?
Types of Lending Pools
Isolated Pool
Main Pool
Leverage Pool
Liquidation
What you will learn:
What you will learn:
What is Coin?
Initialize Coin
Transfer, Withdraw, Deposit & Burn Coin
What is DEX & Constant Product Formula
How to Create a Pool
Add Liquidity Pool using Constant Product Formula
Swap Token
What is lending & borrowing in Web3 Domain?
Types of Lending Pools
Isolated Pool
Main Pool
Leverage Pool
Liquidation
What is Coin?
What is Coin?
Initialize Coin
Initialize Coin
Transfer, Withdraw, Deposit & Burn Coin
Transfer, Withdraw, Deposit & Burn Coin
What is DEX & Constant Product Formula
What is DEX & Constant Product Formula
How to Create a Pool
How to Create a Pool
Add Liquidity Pool using Constant Product Formula
Add Liquidity Pool using Constant Product Formula
Swap Token
Swap Token
What is lending & borrowing in Web3 Domain?
What is lending & borrowing in Web3 Domain?
Types of Lending Pools
Types of Lending Pools
Isolated Pool
Isolated Pool
Main Pool
Main Pool
Leverage Pool
Leverage Pool
Liquidation
Liquidation

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts
Basic Concepts
Basic Concepts
Dive into the core principles of the Move Language. Learn the essential syntax, explore key data structures, and start mastering the fundamental concepts of the Move Language.
Dive into the core principles of the Move Language. Learn the essential syntax, explore key data structures, and start mastering the fundamental concepts of the Move Language.
Start
Start
Install Movement CLI
Start
Data Types
Start
Functions, view Functions & Visibility
Start
Resources on Move & Ability of Resource
Start
Conditionals & Loops
Start
Constants & Error Handling
Start
Generics Type & Phantom Type
Start
Unit Test
Start
Install Movement CLI
Start
Install Movement CLI
Start
Install Movement CLI
Install Movement CLI
Start
Start
Data Types
Start
Data Types
Start
Data Types
Data Types
Start
Start
Functions, view Functions & Visibility
Start
Functions, view Functions & Visibility
Start
Functions, view Functions & Visibility
Functions, view Functions & Visibility
Start
Start
Resources on Move & Ability of Resource
Start
Resources on Move & Ability of Resource
Start
Resources on Move & Ability of Resource
Resources on Move & Ability of Resource
Start
Start
Conditionals & Loops
Start
Conditionals & Loops
Start
Conditionals & Loops
Conditionals & Loops
Start
Start
Constants & Error Handling
Start
Constants & Error Handling
Start
Constants & Error Handling
Constants & Error Handling
Start
Start
Generics Type & Phantom Type
Start
Generics Type & Phantom Type
Start
Generics Type & Phantom Type
Generics Type & Phantom Type
Start
Start
Unit Test
Start
Unit Test
Start
Unit Test
Unit Test
Start
Start

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/01-install-movement-cli
Install Movement CLI
Install Movement CLI
On This Page
Install Movement CLI via build from source (Linux/MacOS)
Install
Check
Build, Test & Call function on Movement
Set up Development Environment
Faucet Move Token
Initialize your Move project
Implement Code
Publish Contract & Interact on Blockchain
Call function with Movement CLI
Prerequisites:
Install
Rust Programming Language
Git
Cmake
LLVM
libssl-dev
and
libclang-dev
Install Movement CLI via build from source (Linux/MacOS)
See Details Here
Install
Step 1: Clone the Aptos-core repo & go into the newly created directory
git clone https://github.com/movementlabsxyz/aptos-core.git && cd aptos-core
Step 2: Install all prerequites using automatic script
Using the Automatic Script to install prerequisites
./scripts/dev_setup.sh
Update your current shell environment
source ~/.cargo/env
Ensure you have
cargo
installed by following this commands:
cargo --version
Step 3: Build the CLI tool
cargo build -p movement
The binary will be available at
target/debug/movement
Step 4: Move this executable to a place in your path
sudo cp target/debug/movement /opt/homebrew/bin/
Check
movement --help
Result
Command Line Interface (CLI) for developing and interacting with the Movement blockchain
Usage: movement <COMMAND>
Commands:
  account     Tool for interacting with accounts
  config      Tool for interacting with configuration of the Movement CLI tool
  genesis     Tool for setting up an Movement chain Genesis transaction
  governance  Tool for on-chain governance
  info        Show build information about the CLI
  init        Tool to initialize current directory for the movement tool
  key         Tool for generating, inspecting, and interacting with keys
  move        Tool for Move smart contract related operations
  multisig    Tool for interacting with multisig accounts
  node        Tool for operations related to nodes
  stake       Tool for manipulating stake and stake pools
  update      Update the CLI or other tools it depends on
  help        Print this message or the help of the given subcommand(s)
Options:
  -h, --help     Print help
  -V, --version  Print version
Build, Test & Call function on Movement
Ensure you have the ClI installed
Set up Development Environment
Initialize your Aptos profile for package development and add Movement as a custom network
movement init --network custom --rest-url https://aptos.testnet.porto.movementlabs.xyz/v1 --faucet-url   https://fund.testnet.porto.movementlabs.xyz
Currently, we'll skip the faucet stage in the CLI and instead execute this through the UI via this
link
.
Sucess Result:
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.porto.movementlabs.xyz/v1
Not configuring a faucet because --skip-faucet was provided
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Movement CLI is now set up for account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586?network=custom
 Run `movement --help` for more information about commands
{
  "Result": "Success"
}
Here you need to pay attention to the Account that was created:
0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
After completing this process, a folder named
.movement
containing a
config.yaml
file will appear in your directory. All the information you previously generated will be stored in this
config.yaml
file.
Faucet Move Token
To execute transactions on the Movement blockchain, you'll need Move Tokens to pay for transaction fees. You can obtain free Move tokens from the faucet UI using this link:
Use the address generated in the file
.movement/config.yaml
Afterwards, you can verify your token balance using the following command:
movement account balance --account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
The result below confirms that you now possess 1 Move token
{
  "Result": [
    {
      "asset_type": "coin",
      "coin_type": "0x1::aptos_coin::AptosCoin",
      "balance": 100000000
    }
  ]
}
Initialize your Move project
You can easily initialize a default project source code using the following command:
movement move init --name hello_movement
After initializing the Move source code, your folder will contain the following files and directories:
├── .movement/config.yaml
├── Move.toml
├── scripts
├── sources
└── tests
The key file to pay attention to is Move.toml
[package] # Includes packages metadata such as name version
name = "hello_movement"
version = "1.0.0"
authors = []
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
[dev-addresses]
# Multiline Style
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
You will copy and paste the previously generated account address into the [addresses] section to publish your contract to that address.
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
Implement Code
Create your
.move
contract file in the
/sources
folder.
├── .aptos/config.yaml
├── Move.toml
├── scripts
├── sources
│   └── hello_world.move
└── tests
/sources/hello_world.move
module movement::hello_world {
    use std::string::{String, utf8};
    use std::debug::print;
    struct MoveResource has key {
        string: String
    }
    public entry fun create_first_resource(caller: &signer) {
        let greeting: String = utf8(b"Hello World!!!");
        print(&greeting);
        move_to(caller, MoveResource {
            string: greeting
        });
    }
    #[test(caller = @0x1)]
    fun test_create_first_resource(caller: &signer) {
        create_first_resource(caller);
    }
}
Building & Testing Contact
movement move build
Result:
{
  "Result": [
    "3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world",
  ]
}
Testing:
movement move test --filter hello_world
Result:
Running Move unit tests
[debug] "Hello World!!!"
[ PASS ] 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::test_create_first_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Publish Contract & Interact on Blockchain
You can deploy your contract (modules) to the Movement blockchain using the following command:
movement move publish
Success Result
Transaction submitted: https://explorer.aptoslabs.com/txn/0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f?network=devnet
{
  "Result": {
    "transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f",
    "gas_used": 7260,
    "gas_unit_price": 100,
    "sender": "122d28da2607724405a4691e35f7fad06667ec32229781f8994c70f24ec59c58",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727944927400079,
    "version": 84201807,
    "vm_status": "Executed successfully"
  }
}
You can use the
transaction hash
to search for your contract on the Movement explorer:
"transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f"
Alternatively, you can search for the account you generated earlier to view the modules you have deployed.
In each module, you can call the available functions to test or verify them directly through the user interface.
Call function with Movement CLI
You can easily use the CLI to call functions on the blockchain after publishing, without needing to access the explorer, by using the
movement move run
command
movement move run --function-id "<module_onwer_address>::<module_name>>::<function_name>" --args <type>:<value> --sender-account <address_account>
In the case of the
hello_world
module, we can call it through the CLI as follows:
movement move run "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::create_first_resource"
On This Page
Install Movement CLI via build from source (Linux/MacOS)
Install
Check
Build, Test & Call function on Movement
Set up Development Environment
Faucet Move Token
Initialize your Move project
Implement Code
Publish Contract & Interact on Blockchain
Call function with Movement CLI
On This Page
Install Movement CLI via build from source (Linux/MacOS)
Install
Check
Build, Test & Call function on Movement
Set up Development Environment
Faucet Move Token
Initialize your Move project
Implement Code
Publish Contract & Interact on Blockchain
Call function with Movement CLI
			On This Page
			On This Page
			Install Movement CLI via build from source (Linux/MacOS)
Install
Check
Build, Test & Call function on Movement
Set up Development Environment
Faucet Move Token
Initialize your Move project
Implement Code
Publish Contract & Interact on Blockchain
Call function with Movement CLI
			Install Movement CLI via build from source (Linux/MacOS)
Install
Check
			Install Movement CLI via build from source (Linux/MacOS)
			Install Movement CLI via build from source (Linux/MacOS)
			Install Movement CLI via build from source (Linux/MacOS)
			Install
Check
			Install
			Install
			Install
			Install
			Check
			Check
			Check
			Check
			Build, Test & Call function on Movement
Set up Development Environment
Faucet Move Token
Initialize your Move project
Implement Code
Publish Contract & Interact on Blockchain
			Build, Test & Call function on Movement
			Build, Test & Call function on Movement
			Build, Test & Call function on Movement
			Set up Development Environment
Faucet Move Token
Initialize your Move project
Implement Code
Publish Contract & Interact on Blockchain
			Set up Development Environment
			Set up Development Environment
			Set up Development Environment
			Set up Development Environment
			Faucet Move Token
			Faucet Move Token
			Faucet Move Token
			Faucet Move Token
			Initialize your Move project
			Initialize your Move project
			Initialize your Move project
			Initialize your Move project
			Implement Code
			Implement Code
			Implement Code
			Implement Code
			Publish Contract & Interact on Blockchain
			Publish Contract & Interact on Blockchain
			Publish Contract & Interact on Blockchain
			Publish Contract & Interact on Blockchain
			Call function with Movement CLI
			Call function with Movement CLI
			Call function with Movement CLI
			Call function with Movement CLI
			Prerequisites:
Install
Rust Programming Language
Git
Cmake
LLVM
libssl-dev
and
libclang-dev
Install Movement CLI via build from source (Linux/MacOS)
See Details Here
Install
Step 1: Clone the Aptos-core repo & go into the newly created directory
git clone https://github.com/movementlabsxyz/aptos-core.git && cd aptos-core
Step 2: Install all prerequites using automatic script
Using the Automatic Script to install prerequisites
./scripts/dev_setup.sh
Update your current shell environment
source ~/.cargo/env
Ensure you have
cargo
installed by following this commands:
cargo --version
Step 3: Build the CLI tool
cargo build -p movement
The binary will be available at
target/debug/movement
Step 4: Move this executable to a place in your path
sudo cp target/debug/movement /opt/homebrew/bin/
Check
movement --help
Result
Command Line Interface (CLI) for developing and interacting with the Movement blockchain
Usage: movement <COMMAND>
Commands:
  account     Tool for interacting with accounts
  config      Tool for interacting with configuration of the Movement CLI tool
  genesis     Tool for setting up an Movement chain Genesis transaction
  governance  Tool for on-chain governance
  info        Show build information about the CLI
  init        Tool to initialize current directory for the movement tool
  key         Tool for generating, inspecting, and interacting with keys
  move        Tool for Move smart contract related operations
  multisig    Tool for interacting with multisig accounts
  node        Tool for operations related to nodes
  stake       Tool for manipulating stake and stake pools
  update      Update the CLI or other tools it depends on
  help        Print this message or the help of the given subcommand(s)
Options:
  -h, --help     Print help
  -V, --version  Print version
Build, Test & Call function on Movement
Ensure you have the ClI installed
Set up Development Environment
Initialize your Aptos profile for package development and add Movement as a custom network
movement init --network custom --rest-url https://aptos.testnet.porto.movementlabs.xyz/v1 --faucet-url   https://fund.testnet.porto.movementlabs.xyz
Currently, we'll skip the faucet stage in the CLI and instead execute this through the UI via this
link
.
Sucess Result:
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.porto.movementlabs.xyz/v1
Not configuring a faucet because --skip-faucet was provided
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Movement CLI is now set up for account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586?network=custom
 Run `movement --help` for more information about commands
{
  "Result": "Success"
}
Here you need to pay attention to the Account that was created:
0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
After completing this process, a folder named
.movement
containing a
config.yaml
file will appear in your directory. All the information you previously generated will be stored in this
config.yaml
file.
Faucet Move Token
To execute transactions on the Movement blockchain, you'll need Move Tokens to pay for transaction fees. You can obtain free Move tokens from the faucet UI using this link:
Use the address generated in the file
.movement/config.yaml
Afterwards, you can verify your token balance using the following command:
movement account balance --account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
The result below confirms that you now possess 1 Move token
{
  "Result": [
    {
      "asset_type": "coin",
      "coin_type": "0x1::aptos_coin::AptosCoin",
      "balance": 100000000
    }
  ]
}
Initialize your Move project
You can easily initialize a default project source code using the following command:
movement move init --name hello_movement
After initializing the Move source code, your folder will contain the following files and directories:
├── .movement/config.yaml
├── Move.toml
├── scripts
├── sources
└── tests
The key file to pay attention to is Move.toml
[package] # Includes packages metadata such as name version
name = "hello_movement"
version = "1.0.0"
authors = []
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
[dev-addresses]
# Multiline Style
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
You will copy and paste the previously generated account address into the [addresses] section to publish your contract to that address.
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
Implement Code
Create your
.move
contract file in the
/sources
folder.
├── .aptos/config.yaml
├── Move.toml
├── scripts
├── sources
│   └── hello_world.move
└── tests
/sources/hello_world.move
module movement::hello_world {
    use std::string::{String, utf8};
    use std::debug::print;
    struct MoveResource has key {
        string: String
    }
    public entry fun create_first_resource(caller: &signer) {
        let greeting: String = utf8(b"Hello World!!!");
        print(&greeting);
        move_to(caller, MoveResource {
            string: greeting
        });
    }
    #[test(caller = @0x1)]
    fun test_create_first_resource(caller: &signer) {
        create_first_resource(caller);
    }
}
Building & Testing Contact
movement move build
Result:
{
  "Result": [
    "3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world",
  ]
}
Testing:
movement move test --filter hello_world
Result:
Running Move unit tests
[debug] "Hello World!!!"
[ PASS ] 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::test_create_first_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Publish Contract & Interact on Blockchain
You can deploy your contract (modules) to the Movement blockchain using the following command:
movement move publish
Success Result
Transaction submitted: https://explorer.aptoslabs.com/txn/0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f?network=devnet
{
  "Result": {
    "transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f",
    "gas_used": 7260,
    "gas_unit_price": 100,
    "sender": "122d28da2607724405a4691e35f7fad06667ec32229781f8994c70f24ec59c58",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727944927400079,
    "version": 84201807,
    "vm_status": "Executed successfully"
  }
}
You can use the
transaction hash
to search for your contract on the Movement explorer:
"transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f"
Alternatively, you can search for the account you generated earlier to view the modules you have deployed.
In each module, you can call the available functions to test or verify them directly through the user interface.
Call function with Movement CLI
You can easily use the CLI to call functions on the blockchain after publishing, without needing to access the explorer, by using the
movement move run
command
movement move run --function-id "<module_onwer_address>::<module_name>>::<function_name>" --args <type>:<value> --sender-account <address_account>
In the case of the
hello_world
module, we can call it through the CLI as follows:
movement move run "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::create_first_resource"
			Prerequisites:
Install
Rust Programming Language
Git
Cmake
LLVM
libssl-dev
and
libclang-dev
Install Movement CLI via build from source (Linux/MacOS)
See Details Here
Install
Step 1: Clone the Aptos-core repo & go into the newly created directory
git clone https://github.com/movementlabsxyz/aptos-core.git && cd aptos-core
Step 2: Install all prerequites using automatic script
Using the Automatic Script to install prerequisites
./scripts/dev_setup.sh
Update your current shell environment
source ~/.cargo/env
Ensure you have
cargo
installed by following this commands:
cargo --version
Step 3: Build the CLI tool
cargo build -p movement
The binary will be available at
target/debug/movement
Step 4: Move this executable to a place in your path
sudo cp target/debug/movement /opt/homebrew/bin/
Check
movement --help
Result
Command Line Interface (CLI) for developing and interacting with the Movement blockchain
Usage: movement <COMMAND>
Commands:
  account     Tool for interacting with accounts
  config      Tool for interacting with configuration of the Movement CLI tool
  genesis     Tool for setting up an Movement chain Genesis transaction
  governance  Tool for on-chain governance
  info        Show build information about the CLI
  init        Tool to initialize current directory for the movement tool
  key         Tool for generating, inspecting, and interacting with keys
  move        Tool for Move smart contract related operations
  multisig    Tool for interacting with multisig accounts
  node        Tool for operations related to nodes
  stake       Tool for manipulating stake and stake pools
  update      Update the CLI or other tools it depends on
  help        Print this message or the help of the given subcommand(s)
Options:
  -h, --help     Print help
  -V, --version  Print version
Build, Test & Call function on Movement
Ensure you have the ClI installed
Set up Development Environment
Initialize your Aptos profile for package development and add Movement as a custom network
movement init --network custom --rest-url https://aptos.testnet.porto.movementlabs.xyz/v1 --faucet-url   https://fund.testnet.porto.movementlabs.xyz
Currently, we'll skip the faucet stage in the CLI and instead execute this through the UI via this
link
.
Sucess Result:
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.porto.movementlabs.xyz/v1
Not configuring a faucet because --skip-faucet was provided
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Movement CLI is now set up for account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586?network=custom
 Run `movement --help` for more information about commands
{
  "Result": "Success"
}
Here you need to pay attention to the Account that was created:
0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
After completing this process, a folder named
.movement
containing a
config.yaml
file will appear in your directory. All the information you previously generated will be stored in this
config.yaml
file.
Faucet Move Token
To execute transactions on the Movement blockchain, you'll need Move Tokens to pay for transaction fees. You can obtain free Move tokens from the faucet UI using this link:
Use the address generated in the file
.movement/config.yaml
Afterwards, you can verify your token balance using the following command:
movement account balance --account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
The result below confirms that you now possess 1 Move token
{
  "Result": [
    {
      "asset_type": "coin",
      "coin_type": "0x1::aptos_coin::AptosCoin",
      "balance": 100000000
    }
  ]
}
Initialize your Move project
You can easily initialize a default project source code using the following command:
movement move init --name hello_movement
After initializing the Move source code, your folder will contain the following files and directories:
├── .movement/config.yaml
├── Move.toml
├── scripts
├── sources
└── tests
The key file to pay attention to is Move.toml
[package] # Includes packages metadata such as name version
name = "hello_movement"
version = "1.0.0"
authors = []
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
[dev-addresses]
# Multiline Style
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
You will copy and paste the previously generated account address into the [addresses] section to publish your contract to that address.
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
Implement Code
Create your
.move
contract file in the
/sources
folder.
├── .aptos/config.yaml
├── Move.toml
├── scripts
├── sources
│   └── hello_world.move
└── tests
/sources/hello_world.move
module movement::hello_world {
    use std::string::{String, utf8};
    use std::debug::print;
    struct MoveResource has key {
        string: String
    }
    public entry fun create_first_resource(caller: &signer) {
        let greeting: String = utf8(b"Hello World!!!");
        print(&greeting);
        move_to(caller, MoveResource {
            string: greeting
        });
    }
    #[test(caller = @0x1)]
    fun test_create_first_resource(caller: &signer) {
        create_first_resource(caller);
    }
}
Building & Testing Contact
movement move build
Result:
{
  "Result": [
    "3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world",
  ]
}
Testing:
movement move test --filter hello_world
Result:
Running Move unit tests
[debug] "Hello World!!!"
[ PASS ] 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::test_create_first_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Publish Contract & Interact on Blockchain
You can deploy your contract (modules) to the Movement blockchain using the following command:
movement move publish
Success Result
Transaction submitted: https://explorer.aptoslabs.com/txn/0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f?network=devnet
{
  "Result": {
    "transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f",
    "gas_used": 7260,
    "gas_unit_price": 100,
    "sender": "122d28da2607724405a4691e35f7fad06667ec32229781f8994c70f24ec59c58",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727944927400079,
    "version": 84201807,
    "vm_status": "Executed successfully"
  }
}
You can use the
transaction hash
to search for your contract on the Movement explorer:
"transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f"
Alternatively, you can search for the account you generated earlier to view the modules you have deployed.
In each module, you can call the available functions to test or verify them directly through the user interface.
Call function with Movement CLI
You can easily use the CLI to call functions on the blockchain after publishing, without needing to access the explorer, by using the
movement move run
command
movement move run --function-id "<module_onwer_address>::<module_name>>::<function_name>" --args <type>:<value> --sender-account <address_account>
In the case of the
hello_world
module, we can call it through the CLI as follows:
movement move run "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::create_first_resource"
			Prerequisites:
Install
Rust Programming Language
Git
Cmake
LLVM
libssl-dev
and
libclang-dev
Install Movement CLI via build from source (Linux/MacOS)
See Details Here
Install
Step 1: Clone the Aptos-core repo & go into the newly created directory
git clone https://github.com/movementlabsxyz/aptos-core.git && cd aptos-core
Step 2: Install all prerequites using automatic script
Using the Automatic Script to install prerequisites
./scripts/dev_setup.sh
Update your current shell environment
source ~/.cargo/env
Ensure you have
cargo
installed by following this commands:
cargo --version
Step 3: Build the CLI tool
cargo build -p movement
The binary will be available at
target/debug/movement
Step 4: Move this executable to a place in your path
sudo cp target/debug/movement /opt/homebrew/bin/
Check
movement --help
Result
Command Line Interface (CLI) for developing and interacting with the Movement blockchain
Usage: movement <COMMAND>
Commands:
  account     Tool for interacting with accounts
  config      Tool for interacting with configuration of the Movement CLI tool
  genesis     Tool for setting up an Movement chain Genesis transaction
  governance  Tool for on-chain governance
  info        Show build information about the CLI
  init        Tool to initialize current directory for the movement tool
  key         Tool for generating, inspecting, and interacting with keys
  move        Tool for Move smart contract related operations
  multisig    Tool for interacting with multisig accounts
  node        Tool for operations related to nodes
  stake       Tool for manipulating stake and stake pools
  update      Update the CLI or other tools it depends on
  help        Print this message or the help of the given subcommand(s)
Options:
  -h, --help     Print help
  -V, --version  Print version
Build, Test & Call function on Movement
Ensure you have the ClI installed
Set up Development Environment
Initialize your Aptos profile for package development and add Movement as a custom network
movement init --network custom --rest-url https://aptos.testnet.porto.movementlabs.xyz/v1 --faucet-url   https://fund.testnet.porto.movementlabs.xyz
Currently, we'll skip the faucet stage in the CLI and instead execute this through the UI via this
link
.
Sucess Result:
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.porto.movementlabs.xyz/v1
Not configuring a faucet because --skip-faucet was provided
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Movement CLI is now set up for account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586?network=custom
 Run `movement --help` for more information about commands
{
  "Result": "Success"
}
Here you need to pay attention to the Account that was created:
0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
After completing this process, a folder named
.movement
containing a
config.yaml
file will appear in your directory. All the information you previously generated will be stored in this
config.yaml
file.
Faucet Move Token
To execute transactions on the Movement blockchain, you'll need Move Tokens to pay for transaction fees. You can obtain free Move tokens from the faucet UI using this link:
Use the address generated in the file
.movement/config.yaml
Afterwards, you can verify your token balance using the following command:
movement account balance --account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
The result below confirms that you now possess 1 Move token
{
  "Result": [
    {
      "asset_type": "coin",
      "coin_type": "0x1::aptos_coin::AptosCoin",
      "balance": 100000000
    }
  ]
}
Initialize your Move project
You can easily initialize a default project source code using the following command:
movement move init --name hello_movement
After initializing the Move source code, your folder will contain the following files and directories:
├── .movement/config.yaml
├── Move.toml
├── scripts
├── sources
└── tests
The key file to pay attention to is Move.toml
[package] # Includes packages metadata such as name version
name = "hello_movement"
version = "1.0.0"
authors = []
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
[dev-addresses]
# Multiline Style
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
You will copy and paste the previously generated account address into the [addresses] section to publish your contract to that address.
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
Implement Code
Create your
.move
contract file in the
/sources
folder.
├── .aptos/config.yaml
├── Move.toml
├── scripts
├── sources
│   └── hello_world.move
└── tests
/sources/hello_world.move
module movement::hello_world {
    use std::string::{String, utf8};
    use std::debug::print;
    struct MoveResource has key {
        string: String
    }
    public entry fun create_first_resource(caller: &signer) {
        let greeting: String = utf8(b"Hello World!!!");
        print(&greeting);
        move_to(caller, MoveResource {
            string: greeting
        });
    }
    #[test(caller = @0x1)]
    fun test_create_first_resource(caller: &signer) {
        create_first_resource(caller);
    }
}
Building & Testing Contact
movement move build
Result:
{
  "Result": [
    "3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world",
  ]
}
Testing:
movement move test --filter hello_world
Result:
Running Move unit tests
[debug] "Hello World!!!"
[ PASS ] 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::test_create_first_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Publish Contract & Interact on Blockchain
You can deploy your contract (modules) to the Movement blockchain using the following command:
movement move publish
Success Result
Transaction submitted: https://explorer.aptoslabs.com/txn/0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f?network=devnet
{
  "Result": {
    "transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f",
    "gas_used": 7260,
    "gas_unit_price": 100,
    "sender": "122d28da2607724405a4691e35f7fad06667ec32229781f8994c70f24ec59c58",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727944927400079,
    "version": 84201807,
    "vm_status": "Executed successfully"
  }
}
You can use the
transaction hash
to search for your contract on the Movement explorer:
"transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f"
Alternatively, you can search for the account you generated earlier to view the modules you have deployed.
In each module, you can call the available functions to test or verify them directly through the user interface.
Call function with Movement CLI
You can easily use the CLI to call functions on the blockchain after publishing, without needing to access the explorer, by using the
movement move run
command
movement move run --function-id "<module_onwer_address>::<module_name>>::<function_name>" --args <type>:<value> --sender-account <address_account>
In the case of the
hello_world
module, we can call it through the CLI as follows:
movement move run "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::create_first_resource"
			Prerequisites:
Install
Rust Programming Language
Git
Cmake
LLVM
libssl-dev
and
libclang-dev
			Prerequisites:
Install
Rust Programming Language
Git
Cmake
LLVM
libssl-dev
and
libclang-dev
			Prerequisites:
			Install
Rust Programming Language
Git
Cmake
LLVM
libssl-dev
and
libclang-dev
			Install
Rust Programming Language
			Install
			Rust Programming Language
			Rust Programming Language
			Git
			Git
			Git
			Cmake
			Cmake
			Cmake
			LLVM
			LLVM
			LLVM
			libssl-dev
and
libclang-dev
			libssl-dev
			libssl-dev
			and
			libclang-dev
			libclang-dev
	Install Movement CLI via build from source (Linux/MacOS)
	Install Movement CLI via build from source (Linux/MacOS)
	See Details Here
	See Details Here
	See Details Here
		Install
		Install
		Step 1: Clone the Aptos-core repo & go into the newly created directory
git clone https://github.com/movementlabsxyz/aptos-core.git && cd aptos-core
Step 2: Install all prerequites using automatic script
Using the Automatic Script to install prerequisites
./scripts/dev_setup.sh
Update your current shell environment
source ~/.cargo/env
Ensure you have
cargo
installed by following this commands:
cargo --version
Step 3: Build the CLI tool
cargo build -p movement
		Step 1: Clone the Aptos-core repo & go into the newly created directory
git clone https://github.com/movementlabsxyz/aptos-core.git && cd aptos-core
		Step 1: Clone the Aptos-core repo & go into the newly created directory
		Step 1: Clone the Aptos-core repo & go into the newly created directory
		<code>git clone https://github.com/movementlabsxyz/aptos-core.git && cd aptos-core</code>
		<code>git clone https://github.com/movementlabsxyz/aptos-core.git && cd aptos-core</code>
		git clone https://github.com/movementlabsxyz/aptos-core.git && cd aptos-core
		Step 2: Install all prerequites using automatic script
Using the Automatic Script to install prerequisites
./scripts/dev_setup.sh
Update your current shell environment
source ~/.cargo/env
Ensure you have
cargo
installed by following this commands:
cargo --version
		Step 2: Install all prerequites using automatic script
		Step 2: Install all prerequites using automatic script
		Using the Automatic Script to install prerequisites
./scripts/dev_setup.sh
Update your current shell environment
source ~/.cargo/env
Ensure you have
cargo
installed by following this commands:
cargo --version
		Using the Automatic Script to install prerequisites
./scripts/dev_setup.sh
		Using the Automatic Script to install prerequisites
		Using the Automatic Script to install prerequisites
		<code>./scripts/dev_setup.sh</code>
		<code>./scripts/dev_setup.sh</code>
		./scripts/dev_setup.sh
		Update your current shell environment
source ~/.cargo/env
		Update your current shell environment
		Update your current shell environment
		<code>source ~/.cargo/env</code>
		<code>source ~/.cargo/env</code>
		source ~/.cargo/env
		Ensure you have
cargo
installed by following this commands:
cargo --version
		Ensure you have
cargo
installed by following this commands:
		Ensure you have
		<code>cargo</code>
		cargo
		installed by following this commands:
		<code>cargo --version</code>
		<code>cargo --version</code>
		cargo --version
		Step 3: Build the CLI tool
cargo build -p movement
		Step 3: Build the CLI tool
		Step 3: Build the CLI tool
		<code>cargo build -p movement</code>
		<code>cargo build -p movement</code>
		cargo build -p movement
		The binary will be available at
target/debug/movement
		The binary will be available at
target/debug/movement
		The binary will be available at
		<code>target/debug/movement</code>
		target/debug/movement
		Step 4: Move this executable to a place in your path
sudo cp target/debug/movement /opt/homebrew/bin/
		Step 4: Move this executable to a place in your path
sudo cp target/debug/movement /opt/homebrew/bin/
		Step 4: Move this executable to a place in your path
		Step 4: Move this executable to a place in your path
		<code>sudo cp target/debug/movement /opt/homebrew/bin/</code>
		<code>sudo cp target/debug/movement /opt/homebrew/bin/</code>
		sudo cp target/debug/movement /opt/homebrew/bin/
		Check
		Check
		<code>movement --help</code>
		<code>movement --help</code>
		movement --help
		Result
		Result
		Result
		<code>Command Line Interface (CLI) for developing and interacting with the Movement blockchain
Usage: movement <COMMAND>
Commands:
  account     Tool for interacting with accounts
  config      Tool for interacting with configuration of the Movement CLI tool
  genesis     Tool for setting up an Movement chain Genesis transaction
  governance  Tool for on-chain governance
  info        Show build information about the CLI
  init        Tool to initialize current directory for the movement tool
  key         Tool for generating, inspecting, and interacting with keys
  move        Tool for Move smart contract related operations
  multisig    Tool for interacting with multisig accounts
  node        Tool for operations related to nodes
  stake       Tool for manipulating stake and stake pools
  update      Update the CLI or other tools it depends on
  help        Print this message or the help of the given subcommand(s)
Options:
  -h, --help     Print help
  -V, --version  Print version</code>
		<code>Command Line Interface (CLI) for developing and interacting with the Movement blockchain
Usage: movement <COMMAND>
Commands:
  account     Tool for interacting with accounts
  config      Tool for interacting with configuration of the Movement CLI tool
  genesis     Tool for setting up an Movement chain Genesis transaction
  governance  Tool for on-chain governance
  info        Show build information about the CLI
  init        Tool to initialize current directory for the movement tool
  key         Tool for generating, inspecting, and interacting with keys
  move        Tool for Move smart contract related operations
  multisig    Tool for interacting with multisig accounts
  node        Tool for operations related to nodes
  stake       Tool for manipulating stake and stake pools
  update      Update the CLI or other tools it depends on
  help        Print this message or the help of the given subcommand(s)
Options:
  -h, --help     Print help
  -V, --version  Print version</code>
		Command Line Interface (CLI) for developing and interacting with the Movement blockchain
Usage: movement <COMMAND>
Commands:
  account     Tool for interacting with accounts
  config      Tool for interacting with configuration of the Movement CLI tool
  genesis     Tool for setting up an Movement chain Genesis transaction
  governance  Tool for on-chain governance
  info        Show build information about the CLI
  init        Tool to initialize current directory for the movement tool
  key         Tool for generating, inspecting, and interacting with keys
  move        Tool for Move smart contract related operations
  multisig    Tool for interacting with multisig accounts
  node        Tool for operations related to nodes
  stake       Tool for manipulating stake and stake pools
  update      Update the CLI or other tools it depends on
  help        Print this message or the help of the given subcommand(s)
Options:
  -h, --help     Print help
  -V, --version  Print version
	Build, Test & Call function on Movement
	Build, Test & Call function on Movement
	Ensure you have the ClI installed
	Ensure you have the ClI installed
	Ensure you have the ClI installed
		Set up Development Environment
		Set up Development Environment
		Initialize your Aptos profile for package development and add Movement as a custom network
movement init --network custom --rest-url https://aptos.testnet.porto.movementlabs.xyz/v1 --faucet-url   https://fund.testnet.porto.movementlabs.xyz
		Initialize your Aptos profile for package development and add Movement as a custom network
movement init --network custom --rest-url https://aptos.testnet.porto.movementlabs.xyz/v1 --faucet-url   https://fund.testnet.porto.movementlabs.xyz
		Initialize your Aptos profile for package development and add Movement as a custom network
		Initialize your Aptos profile for package development and add Movement as a custom network
		<code>movement init --network custom --rest-url https://aptos.testnet.porto.movementlabs.xyz/v1 --faucet-url   https://fund.testnet.porto.movementlabs.xyz</code>
		<code>movement init --network custom --rest-url https://aptos.testnet.porto.movementlabs.xyz/v1 --faucet-url   https://fund.testnet.porto.movementlabs.xyz</code>
		movement init --network custom --rest-url https://aptos.testnet.porto.movementlabs.xyz/v1 --faucet-url   https://fund.testnet.porto.movementlabs.xyz
		Currently, we'll skip the faucet stage in the CLI and instead execute this through the UI via this
link
.
		Currently, we'll skip the faucet stage in the CLI and instead execute this through the UI via this
link
.
		Currently, we'll skip the faucet stage in the CLI and instead execute this through the UI via this
		link
		link
		.
		Sucess Result:
		Sucess Result:
		Sucess Result:
		<code>Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.porto.movementlabs.xyz/v1
Not configuring a faucet because --skip-faucet was provided
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Movement CLI is now set up for account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586?network=custom
 Run `movement --help` for more information about commands
{
  "Result": "Success"
}</code>
		<code>Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.porto.movementlabs.xyz/v1
Not configuring a faucet because --skip-faucet was provided
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Movement CLI is now set up for account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586?network=custom
 Run `movement --help` for more information about commands
{
  "Result": "Success"
}</code>
		Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.porto.movementlabs.xyz/v1
Not configuring a faucet because --skip-faucet was provided
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Movement CLI is now set up for account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586?network=custom
 Run `movement --help` for more information about commands
{
  "Result": "Success"
}
		Here you need to pay attention to the Account that was created:
0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
		Here you need to pay attention to the Account that was created:
0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
		Here you need to pay attention to the Account that was created:
		<code>0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586</code>
		0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
		<code>No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain</code>
		<code>No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain</code>
		No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has been initialized locally, but you must transfer coins to it to create the account onchain
		After completing this process, a folder named
.movement
containing a
config.yaml
file will appear in your directory. All the information you previously generated will be stored in this
config.yaml
file.
		After completing this process, a folder named
		<code>.movement</code>
		.movement
		containing a
		<code>config.yaml</code>
		config.yaml
		file will appear in your directory. All the information you previously generated will be stored in this
		<code>config.yaml</code>
		config.yaml
		file.
		Faucet Move Token
		Faucet Move Token
		To execute transactions on the Movement blockchain, you'll need Move Tokens to pay for transaction fees. You can obtain free Move tokens from the faucet UI using this link:
		To execute transactions on the Movement blockchain, you'll need Move Tokens to pay for transaction fees. You can obtain free Move tokens from the faucet UI using this link:
		Use the address generated in the file
.movement/config.yaml
Afterwards, you can verify your token balance using the following command:
movement account balance --account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
The result below confirms that you now possess 1 Move token
{
  "Result": [
    {
      "asset_type": "coin",
      "coin_type": "0x1::aptos_coin::AptosCoin",
      "balance": 100000000
    }
  ]
}
		Use the address generated in the file
.movement/config.yaml
		Use the address generated in the file
.movement/config.yaml
		Use the address generated in the file
		<code>.movement/config.yaml</code>
		.movement/config.yaml
		Afterwards, you can verify your token balance using the following command:
movement account balance --account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
The result below confirms that you now possess 1 Move token
{
  "Result": [
    {
      "asset_type": "coin",
      "coin_type": "0x1::aptos_coin::AptosCoin",
      "balance": 100000000
    }
  ]
}
		Afterwards, you can verify your token balance using the following command:
		Afterwards, you can verify your token balance using the following command:
		<code>movement account balance --account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586</code>
		<code>movement account balance --account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586</code>
		movement account balance --account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
		The result below confirms that you now possess 1 Move token
		The result below confirms that you now possess 1 Move token
		The result below confirms that you now possess 1 Move token
		<code>{
  "Result": [
    {
      "asset_type": "coin",
      "coin_type": "0x1::aptos_coin::AptosCoin",
      "balance": 100000000
    }
  ]
}</code>
		<code>{
  "Result": [
    {
      "asset_type": "coin",
      "coin_type": "0x1::aptos_coin::AptosCoin",
      "balance": 100000000
    }
  ]
}</code>
		{
  "Result": [
    {
      "asset_type": "coin",
      "coin_type": "0x1::aptos_coin::AptosCoin",
      "balance": 100000000
    }
  ]
}
		Initialize your Move project
		Initialize your Move project
		You can easily initialize a default project source code using the following command:
		You can easily initialize a default project source code using the following command:
		<code>movement move init --name hello_movement</code>
		<code>movement move init --name hello_movement</code>
		movement move init --name hello_movement
		After initializing the Move source code, your folder will contain the following files and directories:
		After initializing the Move source code, your folder will contain the following files and directories:
		<code>├── .movement/config.yaml
├── Move.toml
├── scripts
├── sources
└── tests</code>
		<code>├── .movement/config.yaml
├── Move.toml
├── scripts
├── sources
└── tests</code>
		├── .movement/config.yaml
├── Move.toml
├── scripts
├── sources
└── tests
		The key file to pay attention to is Move.toml
		The key file to pay attention to is Move.toml
		<code>[package] # Includes packages metadata such as name version
name = "hello_movement"
version = "1.0.0"
authors = []
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
[dev-addresses]
# Multiline Style
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]</code>
		<code>[package] # Includes packages metadata such as name version
name = "hello_movement"
version = "1.0.0"
authors = []
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
[dev-addresses]
# Multiline Style
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]</code>
		[package] # Includes packages metadata such as name version
name = "hello_movement"
version = "1.0.0"
authors = []
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
[dev-addresses]
# Multiline Style
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
		You will copy and paste the previously generated account address into the [addresses] section to publish your contract to that address.
		You will copy and paste the previously generated account address into the [addresses] section to publish your contract to that address.
		<code>[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"</code>
		<code>[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"</code>
		[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
		Implement Code
		Implement Code
		Create your
.move
contract file in the
/sources
folder.
		Create your
		<code>.move</code>
		.move
		contract file in the
		<code>/sources</code>
		/sources
		folder.
		<code>├── .aptos/config.yaml
├── Move.toml
├── scripts
├── sources
│   └── hello_world.move
└── tests</code>
		<code>├── .aptos/config.yaml
├── Move.toml
├── scripts
├── sources
│   └── hello_world.move
└── tests</code>
		├── .aptos/config.yaml
├── Move.toml
├── scripts
├── sources
│   └── hello_world.move
└── tests
		/sources/hello_world.move
		/sources/hello_world.move
		<code>/sources/hello_world.move</code>
		/sources/hello_world.move
		<code>module movement::hello_world {
    use std::string::{String, utf8};
    use std::debug::print;
    struct MoveResource has key {
        string: String
    }
    public entry fun create_first_resource(caller: &signer) {
        let greeting: String = utf8(b"Hello World!!!");
        print(&greeting);
        move_to(caller, MoveResource {
            string: greeting
        });
    }
    #[test(caller = @0x1)]
    fun test_create_first_resource(caller: &signer) {
        create_first_resource(caller);
    }
}</code>
		<code>module movement::hello_world {
    use std::string::{String, utf8};
    use std::debug::print;
    struct MoveResource has key {
        string: String
    }
    public entry fun create_first_resource(caller: &signer) {
        let greeting: String = utf8(b"Hello World!!!");
        print(&greeting);
        move_to(caller, MoveResource {
            string: greeting
        });
    }
    #[test(caller = @0x1)]
    fun test_create_first_resource(caller: &signer) {
        create_first_resource(caller);
    }
}</code>
		module movement::hello_world {
    use std::string::{String, utf8};
    use std::debug::print;
    struct MoveResource has key {
        string: String
    }
    public entry fun create_first_resource(caller: &signer) {
        let greeting: String = utf8(b"Hello World!!!");
        print(&greeting);
        move_to(caller, MoveResource {
            string: greeting
        });
    }
    #[test(caller = @0x1)]
    fun test_create_first_resource(caller: &signer) {
        create_first_resource(caller);
    }
}
		Building & Testing Contact
movement move build
Result:
{
  "Result": [
    "3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world",
  ]
}
Testing:
movement move test --filter hello_world
Result:
Running Move unit tests
[debug] "Hello World!!!"
[ PASS ] 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::test_create_first_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
		Building & Testing Contact
movement move build
Result:
{
  "Result": [
    "3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world",
  ]
}
		Building & Testing Contact
		Building & Testing Contact
		<code>movement move build</code>
		<code>movement move build</code>
		movement move build
		Result:
		Result:
		<code>{
  "Result": [
    "3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world",
  ]
}</code>
		<code>{
  "Result": [
    "3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world",
  ]
}</code>
		{
  "Result": [
    "3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world",
  ]
}
		Testing:
movement move test --filter hello_world
Result:
Running Move unit tests
[debug] "Hello World!!!"
[ PASS ] 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::test_create_first_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
		Testing:
		Testing:
		<code>movement move test --filter hello_world</code>
		<code>movement move test --filter hello_world</code>
		movement move test --filter hello_world
		Result:
		Result:
		<code>Running Move unit tests
[debug] "Hello World!!!"
[ PASS ] 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::test_create_first_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
		<code>Running Move unit tests
[debug] "Hello World!!!"
[ PASS ] 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::test_create_first_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
		Running Move unit tests
[debug] "Hello World!!!"
[ PASS ] 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::test_create_first_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
		Publish Contract & Interact on Blockchain
		Publish Contract & Interact on Blockchain
		You can deploy your contract (modules) to the Movement blockchain using the following command:
		You can deploy your contract (modules) to the Movement blockchain using the following command:
		<code>movement move publish</code>
		<code>movement move publish</code>
		movement move publish
		Success Result
		Success Result
		<code>Transaction submitted: https://explorer.aptoslabs.com/txn/0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f?network=devnet
{
  "Result": {
    "transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f",
    "gas_used": 7260,
    "gas_unit_price": 100,
    "sender": "122d28da2607724405a4691e35f7fad06667ec32229781f8994c70f24ec59c58",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727944927400079,
    "version": 84201807,
    "vm_status": "Executed successfully"
  }
}</code>
		<code>Transaction submitted: https://explorer.aptoslabs.com/txn/0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f?network=devnet
{
  "Result": {
    "transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f",
    "gas_used": 7260,
    "gas_unit_price": 100,
    "sender": "122d28da2607724405a4691e35f7fad06667ec32229781f8994c70f24ec59c58",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727944927400079,
    "version": 84201807,
    "vm_status": "Executed successfully"
  }
}</code>
		Transaction submitted: https://explorer.aptoslabs.com/txn/0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f?network=devnet
{
  "Result": {
    "transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f",
    "gas_used": 7260,
    "gas_unit_price": 100,
    "sender": "122d28da2607724405a4691e35f7fad06667ec32229781f8994c70f24ec59c58",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727944927400079,
    "version": 84201807,
    "vm_status": "Executed successfully"
  }
}
		You can use the
transaction hash
to search for your contract on the Movement explorer:
		You can use the
		<code>transaction hash</code>
		transaction hash
		to search for your contract on the Movement explorer:
		<code>"transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f"</code>
		<code>"transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f"</code>
		"transaction_hash": "0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f"
		Alternatively, you can search for the account you generated earlier to view the modules you have deployed.
		Alternatively, you can search for the account you generated earlier to view the modules you have deployed.
		In each module, you can call the available functions to test or verify them directly through the user interface.
		In each module, you can call the available functions to test or verify them directly through the user interface.
	Call function with Movement CLI
	Call function with Movement CLI
	You can easily use the CLI to call functions on the blockchain after publishing, without needing to access the explorer, by using the
movement move run
command
	You can easily use the CLI to call functions on the blockchain after publishing, without needing to access the explorer, by using the
	<code>movement move run</code>
	movement move run
	command
	<code>movement move run --function-id "<module_onwer_address>::<module_name>>::<function_name>" --args <type>:<value> --sender-account <address_account></code>
	<code>movement move run --function-id "<module_onwer_address>::<module_name>>::<function_name>" --args <type>:<value> --sender-account <address_account></code>
	movement move run --function-id "<module_onwer_address>::<module_name>>::<function_name>" --args <type>:<value> --sender-account <address_account>
	In the case of the
hello_world
module, we can call it through the CLI as follows:
	In the case of the
	<code>hello_world</code>
	hello_world
	module, we can call it through the CLI as follows:
	<code>movement move run "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::create_first_resource"</code>
	<code>movement move run "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::create_first_resource"</code>
	movement move run "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::create_first_resource"

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/02-data-types
Data Types
Data Types
Start
Start
Integer
Start
Boolean
Start
Address & Signer
Start
String & Vector
Start
Map (Simple Map)
Start
Integer
Start
Integer
Start
Integer
Integer
Start
Start
Boolean
Start
Boolean
Start
Boolean
Boolean
Start
Start
Address & Signer
Start
Address & Signer
Start
Address & Signer
Address & Signer
Start
Start
String & Vector
Start
String & Vector
Start
String & Vector
String & Vector
Start
Start
Map (Simple Map)
Start
Map (Simple Map)
Start
Map (Simple Map)
Map (Simple Map)
Start
Start

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/02-data-types/01-integer
Integer
Integer
On This Page
Summary
Overview
Code Start
Summary
Move supports six unsigned integer types: u8, u16, u32, u64, u128, and u256.
Direct mathematical operations between different integer types are not allowed.
Type casting is necessary when performing operations with different integer types.
It's recommended to cast smaller types to larger types to avoid overflow risks.
The module demonstrates adding a u8 and a u64 by converting u8 to u64.
A test function verifies the addition operation.
The code can be tested using the Move test command.
Overview
Move supports six unsigned integer types:
u8
,
u16
,
u32
,
u64
,
u128
, and
u256
. Values of these types range from 0 to a maximum that depends on the size of the type.
Although math can be done easily among integers of the same type, it's not possible to do math directly between integers of different type
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    // This will error
    x + y // x and y are different types -> failed to compile
}
To make this expression correct, you need to use two identical data types; we will convert one of the two data types to match the other.
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    (x as u64) + y
}
One of the things to pay attention to when using type casting, like the code above, is that we should only cast smaller types to larger types, and not the other way around. This helps to limit the risk of overflow.
Code Start
This code defines a module in Move language that includes a function plus_two_types, which adds a u8 and a u64 after converting the u8 to u64. The module also contains a test function test_plus_two_types that verifies the addition operation.
module movement::integer_module {
    use std::debug::print;
    fun plus_two_integer(x: u64, y: u64): u64 {
        x + y
    }
    fun plus_two_types(x: u8, y: u64): u64 {
        (x as u64) + y
    }
    fun integer_type() {
        let _a: u8 = 0;
        let _b: u16 = 1;
        let _c: u32 = 2;
        let _d: u64 = 3;
        let _e: u128 = 4;
        let _f: u256 = 5;
    }
    #[test]
    fun test_plus_two_types() {
        let result = plus_two_types(5, 100);
        print(&result);
    }
    #[test]
    fun test_show_interger() {
        integer_type();
    }
    #[test]
    fun test_plus_two_integer() {
        let result = plus_two_integer(5, 100);
        print(&result);
    }
}
Execute test in the terminal
movement move test --filter integer_module
Running Move unit tests
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_integer
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_types[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_show_interger
Test result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}
On This Page
Summary
Overview
Code Start
On This Page
Summary
Overview
Code Start
			On This Page
			On This Page
			Summary
Overview
Code Start
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			Code Start
			Code Start
			Code Start
			Code Start
			Summary
Move supports six unsigned integer types: u8, u16, u32, u64, u128, and u256.
Direct mathematical operations between different integer types are not allowed.
Type casting is necessary when performing operations with different integer types.
It's recommended to cast smaller types to larger types to avoid overflow risks.
The module demonstrates adding a u8 and a u64 by converting u8 to u64.
A test function verifies the addition operation.
The code can be tested using the Move test command.
Overview
Move supports six unsigned integer types:
u8
,
u16
,
u32
,
u64
,
u128
, and
u256
. Values of these types range from 0 to a maximum that depends on the size of the type.
Although math can be done easily among integers of the same type, it's not possible to do math directly between integers of different type
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    // This will error
    x + y // x and y are different types -> failed to compile
}
To make this expression correct, you need to use two identical data types; we will convert one of the two data types to match the other.
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    (x as u64) + y
}
One of the things to pay attention to when using type casting, like the code above, is that we should only cast smaller types to larger types, and not the other way around. This helps to limit the risk of overflow.
Code Start
This code defines a module in Move language that includes a function plus_two_types, which adds a u8 and a u64 after converting the u8 to u64. The module also contains a test function test_plus_two_types that verifies the addition operation.
module movement::integer_module {
    use std::debug::print;
    fun plus_two_integer(x: u64, y: u64): u64 {
        x + y
    }
    fun plus_two_types(x: u8, y: u64): u64 {
        (x as u64) + y
    }
    fun integer_type() {
        let _a: u8 = 0;
        let _b: u16 = 1;
        let _c: u32 = 2;
        let _d: u64 = 3;
        let _e: u128 = 4;
        let _f: u256 = 5;
    }
    #[test]
    fun test_plus_two_types() {
        let result = plus_two_types(5, 100);
        print(&result);
    }
    #[test]
    fun test_show_interger() {
        integer_type();
    }
    #[test]
    fun test_plus_two_integer() {
        let result = plus_two_integer(5, 100);
        print(&result);
    }
}
Execute test in the terminal
movement move test --filter integer_module
Running Move unit tests
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_integer
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_types[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_show_interger
Test result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}
			Summary
Move supports six unsigned integer types: u8, u16, u32, u64, u128, and u256.
Direct mathematical operations between different integer types are not allowed.
Type casting is necessary when performing operations with different integer types.
It's recommended to cast smaller types to larger types to avoid overflow risks.
The module demonstrates adding a u8 and a u64 by converting u8 to u64.
A test function verifies the addition operation.
The code can be tested using the Move test command.
Overview
Move supports six unsigned integer types:
u8
,
u16
,
u32
,
u64
,
u128
, and
u256
. Values of these types range from 0 to a maximum that depends on the size of the type.
Although math can be done easily among integers of the same type, it's not possible to do math directly between integers of different type
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    // This will error
    x + y // x and y are different types -> failed to compile
}
To make this expression correct, you need to use two identical data types; we will convert one of the two data types to match the other.
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    (x as u64) + y
}
One of the things to pay attention to when using type casting, like the code above, is that we should only cast smaller types to larger types, and not the other way around. This helps to limit the risk of overflow.
Code Start
This code defines a module in Move language that includes a function plus_two_types, which adds a u8 and a u64 after converting the u8 to u64. The module also contains a test function test_plus_two_types that verifies the addition operation.
module movement::integer_module {
    use std::debug::print;
    fun plus_two_integer(x: u64, y: u64): u64 {
        x + y
    }
    fun plus_two_types(x: u8, y: u64): u64 {
        (x as u64) + y
    }
    fun integer_type() {
        let _a: u8 = 0;
        let _b: u16 = 1;
        let _c: u32 = 2;
        let _d: u64 = 3;
        let _e: u128 = 4;
        let _f: u256 = 5;
    }
    #[test]
    fun test_plus_two_types() {
        let result = plus_two_types(5, 100);
        print(&result);
    }
    #[test]
    fun test_show_interger() {
        integer_type();
    }
    #[test]
    fun test_plus_two_integer() {
        let result = plus_two_integer(5, 100);
        print(&result);
    }
}
Execute test in the terminal
movement move test --filter integer_module
Running Move unit tests
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_integer
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_types[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_show_interger
Test result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}
			Summary
Move supports six unsigned integer types: u8, u16, u32, u64, u128, and u256.
Direct mathematical operations between different integer types are not allowed.
Type casting is necessary when performing operations with different integer types.
It's recommended to cast smaller types to larger types to avoid overflow risks.
The module demonstrates adding a u8 and a u64 by converting u8 to u64.
A test function verifies the addition operation.
The code can be tested using the Move test command.
Overview
Move supports six unsigned integer types:
u8
,
u16
,
u32
,
u64
,
u128
, and
u256
. Values of these types range from 0 to a maximum that depends on the size of the type.
Although math can be done easily among integers of the same type, it's not possible to do math directly between integers of different type
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    // This will error
    x + y // x and y are different types -> failed to compile
}
To make this expression correct, you need to use two identical data types; we will convert one of the two data types to match the other.
fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    (x as u64) + y
}
One of the things to pay attention to when using type casting, like the code above, is that we should only cast smaller types to larger types, and not the other way around. This helps to limit the risk of overflow.
Code Start
This code defines a module in Move language that includes a function plus_two_types, which adds a u8 and a u64 after converting the u8 to u64. The module also contains a test function test_plus_two_types that verifies the addition operation.
module movement::integer_module {
    use std::debug::print;
    fun plus_two_integer(x: u64, y: u64): u64 {
        x + y
    }
    fun plus_two_types(x: u8, y: u64): u64 {
        (x as u64) + y
    }
    fun integer_type() {
        let _a: u8 = 0;
        let _b: u16 = 1;
        let _c: u32 = 2;
        let _d: u64 = 3;
        let _e: u128 = 4;
        let _f: u256 = 5;
    }
    #[test]
    fun test_plus_two_types() {
        let result = plus_two_types(5, 100);
        print(&result);
    }
    #[test]
    fun test_show_interger() {
        integer_type();
    }
    #[test]
    fun test_plus_two_integer() {
        let result = plus_two_integer(5, 100);
        print(&result);
    }
}
Execute test in the terminal
movement move test --filter integer_module
Running Move unit tests
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_integer
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_types[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_show_interger
Test result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}
	Summary
	Summary
	Move supports six unsigned integer types: u8, u16, u32, u64, u128, and u256.
Direct mathematical operations between different integer types are not allowed.
Type casting is necessary when performing operations with different integer types.
It's recommended to cast smaller types to larger types to avoid overflow risks.
The module demonstrates adding a u8 and a u64 by converting u8 to u64.
A test function verifies the addition operation.
The code can be tested using the Move test command.
	Move supports six unsigned integer types: u8, u16, u32, u64, u128, and u256.
	Move supports six unsigned integer types: u8, u16, u32, u64, u128, and u256.
	Direct mathematical operations between different integer types are not allowed.
	Direct mathematical operations between different integer types are not allowed.
	Type casting is necessary when performing operations with different integer types.
	Type casting is necessary when performing operations with different integer types.
	It's recommended to cast smaller types to larger types to avoid overflow risks.
	It's recommended to cast smaller types to larger types to avoid overflow risks.
	The module demonstrates adding a u8 and a u64 by converting u8 to u64.
	The module demonstrates adding a u8 and a u64 by converting u8 to u64.
	A test function verifies the addition operation.
	A test function verifies the addition operation.
	The code can be tested using the Move test command.
	The code can be tested using the Move test command.
	Overview
	Overview
	Move supports six unsigned integer types:
u8
,
u16
,
u32
,
u64
,
u128
, and
u256
. Values of these types range from 0 to a maximum that depends on the size of the type.
	Move supports six unsigned integer types:
	<code>u8</code>
	u8
	,
	<code>u16</code>
	u16
	,
	<code>u32</code>
	u32
	,
	<code>u64</code>
	u64
	,
	<code>u128</code>
	u128
	, and
	<code>u256</code>
	u256
	. Values of these types range from 0 to a maximum that depends on the size of the type.
	Although math can be done easily among integers of the same type, it's not possible to do math directly between integers of different type
	Although math can be done easily among integers of the same type, it's not possible to do math directly between integers of different type
	<code>fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    // This will error
    x + y // x and y are different types -> failed to compile
}</code>
	<code>fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    // This will error
    x + y // x and y are different types -> failed to compile
}</code>
	fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    // This will error
    x + y // x and y are different types -> failed to compile
}
	To make this expression correct, you need to use two identical data types; we will convert one of the two data types to match the other.
	To make this expression correct, you need to use two identical data types; we will convert one of the two data types to match the other.
	<code>fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    (x as u64) + y
}</code>
	<code>fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    (x as u64) + y
}</code>
	fun plus_two_types(): u64 {
    let x: u8 = 10;
    let y: u64 = 60;
    (x as u64) + y
}
	One of the things to pay attention to when using type casting, like the code above, is that we should only cast smaller types to larger types, and not the other way around. This helps to limit the risk of overflow.
	One of the things to pay attention to when using type casting, like the code above, is that we should only cast smaller types to larger types, and not the other way around. This helps to limit the risk of overflow.
	One of the things to pay attention to when using type casting, like the code above, is that we should only cast smaller types to larger types, and not the other way around. This helps to limit the risk of overflow.
Code Start
Code Start
This code defines a module in Move language that includes a function plus_two_types, which adds a u8 and a u64 after converting the u8 to u64. The module also contains a test function test_plus_two_types that verifies the addition operation.
This code defines a module in Move language that includes a function plus_two_types, which adds a u8 and a u64 after converting the u8 to u64. The module also contains a test function test_plus_two_types that verifies the addition operation.
<code>module movement::integer_module {
    use std::debug::print;
    fun plus_two_integer(x: u64, y: u64): u64 {
        x + y
    }
    fun plus_two_types(x: u8, y: u64): u64 {
        (x as u64) + y
    }
    fun integer_type() {
        let _a: u8 = 0;
        let _b: u16 = 1;
        let _c: u32 = 2;
        let _d: u64 = 3;
        let _e: u128 = 4;
        let _f: u256 = 5;
    }
    #[test]
    fun test_plus_two_types() {
        let result = plus_two_types(5, 100);
        print(&result);
    }
    #[test]
    fun test_show_interger() {
        integer_type();
    }
    #[test]
    fun test_plus_two_integer() {
        let result = plus_two_integer(5, 100);
        print(&result);
    }
}</code>
<code>module movement::integer_module {
    use std::debug::print;
    fun plus_two_integer(x: u64, y: u64): u64 {
        x + y
    }
    fun plus_two_types(x: u8, y: u64): u64 {
        (x as u64) + y
    }
    fun integer_type() {
        let _a: u8 = 0;
        let _b: u16 = 1;
        let _c: u32 = 2;
        let _d: u64 = 3;
        let _e: u128 = 4;
        let _f: u256 = 5;
    }
    #[test]
    fun test_plus_two_types() {
        let result = plus_two_types(5, 100);
        print(&result);
    }
    #[test]
    fun test_show_interger() {
        integer_type();
    }
    #[test]
    fun test_plus_two_integer() {
        let result = plus_two_integer(5, 100);
        print(&result);
    }
}</code>
module movement::integer_module {
    use std::debug::print;
    fun plus_two_integer(x: u64, y: u64): u64 {
        x + y
    }
    fun plus_two_types(x: u8, y: u64): u64 {
        (x as u64) + y
    }
    fun integer_type() {
        let _a: u8 = 0;
        let _b: u16 = 1;
        let _c: u32 = 2;
        let _d: u64 = 3;
        let _e: u128 = 4;
        let _f: u256 = 5;
    }
    #[test]
    fun test_plus_two_types() {
        let result = plus_two_types(5, 100);
        print(&result);
    }
    #[test]
    fun test_show_interger() {
        integer_type();
    }
    #[test]
    fun test_plus_two_integer() {
        let result = plus_two_integer(5, 100);
        print(&result);
    }
}
Execute test in the terminal
Execute test in the terminal
Execute test in the terminal
<code>movement move test --filter integer_module</code>
<code>movement move test --filter integer_module</code>
movement move test --filter integer_module
<code>Running Move unit tests
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_integer
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_types[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_show_interger
Test result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}</code>
<code>Running Move unit tests
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_integer
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_types[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_show_interger
Test result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}</code>
Running Move unit tests
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_integer
[debug] 105
[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_plus_two_types[ PASS    ] 0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module::test_show_interger
Test result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/02-data-types/02-boolean
Boolean
Boolean
On This Page
Summary
Overview
Introduction
Declaring Boolean Variables
Example Code
Conclusion
Summary
Boolean is a primitive data type in Move representing true or false values
Essential for implementing logic and controlling program flow
Declared using the bool type (e.g.,
let a: bool = true
)
Used in conditional statements and loops
Can be printed and tested in Move modules
Fundamental for effective programming and robust application development in Move
Overview
Boolean types in Move are a primitive data type that represent two possible values: true and false. They are essential for implementing logic in your programs, allowing you to control the flow of execution based on conditions.
Introduction
In programming, Boolean types are used to represent truth values. They are fundamental in decision-making processes, enabling conditional statements and loops.
Declaring Boolean Variables
You can declare Boolean variables using the bool type. Here’s how to do it:
let a: bool = true;   // Declaration of a Boolean variable with value true
let b: bool = false;  // Declaration of a Boolean variable with value false
Example Code
Here’s the complete example demonstrating the declaration, usage, and testing of Boolean types in Move:
module movement::boolean_type {
    use std::debug::print;
    fun bool_types() {
        let a: bool = true;
        let b: bool = false;
        print(&a);  // Outputs: true
        print(&b);  // Outputs: false
    }
    #[test]
    fun test_bool_types() {
        bool_types();  // Calls the bool_types function to test its output
    }
}
Run test on terminal
movement move test --filter boolean_type
Running Move unit tests
[debug] true
[debug] false
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::MovementModule::test_bool_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Conclusion
Boolean types are a fundamental aspect of programming in Move, enabling developers to implement logic and control flow effectively. Understanding how to declare, use, and test Boolean types will enhance your programming skills and improve your ability to write robust Move applications.
Read more
here
On This Page
Summary
Overview
Introduction
Declaring Boolean Variables
Example Code
Conclusion
On This Page
Summary
Overview
Introduction
Declaring Boolean Variables
Example Code
Conclusion
			On This Page
			On This Page
			Summary
Overview
Introduction
Declaring Boolean Variables
Example Code
Conclusion
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			Introduction
			Introduction
			Introduction
			Introduction
			Declaring Boolean Variables
			Declaring Boolean Variables
			Declaring Boolean Variables
			Declaring Boolean Variables
			Example Code
			Example Code
			Example Code
			Example Code
			Conclusion
			Conclusion
			Conclusion
			Conclusion
			Summary
Boolean is a primitive data type in Move representing true or false values
Essential for implementing logic and controlling program flow
Declared using the bool type (e.g.,
let a: bool = true
)
Used in conditional statements and loops
Can be printed and tested in Move modules
Fundamental for effective programming and robust application development in Move
Overview
Boolean types in Move are a primitive data type that represent two possible values: true and false. They are essential for implementing logic in your programs, allowing you to control the flow of execution based on conditions.
Introduction
In programming, Boolean types are used to represent truth values. They are fundamental in decision-making processes, enabling conditional statements and loops.
Declaring Boolean Variables
You can declare Boolean variables using the bool type. Here’s how to do it:
let a: bool = true;   // Declaration of a Boolean variable with value true
let b: bool = false;  // Declaration of a Boolean variable with value false
Example Code
Here’s the complete example demonstrating the declaration, usage, and testing of Boolean types in Move:
module movement::boolean_type {
    use std::debug::print;
    fun bool_types() {
        let a: bool = true;
        let b: bool = false;
        print(&a);  // Outputs: true
        print(&b);  // Outputs: false
    }
    #[test]
    fun test_bool_types() {
        bool_types();  // Calls the bool_types function to test its output
    }
}
Run test on terminal
movement move test --filter boolean_type
Running Move unit tests
[debug] true
[debug] false
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::MovementModule::test_bool_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Conclusion
Boolean types are a fundamental aspect of programming in Move, enabling developers to implement logic and control flow effectively. Understanding how to declare, use, and test Boolean types will enhance your programming skills and improve your ability to write robust Move applications.
Read more
here
			Summary
Boolean is a primitive data type in Move representing true or false values
Essential for implementing logic and controlling program flow
Declared using the bool type (e.g.,
let a: bool = true
)
Used in conditional statements and loops
Can be printed and tested in Move modules
Fundamental for effective programming and robust application development in Move
Overview
Boolean types in Move are a primitive data type that represent two possible values: true and false. They are essential for implementing logic in your programs, allowing you to control the flow of execution based on conditions.
Introduction
In programming, Boolean types are used to represent truth values. They are fundamental in decision-making processes, enabling conditional statements and loops.
Declaring Boolean Variables
You can declare Boolean variables using the bool type. Here’s how to do it:
let a: bool = true;   // Declaration of a Boolean variable with value true
let b: bool = false;  // Declaration of a Boolean variable with value false
Example Code
Here’s the complete example demonstrating the declaration, usage, and testing of Boolean types in Move:
module movement::boolean_type {
    use std::debug::print;
    fun bool_types() {
        let a: bool = true;
        let b: bool = false;
        print(&a);  // Outputs: true
        print(&b);  // Outputs: false
    }
    #[test]
    fun test_bool_types() {
        bool_types();  // Calls the bool_types function to test its output
    }
}
Run test on terminal
movement move test --filter boolean_type
Running Move unit tests
[debug] true
[debug] false
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::MovementModule::test_bool_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Conclusion
Boolean types are a fundamental aspect of programming in Move, enabling developers to implement logic and control flow effectively. Understanding how to declare, use, and test Boolean types will enhance your programming skills and improve your ability to write robust Move applications.
Read more
here
			Summary
Boolean is a primitive data type in Move representing true or false values
Essential for implementing logic and controlling program flow
Declared using the bool type (e.g.,
let a: bool = true
)
Used in conditional statements and loops
Can be printed and tested in Move modules
Fundamental for effective programming and robust application development in Move
Overview
Boolean types in Move are a primitive data type that represent two possible values: true and false. They are essential for implementing logic in your programs, allowing you to control the flow of execution based on conditions.
Introduction
In programming, Boolean types are used to represent truth values. They are fundamental in decision-making processes, enabling conditional statements and loops.
Declaring Boolean Variables
You can declare Boolean variables using the bool type. Here’s how to do it:
let a: bool = true;   // Declaration of a Boolean variable with value true
let b: bool = false;  // Declaration of a Boolean variable with value false
Example Code
Here’s the complete example demonstrating the declaration, usage, and testing of Boolean types in Move:
module movement::boolean_type {
    use std::debug::print;
    fun bool_types() {
        let a: bool = true;
        let b: bool = false;
        print(&a);  // Outputs: true
        print(&b);  // Outputs: false
    }
    #[test]
    fun test_bool_types() {
        bool_types();  // Calls the bool_types function to test its output
    }
}
Run test on terminal
movement move test --filter boolean_type
Running Move unit tests
[debug] true
[debug] false
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::MovementModule::test_bool_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Conclusion
Boolean types are a fundamental aspect of programming in Move, enabling developers to implement logic and control flow effectively. Understanding how to declare, use, and test Boolean types will enhance your programming skills and improve your ability to write robust Move applications.
Read more
here
	Summary
	Summary
	Boolean is a primitive data type in Move representing true or false values
Essential for implementing logic and controlling program flow
Declared using the bool type (e.g.,
let a: bool = true
)
Used in conditional statements and loops
Can be printed and tested in Move modules
Fundamental for effective programming and robust application development in Move
	Boolean is a primitive data type in Move representing true or false values
	Boolean is a primitive data type in Move representing true or false values
	Essential for implementing logic and controlling program flow
	Essential for implementing logic and controlling program flow
	Declared using the bool type (e.g.,
let a: bool = true
)
	Declared using the bool type (e.g.,
	<code>let a: bool = true</code>
	let a: bool = true
	)
	Used in conditional statements and loops
	Used in conditional statements and loops
	Can be printed and tested in Move modules
	Can be printed and tested in Move modules
	Fundamental for effective programming and robust application development in Move
	Fundamental for effective programming and robust application development in Move
	Overview
	Overview
	Boolean types in Move are a primitive data type that represent two possible values: true and false. They are essential for implementing logic in your programs, allowing you to control the flow of execution based on conditions.
	Boolean types in Move are a primitive data type that represent two possible values: true and false. They are essential for implementing logic in your programs, allowing you to control the flow of execution based on conditions.
	Introduction
	Introduction
	In programming, Boolean types are used to represent truth values. They are fundamental in decision-making processes, enabling conditional statements and loops.
	In programming, Boolean types are used to represent truth values. They are fundamental in decision-making processes, enabling conditional statements and loops.
	Declaring Boolean Variables
	Declaring Boolean Variables
	You can declare Boolean variables using the bool type. Here’s how to do it:
	You can declare Boolean variables using the bool type. Here’s how to do it:
	<code>let a: bool = true;   // Declaration of a Boolean variable with value true
let b: bool = false;  // Declaration of a Boolean variable with value false</code>
	<code>let a: bool = true;   // Declaration of a Boolean variable with value true
let b: bool = false;  // Declaration of a Boolean variable with value false</code>
	let a: bool = true;   // Declaration of a Boolean variable with value true
let b: bool = false;  // Declaration of a Boolean variable with value false
	Example Code
	Example Code
	Here’s the complete example demonstrating the declaration, usage, and testing of Boolean types in Move:
	Here’s the complete example demonstrating the declaration, usage, and testing of Boolean types in Move:
	<code>module movement::boolean_type {
    use std::debug::print;
    fun bool_types() {
        let a: bool = true;
        let b: bool = false;
        print(&a);  // Outputs: true
        print(&b);  // Outputs: false
    }
    #[test]
    fun test_bool_types() {
        bool_types();  // Calls the bool_types function to test its output
    }
}</code>
	<code>module movement::boolean_type {
    use std::debug::print;
    fun bool_types() {
        let a: bool = true;
        let b: bool = false;
        print(&a);  // Outputs: true
        print(&b);  // Outputs: false
    }
    #[test]
    fun test_bool_types() {
        bool_types();  // Calls the bool_types function to test its output
    }
}</code>
	module movement::boolean_type {
    use std::debug::print;
    fun bool_types() {
        let a: bool = true;
        let b: bool = false;
        print(&a);  // Outputs: true
        print(&b);  // Outputs: false
    }
    #[test]
    fun test_bool_types() {
        bool_types();  // Calls the bool_types function to test its output
    }
}
	Run test on terminal
	Run test on terminal
	Run test on terminal
	<code>movement move test --filter boolean_type</code>
	<code>movement move test --filter boolean_type</code>
	movement move test --filter boolean_type
	<code>Running Move unit tests
[debug] true
[debug] false
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::MovementModule::test_bool_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	<code>Running Move unit tests
[debug] true
[debug] false
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::MovementModule::test_bool_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	Running Move unit tests
[debug] true
[debug] false
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::MovementModule::test_bool_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
	Conclusion
	Conclusion
	Boolean types are a fundamental aspect of programming in Move, enabling developers to implement logic and control flow effectively. Understanding how to declare, use, and test Boolean types will enhance your programming skills and improve your ability to write robust Move applications.
	Boolean types are a fundamental aspect of programming in Move, enabling developers to implement logic and control flow effectively. Understanding how to declare, use, and test Boolean types will enhance your programming skills and improve your ability to write robust Move applications.
	Read more
here
	Read more
here
	Read more
	here
	here

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/02-data-types/03-address-and-signer
Address & Signer
Address & Signer
On This Page
Address
Summary
Address Overview
Address and Syntax:
Declaring Address Variables
Primary purpose
Signer
Signer Overview
Declaring Signer Variables
Address
Summary
Address is a 256-bit identifier representing locations in global storage in Move.
Addresses can store Modules and Resources, but are intentionally opaque and don't support arithmetic operations.
Address syntax includes named and numerical forms, with @ prefix in expression contexts.
Signer represents authority over blockchain resources and is used for transaction execution.
Signer values are automatically generated by the Move VM and cannot be created through literals.
The
std::signer
module provides utility functions for working with signers.
Addresses are primarily used for global storage operations, while signers are used for transaction authorization.
Address Overview
Address is an integrated data type in Move used to represent locations (sometimes referred to as accounts) in global storage. An address value is a
256-bit
(
32-byte
) identifier. At a specific address, two things can be stored: a
Module
and a
Resource
.
Although an address is a
256-bit
integer, Move addresses are designed to be intentionally opaque; they cannot be derived from integers, do not support arithmetic operations, and cannot be altered. While there may be interesting programs utilizing such features (for example, pointer operators in C serve a similar role), Move does not allow such dynamic behavior as it is designed from the ground up to support static verification.
You can use address values at runtime (address-type values) to access resources at that address. You cannot access modules at runtime through address values.
Address and Syntax:
Addresses have two forms:
named
or
numerical
. The syntax of named addresses follows the same rules as any identifier name in Move. The syntax of numerical addresses is not limited to hexadecimal values, and any valid u256 numeric value can be used as an address value; for example,
40
,
0xCAFE
, and
2024
are all valid numeric address literals.
To distinguish when an address is being used in the context of an expression or not, the syntax for using an address varies depending on the context in which it is used:
When an address is used as an expression, it must be prefixed by the character @, for example:
@<numerical_value>
or
@<named_address_identifier>
.
Outside of expression contexts, an address can be written without the prefix @, for example:
<numerical_value>
or
<named_address_identifier>
.
Declaring Address Variables
let addr1: address = @0x1;      //numerical address example
let addr2: address = @my_addrx; //named address example
Primary purpose
The primary purpose of addresses is to interact with global storage operations.
Address values are used with the operations exists, borrow_global, borrow_global_mut, and move_from.
The only global storage operation that does not use an address is move_to, which uses a signer instead.
Signer
Signer Overview
Signer is a data type that represents the authority and control over a resource or asset on the blockchain. The signer data type is used to designate which account or entity is responsible for executing a specific transaction or operation on the blockchain.
You can think of its native implementation as follows:
struct signer has drop { a: address }
Declaring Signer Variables
Signer values are special because they cannot be created through literals or instruction-only constructs that can be generated by the Move VM. Before the VM executes a script with parameters of the signer type, it will automatically generate signer values and pass them into the code:
module movement::address_and_signer {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(new_data: u64, owner: &signer) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
signer
Operations: The package
std::signer
in the standard library module provides 2 utility functions for signer:
signer::address_of(&signer)
: address - Returns the address wrapped by &signer.
signer::borrow_address(&signer)
: &address - Returns a reference to the address wrapped by &signer.
module movement::address_and_signer {
    use std::signer;
    use std::debug::print;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
        print(owner); // signer
        print(&signer::address_of(owner)); // address of signer
    }
    #[test(account = @0x1)]
    fun test_create_resource(account: &signer) {
        create_resource(10, account);
    }
}
Running test
movement move test -f address_and_signer
Result:
Running Move unit tests
[debug] @0x1
[debug] signer(@0x1)
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::address_and_signer::test_create_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Publish & call on blockchain
Publish Modules
movement aptos publish
Call Function
movement move run --function-id 'default::address_and_signer::create_resource' --args u64:10
Check it on your account list with command:
movement account list
In the returned result, you will see an object similar to the one below:
{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::address_and_signer::ResourceName": {
    "data": "10"
  }
}
On This Page
Address
Summary
Address Overview
Address and Syntax:
Declaring Address Variables
Primary purpose
Signer
Signer Overview
Declaring Signer Variables
On This Page
Address
Summary
Address Overview
Address and Syntax:
Declaring Address Variables
Primary purpose
Signer
Signer Overview
Declaring Signer Variables
			On This Page
			On This Page
			Address
Summary
Address Overview
Address and Syntax:
Declaring Address Variables
Primary purpose
Signer
Signer Overview
Declaring Signer Variables
			Address
Summary
Address Overview
Address and Syntax:
Declaring Address Variables
Primary purpose
			Address
			Address
			Address
			Summary
Address Overview
Address and Syntax:
Declaring Address Variables
Primary purpose
			Summary
			Summary
			Summary
			Summary
			Address Overview
			Address Overview
			Address Overview
			Address Overview
			Address and Syntax:
			Address and Syntax:
			Address and Syntax:
			Address and Syntax:
			Declaring Address Variables
			Declaring Address Variables
			Declaring Address Variables
			Declaring Address Variables
			Primary purpose
			Primary purpose
			Primary purpose
			Primary purpose
			Signer
Signer Overview
Declaring Signer Variables
			Signer
			Signer
			Signer
			Signer Overview
Declaring Signer Variables
			Signer Overview
			Signer Overview
			Signer Overview
			Signer Overview
			Declaring Signer Variables
			Declaring Signer Variables
			Declaring Signer Variables
			Declaring Signer Variables
			Address
Summary
Address is a 256-bit identifier representing locations in global storage in Move.
Addresses can store Modules and Resources, but are intentionally opaque and don't support arithmetic operations.
Address syntax includes named and numerical forms, with @ prefix in expression contexts.
Signer represents authority over blockchain resources and is used for transaction execution.
Signer values are automatically generated by the Move VM and cannot be created through literals.
The
std::signer
module provides utility functions for working with signers.
Addresses are primarily used for global storage operations, while signers are used for transaction authorization.
Address Overview
Address is an integrated data type in Move used to represent locations (sometimes referred to as accounts) in global storage. An address value is a
256-bit
(
32-byte
) identifier. At a specific address, two things can be stored: a
Module
and a
Resource
.
Although an address is a
256-bit
integer, Move addresses are designed to be intentionally opaque; they cannot be derived from integers, do not support arithmetic operations, and cannot be altered. While there may be interesting programs utilizing such features (for example, pointer operators in C serve a similar role), Move does not allow such dynamic behavior as it is designed from the ground up to support static verification.
You can use address values at runtime (address-type values) to access resources at that address. You cannot access modules at runtime through address values.
Address and Syntax:
Addresses have two forms:
named
or
numerical
. The syntax of named addresses follows the same rules as any identifier name in Move. The syntax of numerical addresses is not limited to hexadecimal values, and any valid u256 numeric value can be used as an address value; for example,
40
,
0xCAFE
, and
2024
are all valid numeric address literals.
To distinguish when an address is being used in the context of an expression or not, the syntax for using an address varies depending on the context in which it is used:
When an address is used as an expression, it must be prefixed by the character @, for example:
@<numerical_value>
or
@<named_address_identifier>
.
Outside of expression contexts, an address can be written without the prefix @, for example:
<numerical_value>
or
<named_address_identifier>
.
Declaring Address Variables
let addr1: address = @0x1;      //numerical address example
let addr2: address = @my_addrx; //named address example
Primary purpose
The primary purpose of addresses is to interact with global storage operations.
Address values are used with the operations exists, borrow_global, borrow_global_mut, and move_from.
The only global storage operation that does not use an address is move_to, which uses a signer instead.
Signer
Signer Overview
Signer is a data type that represents the authority and control over a resource or asset on the blockchain. The signer data type is used to designate which account or entity is responsible for executing a specific transaction or operation on the blockchain.
You can think of its native implementation as follows:
struct signer has drop { a: address }
Declaring Signer Variables
Signer values are special because they cannot be created through literals or instruction-only constructs that can be generated by the Move VM. Before the VM executes a script with parameters of the signer type, it will automatically generate signer values and pass them into the code:
module movement::address_and_signer {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(new_data: u64, owner: &signer) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
signer
Operations: The package
std::signer
in the standard library module provides 2 utility functions for signer:
signer::address_of(&signer)
: address - Returns the address wrapped by &signer.
signer::borrow_address(&signer)
: &address - Returns a reference to the address wrapped by &signer.
module movement::address_and_signer {
    use std::signer;
    use std::debug::print;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
        print(owner); // signer
        print(&signer::address_of(owner)); // address of signer
    }
    #[test(account = @0x1)]
    fun test_create_resource(account: &signer) {
        create_resource(10, account);
    }
}
Running test
movement move test -f address_and_signer
Result:
Running Move unit tests
[debug] @0x1
[debug] signer(@0x1)
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::address_and_signer::test_create_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Publish & call on blockchain
Publish Modules
movement aptos publish
Call Function
movement move run --function-id 'default::address_and_signer::create_resource' --args u64:10
Check it on your account list with command:
movement account list
In the returned result, you will see an object similar to the one below:
{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::address_and_signer::ResourceName": {
    "data": "10"
  }
}
			Address
Summary
Address is a 256-bit identifier representing locations in global storage in Move.
Addresses can store Modules and Resources, but are intentionally opaque and don't support arithmetic operations.
Address syntax includes named and numerical forms, with @ prefix in expression contexts.
Signer represents authority over blockchain resources and is used for transaction execution.
Signer values are automatically generated by the Move VM and cannot be created through literals.
The
std::signer
module provides utility functions for working with signers.
Addresses are primarily used for global storage operations, while signers are used for transaction authorization.
Address Overview
Address is an integrated data type in Move used to represent locations (sometimes referred to as accounts) in global storage. An address value is a
256-bit
(
32-byte
) identifier. At a specific address, two things can be stored: a
Module
and a
Resource
.
Although an address is a
256-bit
integer, Move addresses are designed to be intentionally opaque; they cannot be derived from integers, do not support arithmetic operations, and cannot be altered. While there may be interesting programs utilizing such features (for example, pointer operators in C serve a similar role), Move does not allow such dynamic behavior as it is designed from the ground up to support static verification.
You can use address values at runtime (address-type values) to access resources at that address. You cannot access modules at runtime through address values.
Address and Syntax:
Addresses have two forms:
named
or
numerical
. The syntax of named addresses follows the same rules as any identifier name in Move. The syntax of numerical addresses is not limited to hexadecimal values, and any valid u256 numeric value can be used as an address value; for example,
40
,
0xCAFE
, and
2024
are all valid numeric address literals.
To distinguish when an address is being used in the context of an expression or not, the syntax for using an address varies depending on the context in which it is used:
When an address is used as an expression, it must be prefixed by the character @, for example:
@<numerical_value>
or
@<named_address_identifier>
.
Outside of expression contexts, an address can be written without the prefix @, for example:
<numerical_value>
or
<named_address_identifier>
.
Declaring Address Variables
let addr1: address = @0x1;      //numerical address example
let addr2: address = @my_addrx; //named address example
Primary purpose
The primary purpose of addresses is to interact with global storage operations.
Address values are used with the operations exists, borrow_global, borrow_global_mut, and move_from.
The only global storage operation that does not use an address is move_to, which uses a signer instead.
Signer
Signer Overview
Signer is a data type that represents the authority and control over a resource or asset on the blockchain. The signer data type is used to designate which account or entity is responsible for executing a specific transaction or operation on the blockchain.
You can think of its native implementation as follows:
struct signer has drop { a: address }
Declaring Signer Variables
Signer values are special because they cannot be created through literals or instruction-only constructs that can be generated by the Move VM. Before the VM executes a script with parameters of the signer type, it will automatically generate signer values and pass them into the code:
module movement::address_and_signer {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(new_data: u64, owner: &signer) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
signer
Operations: The package
std::signer
in the standard library module provides 2 utility functions for signer:
signer::address_of(&signer)
: address - Returns the address wrapped by &signer.
signer::borrow_address(&signer)
: &address - Returns a reference to the address wrapped by &signer.
module movement::address_and_signer {
    use std::signer;
    use std::debug::print;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
        print(owner); // signer
        print(&signer::address_of(owner)); // address of signer
    }
    #[test(account = @0x1)]
    fun test_create_resource(account: &signer) {
        create_resource(10, account);
    }
}
Running test
movement move test -f address_and_signer
Result:
Running Move unit tests
[debug] @0x1
[debug] signer(@0x1)
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::address_and_signer::test_create_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Publish & call on blockchain
Publish Modules
movement aptos publish
Call Function
movement move run --function-id 'default::address_and_signer::create_resource' --args u64:10
Check it on your account list with command:
movement account list
In the returned result, you will see an object similar to the one below:
{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::address_and_signer::ResourceName": {
    "data": "10"
  }
}
			Address
Summary
Address is a 256-bit identifier representing locations in global storage in Move.
Addresses can store Modules and Resources, but are intentionally opaque and don't support arithmetic operations.
Address syntax includes named and numerical forms, with @ prefix in expression contexts.
Signer represents authority over blockchain resources and is used for transaction execution.
Signer values are automatically generated by the Move VM and cannot be created through literals.
The
std::signer
module provides utility functions for working with signers.
Addresses are primarily used for global storage operations, while signers are used for transaction authorization.
Address Overview
Address is an integrated data type in Move used to represent locations (sometimes referred to as accounts) in global storage. An address value is a
256-bit
(
32-byte
) identifier. At a specific address, two things can be stored: a
Module
and a
Resource
.
Although an address is a
256-bit
integer, Move addresses are designed to be intentionally opaque; they cannot be derived from integers, do not support arithmetic operations, and cannot be altered. While there may be interesting programs utilizing such features (for example, pointer operators in C serve a similar role), Move does not allow such dynamic behavior as it is designed from the ground up to support static verification.
You can use address values at runtime (address-type values) to access resources at that address. You cannot access modules at runtime through address values.
Address and Syntax:
Addresses have two forms:
named
or
numerical
. The syntax of named addresses follows the same rules as any identifier name in Move. The syntax of numerical addresses is not limited to hexadecimal values, and any valid u256 numeric value can be used as an address value; for example,
40
,
0xCAFE
, and
2024
are all valid numeric address literals.
To distinguish when an address is being used in the context of an expression or not, the syntax for using an address varies depending on the context in which it is used:
When an address is used as an expression, it must be prefixed by the character @, for example:
@<numerical_value>
or
@<named_address_identifier>
.
Outside of expression contexts, an address can be written without the prefix @, for example:
<numerical_value>
or
<named_address_identifier>
.
Declaring Address Variables
let addr1: address = @0x1;      //numerical address example
let addr2: address = @my_addrx; //named address example
Primary purpose
The primary purpose of addresses is to interact with global storage operations.
Address values are used with the operations exists, borrow_global, borrow_global_mut, and move_from.
The only global storage operation that does not use an address is move_to, which uses a signer instead.
Signer
Signer Overview
Signer is a data type that represents the authority and control over a resource or asset on the blockchain. The signer data type is used to designate which account or entity is responsible for executing a specific transaction or operation on the blockchain.
You can think of its native implementation as follows:
struct signer has drop { a: address }
Declaring Signer Variables
Signer values are special because they cannot be created through literals or instruction-only constructs that can be generated by the Move VM. Before the VM executes a script with parameters of the signer type, it will automatically generate signer values and pass them into the code:
module movement::address_and_signer {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(new_data: u64, owner: &signer) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
signer
Operations: The package
std::signer
in the standard library module provides 2 utility functions for signer:
signer::address_of(&signer)
: address - Returns the address wrapped by &signer.
signer::borrow_address(&signer)
: &address - Returns a reference to the address wrapped by &signer.
module movement::address_and_signer {
    use std::signer;
    use std::debug::print;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
        print(owner); // signer
        print(&signer::address_of(owner)); // address of signer
    }
    #[test(account = @0x1)]
    fun test_create_resource(account: &signer) {
        create_resource(10, account);
    }
}
Running test
movement move test -f address_and_signer
Result:
Running Move unit tests
[debug] @0x1
[debug] signer(@0x1)
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::address_and_signer::test_create_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Publish & call on blockchain
Publish Modules
movement aptos publish
Call Function
movement move run --function-id 'default::address_and_signer::create_resource' --args u64:10
Check it on your account list with command:
movement account list
In the returned result, you will see an object similar to the one below:
{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::address_and_signer::ResourceName": {
    "data": "10"
  }
}
	Address
	Address
		Summary
		Summary
		Address is a 256-bit identifier representing locations in global storage in Move.
Addresses can store Modules and Resources, but are intentionally opaque and don't support arithmetic operations.
Address syntax includes named and numerical forms, with @ prefix in expression contexts.
Signer represents authority over blockchain resources and is used for transaction execution.
Signer values are automatically generated by the Move VM and cannot be created through literals.
The
std::signer
module provides utility functions for working with signers.
Addresses are primarily used for global storage operations, while signers are used for transaction authorization.
		Address is a 256-bit identifier representing locations in global storage in Move.
		Address is a 256-bit identifier representing locations in global storage in Move.
		Addresses can store Modules and Resources, but are intentionally opaque and don't support arithmetic operations.
		Addresses can store Modules and Resources, but are intentionally opaque and don't support arithmetic operations.
		Address syntax includes named and numerical forms, with @ prefix in expression contexts.
		Address syntax includes named and numerical forms, with @ prefix in expression contexts.
		Signer represents authority over blockchain resources and is used for transaction execution.
		Signer represents authority over blockchain resources and is used for transaction execution.
		Signer values are automatically generated by the Move VM and cannot be created through literals.
		Signer values are automatically generated by the Move VM and cannot be created through literals.
		The
std::signer
module provides utility functions for working with signers.
		The
		<code>std::signer</code>
		std::signer
		module provides utility functions for working with signers.
		Addresses are primarily used for global storage operations, while signers are used for transaction authorization.
		Addresses are primarily used for global storage operations, while signers are used for transaction authorization.
		Address Overview
		Address Overview
		Address is an integrated data type in Move used to represent locations (sometimes referred to as accounts) in global storage. An address value is a
256-bit
(
32-byte
) identifier. At a specific address, two things can be stored: a
Module
and a
Resource
.
		Address is an integrated data type in Move used to represent locations (sometimes referred to as accounts) in global storage. An address value is a
		<code>256-bit</code>
		256-bit
		(
		<code>32-byte</code>
		32-byte
		) identifier. At a specific address, two things can be stored: a
		<code>Module</code>
		Module
		and a
		<code>Resource</code>
		Resource
		.
		Although an address is a
256-bit
integer, Move addresses are designed to be intentionally opaque; they cannot be derived from integers, do not support arithmetic operations, and cannot be altered. While there may be interesting programs utilizing such features (for example, pointer operators in C serve a similar role), Move does not allow such dynamic behavior as it is designed from the ground up to support static verification.
		Although an address is a
		<code>256-bit</code>
		256-bit
		integer, Move addresses are designed to be intentionally opaque; they cannot be derived from integers, do not support arithmetic operations, and cannot be altered. While there may be interesting programs utilizing such features (for example, pointer operators in C serve a similar role), Move does not allow such dynamic behavior as it is designed from the ground up to support static verification.
		You can use address values at runtime (address-type values) to access resources at that address. You cannot access modules at runtime through address values.
		You can use address values at runtime (address-type values) to access resources at that address. You cannot access modules at runtime through address values.
		Address and Syntax:
		Address and Syntax:
		Addresses have two forms:
named
or
numerical
. The syntax of named addresses follows the same rules as any identifier name in Move. The syntax of numerical addresses is not limited to hexadecimal values, and any valid u256 numeric value can be used as an address value; for example,
40
,
0xCAFE
, and
2024
are all valid numeric address literals.
		Addresses have two forms:
		<code>named</code>
		named
		or
		<code>numerical</code>
		numerical
		. The syntax of named addresses follows the same rules as any identifier name in Move. The syntax of numerical addresses is not limited to hexadecimal values, and any valid u256 numeric value can be used as an address value; for example,
		<code>40</code>
		40
		,
		<code>0xCAFE</code>
		0xCAFE
		, and
		<code>2024</code>
		2024
		are all valid numeric address literals.
		To distinguish when an address is being used in the context of an expression or not, the syntax for using an address varies depending on the context in which it is used:
		To distinguish when an address is being used in the context of an expression or not, the syntax for using an address varies depending on the context in which it is used:
		When an address is used as an expression, it must be prefixed by the character @, for example:
@<numerical_value>
or
@<named_address_identifier>
.
Outside of expression contexts, an address can be written without the prefix @, for example:
<numerical_value>
or
<named_address_identifier>
.
		When an address is used as an expression, it must be prefixed by the character @, for example:
@<numerical_value>
or
@<named_address_identifier>
.
		When an address is used as an expression, it must be prefixed by the character @, for example:
		<code>@<numerical_value></code>
		@<numerical_value>
		or
		<code>@<named_address_identifier></code>
		@<named_address_identifier>
		.
		Outside of expression contexts, an address can be written without the prefix @, for example:
<numerical_value>
or
<named_address_identifier>
.
		Outside of expression contexts, an address can be written without the prefix @, for example:
		<code><numerical_value></code>
		<numerical_value>
		or
		<code><named_address_identifier></code>
		<named_address_identifier>
		.
		Declaring Address Variables
		Declaring Address Variables
		<code>let addr1: address = @0x1;      //numerical address example
let addr2: address = @my_addrx; //named address example</code>
		<code>let addr1: address = @0x1;      //numerical address example
let addr2: address = @my_addrx; //named address example</code>
		let addr1: address = @0x1;      //numerical address example
let addr2: address = @my_addrx; //named address example
		Primary purpose
		Primary purpose
		The primary purpose of addresses is to interact with global storage operations.
Address values are used with the operations exists, borrow_global, borrow_global_mut, and move_from.
The only global storage operation that does not use an address is move_to, which uses a signer instead.
		The primary purpose of addresses is to interact with global storage operations.
		The primary purpose of addresses is to interact with global storage operations.
		Address values are used with the operations exists, borrow_global, borrow_global_mut, and move_from.
		Address values are used with the operations exists, borrow_global, borrow_global_mut, and move_from.
		The only global storage operation that does not use an address is move_to, which uses a signer instead.
		The only global storage operation that does not use an address is move_to, which uses a signer instead.
	Signer
	Signer
		Signer Overview
		Signer Overview
		Signer is a data type that represents the authority and control over a resource or asset on the blockchain. The signer data type is used to designate which account or entity is responsible for executing a specific transaction or operation on the blockchain.
		Signer is a data type that represents the authority and control over a resource or asset on the blockchain. The signer data type is used to designate which account or entity is responsible for executing a specific transaction or operation on the blockchain.
		You can think of its native implementation as follows:
		You can think of its native implementation as follows:
		struct signer has drop { a: address }
		<code>struct signer has drop { a: address }</code>
		struct signer has drop { a: address }
		Declaring Signer Variables
		Declaring Signer Variables
		Signer values are special because they cannot be created through literals or instruction-only constructs that can be generated by the Move VM. Before the VM executes a script with parameters of the signer type, it will automatically generate signer values and pass them into the code:
		Signer values are special because they cannot be created through literals or instruction-only constructs that can be generated by the Move VM. Before the VM executes a script with parameters of the signer type, it will automatically generate signer values and pass them into the code:
		<code>module movement::address_and_signer {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(new_data: u64, owner: &signer) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}</code>
		<code>module movement::address_and_signer {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(new_data: u64, owner: &signer) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}</code>
		module movement::address_and_signer {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(new_data: u64, owner: &signer) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
		signer
Operations: The package
std::signer
in the standard library module provides 2 utility functions for signer:
		<code>signer</code>
		signer
		Operations: The package
		<code>std::signer</code>
		std::signer
		in the standard library module provides 2 utility functions for signer:
		signer::address_of(&signer)
: address - Returns the address wrapped by &signer.
signer::borrow_address(&signer)
: &address - Returns a reference to the address wrapped by &signer.
		signer::address_of(&signer)
: address - Returns the address wrapped by &signer.
		<code>signer::address_of(&signer)</code>
		signer::address_of(&signer)
		: address - Returns the address wrapped by &signer.
		signer::borrow_address(&signer)
: &address - Returns a reference to the address wrapped by &signer.
		<code>signer::borrow_address(&signer)</code>
		signer::borrow_address(&signer)
		: &address - Returns a reference to the address wrapped by &signer.
		<code>module movement::address_and_signer {
    use std::signer;
    use std::debug::print;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
        print(owner); // signer
        print(&signer::address_of(owner)); // address of signer
    }
    #[test(account = @0x1)]
    fun test_create_resource(account: &signer) {
        create_resource(10, account);
    }
}</code>
		<code>module movement::address_and_signer {
    use std::signer;
    use std::debug::print;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
        print(owner); // signer
        print(&signer::address_of(owner)); // address of signer
    }
    #[test(account = @0x1)]
    fun test_create_resource(account: &signer) {
        create_resource(10, account);
    }
}</code>
		module movement::address_and_signer {
    use std::signer;
    use std::debug::print;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
        print(owner); // signer
        print(&signer::address_of(owner)); // address of signer
    }
    #[test(account = @0x1)]
    fun test_create_resource(account: &signer) {
        create_resource(10, account);
    }
}
		Running test
		Running test
		Running test
		<code>movement move test -f address_and_signer</code>
		<code>movement move test -f address_and_signer</code>
		movement move test -f address_and_signer
		Result:
		Result:
		Result:
		<code>Running Move unit tests
[debug] @0x1
[debug] signer(@0x1)
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::address_and_signer::test_create_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
		<code>Running Move unit tests
[debug] @0x1
[debug] signer(@0x1)
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::address_and_signer::test_create_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
		Running Move unit tests
[debug] @0x1
[debug] signer(@0x1)
[ PASS ] 0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::address_and_signer::test_create_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
		Publish & call on blockchain
		Publish & call on blockchain
		Publish & call on blockchain
		Publish Modules
		Publish Modules
		Publish Modules
		<code>movement aptos publish</code>
		<code>movement aptos publish</code>
		movement aptos publish
		Call Function
		Call Function
		Call Function
		<code>movement move run --function-id 'default::address_and_signer::create_resource' --args u64:10</code>
		<code>movement move run --function-id 'default::address_and_signer::create_resource' --args u64:10</code>
		movement move run --function-id 'default::address_and_signer::create_resource' --args u64:10
		Check it on your account list with command:
		Check it on your account list with command:
		Check it on your account list with command:
		<code>movement account list</code>
		<code>movement account list</code>
		movement account list
		In the returned result, you will see an object similar to the one below:
		In the returned result, you will see an object similar to the one below:
		In the returned result, you will see an object similar to the one below:
		<code>{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::address_and_signer::ResourceName": {
    "data": "10"
  }
}</code>
		<code>{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::address_and_signer::ResourceName": {
    "data": "10"
  }
}</code>
		{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::address_and_signer::ResourceName": {
    "data": "10"
  }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/02-data-types/04-string-and-vector
String & Vector
String & Vector
On This Page
Summary
Vector Overview
Add value into vector
Get Value in vector by index
Take last value from vector
Destroying and Copying Vectors
Copy a vector
Additional Vector Functions
Overview String
Conclusion
Summary
Move's primary collection type is
vector
, a homogeneous, expandable/shrinkable collection of T values.
Vectors can be initialized with any data type, including primitive types, custom types, and nested vectors.
Key vector operations include adding elements, accessing by index, and removing elements.
Vector behavior depends on the capabilities of its element type T, especially for destruction and copying.
Move provides various built-in functions for vector manipulation, such as
push_back
,
pop_back
, and
borrow
.
Strings in Move are represented as
vector<u8>
, with utility functions for conversion and manipulation.
This document covers the fundamentals of working with vectors and strings in Move, including creation, manipulation, and common operations.
Vector Overview
vector<T>
is the only collection type provided by Move. A
vector<T>
is a homogeneous collection of T values that can be expanded or shrunk by adding/removing values from its "end".
A
vector<T>
can be initialized with any data type as T. For example,
vector<u8>
,
vector<address>
,
vector<0x42::MovementModule::ResourceType>
, and
vector<vector<u8>>
let byte_string_example: vector<u8> = b"Hello world"; //Byte strings are quoted string literals prefixed by a b
let hex_string_example: vector<u8> = x"48656c6c6f20776f726c64"; //Hex strings are quoted string literals prefixed by a x
Add value into vector
The following code demonstrates how to add a value to the end of a vector in Move:
The function
add_last_vec
takes a
u64
number as input and returns a
vector<u64>
.
It creates an empty vector using
vector::empty<u64>()
.
The
vector::push_back
function is used to add the input number to the end of the vector.
The
test_add_last_vec
function demonstrates how to use this function and print the resulting vector.
This example showcases basic vector operations in Move, including creation, adding elements, and returning a vector from a function.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun add_last_vec(number: u64): vector<u64> {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, number);
        return list
    }
    #[test]
    fun test_add_last_vec() {
        let vec = add_last_vec(500);
        print(&vec);
    }
}
vector::push_back(&mut list, number);
Here's a breakdown of the arguments:
&mut list
:
This is the first argument to
push_back
.
The
&mut
indicates a mutable reference to
list
.
Mutable references allow the function to modify the original vector.
Using
&mut
is necessary because adding an element changes the vector's contents.
number
:
This is the second argument to
push_back
.
It's the value being added to the end of the vector. The type depends on the vector created earlier.
In this case, it's the
u64
value passed into the
add_last_vec
function.
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[debug] [ 500 ]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_last_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Get Value in vector by index
The following code demonstrates how to retrieve a value from a vector by its index in Move:
The function
get_value_by_index_vec
takes a
u64
index as input and returns a
u64
value.
It creates a vector and populates it with three values: 10, 20, and 30.
The
vector::borrow
function is used to access the element at the specified index. The
*
operator dereferences the borrowed value.
The
test_get_value_by_index_vec
function demonstrates how to use this function to retrieve and print a value from the vector.
This example illustrates how to access elements in a vector by their index, which is a fundamental operation when working with vectors in Move.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun get_value_by_index_vec(index: u64): u64 {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        return *vector::borrow(&list, index)
    }
    #[test]
    fun test_get_value_by_index_vec() {
        let value = get_value_by_index_vec(1);
        print(&value);
    }
}
Running test:
movement move test -f test_get_value_by_index_vec
Result:
Running Move unit tests
[debug] 20
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_get_value_by_index_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Take last value from vector
The following code demonstrates how to remove and return the last value from a vector in Move:
The function
take_last_value_in_vec
creates a vector with three elements: 10, 20, and 30.
It uses
vector::pop_back
to remove and return the last element (30) from the vector.
The function returns a tuple containing the modified vector and the removed value.
The
test_take_last_value_in_vec
function shows how to use this function and print both the resulting vector and the removed value.
This example illustrates how to manipulate vectors by removing elements, which is a common operation when working with dynamic collections in Move.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    
    fun take_last_value_in_vec(): (vector<u64>, u64) {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        let take_value: u64 = vector::pop_back(&mut list);
        return (list, take_value)
    }
    #[test]
    fun test_take_last_value_in_vec() {
        let (list, take_value) = take_last_value_in_vec();
        print(&list);
        print(&take_value);
    }
}
Running test:
movement move test -f test_take_last_value_in_vec
Result:
Running Move unit tests
[debug] [ 10, 20 ]
[debug] 30
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_take_last_value_in_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Destroying and Copying Vectors
Some behaviors of
vector<T>
depend on the capabilities of the element type
T
. For instance, vectors containing elements that can't be dropped can't be implicitly discarded like
v
in the example above. Instead, they must be explicitly destroyed using
vector::destroy_empty
.
Note:
vector::destroy_empty
will trigger a runtime error if the vector is empty (contains zero elements).
fun destroy_any_vector<T>(vec: vector<T>) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
}
Example:
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    #[test]
    fun test_add_vector() {
        let vec = add_last_vec(10);
        print(&vec);
    }
    #[test]
    #[expected_failure]
    fun test_failed_drop_vector() {
        let vec = add_last_vec(10);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
}
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[debug] [
  0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::DropVector {
    data: 10
  }
]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_failed_drop_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}
Copy a vector
Similarly, vectors cannot be copied (using
copy
) unless the element type has the
copy
capability. In other words, a
vector<T>
is copyable only if
T
has the.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop, copy {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_clone_vector() {
        let vec = add_last_vec(10);
        let vec_copy = copy vec;
    }
}
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_clone_vector
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Copying large
vectors
can be
expensive
, so the compiler requires explicit copies to make it easy to see where they occur.
Additional Vector Functions
|
Function
|
Parameters
|
Description
|
Return Value
|
| --- | --- | --- | --- |
|
empty<T>
| None | Creates an empty vector that can store values of type
T
|
vector<T>
|
|
singleton<T>
|
t: T
| Creates a vector of size 1 containing
t
|
vector<T>
|
|
push_back<T>
|
v: &mut vector<T>, t: T
| Adds
t
to the end of
v
| None |
|
pop_back<T>
|
v: &mut vector<T>
| Removes and returns the last element in
v
|
T
|
|
borrow<T>
|
v: &vector<T>, i: u64
| Returns an immutable reference to the
T
at index
i
|
&T
|
|
borrow_mut<T>
|
v: &mut vector<T>, i: u64
| Returns a mutable reference to the
T
at index
i
|
&mut T
|
|
destroy_empty<T>
|
v: vector<T>
| Deletes
v
| None |
|
append<T>
|
v1: &mut vector<T>, v2: vector<T>
| Adds the elements in
v2
to the end of
v1
| None |
|
contains<T>
|
v: &vector<T>, e: &T
| Returns true if
e
is in the vector
v
, otherwise false |
bool
|
|
swap<T>
|
v: &mut vector<T>, i: u64, j: u64
| Swaps the elements at the
i
th and
j
th indices in the vector
v
| None |
|
reverse<T>
|
v: &mut vector<T>
| Reverses the order of the elements in the vector
v
in place | None |
|
index_of<T>
|
v: &vector<T>, e: &T
| Returns
(true, i)
if
e
is in the vector
v
at index
i
, otherwise
(false, 0)
|
(bool, u64)
|
|
remove<T>
|
v: &mut vector<T>, i: u64
| Removes the
i
th element of the vector
v
, shifting all subsequent elements |
T
|
|
swap_remove<T>
|
v: &mut vector<T>, i: u64
| Swaps the
i
th element with the last element and then pops the element |
T
|
Overview String
In Move, String is not a native data type. Data in the Move VM is stored as bytes, so when using a string, the essence of the string will be a vector, a sequence of characters encoded as bytes arranged adjacently to create a string
module movement::string_type {
    use std::string::{String, utf8};
    use std::signer;
    use std::debug::print;
    fun vec_string() {
        let vec_string: vector<u8> = b"Hello by vector u8";
        let by_string: String = utf8(b"Hello by String");
        let by_vec: String = utf8(vec_string);
        print(&vec_string);
        print(&by_string);
        print(&by_vec);
    }
    #[test]
    fun test_vec_string() {
        vec_string()
    }
}
Running test:
movement move test -f test_vec_string
Result:
Running Move unit tests
[debug] 0x48656c6c6f20627920766563746f72207538
[debug] "Hello by String"
[debug] "Hello by vector u8"
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::string_type::test_vec_string
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Conclusion
Vectors and strings are fundamental data structures in Move that provide powerful capabilities for handling collections and text data. Here are the key takeaways:
Vectors (
vector<T>
) offer a flexible, homogeneous collection type that can be used with any data type in Move.
Vector operations like adding, removing, and accessing elements are efficient and well-supported by built-in functions.
The behavior of vectors depends on the capabilities of their element type, particularly for operations like destruction and copying.
Strings in Move are represented as
vector<u8>
, leveraging the vector structure for character sequences.
Move provides utility functions for string manipulation, including conversion between vector and String types.
Understanding these concepts is crucial for effective programming in Move, as they form the basis for many complex data structures and algorithms. Proper use of vectors and strings can lead to more efficient and maintainable code in Move-based smart contracts and applications.
On This Page
Summary
Vector Overview
Add value into vector
Get Value in vector by index
Take last value from vector
Destroying and Copying Vectors
Copy a vector
Additional Vector Functions
Overview String
Conclusion
On This Page
Summary
Vector Overview
Add value into vector
Get Value in vector by index
Take last value from vector
Destroying and Copying Vectors
Copy a vector
Additional Vector Functions
Overview String
Conclusion
			On This Page
			On This Page
			Summary
Vector Overview
Add value into vector
Get Value in vector by index
Take last value from vector
Destroying and Copying Vectors
Copy a vector
Additional Vector Functions
Overview String
Conclusion
			Summary
			Summary
			Summary
			Summary
			Vector Overview
Add value into vector
Get Value in vector by index
Take last value from vector
Destroying and Copying Vectors
Copy a vector
			Vector Overview
			Vector Overview
			Vector Overview
			Add value into vector
Get Value in vector by index
Take last value from vector
Destroying and Copying Vectors
Copy a vector
			Add value into vector
			Add value into vector
			Add value into vector
			Add value into vector
			Get Value in vector by index
			Get Value in vector by index
			Get Value in vector by index
			Get Value in vector by index
			Take last value from vector
			Take last value from vector
			Take last value from vector
			Take last value from vector
			Destroying and Copying Vectors
			Destroying and Copying Vectors
			Destroying and Copying Vectors
			Destroying and Copying Vectors
			Copy a vector
			Copy a vector
			Copy a vector
			Copy a vector
			Additional Vector Functions
			Additional Vector Functions
			Additional Vector Functions
			Additional Vector Functions
			Overview String
			Overview String
			Overview String
			Overview String
			Conclusion
			Conclusion
			Conclusion
			Conclusion
			Summary
Move's primary collection type is
vector
, a homogeneous, expandable/shrinkable collection of T values.
Vectors can be initialized with any data type, including primitive types, custom types, and nested vectors.
Key vector operations include adding elements, accessing by index, and removing elements.
Vector behavior depends on the capabilities of its element type T, especially for destruction and copying.
Move provides various built-in functions for vector manipulation, such as
push_back
,
pop_back
, and
borrow
.
Strings in Move are represented as
vector<u8>
, with utility functions for conversion and manipulation.
This document covers the fundamentals of working with vectors and strings in Move, including creation, manipulation, and common operations.
Vector Overview
vector<T>
is the only collection type provided by Move. A
vector<T>
is a homogeneous collection of T values that can be expanded or shrunk by adding/removing values from its "end".
A
vector<T>
can be initialized with any data type as T. For example,
vector<u8>
,
vector<address>
,
vector<0x42::MovementModule::ResourceType>
, and
vector<vector<u8>>
let byte_string_example: vector<u8> = b"Hello world"; //Byte strings are quoted string literals prefixed by a b
let hex_string_example: vector<u8> = x"48656c6c6f20776f726c64"; //Hex strings are quoted string literals prefixed by a x
Add value into vector
The following code demonstrates how to add a value to the end of a vector in Move:
The function
add_last_vec
takes a
u64
number as input and returns a
vector<u64>
.
It creates an empty vector using
vector::empty<u64>()
.
The
vector::push_back
function is used to add the input number to the end of the vector.
The
test_add_last_vec
function demonstrates how to use this function and print the resulting vector.
This example showcases basic vector operations in Move, including creation, adding elements, and returning a vector from a function.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun add_last_vec(number: u64): vector<u64> {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, number);
        return list
    }
    #[test]
    fun test_add_last_vec() {
        let vec = add_last_vec(500);
        print(&vec);
    }
}
vector::push_back(&mut list, number);
Here's a breakdown of the arguments:
&mut list
:
This is the first argument to
push_back
.
The
&mut
indicates a mutable reference to
list
.
Mutable references allow the function to modify the original vector.
Using
&mut
is necessary because adding an element changes the vector's contents.
number
:
This is the second argument to
push_back
.
It's the value being added to the end of the vector. The type depends on the vector created earlier.
In this case, it's the
u64
value passed into the
add_last_vec
function.
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[debug] [ 500 ]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_last_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Get Value in vector by index
The following code demonstrates how to retrieve a value from a vector by its index in Move:
The function
get_value_by_index_vec
takes a
u64
index as input and returns a
u64
value.
It creates a vector and populates it with three values: 10, 20, and 30.
The
vector::borrow
function is used to access the element at the specified index. The
*
operator dereferences the borrowed value.
The
test_get_value_by_index_vec
function demonstrates how to use this function to retrieve and print a value from the vector.
This example illustrates how to access elements in a vector by their index, which is a fundamental operation when working with vectors in Move.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun get_value_by_index_vec(index: u64): u64 {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        return *vector::borrow(&list, index)
    }
    #[test]
    fun test_get_value_by_index_vec() {
        let value = get_value_by_index_vec(1);
        print(&value);
    }
}
Running test:
movement move test -f test_get_value_by_index_vec
Result:
Running Move unit tests
[debug] 20
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_get_value_by_index_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Take last value from vector
The following code demonstrates how to remove and return the last value from a vector in Move:
The function
take_last_value_in_vec
creates a vector with three elements: 10, 20, and 30.
It uses
vector::pop_back
to remove and return the last element (30) from the vector.
The function returns a tuple containing the modified vector and the removed value.
The
test_take_last_value_in_vec
function shows how to use this function and print both the resulting vector and the removed value.
This example illustrates how to manipulate vectors by removing elements, which is a common operation when working with dynamic collections in Move.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    
    fun take_last_value_in_vec(): (vector<u64>, u64) {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        let take_value: u64 = vector::pop_back(&mut list);
        return (list, take_value)
    }
    #[test]
    fun test_take_last_value_in_vec() {
        let (list, take_value) = take_last_value_in_vec();
        print(&list);
        print(&take_value);
    }
}
Running test:
movement move test -f test_take_last_value_in_vec
Result:
Running Move unit tests
[debug] [ 10, 20 ]
[debug] 30
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_take_last_value_in_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Destroying and Copying Vectors
Some behaviors of
vector<T>
depend on the capabilities of the element type
T
. For instance, vectors containing elements that can't be dropped can't be implicitly discarded like
v
in the example above. Instead, they must be explicitly destroyed using
vector::destroy_empty
.
Note:
vector::destroy_empty
will trigger a runtime error if the vector is empty (contains zero elements).
fun destroy_any_vector<T>(vec: vector<T>) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
}
Example:
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    #[test]
    fun test_add_vector() {
        let vec = add_last_vec(10);
        print(&vec);
    }
    #[test]
    #[expected_failure]
    fun test_failed_drop_vector() {
        let vec = add_last_vec(10);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
}
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[debug] [
  0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::DropVector {
    data: 10
  }
]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_failed_drop_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}
Copy a vector
Similarly, vectors cannot be copied (using
copy
) unless the element type has the
copy
capability. In other words, a
vector<T>
is copyable only if
T
has the.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop, copy {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_clone_vector() {
        let vec = add_last_vec(10);
        let vec_copy = copy vec;
    }
}
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_clone_vector
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Copying large
vectors
can be
expensive
, so the compiler requires explicit copies to make it easy to see where they occur.
Additional Vector Functions
|
Function
|
Parameters
|
Description
|
Return Value
|
| --- | --- | --- | --- |
|
empty<T>
| None | Creates an empty vector that can store values of type
T
|
vector<T>
|
|
singleton<T>
|
t: T
| Creates a vector of size 1 containing
t
|
vector<T>
|
|
push_back<T>
|
v: &mut vector<T>, t: T
| Adds
t
to the end of
v
| None |
|
pop_back<T>
|
v: &mut vector<T>
| Removes and returns the last element in
v
|
T
|
|
borrow<T>
|
v: &vector<T>, i: u64
| Returns an immutable reference to the
T
at index
i
|
&T
|
|
borrow_mut<T>
|
v: &mut vector<T>, i: u64
| Returns a mutable reference to the
T
at index
i
|
&mut T
|
|
destroy_empty<T>
|
v: vector<T>
| Deletes
v
| None |
|
append<T>
|
v1: &mut vector<T>, v2: vector<T>
| Adds the elements in
v2
to the end of
v1
| None |
|
contains<T>
|
v: &vector<T>, e: &T
| Returns true if
e
is in the vector
v
, otherwise false |
bool
|
|
swap<T>
|
v: &mut vector<T>, i: u64, j: u64
| Swaps the elements at the
i
th and
j
th indices in the vector
v
| None |
|
reverse<T>
|
v: &mut vector<T>
| Reverses the order of the elements in the vector
v
in place | None |
|
index_of<T>
|
v: &vector<T>, e: &T
| Returns
(true, i)
if
e
is in the vector
v
at index
i
, otherwise
(false, 0)
|
(bool, u64)
|
|
remove<T>
|
v: &mut vector<T>, i: u64
| Removes the
i
th element of the vector
v
, shifting all subsequent elements |
T
|
|
swap_remove<T>
|
v: &mut vector<T>, i: u64
| Swaps the
i
th element with the last element and then pops the element |
T
|
Overview String
In Move, String is not a native data type. Data in the Move VM is stored as bytes, so when using a string, the essence of the string will be a vector, a sequence of characters encoded as bytes arranged adjacently to create a string
module movement::string_type {
    use std::string::{String, utf8};
    use std::signer;
    use std::debug::print;
    fun vec_string() {
        let vec_string: vector<u8> = b"Hello by vector u8";
        let by_string: String = utf8(b"Hello by String");
        let by_vec: String = utf8(vec_string);
        print(&vec_string);
        print(&by_string);
        print(&by_vec);
    }
    #[test]
    fun test_vec_string() {
        vec_string()
    }
}
Running test:
movement move test -f test_vec_string
Result:
Running Move unit tests
[debug] 0x48656c6c6f20627920766563746f72207538
[debug] "Hello by String"
[debug] "Hello by vector u8"
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::string_type::test_vec_string
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Conclusion
Vectors and strings are fundamental data structures in Move that provide powerful capabilities for handling collections and text data. Here are the key takeaways:
Vectors (
vector<T>
) offer a flexible, homogeneous collection type that can be used with any data type in Move.
Vector operations like adding, removing, and accessing elements are efficient and well-supported by built-in functions.
The behavior of vectors depends on the capabilities of their element type, particularly for operations like destruction and copying.
Strings in Move are represented as
vector<u8>
, leveraging the vector structure for character sequences.
Move provides utility functions for string manipulation, including conversion between vector and String types.
Understanding these concepts is crucial for effective programming in Move, as they form the basis for many complex data structures and algorithms. Proper use of vectors and strings can lead to more efficient and maintainable code in Move-based smart contracts and applications.
			Summary
Move's primary collection type is
vector
, a homogeneous, expandable/shrinkable collection of T values.
Vectors can be initialized with any data type, including primitive types, custom types, and nested vectors.
Key vector operations include adding elements, accessing by index, and removing elements.
Vector behavior depends on the capabilities of its element type T, especially for destruction and copying.
Move provides various built-in functions for vector manipulation, such as
push_back
,
pop_back
, and
borrow
.
Strings in Move are represented as
vector<u8>
, with utility functions for conversion and manipulation.
This document covers the fundamentals of working with vectors and strings in Move, including creation, manipulation, and common operations.
Vector Overview
vector<T>
is the only collection type provided by Move. A
vector<T>
is a homogeneous collection of T values that can be expanded or shrunk by adding/removing values from its "end".
A
vector<T>
can be initialized with any data type as T. For example,
vector<u8>
,
vector<address>
,
vector<0x42::MovementModule::ResourceType>
, and
vector<vector<u8>>
let byte_string_example: vector<u8> = b"Hello world"; //Byte strings are quoted string literals prefixed by a b
let hex_string_example: vector<u8> = x"48656c6c6f20776f726c64"; //Hex strings are quoted string literals prefixed by a x
Add value into vector
The following code demonstrates how to add a value to the end of a vector in Move:
The function
add_last_vec
takes a
u64
number as input and returns a
vector<u64>
.
It creates an empty vector using
vector::empty<u64>()
.
The
vector::push_back
function is used to add the input number to the end of the vector.
The
test_add_last_vec
function demonstrates how to use this function and print the resulting vector.
This example showcases basic vector operations in Move, including creation, adding elements, and returning a vector from a function.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun add_last_vec(number: u64): vector<u64> {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, number);
        return list
    }
    #[test]
    fun test_add_last_vec() {
        let vec = add_last_vec(500);
        print(&vec);
    }
}
vector::push_back(&mut list, number);
Here's a breakdown of the arguments:
&mut list
:
This is the first argument to
push_back
.
The
&mut
indicates a mutable reference to
list
.
Mutable references allow the function to modify the original vector.
Using
&mut
is necessary because adding an element changes the vector's contents.
number
:
This is the second argument to
push_back
.
It's the value being added to the end of the vector. The type depends on the vector created earlier.
In this case, it's the
u64
value passed into the
add_last_vec
function.
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[debug] [ 500 ]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_last_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Get Value in vector by index
The following code demonstrates how to retrieve a value from a vector by its index in Move:
The function
get_value_by_index_vec
takes a
u64
index as input and returns a
u64
value.
It creates a vector and populates it with three values: 10, 20, and 30.
The
vector::borrow
function is used to access the element at the specified index. The
*
operator dereferences the borrowed value.
The
test_get_value_by_index_vec
function demonstrates how to use this function to retrieve and print a value from the vector.
This example illustrates how to access elements in a vector by their index, which is a fundamental operation when working with vectors in Move.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun get_value_by_index_vec(index: u64): u64 {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        return *vector::borrow(&list, index)
    }
    #[test]
    fun test_get_value_by_index_vec() {
        let value = get_value_by_index_vec(1);
        print(&value);
    }
}
Running test:
movement move test -f test_get_value_by_index_vec
Result:
Running Move unit tests
[debug] 20
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_get_value_by_index_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Take last value from vector
The following code demonstrates how to remove and return the last value from a vector in Move:
The function
take_last_value_in_vec
creates a vector with three elements: 10, 20, and 30.
It uses
vector::pop_back
to remove and return the last element (30) from the vector.
The function returns a tuple containing the modified vector and the removed value.
The
test_take_last_value_in_vec
function shows how to use this function and print both the resulting vector and the removed value.
This example illustrates how to manipulate vectors by removing elements, which is a common operation when working with dynamic collections in Move.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    
    fun take_last_value_in_vec(): (vector<u64>, u64) {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        let take_value: u64 = vector::pop_back(&mut list);
        return (list, take_value)
    }
    #[test]
    fun test_take_last_value_in_vec() {
        let (list, take_value) = take_last_value_in_vec();
        print(&list);
        print(&take_value);
    }
}
Running test:
movement move test -f test_take_last_value_in_vec
Result:
Running Move unit tests
[debug] [ 10, 20 ]
[debug] 30
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_take_last_value_in_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Destroying and Copying Vectors
Some behaviors of
vector<T>
depend on the capabilities of the element type
T
. For instance, vectors containing elements that can't be dropped can't be implicitly discarded like
v
in the example above. Instead, they must be explicitly destroyed using
vector::destroy_empty
.
Note:
vector::destroy_empty
will trigger a runtime error if the vector is empty (contains zero elements).
fun destroy_any_vector<T>(vec: vector<T>) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
}
Example:
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    #[test]
    fun test_add_vector() {
        let vec = add_last_vec(10);
        print(&vec);
    }
    #[test]
    #[expected_failure]
    fun test_failed_drop_vector() {
        let vec = add_last_vec(10);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
}
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[debug] [
  0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::DropVector {
    data: 10
  }
]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_failed_drop_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}
Copy a vector
Similarly, vectors cannot be copied (using
copy
) unless the element type has the
copy
capability. In other words, a
vector<T>
is copyable only if
T
has the.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop, copy {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_clone_vector() {
        let vec = add_last_vec(10);
        let vec_copy = copy vec;
    }
}
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_clone_vector
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Copying large
vectors
can be
expensive
, so the compiler requires explicit copies to make it easy to see where they occur.
Additional Vector Functions
|
Function
|
Parameters
|
Description
|
Return Value
|
| --- | --- | --- | --- |
|
empty<T>
| None | Creates an empty vector that can store values of type
T
|
vector<T>
|
|
singleton<T>
|
t: T
| Creates a vector of size 1 containing
t
|
vector<T>
|
|
push_back<T>
|
v: &mut vector<T>, t: T
| Adds
t
to the end of
v
| None |
|
pop_back<T>
|
v: &mut vector<T>
| Removes and returns the last element in
v
|
T
|
|
borrow<T>
|
v: &vector<T>, i: u64
| Returns an immutable reference to the
T
at index
i
|
&T
|
|
borrow_mut<T>
|
v: &mut vector<T>, i: u64
| Returns a mutable reference to the
T
at index
i
|
&mut T
|
|
destroy_empty<T>
|
v: vector<T>
| Deletes
v
| None |
|
append<T>
|
v1: &mut vector<T>, v2: vector<T>
| Adds the elements in
v2
to the end of
v1
| None |
|
contains<T>
|
v: &vector<T>, e: &T
| Returns true if
e
is in the vector
v
, otherwise false |
bool
|
|
swap<T>
|
v: &mut vector<T>, i: u64, j: u64
| Swaps the elements at the
i
th and
j
th indices in the vector
v
| None |
|
reverse<T>
|
v: &mut vector<T>
| Reverses the order of the elements in the vector
v
in place | None |
|
index_of<T>
|
v: &vector<T>, e: &T
| Returns
(true, i)
if
e
is in the vector
v
at index
i
, otherwise
(false, 0)
|
(bool, u64)
|
|
remove<T>
|
v: &mut vector<T>, i: u64
| Removes the
i
th element of the vector
v
, shifting all subsequent elements |
T
|
|
swap_remove<T>
|
v: &mut vector<T>, i: u64
| Swaps the
i
th element with the last element and then pops the element |
T
|
Overview String
In Move, String is not a native data type. Data in the Move VM is stored as bytes, so when using a string, the essence of the string will be a vector, a sequence of characters encoded as bytes arranged adjacently to create a string
module movement::string_type {
    use std::string::{String, utf8};
    use std::signer;
    use std::debug::print;
    fun vec_string() {
        let vec_string: vector<u8> = b"Hello by vector u8";
        let by_string: String = utf8(b"Hello by String");
        let by_vec: String = utf8(vec_string);
        print(&vec_string);
        print(&by_string);
        print(&by_vec);
    }
    #[test]
    fun test_vec_string() {
        vec_string()
    }
}
Running test:
movement move test -f test_vec_string
Result:
Running Move unit tests
[debug] 0x48656c6c6f20627920766563746f72207538
[debug] "Hello by String"
[debug] "Hello by vector u8"
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::string_type::test_vec_string
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Conclusion
Vectors and strings are fundamental data structures in Move that provide powerful capabilities for handling collections and text data. Here are the key takeaways:
Vectors (
vector<T>
) offer a flexible, homogeneous collection type that can be used with any data type in Move.
Vector operations like adding, removing, and accessing elements are efficient and well-supported by built-in functions.
The behavior of vectors depends on the capabilities of their element type, particularly for operations like destruction and copying.
Strings in Move are represented as
vector<u8>
, leveraging the vector structure for character sequences.
Move provides utility functions for string manipulation, including conversion between vector and String types.
Understanding these concepts is crucial for effective programming in Move, as they form the basis for many complex data structures and algorithms. Proper use of vectors and strings can lead to more efficient and maintainable code in Move-based smart contracts and applications.
			Summary
Move's primary collection type is
vector
, a homogeneous, expandable/shrinkable collection of T values.
Vectors can be initialized with any data type, including primitive types, custom types, and nested vectors.
Key vector operations include adding elements, accessing by index, and removing elements.
Vector behavior depends on the capabilities of its element type T, especially for destruction and copying.
Move provides various built-in functions for vector manipulation, such as
push_back
,
pop_back
, and
borrow
.
Strings in Move are represented as
vector<u8>
, with utility functions for conversion and manipulation.
This document covers the fundamentals of working with vectors and strings in Move, including creation, manipulation, and common operations.
Vector Overview
vector<T>
is the only collection type provided by Move. A
vector<T>
is a homogeneous collection of T values that can be expanded or shrunk by adding/removing values from its "end".
A
vector<T>
can be initialized with any data type as T. For example,
vector<u8>
,
vector<address>
,
vector<0x42::MovementModule::ResourceType>
, and
vector<vector<u8>>
let byte_string_example: vector<u8> = b"Hello world"; //Byte strings are quoted string literals prefixed by a b
let hex_string_example: vector<u8> = x"48656c6c6f20776f726c64"; //Hex strings are quoted string literals prefixed by a x
Add value into vector
The following code demonstrates how to add a value to the end of a vector in Move:
The function
add_last_vec
takes a
u64
number as input and returns a
vector<u64>
.
It creates an empty vector using
vector::empty<u64>()
.
The
vector::push_back
function is used to add the input number to the end of the vector.
The
test_add_last_vec
function demonstrates how to use this function and print the resulting vector.
This example showcases basic vector operations in Move, including creation, adding elements, and returning a vector from a function.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun add_last_vec(number: u64): vector<u64> {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, number);
        return list
    }
    #[test]
    fun test_add_last_vec() {
        let vec = add_last_vec(500);
        print(&vec);
    }
}
vector::push_back(&mut list, number);
Here's a breakdown of the arguments:
&mut list
:
This is the first argument to
push_back
.
The
&mut
indicates a mutable reference to
list
.
Mutable references allow the function to modify the original vector.
Using
&mut
is necessary because adding an element changes the vector's contents.
number
:
This is the second argument to
push_back
.
It's the value being added to the end of the vector. The type depends on the vector created earlier.
In this case, it's the
u64
value passed into the
add_last_vec
function.
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[debug] [ 500 ]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_last_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Get Value in vector by index
The following code demonstrates how to retrieve a value from a vector by its index in Move:
The function
get_value_by_index_vec
takes a
u64
index as input and returns a
u64
value.
It creates a vector and populates it with three values: 10, 20, and 30.
The
vector::borrow
function is used to access the element at the specified index. The
*
operator dereferences the borrowed value.
The
test_get_value_by_index_vec
function demonstrates how to use this function to retrieve and print a value from the vector.
This example illustrates how to access elements in a vector by their index, which is a fundamental operation when working with vectors in Move.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun get_value_by_index_vec(index: u64): u64 {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        return *vector::borrow(&list, index)
    }
    #[test]
    fun test_get_value_by_index_vec() {
        let value = get_value_by_index_vec(1);
        print(&value);
    }
}
Running test:
movement move test -f test_get_value_by_index_vec
Result:
Running Move unit tests
[debug] 20
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_get_value_by_index_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Take last value from vector
The following code demonstrates how to remove and return the last value from a vector in Move:
The function
take_last_value_in_vec
creates a vector with three elements: 10, 20, and 30.
It uses
vector::pop_back
to remove and return the last element (30) from the vector.
The function returns a tuple containing the modified vector and the removed value.
The
test_take_last_value_in_vec
function shows how to use this function and print both the resulting vector and the removed value.
This example illustrates how to manipulate vectors by removing elements, which is a common operation when working with dynamic collections in Move.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    
    fun take_last_value_in_vec(): (vector<u64>, u64) {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        let take_value: u64 = vector::pop_back(&mut list);
        return (list, take_value)
    }
    #[test]
    fun test_take_last_value_in_vec() {
        let (list, take_value) = take_last_value_in_vec();
        print(&list);
        print(&take_value);
    }
}
Running test:
movement move test -f test_take_last_value_in_vec
Result:
Running Move unit tests
[debug] [ 10, 20 ]
[debug] 30
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_take_last_value_in_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Destroying and Copying Vectors
Some behaviors of
vector<T>
depend on the capabilities of the element type
T
. For instance, vectors containing elements that can't be dropped can't be implicitly discarded like
v
in the example above. Instead, they must be explicitly destroyed using
vector::destroy_empty
.
Note:
vector::destroy_empty
will trigger a runtime error if the vector is empty (contains zero elements).
fun destroy_any_vector<T>(vec: vector<T>) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
}
Example:
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    #[test]
    fun test_add_vector() {
        let vec = add_last_vec(10);
        print(&vec);
    }
    #[test]
    #[expected_failure]
    fun test_failed_drop_vector() {
        let vec = add_last_vec(10);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
}
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[debug] [
  0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::DropVector {
    data: 10
  }
]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_failed_drop_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}
Copy a vector
Similarly, vectors cannot be copied (using
copy
) unless the element type has the
copy
capability. In other words, a
vector<T>
is copyable only if
T
has the.
module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop, copy {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_clone_vector() {
        let vec = add_last_vec(10);
        let vec_copy = copy vec;
    }
}
Running test:
movement move test -f vector_type
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_clone_vector
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Copying large
vectors
can be
expensive
, so the compiler requires explicit copies to make it easy to see where they occur.
Additional Vector Functions
|
Function
|
Parameters
|
Description
|
Return Value
|
| --- | --- | --- | --- |
|
empty<T>
| None | Creates an empty vector that can store values of type
T
|
vector<T>
|
|
singleton<T>
|
t: T
| Creates a vector of size 1 containing
t
|
vector<T>
|
|
push_back<T>
|
v: &mut vector<T>, t: T
| Adds
t
to the end of
v
| None |
|
pop_back<T>
|
v: &mut vector<T>
| Removes and returns the last element in
v
|
T
|
|
borrow<T>
|
v: &vector<T>, i: u64
| Returns an immutable reference to the
T
at index
i
|
&T
|
|
borrow_mut<T>
|
v: &mut vector<T>, i: u64
| Returns a mutable reference to the
T
at index
i
|
&mut T
|
|
destroy_empty<T>
|
v: vector<T>
| Deletes
v
| None |
|
append<T>
|
v1: &mut vector<T>, v2: vector<T>
| Adds the elements in
v2
to the end of
v1
| None |
|
contains<T>
|
v: &vector<T>, e: &T
| Returns true if
e
is in the vector
v
, otherwise false |
bool
|
|
swap<T>
|
v: &mut vector<T>, i: u64, j: u64
| Swaps the elements at the
i
th and
j
th indices in the vector
v
| None |
|
reverse<T>
|
v: &mut vector<T>
| Reverses the order of the elements in the vector
v
in place | None |
|
index_of<T>
|
v: &vector<T>, e: &T
| Returns
(true, i)
if
e
is in the vector
v
at index
i
, otherwise
(false, 0)
|
(bool, u64)
|
|
remove<T>
|
v: &mut vector<T>, i: u64
| Removes the
i
th element of the vector
v
, shifting all subsequent elements |
T
|
|
swap_remove<T>
|
v: &mut vector<T>, i: u64
| Swaps the
i
th element with the last element and then pops the element |
T
|
Overview String
In Move, String is not a native data type. Data in the Move VM is stored as bytes, so when using a string, the essence of the string will be a vector, a sequence of characters encoded as bytes arranged adjacently to create a string
module movement::string_type {
    use std::string::{String, utf8};
    use std::signer;
    use std::debug::print;
    fun vec_string() {
        let vec_string: vector<u8> = b"Hello by vector u8";
        let by_string: String = utf8(b"Hello by String");
        let by_vec: String = utf8(vec_string);
        print(&vec_string);
        print(&by_string);
        print(&by_vec);
    }
    #[test]
    fun test_vec_string() {
        vec_string()
    }
}
Running test:
movement move test -f test_vec_string
Result:
Running Move unit tests
[debug] 0x48656c6c6f20627920766563746f72207538
[debug] "Hello by String"
[debug] "Hello by vector u8"
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::string_type::test_vec_string
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Conclusion
Vectors and strings are fundamental data structures in Move that provide powerful capabilities for handling collections and text data. Here are the key takeaways:
Vectors (
vector<T>
) offer a flexible, homogeneous collection type that can be used with any data type in Move.
Vector operations like adding, removing, and accessing elements are efficient and well-supported by built-in functions.
The behavior of vectors depends on the capabilities of their element type, particularly for operations like destruction and copying.
Strings in Move are represented as
vector<u8>
, leveraging the vector structure for character sequences.
Move provides utility functions for string manipulation, including conversion between vector and String types.
Understanding these concepts is crucial for effective programming in Move, as they form the basis for many complex data structures and algorithms. Proper use of vectors and strings can lead to more efficient and maintainable code in Move-based smart contracts and applications.
	Summary
	Summary
	Move's primary collection type is
vector
, a homogeneous, expandable/shrinkable collection of T values.
Vectors can be initialized with any data type, including primitive types, custom types, and nested vectors.
Key vector operations include adding elements, accessing by index, and removing elements.
Vector behavior depends on the capabilities of its element type T, especially for destruction and copying.
Move provides various built-in functions for vector manipulation, such as
push_back
,
pop_back
, and
borrow
.
Strings in Move are represented as
vector<u8>
, with utility functions for conversion and manipulation.
	Move's primary collection type is
vector
, a homogeneous, expandable/shrinkable collection of T values.
	Move's primary collection type is
	<code>vector</code>
	vector
	, a homogeneous, expandable/shrinkable collection of T values.
	Vectors can be initialized with any data type, including primitive types, custom types, and nested vectors.
	Vectors can be initialized with any data type, including primitive types, custom types, and nested vectors.
	Key vector operations include adding elements, accessing by index, and removing elements.
	Key vector operations include adding elements, accessing by index, and removing elements.
	Vector behavior depends on the capabilities of its element type T, especially for destruction and copying.
	Vector behavior depends on the capabilities of its element type T, especially for destruction and copying.
	Move provides various built-in functions for vector manipulation, such as
push_back
,
pop_back
, and
borrow
.
	Move provides various built-in functions for vector manipulation, such as
	<code>push_back</code>
	push_back
	,
	<code>pop_back</code>
	pop_back
	, and
	<code>borrow</code>
	borrow
	.
	Strings in Move are represented as
vector<u8>
, with utility functions for conversion and manipulation.
	Strings in Move are represented as
	<code>vector<u8></code>
	vector<u8>
	, with utility functions for conversion and manipulation.
	This document covers the fundamentals of working with vectors and strings in Move, including creation, manipulation, and common operations.
	This document covers the fundamentals of working with vectors and strings in Move, including creation, manipulation, and common operations.
	Vector Overview
	Vector Overview
	vector<T>
is the only collection type provided by Move. A
vector<T>
is a homogeneous collection of T values that can be expanded or shrunk by adding/removing values from its "end".
A
vector<T>
can be initialized with any data type as T. For example,
vector<u8>
,
vector<address>
,
vector<0x42::MovementModule::ResourceType>
, and
vector<vector<u8>>
	vector<T>
is the only collection type provided by Move. A
vector<T>
is a homogeneous collection of T values that can be expanded or shrunk by adding/removing values from its "end".
	<code>vector<T></code>
	vector<T>
	is the only collection type provided by Move. A
	<code>vector<T></code>
	vector<T>
	is a homogeneous collection of T values that can be expanded or shrunk by adding/removing values from its "end".
	A
vector<T>
can be initialized with any data type as T. For example,
vector<u8>
,
vector<address>
,
vector<0x42::MovementModule::ResourceType>
, and
vector<vector<u8>>
	A
	<code>vector<T></code>
	vector<T>
	can be initialized with any data type as T. For example,
	<code>vector<u8></code>
	vector<u8>
	,
	<code>vector<address></code>
	vector<address>
	,
	<code>vector<0x42::MovementModule::ResourceType></code>
	vector<0x42::MovementModule::ResourceType>
	, and
	<code>vector<vector<u8>></code>
	vector<vector<u8>>
	<code>let byte_string_example: vector<u8> = b"Hello world"; //Byte strings are quoted string literals prefixed by a b
let hex_string_example: vector<u8> = x"48656c6c6f20776f726c64"; //Hex strings are quoted string literals prefixed by a x</code>
	<code>let byte_string_example: vector<u8> = b"Hello world"; //Byte strings are quoted string literals prefixed by a b
let hex_string_example: vector<u8> = x"48656c6c6f20776f726c64"; //Hex strings are quoted string literals prefixed by a x</code>
	let byte_string_example: vector<u8> = b"Hello world"; //Byte strings are quoted string literals prefixed by a b
let hex_string_example: vector<u8> = x"48656c6c6f20776f726c64"; //Hex strings are quoted string literals prefixed by a x
		Add value into vector
		Add value into vector
		The following code demonstrates how to add a value to the end of a vector in Move:
		The following code demonstrates how to add a value to the end of a vector in Move:
		The function
add_last_vec
takes a
u64
number as input and returns a
vector<u64>
.
It creates an empty vector using
vector::empty<u64>()
.
The
vector::push_back
function is used to add the input number to the end of the vector.
The
test_add_last_vec
function demonstrates how to use this function and print the resulting vector.
		The function
add_last_vec
takes a
u64
number as input and returns a
vector<u64>
.
		The function
		<code>add_last_vec</code>
		add_last_vec
		takes a
		<code>u64</code>
		u64
		number as input and returns a
		<code>vector<u64></code>
		vector<u64>
		.
		It creates an empty vector using
vector::empty<u64>()
.
		It creates an empty vector using
		<code>vector::empty<u64>()</code>
		vector::empty<u64>()
		.
		The
vector::push_back
function is used to add the input number to the end of the vector.
		The
		<code>vector::push_back</code>
		vector::push_back
		function is used to add the input number to the end of the vector.
		The
test_add_last_vec
function demonstrates how to use this function and print the resulting vector.
		The
		<code>test_add_last_vec</code>
		test_add_last_vec
		function demonstrates how to use this function and print the resulting vector.
		This example showcases basic vector operations in Move, including creation, adding elements, and returning a vector from a function.
		This example showcases basic vector operations in Move, including creation, adding elements, and returning a vector from a function.
		<code>module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun add_last_vec(number: u64): vector<u64> {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, number);
        return list
    }
    #[test]
    fun test_add_last_vec() {
        let vec = add_last_vec(500);
        print(&vec);
    }
}</code>
		<code>module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun add_last_vec(number: u64): vector<u64> {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, number);
        return list
    }
    #[test]
    fun test_add_last_vec() {
        let vec = add_last_vec(500);
        print(&vec);
    }
}</code>
		module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun add_last_vec(number: u64): vector<u64> {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, number);
        return list
    }
    #[test]
    fun test_add_last_vec() {
        let vec = add_last_vec(500);
        print(&vec);
    }
}
		<code>vector::push_back(&mut list, number);</code>
		<code>vector::push_back(&mut list, number);</code>
		vector::push_back(&mut list, number);
		Here's a breakdown of the arguments:
		Here's a breakdown of the arguments:
		&mut list
:
This is the first argument to
push_back
.
The
&mut
indicates a mutable reference to
list
.
Mutable references allow the function to modify the original vector.
Using
&mut
is necessary because adding an element changes the vector's contents.
number
:
This is the second argument to
push_back
.
It's the value being added to the end of the vector. The type depends on the vector created earlier.
In this case, it's the
u64
value passed into the
add_last_vec
function.
		&mut list
:
This is the first argument to
push_back
.
The
&mut
indicates a mutable reference to
list
.
Mutable references allow the function to modify the original vector.
Using
&mut
is necessary because adding an element changes the vector's contents.
		<code>&mut list</code>
		&mut list
		:
		This is the first argument to
push_back
.
The
&mut
indicates a mutable reference to
list
.
Mutable references allow the function to modify the original vector.
Using
&mut
is necessary because adding an element changes the vector's contents.
		This is the first argument to
push_back
.
		This is the first argument to
		<code>push_back</code>
		push_back
		.
		The
&mut
indicates a mutable reference to
list
.
		The
		<code>&mut</code>
		&mut
		indicates a mutable reference to
		<code>list</code>
		list
		.
		Mutable references allow the function to modify the original vector.
		Mutable references allow the function to modify the original vector.
		Using
&mut
is necessary because adding an element changes the vector's contents.
		Using
		<code>&mut</code>
		&mut
		is necessary because adding an element changes the vector's contents.
		number
:
This is the second argument to
push_back
.
It's the value being added to the end of the vector. The type depends on the vector created earlier.
In this case, it's the
u64
value passed into the
add_last_vec
function.
		<code>number</code>
		number
		:
		This is the second argument to
push_back
.
It's the value being added to the end of the vector. The type depends on the vector created earlier.
In this case, it's the
u64
value passed into the
add_last_vec
function.
		This is the second argument to
push_back
.
		This is the second argument to
		<code>push_back</code>
		push_back
		.
		It's the value being added to the end of the vector. The type depends on the vector created earlier.
		It's the value being added to the end of the vector. The type depends on the vector created earlier.
		In this case, it's the
u64
value passed into the
add_last_vec
function.
		In this case, it's the
		<code>u64</code>
		u64
		value passed into the
		<code>add_last_vec</code>
		add_last_vec
		function.
		Running test:
		Running test:
		Running test:
		<code>movement move test -f vector_type</code>
		<code>movement move test -f vector_type</code>
		movement move test -f vector_type
		Result:
		Result:
		Result:
		<code>Running Move unit tests
[debug] [ 500 ]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_last_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
		<code>Running Move unit tests
[debug] [ 500 ]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_last_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
		Running Move unit tests
[debug] [ 500 ]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_last_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
		Get Value in vector by index
		Get Value in vector by index
		The following code demonstrates how to retrieve a value from a vector by its index in Move:
		The following code demonstrates how to retrieve a value from a vector by its index in Move:
		The function
get_value_by_index_vec
takes a
u64
index as input and returns a
u64
value.
It creates a vector and populates it with three values: 10, 20, and 30.
The
vector::borrow
function is used to access the element at the specified index. The
*
operator dereferences the borrowed value.
The
test_get_value_by_index_vec
function demonstrates how to use this function to retrieve and print a value from the vector.
		The function
get_value_by_index_vec
takes a
u64
index as input and returns a
u64
value.
		The function
		<code>get_value_by_index_vec</code>
		get_value_by_index_vec
		takes a
		<code>u64</code>
		u64
		index as input and returns a
		<code>u64</code>
		u64
		value.
		It creates a vector and populates it with three values: 10, 20, and 30.
		It creates a vector and populates it with three values: 10, 20, and 30.
		The
vector::borrow
function is used to access the element at the specified index. The
*
operator dereferences the borrowed value.
		The
		<code>vector::borrow</code>
		vector::borrow
		function is used to access the element at the specified index. The
		<code>*</code>
		*
		operator dereferences the borrowed value.
		The
test_get_value_by_index_vec
function demonstrates how to use this function to retrieve and print a value from the vector.
		The
		<code>test_get_value_by_index_vec</code>
		test_get_value_by_index_vec
		function demonstrates how to use this function to retrieve and print a value from the vector.
		This example illustrates how to access elements in a vector by their index, which is a fundamental operation when working with vectors in Move.
		This example illustrates how to access elements in a vector by their index, which is a fundamental operation when working with vectors in Move.
		<code>module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun get_value_by_index_vec(index: u64): u64 {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        return *vector::borrow(&list, index)
    }
    #[test]
    fun test_get_value_by_index_vec() {
        let value = get_value_by_index_vec(1);
        print(&value);
    }
}</code>
		<code>module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun get_value_by_index_vec(index: u64): u64 {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        return *vector::borrow(&list, index)
    }
    #[test]
    fun test_get_value_by_index_vec() {
        let value = get_value_by_index_vec(1);
        print(&value);
    }
}</code>
		module movement::vector_type {
    use std::vector;
    use std::debug::print;
    fun get_value_by_index_vec(index: u64): u64 {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        return *vector::borrow(&list, index)
    }
    #[test]
    fun test_get_value_by_index_vec() {
        let value = get_value_by_index_vec(1);
        print(&value);
    }
}
		Running test:
		Running test:
		Running test:
		<code>movement move test -f test_get_value_by_index_vec</code>
		<code>movement move test -f test_get_value_by_index_vec</code>
		movement move test -f test_get_value_by_index_vec
		Result:
		Result:
		Result:
		<code>Running Move unit tests
[debug] 20
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_get_value_by_index_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
		<code>Running Move unit tests
[debug] 20
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_get_value_by_index_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
		Running Move unit tests
[debug] 20
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_get_value_by_index_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
		Take last value from vector
		Take last value from vector
		The following code demonstrates how to remove and return the last value from a vector in Move:
		The following code demonstrates how to remove and return the last value from a vector in Move:
		The function
take_last_value_in_vec
creates a vector with three elements: 10, 20, and 30.
It uses
vector::pop_back
to remove and return the last element (30) from the vector.
The function returns a tuple containing the modified vector and the removed value.
The
test_take_last_value_in_vec
function shows how to use this function and print both the resulting vector and the removed value.
		The function
take_last_value_in_vec
creates a vector with three elements: 10, 20, and 30.
		The function
		<code>take_last_value_in_vec</code>
		take_last_value_in_vec
		creates a vector with three elements: 10, 20, and 30.
		It uses
vector::pop_back
to remove and return the last element (30) from the vector.
		It uses
		<code>vector::pop_back</code>
		vector::pop_back
		to remove and return the last element (30) from the vector.
		The function returns a tuple containing the modified vector and the removed value.
		The function returns a tuple containing the modified vector and the removed value.
		The
test_take_last_value_in_vec
function shows how to use this function and print both the resulting vector and the removed value.
		The
		<code>test_take_last_value_in_vec</code>
		test_take_last_value_in_vec
		function shows how to use this function and print both the resulting vector and the removed value.
		This example illustrates how to manipulate vectors by removing elements, which is a common operation when working with dynamic collections in Move.
		This example illustrates how to manipulate vectors by removing elements, which is a common operation when working with dynamic collections in Move.
		<code>module movement::vector_type {
    use std::vector;
    use std::debug::print;
    
    fun take_last_value_in_vec(): (vector<u64>, u64) {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        let take_value: u64 = vector::pop_back(&mut list);
        return (list, take_value)
    }
    #[test]
    fun test_take_last_value_in_vec() {
        let (list, take_value) = take_last_value_in_vec();
        print(&list);
        print(&take_value);
    }
}</code>
		<code>module movement::vector_type {
    use std::vector;
    use std::debug::print;
    
    fun take_last_value_in_vec(): (vector<u64>, u64) {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        let take_value: u64 = vector::pop_back(&mut list);
        return (list, take_value)
    }
    #[test]
    fun test_take_last_value_in_vec() {
        let (list, take_value) = take_last_value_in_vec();
        print(&list);
        print(&take_value);
    }
}</code>
		module movement::vector_type {
    use std::vector;
    use std::debug::print;
    
    fun take_last_value_in_vec(): (vector<u64>, u64) {
        let list = vector::empty<u64>();
        vector::push_back(&mut list, 10);
        vector::push_back(&mut list, 20);
        vector::push_back(&mut list, 30);
        let take_value: u64 = vector::pop_back(&mut list);
        return (list, take_value)
    }
    #[test]
    fun test_take_last_value_in_vec() {
        let (list, take_value) = take_last_value_in_vec();
        print(&list);
        print(&take_value);
    }
}
		Running test:
		Running test:
		Running test:
		<code>movement move test -f test_take_last_value_in_vec</code>
		<code>movement move test -f test_take_last_value_in_vec</code>
		movement move test -f test_take_last_value_in_vec
		Result:
		Result:
		Result:
		<code>Running Move unit tests
[debug] [ 10, 20 ]
[debug] 30
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_take_last_value_in_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
		<code>Running Move unit tests
[debug] [ 10, 20 ]
[debug] 30
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_take_last_value_in_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
		Running Move unit tests
[debug] [ 10, 20 ]
[debug] 30
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_take_last_value_in_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
		Destroying and Copying Vectors
		Destroying and Copying Vectors
		Some behaviors of
vector<T>
depend on the capabilities of the element type
T
. For instance, vectors containing elements that can't be dropped can't be implicitly discarded like
v
in the example above. Instead, they must be explicitly destroyed using
vector::destroy_empty
.
		Some behaviors of
vector<T>
depend on the capabilities of the element type
T
. For instance, vectors containing elements that can't be dropped can't be implicitly discarded like
v
in the example above. Instead, they must be explicitly destroyed using
vector::destroy_empty
.
		Some behaviors of
		<code>vector<T></code>
		vector<T>
		depend on the capabilities of the element type
		<code>T</code>
		T
		. For instance, vectors containing elements that can't be dropped can't be implicitly discarded like
		<code>v</code>
		v
		in the example above. Instead, they must be explicitly destroyed using
		<code>vector::destroy_empty</code>
		vector::destroy_empty
		.
		Note:
vector::destroy_empty
will trigger a runtime error if the vector is empty (contains zero elements).
		Note:
		<code>vector::destroy_empty</code>
		vector::destroy_empty
		will trigger a runtime error if the vector is empty (contains zero elements).
		<code>fun destroy_any_vector<T>(vec: vector<T>) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
}</code>
		<code>fun destroy_any_vector<T>(vec: vector<T>) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
}</code>
		fun destroy_any_vector<T>(vec: vector<T>) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
}
		Example:
		Example:
		Example:
		<code>module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    #[test]
    fun test_add_vector() {
        let vec = add_last_vec(10);
        print(&vec);
    }
    #[test]
    #[expected_failure]
    fun test_failed_drop_vector() {
        let vec = add_last_vec(10);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
}</code>
		<code>module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    #[test]
    fun test_add_vector() {
        let vec = add_last_vec(10);
        print(&vec);
    }
    #[test]
    #[expected_failure]
    fun test_failed_drop_vector() {
        let vec = add_last_vec(10);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
}</code>
		module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    #[test]
    fun test_add_vector() {
        let vec = add_last_vec(10);
        print(&vec);
    }
    #[test]
    #[expected_failure]
    fun test_failed_drop_vector() {
        let vec = add_last_vec(10);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
}
		Running test:
		Running test:
		Running test:
		<code>movement move test -f vector_type</code>
		<code>movement move test -f vector_type</code>
		movement move test -f vector_type
		Result:
		Result:
		Result:
		<code>Running Move unit tests
[debug] [
  0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::DropVector {
    data: 10
  }
]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_failed_drop_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}</code>
		<code>Running Move unit tests
[debug] [
  0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::DropVector {
    data: 10
  }
]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_failed_drop_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}</code>
		Running Move unit tests
[debug] [
  0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::DropVector {
    data: 10
  }
]
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_add_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_failed_drop_vector
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 3; passed: 3; failed: 0
{
  "Result": "Success"
}
		Copy a vector
		Copy a vector
		Similarly, vectors cannot be copied (using
copy
) unless the element type has the
copy
capability. In other words, a
vector<T>
is copyable only if
T
has the.
		Similarly, vectors cannot be copied (using
		<code>copy</code>
		copy
		) unless the element type has the
		<code>copy</code>
		copy
		capability. In other words, a
		<code>vector<T></code>
		vector<T>
		is copyable only if
		<code>T</code>
		T
		has the.
		<code>module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop, copy {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_clone_vector() {
        let vec = add_last_vec(10);
        let vec_copy = copy vec;
    }
}</code>
		<code>module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop, copy {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_clone_vector() {
        let vec = add_last_vec(10);
        let vec_copy = copy vec;
    }
}</code>
		module movement::vector_type {
    use std::vector;
    use std::debug::print;
    struct DropVector has drop, copy {
        data: u64
    }
    fun add_last_vec(number: u64): vector<DropVector> {
        let list = vector::empty<DropVector>();
        vector::push_back(&mut list, DropVector { data: number });
        return list
    }
    
    #[test]
    fun test_success_drop_vector() {
        let vec = add_last_vec(10);
        vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
    }
    #[test]
    fun test_clone_vector() {
        let vec = add_last_vec(10);
        let vec_copy = copy vec;
    }
}
		Running test:
		Running test:
		Running test:
		<code>movement move test -f vector_type</code>
		<code>movement move test -f vector_type</code>
		movement move test -f vector_type
		Result:
		Result:
		Result:
		<code>Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_clone_vector
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}</code>
		<code>Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_clone_vector
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}</code>
		Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_clone_vector
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::test_success_drop_vectorTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
		Copying large
vectors
can be
expensive
, so the compiler requires explicit copies to make it easy to see where they occur.
		Copying large
		<code>vectors</code>
		vectors
		can be
		expensive
		expensive
		, so the compiler requires explicit copies to make it easy to see where they occur.
	Additional Vector Functions
	Additional Vector Functions
	|
Function
|
Parameters
|
Description
|
Return Value
|
| --- | --- | --- | --- |
|
empty<T>
| None | Creates an empty vector that can store values of type
T
|
vector<T>
|
|
singleton<T>
|
t: T
| Creates a vector of size 1 containing
t
|
vector<T>
|
|
push_back<T>
|
v: &mut vector<T>, t: T
| Adds
t
to the end of
v
| None |
|
pop_back<T>
|
v: &mut vector<T>
| Removes and returns the last element in
v
|
T
|
|
borrow<T>
|
v: &vector<T>, i: u64
| Returns an immutable reference to the
T
at index
i
|
&T
|
|
borrow_mut<T>
|
v: &mut vector<T>, i: u64
| Returns a mutable reference to the
T
at index
i
|
&mut T
|
|
destroy_empty<T>
|
v: vector<T>
| Deletes
v
| None |
|
append<T>
|
v1: &mut vector<T>, v2: vector<T>
| Adds the elements in
v2
to the end of
v1
| None |
|
contains<T>
|
v: &vector<T>, e: &T
| Returns true if
e
is in the vector
v
, otherwise false |
bool
|
|
swap<T>
|
v: &mut vector<T>, i: u64, j: u64
| Swaps the elements at the
i
th and
j
th indices in the vector
v
| None |
|
reverse<T>
|
v: &mut vector<T>
| Reverses the order of the elements in the vector
v
in place | None |
|
index_of<T>
|
v: &vector<T>, e: &T
| Returns
(true, i)
if
e
is in the vector
v
at index
i
, otherwise
(false, 0)
|
(bool, u64)
|
|
remove<T>
|
v: &mut vector<T>, i: u64
| Removes the
i
th element of the vector
v
, shifting all subsequent elements |
T
|
|
swap_remove<T>
|
v: &mut vector<T>, i: u64
| Swaps the
i
th element with the last element and then pops the element |
T
|
	|
	Function
	Function
	|
	Parameters
	Parameters
	|
	Description
	Description
	|
	Return Value
	Return Value
	|
| --- | --- | --- | --- |
|
	<code>empty<T></code>
	empty<T>
	| None | Creates an empty vector that can store values of type
	<code>T</code>
	T
	|
	<code>vector<T></code>
	vector<T>
	|
|
	<code>singleton<T></code>
	singleton<T>
	|
	<code>t: T</code>
	t: T
	| Creates a vector of size 1 containing
	<code>t</code>
	t
	|
	<code>vector<T></code>
	vector<T>
	|
|
	<code>push_back<T></code>
	push_back<T>
	|
	<code>v: &mut vector<T>, t: T</code>
	v: &mut vector<T>, t: T
	| Adds
	<code>t</code>
	t
	to the end of
	<code>v</code>
	v
	| None |
|
	<code>pop_back<T></code>
	pop_back<T>
	|
	<code>v: &mut vector<T></code>
	v: &mut vector<T>
	| Removes and returns the last element in
	<code>v</code>
	v
	|
	<code>T</code>
	T
	|
|
	<code>borrow<T></code>
	borrow<T>
	|
	<code>v: &vector<T>, i: u64</code>
	v: &vector<T>, i: u64
	| Returns an immutable reference to the
	<code>T</code>
	T
	at index
	<code>i</code>
	i
	|
	<code>&T</code>
	&T
	|
|
	<code>borrow_mut<T></code>
	borrow_mut<T>
	|
	<code>v: &mut vector<T>, i: u64</code>
	v: &mut vector<T>, i: u64
	| Returns a mutable reference to the
	<code>T</code>
	T
	at index
	<code>i</code>
	i
	|
	<code>&mut T</code>
	&mut T
	|
|
	<code>destroy_empty<T></code>
	destroy_empty<T>
	|
	<code>v: vector<T></code>
	v: vector<T>
	| Deletes
	<code>v</code>
	v
	| None |
|
	<code>append<T></code>
	append<T>
	|
	<code>v1: &mut vector<T>, v2: vector<T></code>
	v1: &mut vector<T>, v2: vector<T>
	| Adds the elements in
	<code>v2</code>
	v2
	to the end of
	<code>v1</code>
	v1
	| None |
|
	<code>contains<T></code>
	contains<T>
	|
	<code>v: &vector<T>, e: &T</code>
	v: &vector<T>, e: &T
	| Returns true if
	<code>e</code>
	e
	is in the vector
	<code>v</code>
	v
	, otherwise false |
	<code>bool</code>
	bool
	|
|
	<code>swap<T></code>
	swap<T>
	|
	<code>v: &mut vector<T>, i: u64, j: u64</code>
	v: &mut vector<T>, i: u64, j: u64
	| Swaps the elements at the
	<code>i</code>
	i
	th and
	<code>j</code>
	j
	th indices in the vector
	<code>v</code>
	v
	| None |
|
	<code>reverse<T></code>
	reverse<T>
	|
	<code>v: &mut vector<T></code>
	v: &mut vector<T>
	| Reverses the order of the elements in the vector
	<code>v</code>
	v
	in place | None |
|
	<code>index_of<T></code>
	index_of<T>
	|
	<code>v: &vector<T>, e: &T</code>
	v: &vector<T>, e: &T
	| Returns
	<code>(true, i)</code>
	(true, i)
	if
	<code>e</code>
	e
	is in the vector
	<code>v</code>
	v
	at index
	<code>i</code>
	i
	, otherwise
	<code>(false, 0)</code>
	(false, 0)
	|
	<code>(bool, u64)</code>
	(bool, u64)
	|
|
	<code>remove<T></code>
	remove<T>
	|
	<code>v: &mut vector<T>, i: u64</code>
	v: &mut vector<T>, i: u64
	| Removes the
	<code>i</code>
	i
	th element of the vector
	<code>v</code>
	v
	, shifting all subsequent elements |
	<code>T</code>
	T
	|
|
	<code>swap_remove<T></code>
	swap_remove<T>
	|
	<code>v: &mut vector<T>, i: u64</code>
	v: &mut vector<T>, i: u64
	| Swaps the
	<code>i</code>
	i
	th element with the last element and then pops the element |
	<code>T</code>
	T
	|
	Overview String
	Overview String
	In Move, String is not a native data type. Data in the Move VM is stored as bytes, so when using a string, the essence of the string will be a vector, a sequence of characters encoded as bytes arranged adjacently to create a string
	In Move, String is not a native data type. Data in the Move VM is stored as bytes, so when using a string, the essence of the string will be a vector, a sequence of characters encoded as bytes arranged adjacently to create a string
	<code>module movement::string_type {
    use std::string::{String, utf8};
    use std::signer;
    use std::debug::print;
    fun vec_string() {
        let vec_string: vector<u8> = b"Hello by vector u8";
        let by_string: String = utf8(b"Hello by String");
        let by_vec: String = utf8(vec_string);
        print(&vec_string);
        print(&by_string);
        print(&by_vec);
    }
    #[test]
    fun test_vec_string() {
        vec_string()
    }
}</code>
	<code>module movement::string_type {
    use std::string::{String, utf8};
    use std::signer;
    use std::debug::print;
    fun vec_string() {
        let vec_string: vector<u8> = b"Hello by vector u8";
        let by_string: String = utf8(b"Hello by String");
        let by_vec: String = utf8(vec_string);
        print(&vec_string);
        print(&by_string);
        print(&by_vec);
    }
    #[test]
    fun test_vec_string() {
        vec_string()
    }
}</code>
	module movement::string_type {
    use std::string::{String, utf8};
    use std::signer;
    use std::debug::print;
    fun vec_string() {
        let vec_string: vector<u8> = b"Hello by vector u8";
        let by_string: String = utf8(b"Hello by String");
        let by_vec: String = utf8(vec_string);
        print(&vec_string);
        print(&by_string);
        print(&by_vec);
    }
    #[test]
    fun test_vec_string() {
        vec_string()
    }
}
	Running test:
	Running test:
	Running test:
	<code>movement move test -f test_vec_string</code>
	<code>movement move test -f test_vec_string</code>
	movement move test -f test_vec_string
	Result:
	Result:
	Result:
	<code>Running Move unit tests
[debug] 0x48656c6c6f20627920766563746f72207538
[debug] "Hello by String"
[debug] "Hello by vector u8"
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::string_type::test_vec_string
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	<code>Running Move unit tests
[debug] 0x48656c6c6f20627920766563746f72207538
[debug] "Hello by String"
[debug] "Hello by vector u8"
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::string_type::test_vec_string
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	Running Move unit tests
[debug] 0x48656c6c6f20627920766563746f72207538
[debug] "Hello by String"
[debug] "Hello by vector u8"
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::string_type::test_vec_string
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
	Conclusion
	Conclusion
	Vectors and strings are fundamental data structures in Move that provide powerful capabilities for handling collections and text data. Here are the key takeaways:
	Vectors and strings are fundamental data structures in Move that provide powerful capabilities for handling collections and text data. Here are the key takeaways:
	Vectors (
vector<T>
) offer a flexible, homogeneous collection type that can be used with any data type in Move.
Vector operations like adding, removing, and accessing elements are efficient and well-supported by built-in functions.
The behavior of vectors depends on the capabilities of their element type, particularly for operations like destruction and copying.
Strings in Move are represented as
vector<u8>
, leveraging the vector structure for character sequences.
Move provides utility functions for string manipulation, including conversion between vector and String types.
	Vectors (
vector<T>
) offer a flexible, homogeneous collection type that can be used with any data type in Move.
	Vectors (
	<code>vector<T></code>
	vector<T>
	) offer a flexible, homogeneous collection type that can be used with any data type in Move.
	Vector operations like adding, removing, and accessing elements are efficient and well-supported by built-in functions.
	Vector operations like adding, removing, and accessing elements are efficient and well-supported by built-in functions.
	The behavior of vectors depends on the capabilities of their element type, particularly for operations like destruction and copying.
	The behavior of vectors depends on the capabilities of their element type, particularly for operations like destruction and copying.
	Strings in Move are represented as
vector<u8>
, leveraging the vector structure for character sequences.
	Strings in Move are represented as
	<code>vector<u8></code>
	vector<u8>
	, leveraging the vector structure for character sequences.
	Move provides utility functions for string manipulation, including conversion between vector and String types.
	Move provides utility functions for string manipulation, including conversion between vector and String types.
	Understanding these concepts is crucial for effective programming in Move, as they form the basis for many complex data structures and algorithms. Proper use of vectors and strings can lead to more efficient and maintainable code in Move-based smart contracts and applications.
	Understanding these concepts is crucial for effective programming in Move, as they form the basis for many complex data structures and algorithms. Proper use of vectors and strings can lead to more efficient and maintainable code in Move-based smart contracts and applications.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/02-data-types/05-map-simple-map
Map (Simple Map)
Map (Simple Map)
On This Page
Overview
Example:
Additional SimpleMap Functions
Overview
0x1::simple_map
This module provides a solution for map features. Maps will have the following characteristics:
Keys point to Values: Each key is associated with a value.
Each key must be unique: No two keys are duplicated.
A Key can be found within O(Log N) time
Data is stored in order sorted by Key: Elements in maps are arranged based on the key.
Adding and removing elements takes O(N) time: The time to add or remove an element is proportional to the number of elements in the map.
Example:
The code below demonstrates the usage of a SimpleMap in the Move programming language:
It defines a module called
SimpleMapType
within the
movement
module.
The module imports necessary dependencies:
SimpleMap
from the
simple_map
module,
print
from the
debug
module, and
signer
from the standard library.
A function
map_in_move
is defined that takes a signer reference as an argument and returns a
SimpleMap
with address keys and u64 values.
Inside
map_in_move
, a new SimpleMap is created using
simple_map::create()
.
An element is added to the map using
simple_map::add()
, where the key is the signer's address and the value is 10.
The function returns the created map.
A test function
test_map_in_move
is defined using the
#[test]
attribute. It calls
map_in_move
and prints the resulting map.
This example showcases how to create, populate, and use a SimpleMap in Move, demonstrating its basic operations and integration with other Move concepts like signers and testing.
module movement::simple_map_module {
    use std::simple_map::{SimpleMap, Self};
    use std::debug::print;
    use std::signer;
    fun map_in_move(sign: &signer): SimpleMap<address, u64> {
        let mp: SimpleMap<address, u64> = simple_map::create();
        simple_map::add(&mut mp, signer::address_of(sign), 10);
        return mp
    }
    #[test(account = @0x1)]
    fun test_map_in_move(account: &signer) {
        let map = map_in_move(account);
        print(&map);
    }
}
Running test:
movement move test -f test_map_in_move
Result:
Running Move unit tests
[debug] 0x1::simple_map::SimpleMap<address, u64> {
  data: [
    0x1::simple_map::Element<address, u64> {
      key: @0x1,
      value: 10
    }
  ]
}
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::simple_map_module::test_map_in_move
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Additional SimpleMap Functions
|
Function
|
Description
|
Return Value
|
| --- | --- | --- |
|
length
| Gets the number of elements |
u64
|
|
new
| Creates an empty SimpleMap |
SimpleMap<K, V>
|
|
new_from
| Creates from key-value vectors |
SimpleMap<K, V>
|
|
create
| Deprecated alias for
new
|
SimpleMap<K, V>
|
|
borrow
| Borrows a value by key |
&V
|
|
borrow_mut
| Mutably borrows a value by key |
&mut V
|
|
contains_key
| Checks for key existence |
bool
|
|
destroy_empty
| Destroys an empty map | None |
|
add
| Adds a key-value pair | None |
|
add_all
| Adds multiple key-value pairs | None |
|
upsert
| Inserts or updates a pair | None |
|
keys
| Gets all keys |
vector<K>
|
|
values
| Gets all values |
vector<V>
|
|
to_vec_pair
| Converts to key-value vectors |
(vector<K, V>)
|
|
destroy
| Destroys map with lambdas | None |
|
remove
| Removes and returns a pair |
(K, V)
|
|
find
| Finds key index (internal) |
Option<u64>
|
On This Page
Overview
Example:
Additional SimpleMap Functions
On This Page
Overview
Example:
Additional SimpleMap Functions
			On This Page
			On This Page
			Overview
Example:
Additional SimpleMap Functions
			Overview
			Overview
			Overview
			Overview
			Example:
			Example:
			Example:
			Example:
			Additional SimpleMap Functions
			Additional SimpleMap Functions
			Additional SimpleMap Functions
			Additional SimpleMap Functions
			Overview
0x1::simple_map
This module provides a solution for map features. Maps will have the following characteristics:
Keys point to Values: Each key is associated with a value.
Each key must be unique: No two keys are duplicated.
A Key can be found within O(Log N) time
Data is stored in order sorted by Key: Elements in maps are arranged based on the key.
Adding and removing elements takes O(N) time: The time to add or remove an element is proportional to the number of elements in the map.
Example:
The code below demonstrates the usage of a SimpleMap in the Move programming language:
It defines a module called
SimpleMapType
within the
movement
module.
The module imports necessary dependencies:
SimpleMap
from the
simple_map
module,
print
from the
debug
module, and
signer
from the standard library.
A function
map_in_move
is defined that takes a signer reference as an argument and returns a
SimpleMap
with address keys and u64 values.
Inside
map_in_move
, a new SimpleMap is created using
simple_map::create()
.
An element is added to the map using
simple_map::add()
, where the key is the signer's address and the value is 10.
The function returns the created map.
A test function
test_map_in_move
is defined using the
#[test]
attribute. It calls
map_in_move
and prints the resulting map.
This example showcases how to create, populate, and use a SimpleMap in Move, demonstrating its basic operations and integration with other Move concepts like signers and testing.
module movement::simple_map_module {
    use std::simple_map::{SimpleMap, Self};
    use std::debug::print;
    use std::signer;
    fun map_in_move(sign: &signer): SimpleMap<address, u64> {
        let mp: SimpleMap<address, u64> = simple_map::create();
        simple_map::add(&mut mp, signer::address_of(sign), 10);
        return mp
    }
    #[test(account = @0x1)]
    fun test_map_in_move(account: &signer) {
        let map = map_in_move(account);
        print(&map);
    }
}
Running test:
movement move test -f test_map_in_move
Result:
Running Move unit tests
[debug] 0x1::simple_map::SimpleMap<address, u64> {
  data: [
    0x1::simple_map::Element<address, u64> {
      key: @0x1,
      value: 10
    }
  ]
}
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::simple_map_module::test_map_in_move
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Additional SimpleMap Functions
|
Function
|
Description
|
Return Value
|
| --- | --- | --- |
|
length
| Gets the number of elements |
u64
|
|
new
| Creates an empty SimpleMap |
SimpleMap<K, V>
|
|
new_from
| Creates from key-value vectors |
SimpleMap<K, V>
|
|
create
| Deprecated alias for
new
|
SimpleMap<K, V>
|
|
borrow
| Borrows a value by key |
&V
|
|
borrow_mut
| Mutably borrows a value by key |
&mut V
|
|
contains_key
| Checks for key existence |
bool
|
|
destroy_empty
| Destroys an empty map | None |
|
add
| Adds a key-value pair | None |
|
add_all
| Adds multiple key-value pairs | None |
|
upsert
| Inserts or updates a pair | None |
|
keys
| Gets all keys |
vector<K>
|
|
values
| Gets all values |
vector<V>
|
|
to_vec_pair
| Converts to key-value vectors |
(vector<K, V>)
|
|
destroy
| Destroys map with lambdas | None |
|
remove
| Removes and returns a pair |
(K, V)
|
|
find
| Finds key index (internal) |
Option<u64>
|
			Overview
0x1::simple_map
This module provides a solution for map features. Maps will have the following characteristics:
Keys point to Values: Each key is associated with a value.
Each key must be unique: No two keys are duplicated.
A Key can be found within O(Log N) time
Data is stored in order sorted by Key: Elements in maps are arranged based on the key.
Adding and removing elements takes O(N) time: The time to add or remove an element is proportional to the number of elements in the map.
Example:
The code below demonstrates the usage of a SimpleMap in the Move programming language:
It defines a module called
SimpleMapType
within the
movement
module.
The module imports necessary dependencies:
SimpleMap
from the
simple_map
module,
print
from the
debug
module, and
signer
from the standard library.
A function
map_in_move
is defined that takes a signer reference as an argument and returns a
SimpleMap
with address keys and u64 values.
Inside
map_in_move
, a new SimpleMap is created using
simple_map::create()
.
An element is added to the map using
simple_map::add()
, where the key is the signer's address and the value is 10.
The function returns the created map.
A test function
test_map_in_move
is defined using the
#[test]
attribute. It calls
map_in_move
and prints the resulting map.
This example showcases how to create, populate, and use a SimpleMap in Move, demonstrating its basic operations and integration with other Move concepts like signers and testing.
module movement::simple_map_module {
    use std::simple_map::{SimpleMap, Self};
    use std::debug::print;
    use std::signer;
    fun map_in_move(sign: &signer): SimpleMap<address, u64> {
        let mp: SimpleMap<address, u64> = simple_map::create();
        simple_map::add(&mut mp, signer::address_of(sign), 10);
        return mp
    }
    #[test(account = @0x1)]
    fun test_map_in_move(account: &signer) {
        let map = map_in_move(account);
        print(&map);
    }
}
Running test:
movement move test -f test_map_in_move
Result:
Running Move unit tests
[debug] 0x1::simple_map::SimpleMap<address, u64> {
  data: [
    0x1::simple_map::Element<address, u64> {
      key: @0x1,
      value: 10
    }
  ]
}
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::simple_map_module::test_map_in_move
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Additional SimpleMap Functions
|
Function
|
Description
|
Return Value
|
| --- | --- | --- |
|
length
| Gets the number of elements |
u64
|
|
new
| Creates an empty SimpleMap |
SimpleMap<K, V>
|
|
new_from
| Creates from key-value vectors |
SimpleMap<K, V>
|
|
create
| Deprecated alias for
new
|
SimpleMap<K, V>
|
|
borrow
| Borrows a value by key |
&V
|
|
borrow_mut
| Mutably borrows a value by key |
&mut V
|
|
contains_key
| Checks for key existence |
bool
|
|
destroy_empty
| Destroys an empty map | None |
|
add
| Adds a key-value pair | None |
|
add_all
| Adds multiple key-value pairs | None |
|
upsert
| Inserts or updates a pair | None |
|
keys
| Gets all keys |
vector<K>
|
|
values
| Gets all values |
vector<V>
|
|
to_vec_pair
| Converts to key-value vectors |
(vector<K, V>)
|
|
destroy
| Destroys map with lambdas | None |
|
remove
| Removes and returns a pair |
(K, V)
|
|
find
| Finds key index (internal) |
Option<u64>
|
			Overview
0x1::simple_map
This module provides a solution for map features. Maps will have the following characteristics:
Keys point to Values: Each key is associated with a value.
Each key must be unique: No two keys are duplicated.
A Key can be found within O(Log N) time
Data is stored in order sorted by Key: Elements in maps are arranged based on the key.
Adding and removing elements takes O(N) time: The time to add or remove an element is proportional to the number of elements in the map.
Example:
The code below demonstrates the usage of a SimpleMap in the Move programming language:
It defines a module called
SimpleMapType
within the
movement
module.
The module imports necessary dependencies:
SimpleMap
from the
simple_map
module,
print
from the
debug
module, and
signer
from the standard library.
A function
map_in_move
is defined that takes a signer reference as an argument and returns a
SimpleMap
with address keys and u64 values.
Inside
map_in_move
, a new SimpleMap is created using
simple_map::create()
.
An element is added to the map using
simple_map::add()
, where the key is the signer's address and the value is 10.
The function returns the created map.
A test function
test_map_in_move
is defined using the
#[test]
attribute. It calls
map_in_move
and prints the resulting map.
This example showcases how to create, populate, and use a SimpleMap in Move, demonstrating its basic operations and integration with other Move concepts like signers and testing.
module movement::simple_map_module {
    use std::simple_map::{SimpleMap, Self};
    use std::debug::print;
    use std::signer;
    fun map_in_move(sign: &signer): SimpleMap<address, u64> {
        let mp: SimpleMap<address, u64> = simple_map::create();
        simple_map::add(&mut mp, signer::address_of(sign), 10);
        return mp
    }
    #[test(account = @0x1)]
    fun test_map_in_move(account: &signer) {
        let map = map_in_move(account);
        print(&map);
    }
}
Running test:
movement move test -f test_map_in_move
Result:
Running Move unit tests
[debug] 0x1::simple_map::SimpleMap<address, u64> {
  data: [
    0x1::simple_map::Element<address, u64> {
      key: @0x1,
      value: 10
    }
  ]
}
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::simple_map_module::test_map_in_move
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Additional SimpleMap Functions
|
Function
|
Description
|
Return Value
|
| --- | --- | --- |
|
length
| Gets the number of elements |
u64
|
|
new
| Creates an empty SimpleMap |
SimpleMap<K, V>
|
|
new_from
| Creates from key-value vectors |
SimpleMap<K, V>
|
|
create
| Deprecated alias for
new
|
SimpleMap<K, V>
|
|
borrow
| Borrows a value by key |
&V
|
|
borrow_mut
| Mutably borrows a value by key |
&mut V
|
|
contains_key
| Checks for key existence |
bool
|
|
destroy_empty
| Destroys an empty map | None |
|
add
| Adds a key-value pair | None |
|
add_all
| Adds multiple key-value pairs | None |
|
upsert
| Inserts or updates a pair | None |
|
keys
| Gets all keys |
vector<K>
|
|
values
| Gets all values |
vector<V>
|
|
to_vec_pair
| Converts to key-value vectors |
(vector<K, V>)
|
|
destroy
| Destroys map with lambdas | None |
|
remove
| Removes and returns a pair |
(K, V)
|
|
find
| Finds key index (internal) |
Option<u64>
|
	Overview
	Overview
	0x1::simple_map
	<code>0x1::simple_map</code>
	0x1::simple_map
	This module provides a solution for map features. Maps will have the following characteristics:
	This module provides a solution for map features. Maps will have the following characteristics:
	Keys point to Values: Each key is associated with a value.
Each key must be unique: No two keys are duplicated.
A Key can be found within O(Log N) time
Data is stored in order sorted by Key: Elements in maps are arranged based on the key.
Adding and removing elements takes O(N) time: The time to add or remove an element is proportional to the number of elements in the map.
	Keys point to Values: Each key is associated with a value.
	Keys point to Values: Each key is associated with a value.
	Each key must be unique: No two keys are duplicated.
	Each key must be unique: No two keys are duplicated.
	A Key can be found within O(Log N) time
	A Key can be found within O(Log N) time
	Data is stored in order sorted by Key: Elements in maps are arranged based on the key.
	Data is stored in order sorted by Key: Elements in maps are arranged based on the key.
	Adding and removing elements takes O(N) time: The time to add or remove an element is proportional to the number of elements in the map.
	Adding and removing elements takes O(N) time: The time to add or remove an element is proportional to the number of elements in the map.
	Example:
	Example:
	The code below demonstrates the usage of a SimpleMap in the Move programming language:
	The code below demonstrates the usage of a SimpleMap in the Move programming language:
	It defines a module called
SimpleMapType
within the
movement
module.
The module imports necessary dependencies:
SimpleMap
from the
simple_map
module,
print
from the
debug
module, and
signer
from the standard library.
A function
map_in_move
is defined that takes a signer reference as an argument and returns a
SimpleMap
with address keys and u64 values.
Inside
map_in_move
, a new SimpleMap is created using
simple_map::create()
.
An element is added to the map using
simple_map::add()
, where the key is the signer's address and the value is 10.
The function returns the created map.
A test function
test_map_in_move
is defined using the
#[test]
attribute. It calls
map_in_move
and prints the resulting map.
	It defines a module called
SimpleMapType
within the
movement
module.
	It defines a module called
	<code>SimpleMapType</code>
	SimpleMapType
	within the
	<code>movement</code>
	movement
	module.
	The module imports necessary dependencies:
SimpleMap
from the
simple_map
module,
print
from the
debug
module, and
signer
from the standard library.
	The module imports necessary dependencies:
	<code>SimpleMap</code>
	SimpleMap
	from the
	<code>simple_map</code>
	simple_map
	module,
	<code>print</code>
	print
	from the
	<code>debug</code>
	debug
	module, and
	<code>signer</code>
	signer
	from the standard library.
	A function
map_in_move
is defined that takes a signer reference as an argument and returns a
SimpleMap
with address keys and u64 values.
	A function
	<code>map_in_move</code>
	map_in_move
	is defined that takes a signer reference as an argument and returns a
	<code>SimpleMap</code>
	SimpleMap
	with address keys and u64 values.
	Inside
map_in_move
, a new SimpleMap is created using
simple_map::create()
.
	Inside
	<code>map_in_move</code>
	map_in_move
	, a new SimpleMap is created using
	<code>simple_map::create()</code>
	simple_map::create()
	.
	An element is added to the map using
simple_map::add()
, where the key is the signer's address and the value is 10.
	An element is added to the map using
	<code>simple_map::add()</code>
	simple_map::add()
	, where the key is the signer's address and the value is 10.
	The function returns the created map.
	The function returns the created map.
	A test function
test_map_in_move
is defined using the
#[test]
attribute. It calls
map_in_move
and prints the resulting map.
	A test function
	<code>test_map_in_move</code>
	test_map_in_move
	is defined using the
	<code>#[test]</code>
	#[test]
	attribute. It calls
	<code>map_in_move</code>
	map_in_move
	and prints the resulting map.
	This example showcases how to create, populate, and use a SimpleMap in Move, demonstrating its basic operations and integration with other Move concepts like signers and testing.
	This example showcases how to create, populate, and use a SimpleMap in Move, demonstrating its basic operations and integration with other Move concepts like signers and testing.
	<code>module movement::simple_map_module {
    use std::simple_map::{SimpleMap, Self};
    use std::debug::print;
    use std::signer;
    fun map_in_move(sign: &signer): SimpleMap<address, u64> {
        let mp: SimpleMap<address, u64> = simple_map::create();
        simple_map::add(&mut mp, signer::address_of(sign), 10);
        return mp
    }
    #[test(account = @0x1)]
    fun test_map_in_move(account: &signer) {
        let map = map_in_move(account);
        print(&map);
    }
}</code>
	<code>module movement::simple_map_module {
    use std::simple_map::{SimpleMap, Self};
    use std::debug::print;
    use std::signer;
    fun map_in_move(sign: &signer): SimpleMap<address, u64> {
        let mp: SimpleMap<address, u64> = simple_map::create();
        simple_map::add(&mut mp, signer::address_of(sign), 10);
        return mp
    }
    #[test(account = @0x1)]
    fun test_map_in_move(account: &signer) {
        let map = map_in_move(account);
        print(&map);
    }
}</code>
	module movement::simple_map_module {
    use std::simple_map::{SimpleMap, Self};
    use std::debug::print;
    use std::signer;
    fun map_in_move(sign: &signer): SimpleMap<address, u64> {
        let mp: SimpleMap<address, u64> = simple_map::create();
        simple_map::add(&mut mp, signer::address_of(sign), 10);
        return mp
    }
    #[test(account = @0x1)]
    fun test_map_in_move(account: &signer) {
        let map = map_in_move(account);
        print(&map);
    }
}
	Running test:
	Running test:
	Running test:
	<code>movement move test -f test_map_in_move</code>
	<code>movement move test -f test_map_in_move</code>
	movement move test -f test_map_in_move
	Result:
	Result:
	Result:
	<code>Running Move unit tests
[debug] 0x1::simple_map::SimpleMap<address, u64> {
  data: [
    0x1::simple_map::Element<address, u64> {
      key: @0x1,
      value: 10
    }
  ]
}
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::simple_map_module::test_map_in_move
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	<code>Running Move unit tests
[debug] 0x1::simple_map::SimpleMap<address, u64> {
  data: [
    0x1::simple_map::Element<address, u64> {
      key: @0x1,
      value: 10
    }
  ]
}
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::simple_map_module::test_map_in_move
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	Running Move unit tests
[debug] 0x1::simple_map::SimpleMap<address, u64> {
  data: [
    0x1::simple_map::Element<address, u64> {
      key: @0x1,
      value: 10
    }
  ]
}
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::simple_map_module::test_map_in_move
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
	Additional SimpleMap Functions
	Additional SimpleMap Functions
	|
Function
|
Description
|
Return Value
|
| --- | --- | --- |
|
length
| Gets the number of elements |
u64
|
|
new
| Creates an empty SimpleMap |
SimpleMap<K, V>
|
|
new_from
| Creates from key-value vectors |
SimpleMap<K, V>
|
|
create
| Deprecated alias for
new
|
SimpleMap<K, V>
|
|
borrow
| Borrows a value by key |
&V
|
|
borrow_mut
| Mutably borrows a value by key |
&mut V
|
|
contains_key
| Checks for key existence |
bool
|
|
destroy_empty
| Destroys an empty map | None |
|
add
| Adds a key-value pair | None |
|
add_all
| Adds multiple key-value pairs | None |
|
upsert
| Inserts or updates a pair | None |
|
keys
| Gets all keys |
vector<K>
|
|
values
| Gets all values |
vector<V>
|
|
to_vec_pair
| Converts to key-value vectors |
(vector<K, V>)
|
|
destroy
| Destroys map with lambdas | None |
|
remove
| Removes and returns a pair |
(K, V)
|
|
find
| Finds key index (internal) |
Option<u64>
|
	|
	Function
	Function
	|
	Description
	Description
	|
	Return Value
	Return Value
	|
| --- | --- | --- |
|
	<code>length</code>
	length
	| Gets the number of elements |
	<code>u64</code>
	u64
	|
|
	<code>new</code>
	new
	| Creates an empty SimpleMap |
	<code>SimpleMap<K, V></code>
	SimpleMap<K, V>
	|
|
	<code>new_from</code>
	new_from
	| Creates from key-value vectors |
	<code>SimpleMap<K, V></code>
	SimpleMap<K, V>
	|
|
	<code>create</code>
	create
	| Deprecated alias for
	<code>new</code>
	new
	|
	<code>SimpleMap<K, V></code>
	SimpleMap<K, V>
	|
|
	<code>borrow</code>
	borrow
	| Borrows a value by key |
	<code>&V</code>
	&V
	|
|
	<code>borrow_mut</code>
	borrow_mut
	| Mutably borrows a value by key |
	<code>&mut V</code>
	&mut V
	|
|
	<code>contains_key</code>
	contains_key
	| Checks for key existence |
	<code>bool</code>
	bool
	|
|
	<code>destroy_empty</code>
	destroy_empty
	| Destroys an empty map | None |
|
	<code>add</code>
	add
	| Adds a key-value pair | None |
|
	<code>add_all</code>
	add_all
	| Adds multiple key-value pairs | None |
|
	<code>upsert</code>
	upsert
	| Inserts or updates a pair | None |
|
	<code>keys</code>
	keys
	| Gets all keys |
	<code>vector<K></code>
	vector<K>
	|
|
	<code>values</code>
	values
	| Gets all values |
	<code>vector<V></code>
	vector<V>
	|
|
	<code>to_vec_pair</code>
	to_vec_pair
	| Converts to key-value vectors |
	<code>(vector<K, V>)</code>
	(vector<K, V>)
	|
|
	<code>destroy</code>
	destroy
	| Destroys map with lambdas | None |
|
	<code>remove</code>
	remove
	| Removes and returns a pair |
	<code>(K, V)</code>
	(K, V)
	|
|
	<code>find</code>
	find
	| Finds key index (internal) |
	<code>Option<u64></code>
	Option<u64>
	|

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/03-functions-view-functions-and-visibility
Functions, view Functions & Visibility
Functions, view Functions & Visibility
On This Page
Function
Overview
Declaring Address Variables
View Function
Definition
Importance
Benefits
How to Use
Advantages
Conclusion
Function Visibilities
Private
Public
Public(friend)
Entry
Function
Overview
Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.
Declaring Address Variables
fun name(params: type): return_type {
    todo!()
}
// example
fun plus(what_plus: u64): u64 {
    let result = 0 + what_plus;
    return result;
}
View Function
Definition
A view function is a function that retrieves data from the blockchain without making any changes. It is used to read and display data stored on the blockchain.
Importance
View functions are important in the Movement blockchain because:
They allow external applications to access and display data on the blockchain without direct access to the blockchain.
They improve the efficiency and security of the blockchain network.
Benefits
Create a GET API structure to display complex states of smart contracts.
Simplify the process of retrieving complex data, saving time and resources.
Significantly improve the usability of the Aptos blockchain.
Make the blockchain more accessible to developers.
How to Use
Use the
#[view]
decorator to define a view function:
#[view]
public fun get_todos(todo_address: address): vector<String> acquires TodoStore {
    borrow_global<TodoStore>(todo_address).todos
}
Advantages
Retrieve complex states from smart contracts more efficiently.
Define functions that return specific data from smart contracts.
Provide a simple API for external invokers to retrieve data from the blockchain.
Receive specific required data instead of the entire database with each query.
Conclusion
Significantly improving its usability and accessibility. They help developers create more efficient applications by simplifying the process of retrieving data from the blockchain.
Function Visibilities
Private
The functions can only be used within the module where they are defined.
Think of them as "module-only" functions. No other module or script can access them.
module movement::PrivModule {
    fun pri_func(): u8 {
        return 0;
    }
}
module movement::PublModule {
    fun other_func(): u8 {
        // This will error
        let result: u8 = movement::PrivModule::pri_func(); // Error
        return result;
    }
}
Public
The functions can be used by any other module or script.
They are like "open to everyone" functions.
module movement::PrivModule {
    use std::debug::print;
    fun pri_func(): u8 {
        return 0
    }
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    public fun public_func(): u8 {
        return 0
    }
}
Public(friend)
The functions can be used by the module where they are defined and by specific modules listed as "friends." - It’s like having "VIP access" that only selected friends can use these functions.
module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        // This will error
        let result = movement::PublModule::public_func(); // Error
        // This will error
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid call to
        // This will error
                     '(movement=0xDB8A45E0E06D2BD305CDB824FDA101CEC6A24721CB03188C5543A5E5A8C3F3B0)::PublModule::public_func'
        print(&result);
    }
}
module movement::PublModule {
    public(friend) fun public_func(): u8 {
        return 0
    }
}
To allow
PrivModule
to call
public(friend)
from within
PublModule
, we need to add
PrivModule
to the friend list of
PublModule
by doing the following:
module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    friend movement::PrivModule;
    public(friend) fun public_func(): u8 {
        return 0
    }
}
Entry
These are special functions where the Move program starts running or where the user can call into the contract.
You can combine "entry" with "public" or "public(friend)" to specify who can initiate execution.
Example:
module movement::FunctionVisibilities {
    use std::string::utf8;
    use std::debug::print;
    public(friend) entry fun internal_transfer() { // public friend entry
        print(&utf8(b"internal transfer"));
    }
    public entry fun pub_transfer() { // public entry
        print(&utf8(b"public transfer"));
    }
    entry fun transfer(){ // private entry
        print(&utf8(b"transfer"));
    }
}
Movement CLI
movement move publish --named-addresses movement=default
Result
{
  "Result": {
    "transaction_hash": "0x995bff9d25cbb2863b1171d097e3af93c2c1867b0325ceeb1bd3ec44c841270a",
    "gas_used": 1280,
    "gas_unit_price": 100,
    "sender": "bcbcad47635cf19f831e82a0abd0775b4892cb79bb8600592a99e73c727f717c",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1726818525771069,
    "version": 17512651,
    "vm_status": "Executed successfully"
  }
}
Call Entry Function
movement move run --function-id 'default::FunctionVisibilities::internal_transfer'
movement move run --function-id 'default::FunctionVisibilities::pub_transfer'
movement move run --function-id 'default::FunctionVisibilities::transfer'
{
  "Result": {
    "transaction_hash": "0xdf1e9661d7408034273fa49a8cecb4ca7acc2656705b348e0aee76a2a4799ce7",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "e084b2010bb36fb4802d2c8bad7c66ade3728b202a30e330e58cd1904d65a043",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1726819967229264,
    "version": 2034,
    "vm_status": "Executed successfully"
  }
}
On This Page
Function
Overview
Declaring Address Variables
View Function
Definition
Importance
Benefits
How to Use
Advantages
Conclusion
Function Visibilities
Private
Public
Public(friend)
Entry
On This Page
Function
Overview
Declaring Address Variables
View Function
Definition
Importance
Benefits
How to Use
Advantages
Conclusion
Function Visibilities
Private
Public
Public(friend)
Entry
			On This Page
			On This Page
			Function
Overview
Declaring Address Variables
View Function
Definition
Importance
Benefits
How to Use
Advantages
Conclusion
Function Visibilities
Private
Public
Public(friend)
Entry
			Function
Overview
Declaring Address Variables
			Function
			Function
			Function
			Overview
Declaring Address Variables
			Overview
			Overview
			Overview
			Overview
			Declaring Address Variables
			Declaring Address Variables
			Declaring Address Variables
			Declaring Address Variables
			View Function
Definition
Importance
Benefits
How to Use
Advantages
Conclusion
			View Function
			View Function
			View Function
			Definition
Importance
Benefits
How to Use
Advantages
Conclusion
			Definition
			Definition
			Definition
			Definition
			Importance
			Importance
			Importance
			Importance
			Benefits
			Benefits
			Benefits
			Benefits
			How to Use
			How to Use
			How to Use
			How to Use
			Advantages
			Advantages
			Advantages
			Advantages
			Conclusion
			Conclusion
			Conclusion
			Conclusion
			Function Visibilities
Private
Public
Public(friend)
Entry
			Function Visibilities
			Function Visibilities
			Function Visibilities
			Private
Public
Public(friend)
Entry
			Private
			Private
			Private
			Private
			Public
			Public
			Public
			Public
			Public(friend)
			Public(friend)
			Public(friend)
			Public(friend)
			Entry
			Entry
			Entry
			Entry
			Function
Overview
Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.
Declaring Address Variables
fun name(params: type): return_type {
    todo!()
}
// example
fun plus(what_plus: u64): u64 {
    let result = 0 + what_plus;
    return result;
}
View Function
Definition
A view function is a function that retrieves data from the blockchain without making any changes. It is used to read and display data stored on the blockchain.
Importance
View functions are important in the Movement blockchain because:
They allow external applications to access and display data on the blockchain without direct access to the blockchain.
They improve the efficiency and security of the blockchain network.
Benefits
Create a GET API structure to display complex states of smart contracts.
Simplify the process of retrieving complex data, saving time and resources.
Significantly improve the usability of the Aptos blockchain.
Make the blockchain more accessible to developers.
How to Use
Use the
#[view]
decorator to define a view function:
#[view]
public fun get_todos(todo_address: address): vector<String> acquires TodoStore {
    borrow_global<TodoStore>(todo_address).todos
}
Advantages
Retrieve complex states from smart contracts more efficiently.
Define functions that return specific data from smart contracts.
Provide a simple API for external invokers to retrieve data from the blockchain.
Receive specific required data instead of the entire database with each query.
Conclusion
Significantly improving its usability and accessibility. They help developers create more efficient applications by simplifying the process of retrieving data from the blockchain.
Function Visibilities
Private
The functions can only be used within the module where they are defined.
Think of them as "module-only" functions. No other module or script can access them.
module movement::PrivModule {
    fun pri_func(): u8 {
        return 0;
    }
}
module movement::PublModule {
    fun other_func(): u8 {
        // This will error
        let result: u8 = movement::PrivModule::pri_func(); // Error
        return result;
    }
}
Public
The functions can be used by any other module or script.
They are like "open to everyone" functions.
module movement::PrivModule {
    use std::debug::print;
    fun pri_func(): u8 {
        return 0
    }
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    public fun public_func(): u8 {
        return 0
    }
}
Public(friend)
The functions can be used by the module where they are defined and by specific modules listed as "friends." - It’s like having "VIP access" that only selected friends can use these functions.
module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        // This will error
        let result = movement::PublModule::public_func(); // Error
        // This will error
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid call to
        // This will error
                     '(movement=0xDB8A45E0E06D2BD305CDB824FDA101CEC6A24721CB03188C5543A5E5A8C3F3B0)::PublModule::public_func'
        print(&result);
    }
}
module movement::PublModule {
    public(friend) fun public_func(): u8 {
        return 0
    }
}
To allow
PrivModule
to call
public(friend)
from within
PublModule
, we need to add
PrivModule
to the friend list of
PublModule
by doing the following:
module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    friend movement::PrivModule;
    public(friend) fun public_func(): u8 {
        return 0
    }
}
Entry
These are special functions where the Move program starts running or where the user can call into the contract.
You can combine "entry" with "public" or "public(friend)" to specify who can initiate execution.
Example:
module movement::FunctionVisibilities {
    use std::string::utf8;
    use std::debug::print;
    public(friend) entry fun internal_transfer() { // public friend entry
        print(&utf8(b"internal transfer"));
    }
    public entry fun pub_transfer() { // public entry
        print(&utf8(b"public transfer"));
    }
    entry fun transfer(){ // private entry
        print(&utf8(b"transfer"));
    }
}
Movement CLI
movement move publish --named-addresses movement=default
Result
{
  "Result": {
    "transaction_hash": "0x995bff9d25cbb2863b1171d097e3af93c2c1867b0325ceeb1bd3ec44c841270a",
    "gas_used": 1280,
    "gas_unit_price": 100,
    "sender": "bcbcad47635cf19f831e82a0abd0775b4892cb79bb8600592a99e73c727f717c",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1726818525771069,
    "version": 17512651,
    "vm_status": "Executed successfully"
  }
}
Call Entry Function
movement move run --function-id 'default::FunctionVisibilities::internal_transfer'
movement move run --function-id 'default::FunctionVisibilities::pub_transfer'
movement move run --function-id 'default::FunctionVisibilities::transfer'
{
  "Result": {
    "transaction_hash": "0xdf1e9661d7408034273fa49a8cecb4ca7acc2656705b348e0aee76a2a4799ce7",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "e084b2010bb36fb4802d2c8bad7c66ade3728b202a30e330e58cd1904d65a043",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1726819967229264,
    "version": 2034,
    "vm_status": "Executed successfully"
  }
}
			Function
Overview
Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.
Declaring Address Variables
fun name(params: type): return_type {
    todo!()
}
// example
fun plus(what_plus: u64): u64 {
    let result = 0 + what_plus;
    return result;
}
View Function
Definition
A view function is a function that retrieves data from the blockchain without making any changes. It is used to read and display data stored on the blockchain.
Importance
View functions are important in the Movement blockchain because:
They allow external applications to access and display data on the blockchain without direct access to the blockchain.
They improve the efficiency and security of the blockchain network.
Benefits
Create a GET API structure to display complex states of smart contracts.
Simplify the process of retrieving complex data, saving time and resources.
Significantly improve the usability of the Aptos blockchain.
Make the blockchain more accessible to developers.
How to Use
Use the
#[view]
decorator to define a view function:
#[view]
public fun get_todos(todo_address: address): vector<String> acquires TodoStore {
    borrow_global<TodoStore>(todo_address).todos
}
Advantages
Retrieve complex states from smart contracts more efficiently.
Define functions that return specific data from smart contracts.
Provide a simple API for external invokers to retrieve data from the blockchain.
Receive specific required data instead of the entire database with each query.
Conclusion
Significantly improving its usability and accessibility. They help developers create more efficient applications by simplifying the process of retrieving data from the blockchain.
Function Visibilities
Private
The functions can only be used within the module where they are defined.
Think of them as "module-only" functions. No other module or script can access them.
module movement::PrivModule {
    fun pri_func(): u8 {
        return 0;
    }
}
module movement::PublModule {
    fun other_func(): u8 {
        // This will error
        let result: u8 = movement::PrivModule::pri_func(); // Error
        return result;
    }
}
Public
The functions can be used by any other module or script.
They are like "open to everyone" functions.
module movement::PrivModule {
    use std::debug::print;
    fun pri_func(): u8 {
        return 0
    }
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    public fun public_func(): u8 {
        return 0
    }
}
Public(friend)
The functions can be used by the module where they are defined and by specific modules listed as "friends." - It’s like having "VIP access" that only selected friends can use these functions.
module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        // This will error
        let result = movement::PublModule::public_func(); // Error
        // This will error
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid call to
        // This will error
                     '(movement=0xDB8A45E0E06D2BD305CDB824FDA101CEC6A24721CB03188C5543A5E5A8C3F3B0)::PublModule::public_func'
        print(&result);
    }
}
module movement::PublModule {
    public(friend) fun public_func(): u8 {
        return 0
    }
}
To allow
PrivModule
to call
public(friend)
from within
PublModule
, we need to add
PrivModule
to the friend list of
PublModule
by doing the following:
module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    friend movement::PrivModule;
    public(friend) fun public_func(): u8 {
        return 0
    }
}
Entry
These are special functions where the Move program starts running or where the user can call into the contract.
You can combine "entry" with "public" or "public(friend)" to specify who can initiate execution.
Example:
module movement::FunctionVisibilities {
    use std::string::utf8;
    use std::debug::print;
    public(friend) entry fun internal_transfer() { // public friend entry
        print(&utf8(b"internal transfer"));
    }
    public entry fun pub_transfer() { // public entry
        print(&utf8(b"public transfer"));
    }
    entry fun transfer(){ // private entry
        print(&utf8(b"transfer"));
    }
}
Movement CLI
movement move publish --named-addresses movement=default
Result
{
  "Result": {
    "transaction_hash": "0x995bff9d25cbb2863b1171d097e3af93c2c1867b0325ceeb1bd3ec44c841270a",
    "gas_used": 1280,
    "gas_unit_price": 100,
    "sender": "bcbcad47635cf19f831e82a0abd0775b4892cb79bb8600592a99e73c727f717c",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1726818525771069,
    "version": 17512651,
    "vm_status": "Executed successfully"
  }
}
Call Entry Function
movement move run --function-id 'default::FunctionVisibilities::internal_transfer'
movement move run --function-id 'default::FunctionVisibilities::pub_transfer'
movement move run --function-id 'default::FunctionVisibilities::transfer'
{
  "Result": {
    "transaction_hash": "0xdf1e9661d7408034273fa49a8cecb4ca7acc2656705b348e0aee76a2a4799ce7",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "e084b2010bb36fb4802d2c8bad7c66ade3728b202a30e330e58cd1904d65a043",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1726819967229264,
    "version": 2034,
    "vm_status": "Executed successfully"
  }
}
			Function
Overview
Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.
Declaring Address Variables
fun name(params: type): return_type {
    todo!()
}
// example
fun plus(what_plus: u64): u64 {
    let result = 0 + what_plus;
    return result;
}
View Function
Definition
A view function is a function that retrieves data from the blockchain without making any changes. It is used to read and display data stored on the blockchain.
Importance
View functions are important in the Movement blockchain because:
They allow external applications to access and display data on the blockchain without direct access to the blockchain.
They improve the efficiency and security of the blockchain network.
Benefits
Create a GET API structure to display complex states of smart contracts.
Simplify the process of retrieving complex data, saving time and resources.
Significantly improve the usability of the Aptos blockchain.
Make the blockchain more accessible to developers.
How to Use
Use the
#[view]
decorator to define a view function:
#[view]
public fun get_todos(todo_address: address): vector<String> acquires TodoStore {
    borrow_global<TodoStore>(todo_address).todos
}
Advantages
Retrieve complex states from smart contracts more efficiently.
Define functions that return specific data from smart contracts.
Provide a simple API for external invokers to retrieve data from the blockchain.
Receive specific required data instead of the entire database with each query.
Conclusion
Significantly improving its usability and accessibility. They help developers create more efficient applications by simplifying the process of retrieving data from the blockchain.
Function Visibilities
Private
The functions can only be used within the module where they are defined.
Think of them as "module-only" functions. No other module or script can access them.
module movement::PrivModule {
    fun pri_func(): u8 {
        return 0;
    }
}
module movement::PublModule {
    fun other_func(): u8 {
        // This will error
        let result: u8 = movement::PrivModule::pri_func(); // Error
        return result;
    }
}
Public
The functions can be used by any other module or script.
They are like "open to everyone" functions.
module movement::PrivModule {
    use std::debug::print;
    fun pri_func(): u8 {
        return 0
    }
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    public fun public_func(): u8 {
        return 0
    }
}
Public(friend)
The functions can be used by the module where they are defined and by specific modules listed as "friends." - It’s like having "VIP access" that only selected friends can use these functions.
module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        // This will error
        let result = movement::PublModule::public_func(); // Error
        // This will error
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid call to
        // This will error
                     '(movement=0xDB8A45E0E06D2BD305CDB824FDA101CEC6A24721CB03188C5543A5E5A8C3F3B0)::PublModule::public_func'
        print(&result);
    }
}
module movement::PublModule {
    public(friend) fun public_func(): u8 {
        return 0
    }
}
To allow
PrivModule
to call
public(friend)
from within
PublModule
, we need to add
PrivModule
to the friend list of
PublModule
by doing the following:
module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    friend movement::PrivModule;
    public(friend) fun public_func(): u8 {
        return 0
    }
}
Entry
These are special functions where the Move program starts running or where the user can call into the contract.
You can combine "entry" with "public" or "public(friend)" to specify who can initiate execution.
Example:
module movement::FunctionVisibilities {
    use std::string::utf8;
    use std::debug::print;
    public(friend) entry fun internal_transfer() { // public friend entry
        print(&utf8(b"internal transfer"));
    }
    public entry fun pub_transfer() { // public entry
        print(&utf8(b"public transfer"));
    }
    entry fun transfer(){ // private entry
        print(&utf8(b"transfer"));
    }
}
Movement CLI
movement move publish --named-addresses movement=default
Result
{
  "Result": {
    "transaction_hash": "0x995bff9d25cbb2863b1171d097e3af93c2c1867b0325ceeb1bd3ec44c841270a",
    "gas_used": 1280,
    "gas_unit_price": 100,
    "sender": "bcbcad47635cf19f831e82a0abd0775b4892cb79bb8600592a99e73c727f717c",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1726818525771069,
    "version": 17512651,
    "vm_status": "Executed successfully"
  }
}
Call Entry Function
movement move run --function-id 'default::FunctionVisibilities::internal_transfer'
movement move run --function-id 'default::FunctionVisibilities::pub_transfer'
movement move run --function-id 'default::FunctionVisibilities::transfer'
{
  "Result": {
    "transaction_hash": "0xdf1e9661d7408034273fa49a8cecb4ca7acc2656705b348e0aee76a2a4799ce7",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "e084b2010bb36fb4802d2c8bad7c66ade3728b202a30e330e58cd1904d65a043",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1726819967229264,
    "version": 2034,
    "vm_status": "Executed successfully"
  }
}
	Function
	Function
		Overview
		Overview
		Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.
		Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.
		Declaring Address Variables
		Declaring Address Variables
		<code>fun name(params: type): return_type {
    todo!()
}
// example
fun plus(what_plus: u64): u64 {
    let result = 0 + what_plus;
    return result;
}</code>
		<code>fun name(params: type): return_type {
    todo!()
}
// example
fun plus(what_plus: u64): u64 {
    let result = 0 + what_plus;
    return result;
}</code>
		fun name(params: type): return_type {
    todo!()
}
// example
fun plus(what_plus: u64): u64 {
    let result = 0 + what_plus;
    return result;
}
	View Function
	View Function
		Definition
		Definition
		A view function is a function that retrieves data from the blockchain without making any changes. It is used to read and display data stored on the blockchain.
		A view function is a function that retrieves data from the blockchain without making any changes. It is used to read and display data stored on the blockchain.
		Importance
		Importance
		View functions are important in the Movement blockchain because:
		View functions are important in the Movement blockchain because:
		They allow external applications to access and display data on the blockchain without direct access to the blockchain.
They improve the efficiency and security of the blockchain network.
		They allow external applications to access and display data on the blockchain without direct access to the blockchain.
		They allow external applications to access and display data on the blockchain without direct access to the blockchain.
		They improve the efficiency and security of the blockchain network.
		They improve the efficiency and security of the blockchain network.
		Benefits
		Benefits
		Create a GET API structure to display complex states of smart contracts.
Simplify the process of retrieving complex data, saving time and resources.
Significantly improve the usability of the Aptos blockchain.
Make the blockchain more accessible to developers.
		Create a GET API structure to display complex states of smart contracts.
		Create a GET API structure to display complex states of smart contracts.
		Simplify the process of retrieving complex data, saving time and resources.
		Simplify the process of retrieving complex data, saving time and resources.
		Significantly improve the usability of the Aptos blockchain.
		Significantly improve the usability of the Aptos blockchain.
		Make the blockchain more accessible to developers.
		Make the blockchain more accessible to developers.
		How to Use
		How to Use
		Use the
#[view]
decorator to define a view function:
		Use the
		<code>#[view]</code>
		#[view]
		decorator to define a view function:
		<code>#[view]
public fun get_todos(todo_address: address): vector<String> acquires TodoStore {
    borrow_global<TodoStore>(todo_address).todos
}</code>
		<code>#[view]
public fun get_todos(todo_address: address): vector<String> acquires TodoStore {
    borrow_global<TodoStore>(todo_address).todos
}</code>
		#[view]
public fun get_todos(todo_address: address): vector<String> acquires TodoStore {
    borrow_global<TodoStore>(todo_address).todos
}
		Advantages
		Advantages
		Retrieve complex states from smart contracts more efficiently.
Define functions that return specific data from smart contracts.
Provide a simple API for external invokers to retrieve data from the blockchain.
Receive specific required data instead of the entire database with each query.
		Retrieve complex states from smart contracts more efficiently.
		Retrieve complex states from smart contracts more efficiently.
		Define functions that return specific data from smart contracts.
		Define functions that return specific data from smart contracts.
		Provide a simple API for external invokers to retrieve data from the blockchain.
		Provide a simple API for external invokers to retrieve data from the blockchain.
		Receive specific required data instead of the entire database with each query.
		Receive specific required data instead of the entire database with each query.
		Conclusion
		Conclusion
		Significantly improving its usability and accessibility. They help developers create more efficient applications by simplifying the process of retrieving data from the blockchain.
		Significantly improving its usability and accessibility. They help developers create more efficient applications by simplifying the process of retrieving data from the blockchain.
	Function Visibilities
	Function Visibilities
		Private
		Private
		The functions can only be used within the module where they are defined.
Think of them as "module-only" functions. No other module or script can access them.
		The functions can only be used within the module where they are defined.
		The functions can only be used within the module where they are defined.
		Think of them as "module-only" functions. No other module or script can access them.
		Think of them as "module-only" functions. No other module or script can access them.
		<code>module movement::PrivModule {
    fun pri_func(): u8 {
        return 0;
    }
}
module movement::PublModule {
    fun other_func(): u8 {
        // This will error
        let result: u8 = movement::PrivModule::pri_func(); // Error
        return result;
    }
}</code>
		<code>module movement::PrivModule {
    fun pri_func(): u8 {
        return 0;
    }
}
module movement::PublModule {
    fun other_func(): u8 {
        // This will error
        let result: u8 = movement::PrivModule::pri_func(); // Error
        return result;
    }
}</code>
		module movement::PrivModule {
    fun pri_func(): u8 {
        return 0;
    }
}
module movement::PublModule {
    fun other_func(): u8 {
        // This will error
        let result: u8 = movement::PrivModule::pri_func(); // Error
        return result;
    }
}
		Public
		Public
		The functions can be used by any other module or script.
They are like "open to everyone" functions.
		The functions can be used by any other module or script.
		The functions can be used by any other module or script.
		They are like "open to everyone" functions.
		They are like "open to everyone" functions.
		<code>module movement::PrivModule {
    use std::debug::print;
    fun pri_func(): u8 {
        return 0
    }
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    public fun public_func(): u8 {
        return 0
    }
}</code>
		<code>module movement::PrivModule {
    use std::debug::print;
    fun pri_func(): u8 {
        return 0
    }
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    public fun public_func(): u8 {
        return 0
    }
}</code>
		module movement::PrivModule {
    use std::debug::print;
    fun pri_func(): u8 {
        return 0
    }
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    public fun public_func(): u8 {
        return 0
    }
}
		Public(friend)
		Public(friend)
		The functions can be used by the module where they are defined and by specific modules listed as "friends." - It’s like having "VIP access" that only selected friends can use these functions.
		The functions can be used by the module where they are defined and by specific modules listed as "friends." - It’s like having "VIP access" that only selected friends can use these functions.
		The functions can be used by the module where they are defined and by specific modules listed as "friends." - It’s like having "VIP access" that only selected friends can use these functions.
		<code>module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        // This will error
        let result = movement::PublModule::public_func(); // Error
        // This will error
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid call to
        // This will error
                     '(movement=0xDB8A45E0E06D2BD305CDB824FDA101CEC6A24721CB03188C5543A5E5A8C3F3B0)::PublModule::public_func'
        print(&result);
    }
}
module movement::PublModule {
    public(friend) fun public_func(): u8 {
        return 0
    }
}</code>
		<code>module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        // This will error
        let result = movement::PublModule::public_func(); // Error
        // This will error
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid call to
        // This will error
                     '(movement=0xDB8A45E0E06D2BD305CDB824FDA101CEC6A24721CB03188C5543A5E5A8C3F3B0)::PublModule::public_func'
        print(&result);
    }
}
module movement::PublModule {
    public(friend) fun public_func(): u8 {
        return 0
    }
}</code>
		module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        // This will error
        let result = movement::PublModule::public_func(); // Error
        // This will error
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid call to
        // This will error
                     '(movement=0xDB8A45E0E06D2BD305CDB824FDA101CEC6A24721CB03188C5543A5E5A8C3F3B0)::PublModule::public_func'
        print(&result);
    }
}
module movement::PublModule {
    public(friend) fun public_func(): u8 {
        return 0
    }
}
		To allow
PrivModule
to call
public(friend)
from within
PublModule
, we need to add
PrivModule
to the friend list of
PublModule
by doing the following:
		To allow
		<code>PrivModule</code>
		PrivModule
		to call
		<code>public(friend)</code>
		public(friend)
		from within
		<code>PublModule</code>
		PublModule
		, we need to add
		<code>PrivModule</code>
		PrivModule
		to the friend list of
		<code>PublModule</code>
		PublModule
		by doing the following:
		<code>module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    friend movement::PrivModule;
    public(friend) fun public_func(): u8 {
        return 0
    }
}</code>
		<code>module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    friend movement::PrivModule;
    public(friend) fun public_func(): u8 {
        return 0
    }
}</code>
		module movement::PrivModule {
    use std::debug::print;
    fun call_public_func() {
        let result = movement::PublModule::public_func();
        print(&result);
    }
    #[test]
    fun test_call_public_func() {
        call_public_func();
    }
}
module movement::PublModule {
    friend movement::PrivModule;
    public(friend) fun public_func(): u8 {
        return 0
    }
}
		Entry
		Entry
		These are special functions where the Move program starts running or where the user can call into the contract.
You can combine "entry" with "public" or "public(friend)" to specify who can initiate execution.
		These are special functions where the Move program starts running or where the user can call into the contract.
		These are special functions where the Move program starts running or where the user can call into the contract.
		You can combine "entry" with "public" or "public(friend)" to specify who can initiate execution.
		You can combine "entry" with "public" or "public(friend)" to specify who can initiate execution.
		Example:
		Example:
		<code>module movement::FunctionVisibilities {
    use std::string::utf8;
    use std::debug::print;
    public(friend) entry fun internal_transfer() { // public friend entry
        print(&utf8(b"internal transfer"));
    }
    public entry fun pub_transfer() { // public entry
        print(&utf8(b"public transfer"));
    }
    entry fun transfer(){ // private entry
        print(&utf8(b"transfer"));
    }
}</code>
		<code>module movement::FunctionVisibilities {
    use std::string::utf8;
    use std::debug::print;
    public(friend) entry fun internal_transfer() { // public friend entry
        print(&utf8(b"internal transfer"));
    }
    public entry fun pub_transfer() { // public entry
        print(&utf8(b"public transfer"));
    }
    entry fun transfer(){ // private entry
        print(&utf8(b"transfer"));
    }
}</code>
		module movement::FunctionVisibilities {
    use std::string::utf8;
    use std::debug::print;
    public(friend) entry fun internal_transfer() { // public friend entry
        print(&utf8(b"internal transfer"));
    }
    public entry fun pub_transfer() { // public entry
        print(&utf8(b"public transfer"));
    }
    entry fun transfer(){ // private entry
        print(&utf8(b"transfer"));
    }
}
		Movement CLI
		Movement CLI
		Movement CLI
		<code>movement move publish --named-addresses movement=default</code>
		<code>movement move publish --named-addresses movement=default</code>
		movement move publish --named-addresses movement=default
		Result
		Result
		Result
		<code>{
  "Result": {
    "transaction_hash": "0x995bff9d25cbb2863b1171d097e3af93c2c1867b0325ceeb1bd3ec44c841270a",
    "gas_used": 1280,
    "gas_unit_price": 100,
    "sender": "bcbcad47635cf19f831e82a0abd0775b4892cb79bb8600592a99e73c727f717c",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1726818525771069,
    "version": 17512651,
    "vm_status": "Executed successfully"
  }
}</code>
		<code>{
  "Result": {
    "transaction_hash": "0x995bff9d25cbb2863b1171d097e3af93c2c1867b0325ceeb1bd3ec44c841270a",
    "gas_used": 1280,
    "gas_unit_price": 100,
    "sender": "bcbcad47635cf19f831e82a0abd0775b4892cb79bb8600592a99e73c727f717c",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1726818525771069,
    "version": 17512651,
    "vm_status": "Executed successfully"
  }
}</code>
		{
  "Result": {
    "transaction_hash": "0x995bff9d25cbb2863b1171d097e3af93c2c1867b0325ceeb1bd3ec44c841270a",
    "gas_used": 1280,
    "gas_unit_price": 100,
    "sender": "bcbcad47635cf19f831e82a0abd0775b4892cb79bb8600592a99e73c727f717c",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1726818525771069,
    "version": 17512651,
    "vm_status": "Executed successfully"
  }
}
		Call Entry Function
		Call Entry Function
		<code>movement move run --function-id 'default::FunctionVisibilities::internal_transfer'
movement move run --function-id 'default::FunctionVisibilities::pub_transfer'
movement move run --function-id 'default::FunctionVisibilities::transfer'</code>
		<code>movement move run --function-id 'default::FunctionVisibilities::internal_transfer'
movement move run --function-id 'default::FunctionVisibilities::pub_transfer'
movement move run --function-id 'default::FunctionVisibilities::transfer'</code>
		movement move run --function-id 'default::FunctionVisibilities::internal_transfer'
movement move run --function-id 'default::FunctionVisibilities::pub_transfer'
movement move run --function-id 'default::FunctionVisibilities::transfer'
		<code>{
  "Result": {
    "transaction_hash": "0xdf1e9661d7408034273fa49a8cecb4ca7acc2656705b348e0aee76a2a4799ce7",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "e084b2010bb36fb4802d2c8bad7c66ade3728b202a30e330e58cd1904d65a043",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1726819967229264,
    "version": 2034,
    "vm_status": "Executed successfully"
  }
}</code>
		<code>{
  "Result": {
    "transaction_hash": "0xdf1e9661d7408034273fa49a8cecb4ca7acc2656705b348e0aee76a2a4799ce7",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "e084b2010bb36fb4802d2c8bad7c66ade3728b202a30e330e58cd1904d65a043",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1726819967229264,
    "version": 2034,
    "vm_status": "Executed successfully"
  }
}</code>
		{
  "Result": {
    "transaction_hash": "0xdf1e9661d7408034273fa49a8cecb4ca7acc2656705b348e0aee76a2a4799ce7",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "e084b2010bb36fb4802d2c8bad7c66ade3728b202a30e330e58cd1904d65a043",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1726819967229264,
    "version": 2034,
    "vm_status": "Executed successfully"
  }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/04-resources-on-move-and-ability-of-resource
Resources on Move & Ability of Resource
Resources on Move & Ability of Resource
On This Page
Movement modules
Resources & Struct Abilities
Initializing and Transferring Resources
Start Code
Step 1: Initialize move file
Step 2: Configuration Move.toml
Step 3: Build the Contract
Step 4: Publish & Create a Rosource
Movement modules
In Move, code is structured into modules, which are then deployed on the Movement blockchain. These modules serve as the building blocks of smart contracts, allowing users to interact with them by executing their functions through transactions. Modules are bundled together into packages, and when developers deploy their code, they upload an entire package to the blockchain at once. This package can contain one or multiple modules. To keep things straightforward in this course, we'll focus on working with a package that consists of just one module.
module 0xAddress::module_name {
}
Every Move module is uniquely identified by combining its deployment address and module name. The complete identifier is structured as
<address>::<module_name>
. Typically, the module name follows
snake_case
convention. For demonstration purposes, we use 0xcafe as the address in our examples. However, it's important to note that when you deploy a module to the blockchain, you'll need to use an address for which you possess the private key. We'll explore this concept in more detail that later.
Resources & Struct Abilities
In Move, Resources are represented as structs if they have key attributes. All data is stored in global storage. For now, take a look at the simple example below:
module 0xAddress::module_name {
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
        store_abilitiy: ResourceAbilities
    }
    // Value can be stored in global storage or other resouces
    struct ResourceAbilities has key, store, copy, drop {
        data: u64
    }
}
key
: Value can be used as a key for global storage operations.
copy
: Value can be copied (or duplicated by value).
drop
: Value can be deleted when the scope ends.
store
: Value can be stored in global storage or other resources
Initializing and Transferring Resources
Now that we have defined a Resource, we will define it as an NFT to demonstrate what you have done. When initializing a Resource, you cannot initialize default values right from the start; instead, you will do this through a function.
module 0xAddress::module_name {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
All resources in Move need an address for storage; this address can be a user address or an object address (which will be discussed later). The init_module function initializes a new resource and then transfers it to the signer (this is a special data type in Move that will be explained in more detail later). Essentially, it moves this resource to a specific address for ownership and storage.
Start Code
Step 1: Initialize move file
Create a move file in the sources folder, and use the code above.
module movement::movement_module {
    use std::signer;
    struct ResourceName has key {
        data: u64
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
Step 2: Configuration Move.toml
Edit the Move.toml file as shown below
[package] # Includes packages metadata such as name version
name = "hello_blockchain" # Name of project
version = "1.0.0"
authors = []
# Optional
license = ""
[addresses]
movement = "0x{YOUR_ACCOUNT_ADDRESS}"
# movement = "0xefa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5"
[dev-addresses]
[dependencies.AptosFramework]
git = "<https://github.com/aptos-labs/aptos-core.git>"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
Use
YOUR_ACCOUNT_ADDRESS
as the account to store modules, specifically the MovementModule in the example above
Step 3: Build the Contract
movement move build
{
  "Result": [
    "efa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5::movement_module"
  ]
}
Step 4: Publish & Create a Rosource
After completing the contract build and initializing the modules, you can use the CLI to call the functions in the module as shown below with the structure
address::module_name::function_name
aptos move publish
aptos move run --function-id 'default::movement_module::create_resource' --args u64:50
On This Page
Movement modules
Resources & Struct Abilities
Initializing and Transferring Resources
Start Code
Step 1: Initialize move file
Step 2: Configuration Move.toml
Step 3: Build the Contract
Step 4: Publish & Create a Rosource
On This Page
Movement modules
Resources & Struct Abilities
Initializing and Transferring Resources
Start Code
Step 1: Initialize move file
Step 2: Configuration Move.toml
Step 3: Build the Contract
Step 4: Publish & Create a Rosource
			On This Page
			On This Page
			Movement modules
Resources & Struct Abilities
Initializing and Transferring Resources
Start Code
Step 1: Initialize move file
Step 2: Configuration Move.toml
Step 3: Build the Contract
Step 4: Publish & Create a Rosource
			Movement modules
			Movement modules
			Movement modules
			Movement modules
			Resources & Struct Abilities
			Resources & Struct Abilities
			Resources & Struct Abilities
			Resources & Struct Abilities
			Initializing and Transferring Resources
			Initializing and Transferring Resources
			Initializing and Transferring Resources
			Initializing and Transferring Resources
			Start Code
Step 1: Initialize move file
Step 2: Configuration Move.toml
Step 3: Build the Contract
Step 4: Publish & Create a Rosource
			Start Code
			Start Code
			Start Code
			Step 1: Initialize move file
Step 2: Configuration Move.toml
Step 3: Build the Contract
Step 4: Publish & Create a Rosource
			Step 1: Initialize move file
			Step 1: Initialize move file
			Step 1: Initialize move file
			Step 1: Initialize move file
			Step 2: Configuration Move.toml
			Step 2: Configuration Move.toml
			Step 2: Configuration Move.toml
			Step 2: Configuration Move.toml
			Step 3: Build the Contract
			Step 3: Build the Contract
			Step 3: Build the Contract
			Step 3: Build the Contract
			Step 4: Publish & Create a Rosource
			Step 4: Publish & Create a Rosource
			Step 4: Publish & Create a Rosource
			Step 4: Publish & Create a Rosource
			Movement modules
In Move, code is structured into modules, which are then deployed on the Movement blockchain. These modules serve as the building blocks of smart contracts, allowing users to interact with them by executing their functions through transactions. Modules are bundled together into packages, and when developers deploy their code, they upload an entire package to the blockchain at once. This package can contain one or multiple modules. To keep things straightforward in this course, we'll focus on working with a package that consists of just one module.
module 0xAddress::module_name {
}
Every Move module is uniquely identified by combining its deployment address and module name. The complete identifier is structured as
<address>::<module_name>
. Typically, the module name follows
snake_case
convention. For demonstration purposes, we use 0xcafe as the address in our examples. However, it's important to note that when you deploy a module to the blockchain, you'll need to use an address for which you possess the private key. We'll explore this concept in more detail that later.
Resources & Struct Abilities
In Move, Resources are represented as structs if they have key attributes. All data is stored in global storage. For now, take a look at the simple example below:
module 0xAddress::module_name {
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
        store_abilitiy: ResourceAbilities
    }
    // Value can be stored in global storage or other resouces
    struct ResourceAbilities has key, store, copy, drop {
        data: u64
    }
}
key
: Value can be used as a key for global storage operations.
copy
: Value can be copied (or duplicated by value).
drop
: Value can be deleted when the scope ends.
store
: Value can be stored in global storage or other resources
Initializing and Transferring Resources
Now that we have defined a Resource, we will define it as an NFT to demonstrate what you have done. When initializing a Resource, you cannot initialize default values right from the start; instead, you will do this through a function.
module 0xAddress::module_name {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
All resources in Move need an address for storage; this address can be a user address or an object address (which will be discussed later). The init_module function initializes a new resource and then transfers it to the signer (this is a special data type in Move that will be explained in more detail later). Essentially, it moves this resource to a specific address for ownership and storage.
Start Code
Step 1: Initialize move file
Create a move file in the sources folder, and use the code above.
module movement::movement_module {
    use std::signer;
    struct ResourceName has key {
        data: u64
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
Step 2: Configuration Move.toml
Edit the Move.toml file as shown below
[package] # Includes packages metadata such as name version
name = "hello_blockchain" # Name of project
version = "1.0.0"
authors = []
# Optional
license = ""
[addresses]
movement = "0x{YOUR_ACCOUNT_ADDRESS}"
# movement = "0xefa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5"
[dev-addresses]
[dependencies.AptosFramework]
git = "<https://github.com/aptos-labs/aptos-core.git>"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
Use
YOUR_ACCOUNT_ADDRESS
as the account to store modules, specifically the MovementModule in the example above
Step 3: Build the Contract
movement move build
{
  "Result": [
    "efa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5::movement_module"
  ]
}
Step 4: Publish & Create a Rosource
After completing the contract build and initializing the modules, you can use the CLI to call the functions in the module as shown below with the structure
address::module_name::function_name
aptos move publish
aptos move run --function-id 'default::movement_module::create_resource' --args u64:50
			Movement modules
In Move, code is structured into modules, which are then deployed on the Movement blockchain. These modules serve as the building blocks of smart contracts, allowing users to interact with them by executing their functions through transactions. Modules are bundled together into packages, and when developers deploy their code, they upload an entire package to the blockchain at once. This package can contain one or multiple modules. To keep things straightforward in this course, we'll focus on working with a package that consists of just one module.
module 0xAddress::module_name {
}
Every Move module is uniquely identified by combining its deployment address and module name. The complete identifier is structured as
<address>::<module_name>
. Typically, the module name follows
snake_case
convention. For demonstration purposes, we use 0xcafe as the address in our examples. However, it's important to note that when you deploy a module to the blockchain, you'll need to use an address for which you possess the private key. We'll explore this concept in more detail that later.
Resources & Struct Abilities
In Move, Resources are represented as structs if they have key attributes. All data is stored in global storage. For now, take a look at the simple example below:
module 0xAddress::module_name {
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
        store_abilitiy: ResourceAbilities
    }
    // Value can be stored in global storage or other resouces
    struct ResourceAbilities has key, store, copy, drop {
        data: u64
    }
}
key
: Value can be used as a key for global storage operations.
copy
: Value can be copied (or duplicated by value).
drop
: Value can be deleted when the scope ends.
store
: Value can be stored in global storage or other resources
Initializing and Transferring Resources
Now that we have defined a Resource, we will define it as an NFT to demonstrate what you have done. When initializing a Resource, you cannot initialize default values right from the start; instead, you will do this through a function.
module 0xAddress::module_name {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
All resources in Move need an address for storage; this address can be a user address or an object address (which will be discussed later). The init_module function initializes a new resource and then transfers it to the signer (this is a special data type in Move that will be explained in more detail later). Essentially, it moves this resource to a specific address for ownership and storage.
Start Code
Step 1: Initialize move file
Create a move file in the sources folder, and use the code above.
module movement::movement_module {
    use std::signer;
    struct ResourceName has key {
        data: u64
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
Step 2: Configuration Move.toml
Edit the Move.toml file as shown below
[package] # Includes packages metadata such as name version
name = "hello_blockchain" # Name of project
version = "1.0.0"
authors = []
# Optional
license = ""
[addresses]
movement = "0x{YOUR_ACCOUNT_ADDRESS}"
# movement = "0xefa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5"
[dev-addresses]
[dependencies.AptosFramework]
git = "<https://github.com/aptos-labs/aptos-core.git>"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
Use
YOUR_ACCOUNT_ADDRESS
as the account to store modules, specifically the MovementModule in the example above
Step 3: Build the Contract
movement move build
{
  "Result": [
    "efa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5::movement_module"
  ]
}
Step 4: Publish & Create a Rosource
After completing the contract build and initializing the modules, you can use the CLI to call the functions in the module as shown below with the structure
address::module_name::function_name
aptos move publish
aptos move run --function-id 'default::movement_module::create_resource' --args u64:50
			Movement modules
In Move, code is structured into modules, which are then deployed on the Movement blockchain. These modules serve as the building blocks of smart contracts, allowing users to interact with them by executing their functions through transactions. Modules are bundled together into packages, and when developers deploy their code, they upload an entire package to the blockchain at once. This package can contain one or multiple modules. To keep things straightforward in this course, we'll focus on working with a package that consists of just one module.
module 0xAddress::module_name {
}
Every Move module is uniquely identified by combining its deployment address and module name. The complete identifier is structured as
<address>::<module_name>
. Typically, the module name follows
snake_case
convention. For demonstration purposes, we use 0xcafe as the address in our examples. However, it's important to note that when you deploy a module to the blockchain, you'll need to use an address for which you possess the private key. We'll explore this concept in more detail that later.
Resources & Struct Abilities
In Move, Resources are represented as structs if they have key attributes. All data is stored in global storage. For now, take a look at the simple example below:
module 0xAddress::module_name {
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
        store_abilitiy: ResourceAbilities
    }
    // Value can be stored in global storage or other resouces
    struct ResourceAbilities has key, store, copy, drop {
        data: u64
    }
}
key
: Value can be used as a key for global storage operations.
copy
: Value can be copied (or duplicated by value).
drop
: Value can be deleted when the scope ends.
store
: Value can be stored in global storage or other resources
Initializing and Transferring Resources
Now that we have defined a Resource, we will define it as an NFT to demonstrate what you have done. When initializing a Resource, you cannot initialize default values right from the start; instead, you will do this through a function.
module 0xAddress::module_name {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
All resources in Move need an address for storage; this address can be a user address or an object address (which will be discussed later). The init_module function initializes a new resource and then transfers it to the signer (this is a special data type in Move that will be explained in more detail later). Essentially, it moves this resource to a specific address for ownership and storage.
Start Code
Step 1: Initialize move file
Create a move file in the sources folder, and use the code above.
module movement::movement_module {
    use std::signer;
    struct ResourceName has key {
        data: u64
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
Step 2: Configuration Move.toml
Edit the Move.toml file as shown below
[package] # Includes packages metadata such as name version
name = "hello_blockchain" # Name of project
version = "1.0.0"
authors = []
# Optional
license = ""
[addresses]
movement = "0x{YOUR_ACCOUNT_ADDRESS}"
# movement = "0xefa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5"
[dev-addresses]
[dependencies.AptosFramework]
git = "<https://github.com/aptos-labs/aptos-core.git>"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
Use
YOUR_ACCOUNT_ADDRESS
as the account to store modules, specifically the MovementModule in the example above
Step 3: Build the Contract
movement move build
{
  "Result": [
    "efa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5::movement_module"
  ]
}
Step 4: Publish & Create a Rosource
After completing the contract build and initializing the modules, you can use the CLI to call the functions in the module as shown below with the structure
address::module_name::function_name
aptos move publish
aptos move run --function-id 'default::movement_module::create_resource' --args u64:50
	Movement modules
	Movement modules
	In Move, code is structured into modules, which are then deployed on the Movement blockchain. These modules serve as the building blocks of smart contracts, allowing users to interact with them by executing their functions through transactions. Modules are bundled together into packages, and when developers deploy their code, they upload an entire package to the blockchain at once. This package can contain one or multiple modules. To keep things straightforward in this course, we'll focus on working with a package that consists of just one module.
	In Move, code is structured into modules, which are then deployed on the Movement blockchain. These modules serve as the building blocks of smart contracts, allowing users to interact with them by executing their functions through transactions. Modules are bundled together into packages, and when developers deploy their code, they upload an entire package to the blockchain at once. This package can contain one or multiple modules. To keep things straightforward in this course, we'll focus on working with a package that consists of just one module.
	<code>module 0xAddress::module_name {
}</code>
	<code>module 0xAddress::module_name {
}</code>
	module 0xAddress::module_name {
}
	Every Move module is uniquely identified by combining its deployment address and module name. The complete identifier is structured as
<address>::<module_name>
. Typically, the module name follows
snake_case
convention. For demonstration purposes, we use 0xcafe as the address in our examples. However, it's important to note that when you deploy a module to the blockchain, you'll need to use an address for which you possess the private key. We'll explore this concept in more detail that later.
	Every Move module is uniquely identified by combining its deployment address and module name. The complete identifier is structured as
	<code><address>::<module_name></code>
	<address>::<module_name>
	. Typically, the module name follows
	<code>snake_case</code>
	snake_case
	convention. For demonstration purposes, we use 0xcafe as the address in our examples. However, it's important to note that when you deploy a module to the blockchain, you'll need to use an address for which you possess the private key. We'll explore this concept in more detail that later.
	Resources & Struct Abilities
	Resources & Struct Abilities
	In Move, Resources are represented as structs if they have key attributes. All data is stored in global storage. For now, take a look at the simple example below:
	In Move, Resources are represented as structs if they have key attributes. All data is stored in global storage. For now, take a look at the simple example below:
	<code>module 0xAddress::module_name {
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
        store_abilitiy: ResourceAbilities
    }
    // Value can be stored in global storage or other resouces
    struct ResourceAbilities has key, store, copy, drop {
        data: u64
    }
}</code>
	<code>module 0xAddress::module_name {
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
        store_abilitiy: ResourceAbilities
    }
    // Value can be stored in global storage or other resouces
    struct ResourceAbilities has key, store, copy, drop {
        data: u64
    }
}</code>
	module 0xAddress::module_name {
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
        store_abilitiy: ResourceAbilities
    }
    // Value can be stored in global storage or other resouces
    struct ResourceAbilities has key, store, copy, drop {
        data: u64
    }
}
	key
: Value can be used as a key for global storage operations.
copy
: Value can be copied (or duplicated by value).
drop
: Value can be deleted when the scope ends.
store
: Value can be stored in global storage or other resources
	key
: Value can be used as a key for global storage operations.
	<code>key</code>
	key
	: Value can be used as a key for global storage operations.
	copy
: Value can be copied (or duplicated by value).
	<code>copy</code>
	copy
	: Value can be copied (or duplicated by value).
	drop
: Value can be deleted when the scope ends.
	<code>drop</code>
	drop
	: Value can be deleted when the scope ends.
	store
: Value can be stored in global storage or other resources
	<code>store</code>
	store
	: Value can be stored in global storage or other resources
	Initializing and Transferring Resources
	Initializing and Transferring Resources
	Now that we have defined a Resource, we will define it as an NFT to demonstrate what you have done. When initializing a Resource, you cannot initialize default values right from the start; instead, you will do this through a function.
	Now that we have defined a Resource, we will define it as an NFT to demonstrate what you have done. When initializing a Resource, you cannot initialize default values right from the start; instead, you will do this through a function.
	<code>module 0xAddress::module_name {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}</code>
	<code>module 0xAddress::module_name {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}</code>
	module 0xAddress::module_name {
    use std::signer;
    // All structures that are saved to global storage must include the key attribute
    struct ResourceName has key {
        data: u64,
    }
    fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
	All resources in Move need an address for storage; this address can be a user address or an object address (which will be discussed later). The init_module function initializes a new resource and then transfers it to the signer (this is a special data type in Move that will be explained in more detail later). Essentially, it moves this resource to a specific address for ownership and storage.
	All resources in Move need an address for storage; this address can be a user address or an object address (which will be discussed later). The init_module function initializes a new resource and then transfers it to the signer (this is a special data type in Move that will be explained in more detail later). Essentially, it moves this resource to a specific address for ownership and storage.
	Start Code
	Start Code
		Step 1: Initialize move file
		Step 1: Initialize move file
		Create a move file in the sources folder, and use the code above.
		Create a move file in the sources folder, and use the code above.
		<code>module movement::movement_module {
    use std::signer;
    struct ResourceName has key {
        data: u64
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}</code>
		<code>module movement::movement_module {
    use std::signer;
    struct ResourceName has key {
        data: u64
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}</code>
		module movement::movement_module {
    use std::signer;
    struct ResourceName has key {
        data: u64
    }
    public entry fun create_resource(owner: &signer, new_data: u64) {
        move_to(owner, ResourceName{
            data: new_data
        });
    }
}
		Step 2: Configuration Move.toml
		Step 2: Configuration Move.toml
		Edit the Move.toml file as shown below
		Edit the Move.toml file as shown below
		<code>[package] # Includes packages metadata such as name version
name = "hello_blockchain" # Name of project
version = "1.0.0"
authors = []
# Optional
license = ""
[addresses]
movement = "0x{YOUR_ACCOUNT_ADDRESS}"
# movement = "0xefa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5"
[dev-addresses]
[dependencies.AptosFramework]
git = "<https://github.com/aptos-labs/aptos-core.git>"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]</code>
		<code>[package] # Includes packages metadata such as name version
name = "hello_blockchain" # Name of project
version = "1.0.0"
authors = []
# Optional
license = ""
[addresses]
movement = "0x{YOUR_ACCOUNT_ADDRESS}"
# movement = "0xefa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5"
[dev-addresses]
[dependencies.AptosFramework]
git = "<https://github.com/aptos-labs/aptos-core.git>"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]</code>
		[package] # Includes packages metadata such as name version
name = "hello_blockchain" # Name of project
version = "1.0.0"
authors = []
# Optional
license = ""
[addresses]
movement = "0x{YOUR_ACCOUNT_ADDRESS}"
# movement = "0xefa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5"
[dev-addresses]
[dependencies.AptosFramework]
git = "<https://github.com/aptos-labs/aptos-core.git>"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
		Use
YOUR_ACCOUNT_ADDRESS
as the account to store modules, specifically the MovementModule in the example above
		Use
YOUR_ACCOUNT_ADDRESS
as the account to store modules, specifically the MovementModule in the example above
		Use
		<code>YOUR_ACCOUNT_ADDRESS</code>
		YOUR_ACCOUNT_ADDRESS
		as the account to store modules, specifically the MovementModule in the example above
		Step 3: Build the Contract
		Step 3: Build the Contract
		<code>movement move build</code>
		<code>movement move build</code>
		movement move build
		<code>{
  "Result": [
    "efa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5::movement_module"
  ]
}</code>
		<code>{
  "Result": [
    "efa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5::movement_module"
  ]
}</code>
		{
  "Result": [
    "efa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5::movement_module"
  ]
}
		Step 4: Publish & Create a Rosource
		Step 4: Publish & Create a Rosource
		After completing the contract build and initializing the modules, you can use the CLI to call the functions in the module as shown below with the structure
address::module_name::function_name
		After completing the contract build and initializing the modules, you can use the CLI to call the functions in the module as shown below with the structure
		<code>address::module_name::function_name</code>
		address::module_name::function_name
		<code>aptos move publish</code>
		<code>aptos move publish</code>
		aptos move publish
		<code>aptos move run --function-id 'default::movement_module::create_resource' --args u64:50</code>
		<code>aptos move run --function-id 'default::movement_module::create_resource' --args u64:50</code>
		aptos move run --function-id 'default::movement_module::create_resource' --args u64:50

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/05-conditionals-and-loops
Conditionals & Loops
Conditionals & Loops
On This Page
Summary
Conditionals in Move
Basic Syntax
Key Points
Multiple Conditions
Loops
While Loops
For Loops
Infinite Loops
Example: Sum of First N Natural Numbers
Summary
Conditionals in Move use
if-else
statements with boolean conditions and required curly braces.
Multiple conditions can be chained using
else if
.
Move supports three types of loops:
while
,
for
, and infinite (
loop
).
While loops execute code as long as a condition is true.
For loops iterate over a range of values.
Infinite loops use the
loop
keyword and continue until explicitly broken.
Conditionals in Move
Conditionals are fundamental control structures in programming that allow you to execute different code based on certain conditions. In move, the most common conditional structure is the if-else statement.
Basic Syntax
The basic syntax of an if-else statement in Move is as follows:
if (condition) {
    // code to execute if condition is true
} else {
    // code to execute if condition is false
}
Key Points
The condition must be a boolean expression.
Curly braces {} are required, even if the block contains only one line of code.
The else block is optional.
Multiple Conditions
You can chain multiple conditions using else if:
if (condition1) {
    // code for condition1
} else if (condition2) {
    // code for condition2
} else {
    // code if no condition is true
}
Loops
Loops are essential control structures in programming that allow you to repeat a block of code multiple times. In Move, there are three main types of loops: while loops, for loops, and loop (infinite loop).
While Loops
While loops execute a block of code as long as a specified condition is true.
while (condition) {
    // code to be executed
}
For Loops
For loops are used to iterate over a range of values.
for (i in 1..n) {
    // code to be executed
}
Infinite Loops
The 'loop' keyword creates an infinite loop that continues until explicitly broken.
loop {
    // code to be executed
    if (condition) {
        break;
    }
}
Example: Sum of First N Natural Numbers
The code below demonstrates how to calculate the sum of the first N natural numbers using different types of loops in Move:
module movement::loops {
    use std::vector;
    // Sum of first N natural numbers using while loop
    fun sum_using_while(n: u64): u64 {
        let sum = 0;
        let i = 1;
        while (i <= n) {
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using for loop
    fun sum_using_for(n: u64): u64 {
        let sum = 0;
        for (i in 1..(n+1)) {
            sum = sum + i;
        };
        sum
    }
    // Sum of first N natural numbers using infinite loop
    fun sum_using_loop(n: u64): u64 {
        let sum = 0;
        let i = 1;
        loop {
            if (i > n) break;
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using vector and fold
    fun sum_using_vector(n: u64): u64 {
        let numbers = vector::empty<u64>();
        let i = 1;
        while (i <= n) {
            vector::push_back(&mut numbers, i);
            i = i + 1;
        };
        vector::fold(numbers, 0, |acc, num| acc + num)
    }
    #[test_only]
    use std::debug;
    #[test]
    fun test_sum_functions() {
        let n = 10;
        let expected_sum = 55; // Sum of 1 to 10
        assert!(sum_using_while(n) == expected_sum, 0);
        assert!(sum_using_for(n) == expected_sum, 1);
        assert!(sum_using_loop(n) == expected_sum, 2);
        assert!(sum_using_vector(n) == expected_sum, 3);
        debug::print(&sum_using_while(n));
        debug::print(&sum_using_for(n));
        debug::print(&sum_using_loop(n));
        debug::print(&sum_using_vector(n));
    }
}
Running test:
movement move test -f test_sum_functions
Result:
Running Move unit tests
[debug] 55
[debug] 55
[debug] 55
[debug] 55
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::loops::test_sum_functions
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
On This Page
Summary
Conditionals in Move
Basic Syntax
Key Points
Multiple Conditions
Loops
While Loops
For Loops
Infinite Loops
Example: Sum of First N Natural Numbers
On This Page
Summary
Conditionals in Move
Basic Syntax
Key Points
Multiple Conditions
Loops
While Loops
For Loops
Infinite Loops
Example: Sum of First N Natural Numbers
			On This Page
			On This Page
			Summary
Conditionals in Move
Basic Syntax
Key Points
Multiple Conditions
Loops
While Loops
For Loops
Infinite Loops
Example: Sum of First N Natural Numbers
			Summary
			Summary
			Summary
			Summary
			Conditionals in Move
Basic Syntax
Key Points
Multiple Conditions
			Conditionals in Move
			Conditionals in Move
			Conditionals in Move
			Basic Syntax
Key Points
Multiple Conditions
			Basic Syntax
			Basic Syntax
			Basic Syntax
			Basic Syntax
			Key Points
			Key Points
			Key Points
			Key Points
			Multiple Conditions
			Multiple Conditions
			Multiple Conditions
			Multiple Conditions
			Loops
While Loops
For Loops
Infinite Loops
Example: Sum of First N Natural Numbers
			Loops
			Loops
			Loops
			While Loops
For Loops
Infinite Loops
Example: Sum of First N Natural Numbers
			While Loops
			While Loops
			While Loops
			While Loops
			For Loops
			For Loops
			For Loops
			For Loops
			Infinite Loops
			Infinite Loops
			Infinite Loops
			Infinite Loops
			Example: Sum of First N Natural Numbers
			Example: Sum of First N Natural Numbers
			Example: Sum of First N Natural Numbers
			Example: Sum of First N Natural Numbers
			Summary
Conditionals in Move use
if-else
statements with boolean conditions and required curly braces.
Multiple conditions can be chained using
else if
.
Move supports three types of loops:
while
,
for
, and infinite (
loop
).
While loops execute code as long as a condition is true.
For loops iterate over a range of values.
Infinite loops use the
loop
keyword and continue until explicitly broken.
Conditionals in Move
Conditionals are fundamental control structures in programming that allow you to execute different code based on certain conditions. In move, the most common conditional structure is the if-else statement.
Basic Syntax
The basic syntax of an if-else statement in Move is as follows:
if (condition) {
    // code to execute if condition is true
} else {
    // code to execute if condition is false
}
Key Points
The condition must be a boolean expression.
Curly braces {} are required, even if the block contains only one line of code.
The else block is optional.
Multiple Conditions
You can chain multiple conditions using else if:
if (condition1) {
    // code for condition1
} else if (condition2) {
    // code for condition2
} else {
    // code if no condition is true
}
Loops
Loops are essential control structures in programming that allow you to repeat a block of code multiple times. In Move, there are three main types of loops: while loops, for loops, and loop (infinite loop).
While Loops
While loops execute a block of code as long as a specified condition is true.
while (condition) {
    // code to be executed
}
For Loops
For loops are used to iterate over a range of values.
for (i in 1..n) {
    // code to be executed
}
Infinite Loops
The 'loop' keyword creates an infinite loop that continues until explicitly broken.
loop {
    // code to be executed
    if (condition) {
        break;
    }
}
Example: Sum of First N Natural Numbers
The code below demonstrates how to calculate the sum of the first N natural numbers using different types of loops in Move:
module movement::loops {
    use std::vector;
    // Sum of first N natural numbers using while loop
    fun sum_using_while(n: u64): u64 {
        let sum = 0;
        let i = 1;
        while (i <= n) {
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using for loop
    fun sum_using_for(n: u64): u64 {
        let sum = 0;
        for (i in 1..(n+1)) {
            sum = sum + i;
        };
        sum
    }
    // Sum of first N natural numbers using infinite loop
    fun sum_using_loop(n: u64): u64 {
        let sum = 0;
        let i = 1;
        loop {
            if (i > n) break;
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using vector and fold
    fun sum_using_vector(n: u64): u64 {
        let numbers = vector::empty<u64>();
        let i = 1;
        while (i <= n) {
            vector::push_back(&mut numbers, i);
            i = i + 1;
        };
        vector::fold(numbers, 0, |acc, num| acc + num)
    }
    #[test_only]
    use std::debug;
    #[test]
    fun test_sum_functions() {
        let n = 10;
        let expected_sum = 55; // Sum of 1 to 10
        assert!(sum_using_while(n) == expected_sum, 0);
        assert!(sum_using_for(n) == expected_sum, 1);
        assert!(sum_using_loop(n) == expected_sum, 2);
        assert!(sum_using_vector(n) == expected_sum, 3);
        debug::print(&sum_using_while(n));
        debug::print(&sum_using_for(n));
        debug::print(&sum_using_loop(n));
        debug::print(&sum_using_vector(n));
    }
}
Running test:
movement move test -f test_sum_functions
Result:
Running Move unit tests
[debug] 55
[debug] 55
[debug] 55
[debug] 55
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::loops::test_sum_functions
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
			Summary
Conditionals in Move use
if-else
statements with boolean conditions and required curly braces.
Multiple conditions can be chained using
else if
.
Move supports three types of loops:
while
,
for
, and infinite (
loop
).
While loops execute code as long as a condition is true.
For loops iterate over a range of values.
Infinite loops use the
loop
keyword and continue until explicitly broken.
Conditionals in Move
Conditionals are fundamental control structures in programming that allow you to execute different code based on certain conditions. In move, the most common conditional structure is the if-else statement.
Basic Syntax
The basic syntax of an if-else statement in Move is as follows:
if (condition) {
    // code to execute if condition is true
} else {
    // code to execute if condition is false
}
Key Points
The condition must be a boolean expression.
Curly braces {} are required, even if the block contains only one line of code.
The else block is optional.
Multiple Conditions
You can chain multiple conditions using else if:
if (condition1) {
    // code for condition1
} else if (condition2) {
    // code for condition2
} else {
    // code if no condition is true
}
Loops
Loops are essential control structures in programming that allow you to repeat a block of code multiple times. In Move, there are three main types of loops: while loops, for loops, and loop (infinite loop).
While Loops
While loops execute a block of code as long as a specified condition is true.
while (condition) {
    // code to be executed
}
For Loops
For loops are used to iterate over a range of values.
for (i in 1..n) {
    // code to be executed
}
Infinite Loops
The 'loop' keyword creates an infinite loop that continues until explicitly broken.
loop {
    // code to be executed
    if (condition) {
        break;
    }
}
Example: Sum of First N Natural Numbers
The code below demonstrates how to calculate the sum of the first N natural numbers using different types of loops in Move:
module movement::loops {
    use std::vector;
    // Sum of first N natural numbers using while loop
    fun sum_using_while(n: u64): u64 {
        let sum = 0;
        let i = 1;
        while (i <= n) {
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using for loop
    fun sum_using_for(n: u64): u64 {
        let sum = 0;
        for (i in 1..(n+1)) {
            sum = sum + i;
        };
        sum
    }
    // Sum of first N natural numbers using infinite loop
    fun sum_using_loop(n: u64): u64 {
        let sum = 0;
        let i = 1;
        loop {
            if (i > n) break;
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using vector and fold
    fun sum_using_vector(n: u64): u64 {
        let numbers = vector::empty<u64>();
        let i = 1;
        while (i <= n) {
            vector::push_back(&mut numbers, i);
            i = i + 1;
        };
        vector::fold(numbers, 0, |acc, num| acc + num)
    }
    #[test_only]
    use std::debug;
    #[test]
    fun test_sum_functions() {
        let n = 10;
        let expected_sum = 55; // Sum of 1 to 10
        assert!(sum_using_while(n) == expected_sum, 0);
        assert!(sum_using_for(n) == expected_sum, 1);
        assert!(sum_using_loop(n) == expected_sum, 2);
        assert!(sum_using_vector(n) == expected_sum, 3);
        debug::print(&sum_using_while(n));
        debug::print(&sum_using_for(n));
        debug::print(&sum_using_loop(n));
        debug::print(&sum_using_vector(n));
    }
}
Running test:
movement move test -f test_sum_functions
Result:
Running Move unit tests
[debug] 55
[debug] 55
[debug] 55
[debug] 55
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::loops::test_sum_functions
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
			Summary
Conditionals in Move use
if-else
statements with boolean conditions and required curly braces.
Multiple conditions can be chained using
else if
.
Move supports three types of loops:
while
,
for
, and infinite (
loop
).
While loops execute code as long as a condition is true.
For loops iterate over a range of values.
Infinite loops use the
loop
keyword and continue until explicitly broken.
Conditionals in Move
Conditionals are fundamental control structures in programming that allow you to execute different code based on certain conditions. In move, the most common conditional structure is the if-else statement.
Basic Syntax
The basic syntax of an if-else statement in Move is as follows:
if (condition) {
    // code to execute if condition is true
} else {
    // code to execute if condition is false
}
Key Points
The condition must be a boolean expression.
Curly braces {} are required, even if the block contains only one line of code.
The else block is optional.
Multiple Conditions
You can chain multiple conditions using else if:
if (condition1) {
    // code for condition1
} else if (condition2) {
    // code for condition2
} else {
    // code if no condition is true
}
Loops
Loops are essential control structures in programming that allow you to repeat a block of code multiple times. In Move, there are three main types of loops: while loops, for loops, and loop (infinite loop).
While Loops
While loops execute a block of code as long as a specified condition is true.
while (condition) {
    // code to be executed
}
For Loops
For loops are used to iterate over a range of values.
for (i in 1..n) {
    // code to be executed
}
Infinite Loops
The 'loop' keyword creates an infinite loop that continues until explicitly broken.
loop {
    // code to be executed
    if (condition) {
        break;
    }
}
Example: Sum of First N Natural Numbers
The code below demonstrates how to calculate the sum of the first N natural numbers using different types of loops in Move:
module movement::loops {
    use std::vector;
    // Sum of first N natural numbers using while loop
    fun sum_using_while(n: u64): u64 {
        let sum = 0;
        let i = 1;
        while (i <= n) {
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using for loop
    fun sum_using_for(n: u64): u64 {
        let sum = 0;
        for (i in 1..(n+1)) {
            sum = sum + i;
        };
        sum
    }
    // Sum of first N natural numbers using infinite loop
    fun sum_using_loop(n: u64): u64 {
        let sum = 0;
        let i = 1;
        loop {
            if (i > n) break;
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using vector and fold
    fun sum_using_vector(n: u64): u64 {
        let numbers = vector::empty<u64>();
        let i = 1;
        while (i <= n) {
            vector::push_back(&mut numbers, i);
            i = i + 1;
        };
        vector::fold(numbers, 0, |acc, num| acc + num)
    }
    #[test_only]
    use std::debug;
    #[test]
    fun test_sum_functions() {
        let n = 10;
        let expected_sum = 55; // Sum of 1 to 10
        assert!(sum_using_while(n) == expected_sum, 0);
        assert!(sum_using_for(n) == expected_sum, 1);
        assert!(sum_using_loop(n) == expected_sum, 2);
        assert!(sum_using_vector(n) == expected_sum, 3);
        debug::print(&sum_using_while(n));
        debug::print(&sum_using_for(n));
        debug::print(&sum_using_loop(n));
        debug::print(&sum_using_vector(n));
    }
}
Running test:
movement move test -f test_sum_functions
Result:
Running Move unit tests
[debug] 55
[debug] 55
[debug] 55
[debug] 55
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::loops::test_sum_functions
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
	Summary
	Summary
	Conditionals in Move use
if-else
statements with boolean conditions and required curly braces.
Multiple conditions can be chained using
else if
.
Move supports three types of loops:
while
,
for
, and infinite (
loop
).
While loops execute code as long as a condition is true.
For loops iterate over a range of values.
Infinite loops use the
loop
keyword and continue until explicitly broken.
	Conditionals in Move use
if-else
statements with boolean conditions and required curly braces.
	Conditionals in Move use
	<code>if-else</code>
	if-else
	statements with boolean conditions and required curly braces.
	Multiple conditions can be chained using
else if
.
	Multiple conditions can be chained using
	<code>else if</code>
	else if
	.
	Move supports three types of loops:
while
,
for
, and infinite (
loop
).
	Move supports three types of loops:
	<code>while</code>
	while
	,
	<code>for</code>
	for
	, and infinite (
	<code>loop</code>
	loop
	).
	While loops execute code as long as a condition is true.
	While loops execute code as long as a condition is true.
	For loops iterate over a range of values.
	For loops iterate over a range of values.
	Infinite loops use the
loop
keyword and continue until explicitly broken.
	Infinite loops use the
	<code>loop</code>
	loop
	keyword and continue until explicitly broken.
Conditionals in Move
Conditionals in Move
Conditionals are fundamental control structures in programming that allow you to execute different code based on certain conditions. In move, the most common conditional structure is the if-else statement.
Conditionals are fundamental control structures in programming that allow you to execute different code based on certain conditions. In move, the most common conditional structure is the if-else statement.
	Basic Syntax
	Basic Syntax
	The basic syntax of an if-else statement in Move is as follows:
	The basic syntax of an if-else statement in Move is as follows:
	<code>if (condition) {
    // code to execute if condition is true
} else {
    // code to execute if condition is false
}</code>
	<code>if (condition) {
    // code to execute if condition is true
} else {
    // code to execute if condition is false
}</code>
	if (condition) {
    // code to execute if condition is true
} else {
    // code to execute if condition is false
}
	Key Points
	Key Points
	The condition must be a boolean expression.
Curly braces {} are required, even if the block contains only one line of code.
The else block is optional.
	The condition must be a boolean expression.
	The condition must be a boolean expression.
	Curly braces {} are required, even if the block contains only one line of code.
	Curly braces {} are required, even if the block contains only one line of code.
	The else block is optional.
	The else block is optional.
	Multiple Conditions
	Multiple Conditions
	You can chain multiple conditions using else if:
	You can chain multiple conditions using else if:
	<code>if (condition1) {
    // code for condition1
} else if (condition2) {
    // code for condition2
} else {
    // code if no condition is true
}</code>
	<code>if (condition1) {
    // code for condition1
} else if (condition2) {
    // code for condition2
} else {
    // code if no condition is true
}</code>
	if (condition1) {
    // code for condition1
} else if (condition2) {
    // code for condition2
} else {
    // code if no condition is true
}
Loops
Loops
Loops are essential control structures in programming that allow you to repeat a block of code multiple times. In Move, there are three main types of loops: while loops, for loops, and loop (infinite loop).
Loops are essential control structures in programming that allow you to repeat a block of code multiple times. In Move, there are three main types of loops: while loops, for loops, and loop (infinite loop).
	While Loops
	While Loops
	While loops execute a block of code as long as a specified condition is true.
	While loops execute a block of code as long as a specified condition is true.
	<code>while (condition) {
    // code to be executed
}</code>
	<code>while (condition) {
    // code to be executed
}</code>
	while (condition) {
    // code to be executed
}
	For Loops
	For Loops
	For loops are used to iterate over a range of values.
	For loops are used to iterate over a range of values.
	<code>for (i in 1..n) {
    // code to be executed
}</code>
	<code>for (i in 1..n) {
    // code to be executed
}</code>
	for (i in 1..n) {
    // code to be executed
}
	Infinite Loops
	Infinite Loops
	The 'loop' keyword creates an infinite loop that continues until explicitly broken.
	The 'loop' keyword creates an infinite loop that continues until explicitly broken.
	<code>loop {
    // code to be executed
    if (condition) {
        break;
    }
}</code>
	<code>loop {
    // code to be executed
    if (condition) {
        break;
    }
}</code>
	loop {
    // code to be executed
    if (condition) {
        break;
    }
}
	Example: Sum of First N Natural Numbers
	Example: Sum of First N Natural Numbers
	The code below demonstrates how to calculate the sum of the first N natural numbers using different types of loops in Move:
	The code below demonstrates how to calculate the sum of the first N natural numbers using different types of loops in Move:
	<code>module movement::loops {
    use std::vector;
    // Sum of first N natural numbers using while loop
    fun sum_using_while(n: u64): u64 {
        let sum = 0;
        let i = 1;
        while (i <= n) {
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using for loop
    fun sum_using_for(n: u64): u64 {
        let sum = 0;
        for (i in 1..(n+1)) {
            sum = sum + i;
        };
        sum
    }
    // Sum of first N natural numbers using infinite loop
    fun sum_using_loop(n: u64): u64 {
        let sum = 0;
        let i = 1;
        loop {
            if (i > n) break;
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using vector and fold
    fun sum_using_vector(n: u64): u64 {
        let numbers = vector::empty<u64>();
        let i = 1;
        while (i <= n) {
            vector::push_back(&mut numbers, i);
            i = i + 1;
        };
        vector::fold(numbers, 0, |acc, num| acc + num)
    }
    #[test_only]
    use std::debug;
    #[test]
    fun test_sum_functions() {
        let n = 10;
        let expected_sum = 55; // Sum of 1 to 10
        assert!(sum_using_while(n) == expected_sum, 0);
        assert!(sum_using_for(n) == expected_sum, 1);
        assert!(sum_using_loop(n) == expected_sum, 2);
        assert!(sum_using_vector(n) == expected_sum, 3);
        debug::print(&sum_using_while(n));
        debug::print(&sum_using_for(n));
        debug::print(&sum_using_loop(n));
        debug::print(&sum_using_vector(n));
    }
}</code>
	<code>module movement::loops {
    use std::vector;
    // Sum of first N natural numbers using while loop
    fun sum_using_while(n: u64): u64 {
        let sum = 0;
        let i = 1;
        while (i <= n) {
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using for loop
    fun sum_using_for(n: u64): u64 {
        let sum = 0;
        for (i in 1..(n+1)) {
            sum = sum + i;
        };
        sum
    }
    // Sum of first N natural numbers using infinite loop
    fun sum_using_loop(n: u64): u64 {
        let sum = 0;
        let i = 1;
        loop {
            if (i > n) break;
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using vector and fold
    fun sum_using_vector(n: u64): u64 {
        let numbers = vector::empty<u64>();
        let i = 1;
        while (i <= n) {
            vector::push_back(&mut numbers, i);
            i = i + 1;
        };
        vector::fold(numbers, 0, |acc, num| acc + num)
    }
    #[test_only]
    use std::debug;
    #[test]
    fun test_sum_functions() {
        let n = 10;
        let expected_sum = 55; // Sum of 1 to 10
        assert!(sum_using_while(n) == expected_sum, 0);
        assert!(sum_using_for(n) == expected_sum, 1);
        assert!(sum_using_loop(n) == expected_sum, 2);
        assert!(sum_using_vector(n) == expected_sum, 3);
        debug::print(&sum_using_while(n));
        debug::print(&sum_using_for(n));
        debug::print(&sum_using_loop(n));
        debug::print(&sum_using_vector(n));
    }
}</code>
	module movement::loops {
    use std::vector;
    // Sum of first N natural numbers using while loop
    fun sum_using_while(n: u64): u64 {
        let sum = 0;
        let i = 1;
        while (i <= n) {
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using for loop
    fun sum_using_for(n: u64): u64 {
        let sum = 0;
        for (i in 1..(n+1)) {
            sum = sum + i;
        };
        sum
    }
    // Sum of first N natural numbers using infinite loop
    fun sum_using_loop(n: u64): u64 {
        let sum = 0;
        let i = 1;
        loop {
            if (i > n) break;
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
    // Sum of first N natural numbers using vector and fold
    fun sum_using_vector(n: u64): u64 {
        let numbers = vector::empty<u64>();
        let i = 1;
        while (i <= n) {
            vector::push_back(&mut numbers, i);
            i = i + 1;
        };
        vector::fold(numbers, 0, |acc, num| acc + num)
    }
    #[test_only]
    use std::debug;
    #[test]
    fun test_sum_functions() {
        let n = 10;
        let expected_sum = 55; // Sum of 1 to 10
        assert!(sum_using_while(n) == expected_sum, 0);
        assert!(sum_using_for(n) == expected_sum, 1);
        assert!(sum_using_loop(n) == expected_sum, 2);
        assert!(sum_using_vector(n) == expected_sum, 3);
        debug::print(&sum_using_while(n));
        debug::print(&sum_using_for(n));
        debug::print(&sum_using_loop(n));
        debug::print(&sum_using_vector(n));
    }
}
	Running test:
	Running test:
	Running test:
	<code>movement move test -f test_sum_functions</code>
	<code>movement move test -f test_sum_functions</code>
	movement move test -f test_sum_functions
	Result:
	Result:
	Result:
	<code>Running Move unit tests
[debug] 55
[debug] 55
[debug] 55
[debug] 55
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::loops::test_sum_functions
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	<code>Running Move unit tests
[debug] 55
[debug] 55
[debug] 55
[debug] 55
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::loops::test_sum_functions
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	Running Move unit tests
[debug] 55
[debug] 55
[debug] 55
[debug] 55
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::loops::test_sum_functions
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/06-constants-and-error-handling
Constants & Error Handling
Constants & Error Handling
On This Page
Key Takeaways
Constants
Overview
Naming Conventions
Examples:
Error Handling
Error Handling in Move
Using in Real-World Projects
Abort Example
Assert Example
Error Handling Advanced
Conclusion
Key Takeaways
Constants in Move provide immutable values with compile-time evaluation and memory optimization.
Naming conventions for constants enhance code readability (e.g., uppercase for non-error values, camel case with 'E' prefix for error codes).
Error handling utilizes
abort
statements and
assert!
macros for precise control.
Combining constants with error handling creates robust, self-documenting code.
Advanced techniques include centralizing error codes in dedicated modules for improved organization and reusability.
Proper use of constants and error handling is crucial for building secure and maintainable Move programs.
Constants
Overview
Constants in Move are a powerful way to define immutable values within a
module
or
script
. They are declared using the
const
keyword and offer several advantages:
Compile-time evaluation: The constant's value must be determinable at compilation, ensuring efficiency.
Memory optimization: Constants are stored directly in the compiled code, reducing runtime memory usage.
Value semantics: Each use of a constant creates a new copy, preserving data integrity across different parts of your code.
By leveraging constants, developers can create more readable, maintainable, and performant Move programs.
const <NAME>: <TYPE> = <EXPRESSION>;
Naming Conventions
Naming conventions for constants in Move are designed to enhance code readability and maintainability. Here are the key rules:
Initial character: Constants must begin with an uppercase letter (A-Z).
Subsequent characters: After the first letter, you can use:
Uppercase letters (A-Z)
Lowercase letters (a-z)
Digits (0-9)
Underscores (_)
This naming convention helps distinguish constants from other identifiers in your code, making it easier to recognize and use them appropriately throughout your Move programs.
Key Considerations for Constants in Move:
Type Restrictions: Constants are confined to fundamental data types such as
bool
, integer variants (
u8
to
u256
),
address
, and
vector<u8>
.
Naming Conventions:
Error codes: Use upper camel case with an 'E' prefix (e.g.,
EInsufficientFunds
)
Non-error values: Employ upper snake case (e.g.,
MAX_SUPPLY
)
Scope Limitations: Constants are
module-specific
and cannot be declared as
public
or accessed externally.
Visibility: The value of a constant is restricted to its defining module or script.
Examples:
module movement::config {
    const EOnlyAdmin: u64 = 1;
    const ENotHavePermission: u64 = 2;
    const VECTOR_U8: vector<u8> = b"hello";
}
Error Handling
Error Handling in Move
Move provides robust mechanisms for error handling, primarily through two key functions:
abort
: Immediately terminates execution with a specified error code
abort <error_code>; // error_code must be of type u64
assert!
: Evaluates a condition and aborts if it's false
assert!(<boolean_expression>, <error_code>)
These tools allow developers to implement precise error handling, enhancing the reliability and debuggability of Move programs.
Using in Real-World Projects
In real-world projects, error handling is frequently used. For large projects, we combine it with constants to manage errors more optimally, as shown in the example above:
module movement::constants_error_handling_module {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}
In the code above, we can see practical examples of error handling in Move using both the
abort
statement and the
assert!
macro, combined with constant error codes. Let's break it down:
Abort Example
The
ENotHavePermission
constant is defined with a value of 1, representing a specific error condition.
In the
const_error
function, there's a conditional check: if the input
n
equals 5, it triggers an abort with the
ENotHavePermission
error code.
The
abort
statement immediately halts the execution of the function and returns the specified error code (1 in this case).
A test function
test_const_error
is provided to verify this behavior. It's marked with
#[expected_failure(abort_code = 1)]
, indicating that it's expected to fail with the specific abort code 1.
Assert Example
The
ENotEven
constant is defined with a value of 2, representing another error condition.
In the
is_even
function, the
assert!
macro is used to check if the input number is even.
If the assertion fails (i.e., the number is odd), it aborts with the
ENotEven
error code.
Two test functions are provided:
test_is_even_failed
expects failure with abort code 2, while
test_is_even_success
expects successful execution.
This approach to error handling offers several benefits:
Clear error identification: Using named constants for error codes improves code readability and maintainability.
Consistent error reporting: By centralizing error codes as constants, you ensure consistency across your module.
Testability: The
#[expected_failure]
attribute allows you to write tests that specifically check for correct error handling.
Flexibility: Developers can choose between
abort
for immediate termination or
assert!
for condition-based checks.
By combining constants with both the
abort
mechanism and
assert!
macro, Move developers can create robust, self-documenting error handling systems that are easy to maintain, test, and adapt to various scenarios.
Error Handling Advanced
Note: Constants are
module-specific
and cannot be declared as
public
or accessed externally.
In real-world projects, the number of error handling cases can be very large. Additionally, an error may occur in multiple different modules. I have used functions to develop and optimize error handling beyond Move's traditional methods. For example:
module movement::errors {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    public fun get_enot_have_permission(): u64 {
        ENotHavePermission
    }
    public fun get_enot_even(): u64 {
        ENotEven
    }
}
module movement::constants_abort_error {
    use movement::errors;
    fun const_error(n: u64) {
        if (n == 5) {
            abort errors::get_enot_have_permission() // throwing error as the given constant
        }
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
}
module movement::constants_assert_error {
    use movement::errors;
    fun is_even(num: u64) {
        assert!(num % 2 == 0, errors::get_enot_even()); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}
With this approach, you can separate error handling into a dedicated module, making it easier to manage and resulting in cleaner code, as well as enabling reuse across different modules.
Conclusion
In this comprehensive overview of constants and error handling in Move, we've explored several key concepts:
Constants provide immutable values, offering compile-time evaluation, memory optimization, and value semantics.
Proper naming conventions for constants enhance code readability and maintainability.
Error handling in Move primarily relies on the
abort
statement and
assert!
macro.
Combining constants with error handling creates a robust system for managing and reporting errors.
Advanced error handling techniques, such as centralizing error codes in a dedicated module, can improve code organization and reusability.
By mastering these concepts, developers can create more efficient, readable, and maintainable Move programs. Constants and effective error handling are crucial for building robust smart contracts and decentralized applications on blockchain platforms that support Move.
As the Move ecosystem continues to evolve, these fundamental practices will remain essential for writing high-quality, secure code. Developers should strive to implement these patterns consistently in their projects to ensure reliability and ease of maintenance in the long term.
On This Page
Key Takeaways
Constants
Overview
Naming Conventions
Examples:
Error Handling
Error Handling in Move
Using in Real-World Projects
Abort Example
Assert Example
Error Handling Advanced
Conclusion
On This Page
Key Takeaways
Constants
Overview
Naming Conventions
Examples:
Error Handling
Error Handling in Move
Using in Real-World Projects
Abort Example
Assert Example
Error Handling Advanced
Conclusion
			On This Page
			On This Page
			Key Takeaways
Constants
Overview
Naming Conventions
Examples:
Error Handling
Error Handling in Move
Using in Real-World Projects
Abort Example
Assert Example
Error Handling Advanced
Conclusion
			Key Takeaways
			Key Takeaways
			Key Takeaways
			Key Takeaways
			Constants
Overview
Naming Conventions
Examples:
			Constants
			Constants
			Constants
			Overview
Naming Conventions
Examples:
			Overview
			Overview
			Overview
			Overview
			Naming Conventions
			Naming Conventions
			Naming Conventions
			Naming Conventions
			Examples:
			Examples:
			Examples:
			Examples:
			Error Handling
Error Handling in Move
Using in Real-World Projects
Abort Example
Assert Example
			Error Handling
			Error Handling
			Error Handling
			Error Handling in Move
Using in Real-World Projects
Abort Example
Assert Example
			Error Handling in Move
			Error Handling in Move
			Error Handling in Move
			Error Handling in Move
			Using in Real-World Projects
Abort Example
Assert Example
			Using in Real-World Projects
			Using in Real-World Projects
			Using in Real-World Projects
			Abort Example
Assert Example
			Abort Example
			Abort Example
			Abort Example
			Abort Example
			Assert Example
			Assert Example
			Assert Example
			Assert Example
			Error Handling Advanced
			Error Handling Advanced
			Error Handling Advanced
			Error Handling Advanced
			Conclusion
			Conclusion
			Conclusion
			Conclusion
			Key Takeaways
Constants in Move provide immutable values with compile-time evaluation and memory optimization.
Naming conventions for constants enhance code readability (e.g., uppercase for non-error values, camel case with 'E' prefix for error codes).
Error handling utilizes
abort
statements and
assert!
macros for precise control.
Combining constants with error handling creates robust, self-documenting code.
Advanced techniques include centralizing error codes in dedicated modules for improved organization and reusability.
Proper use of constants and error handling is crucial for building secure and maintainable Move programs.
Constants
Overview
Constants in Move are a powerful way to define immutable values within a
module
or
script
. They are declared using the
const
keyword and offer several advantages:
Compile-time evaluation: The constant's value must be determinable at compilation, ensuring efficiency.
Memory optimization: Constants are stored directly in the compiled code, reducing runtime memory usage.
Value semantics: Each use of a constant creates a new copy, preserving data integrity across different parts of your code.
By leveraging constants, developers can create more readable, maintainable, and performant Move programs.
const <NAME>: <TYPE> = <EXPRESSION>;
Naming Conventions
Naming conventions for constants in Move are designed to enhance code readability and maintainability. Here are the key rules:
Initial character: Constants must begin with an uppercase letter (A-Z).
Subsequent characters: After the first letter, you can use:
Uppercase letters (A-Z)
Lowercase letters (a-z)
Digits (0-9)
Underscores (_)
This naming convention helps distinguish constants from other identifiers in your code, making it easier to recognize and use them appropriately throughout your Move programs.
Key Considerations for Constants in Move:
Type Restrictions: Constants are confined to fundamental data types such as
bool
, integer variants (
u8
to
u256
),
address
, and
vector<u8>
.
Naming Conventions:
Error codes: Use upper camel case with an 'E' prefix (e.g.,
EInsufficientFunds
)
Non-error values: Employ upper snake case (e.g.,
MAX_SUPPLY
)
Scope Limitations: Constants are
module-specific
and cannot be declared as
public
or accessed externally.
Visibility: The value of a constant is restricted to its defining module or script.
Examples:
module movement::config {
    const EOnlyAdmin: u64 = 1;
    const ENotHavePermission: u64 = 2;
    const VECTOR_U8: vector<u8> = b"hello";
}
Error Handling
Error Handling in Move
Move provides robust mechanisms for error handling, primarily through two key functions:
abort
: Immediately terminates execution with a specified error code
abort <error_code>; // error_code must be of type u64
assert!
: Evaluates a condition and aborts if it's false
assert!(<boolean_expression>, <error_code>)
These tools allow developers to implement precise error handling, enhancing the reliability and debuggability of Move programs.
Using in Real-World Projects
In real-world projects, error handling is frequently used. For large projects, we combine it with constants to manage errors more optimally, as shown in the example above:
module movement::constants_error_handling_module {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}
In the code above, we can see practical examples of error handling in Move using both the
abort
statement and the
assert!
macro, combined with constant error codes. Let's break it down:
Abort Example
The
ENotHavePermission
constant is defined with a value of 1, representing a specific error condition.
In the
const_error
function, there's a conditional check: if the input
n
equals 5, it triggers an abort with the
ENotHavePermission
error code.
The
abort
statement immediately halts the execution of the function and returns the specified error code (1 in this case).
A test function
test_const_error
is provided to verify this behavior. It's marked with
#[expected_failure(abort_code = 1)]
, indicating that it's expected to fail with the specific abort code 1.
Assert Example
The
ENotEven
constant is defined with a value of 2, representing another error condition.
In the
is_even
function, the
assert!
macro is used to check if the input number is even.
If the assertion fails (i.e., the number is odd), it aborts with the
ENotEven
error code.
Two test functions are provided:
test_is_even_failed
expects failure with abort code 2, while
test_is_even_success
expects successful execution.
This approach to error handling offers several benefits:
Clear error identification: Using named constants for error codes improves code readability and maintainability.
Consistent error reporting: By centralizing error codes as constants, you ensure consistency across your module.
Testability: The
#[expected_failure]
attribute allows you to write tests that specifically check for correct error handling.
Flexibility: Developers can choose between
abort
for immediate termination or
assert!
for condition-based checks.
By combining constants with both the
abort
mechanism and
assert!
macro, Move developers can create robust, self-documenting error handling systems that are easy to maintain, test, and adapt to various scenarios.
Error Handling Advanced
Note: Constants are
module-specific
and cannot be declared as
public
or accessed externally.
In real-world projects, the number of error handling cases can be very large. Additionally, an error may occur in multiple different modules. I have used functions to develop and optimize error handling beyond Move's traditional methods. For example:
module movement::errors {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    public fun get_enot_have_permission(): u64 {
        ENotHavePermission
    }
    public fun get_enot_even(): u64 {
        ENotEven
    }
}
module movement::constants_abort_error {
    use movement::errors;
    fun const_error(n: u64) {
        if (n == 5) {
            abort errors::get_enot_have_permission() // throwing error as the given constant
        }
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
}
module movement::constants_assert_error {
    use movement::errors;
    fun is_even(num: u64) {
        assert!(num % 2 == 0, errors::get_enot_even()); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}
With this approach, you can separate error handling into a dedicated module, making it easier to manage and resulting in cleaner code, as well as enabling reuse across different modules.
Conclusion
In this comprehensive overview of constants and error handling in Move, we've explored several key concepts:
Constants provide immutable values, offering compile-time evaluation, memory optimization, and value semantics.
Proper naming conventions for constants enhance code readability and maintainability.
Error handling in Move primarily relies on the
abort
statement and
assert!
macro.
Combining constants with error handling creates a robust system for managing and reporting errors.
Advanced error handling techniques, such as centralizing error codes in a dedicated module, can improve code organization and reusability.
By mastering these concepts, developers can create more efficient, readable, and maintainable Move programs. Constants and effective error handling are crucial for building robust smart contracts and decentralized applications on blockchain platforms that support Move.
As the Move ecosystem continues to evolve, these fundamental practices will remain essential for writing high-quality, secure code. Developers should strive to implement these patterns consistently in their projects to ensure reliability and ease of maintenance in the long term.
			Key Takeaways
Constants in Move provide immutable values with compile-time evaluation and memory optimization.
Naming conventions for constants enhance code readability (e.g., uppercase for non-error values, camel case with 'E' prefix for error codes).
Error handling utilizes
abort
statements and
assert!
macros for precise control.
Combining constants with error handling creates robust, self-documenting code.
Advanced techniques include centralizing error codes in dedicated modules for improved organization and reusability.
Proper use of constants and error handling is crucial for building secure and maintainable Move programs.
Constants
Overview
Constants in Move are a powerful way to define immutable values within a
module
or
script
. They are declared using the
const
keyword and offer several advantages:
Compile-time evaluation: The constant's value must be determinable at compilation, ensuring efficiency.
Memory optimization: Constants are stored directly in the compiled code, reducing runtime memory usage.
Value semantics: Each use of a constant creates a new copy, preserving data integrity across different parts of your code.
By leveraging constants, developers can create more readable, maintainable, and performant Move programs.
const <NAME>: <TYPE> = <EXPRESSION>;
Naming Conventions
Naming conventions for constants in Move are designed to enhance code readability and maintainability. Here are the key rules:
Initial character: Constants must begin with an uppercase letter (A-Z).
Subsequent characters: After the first letter, you can use:
Uppercase letters (A-Z)
Lowercase letters (a-z)
Digits (0-9)
Underscores (_)
This naming convention helps distinguish constants from other identifiers in your code, making it easier to recognize and use them appropriately throughout your Move programs.
Key Considerations for Constants in Move:
Type Restrictions: Constants are confined to fundamental data types such as
bool
, integer variants (
u8
to
u256
),
address
, and
vector<u8>
.
Naming Conventions:
Error codes: Use upper camel case with an 'E' prefix (e.g.,
EInsufficientFunds
)
Non-error values: Employ upper snake case (e.g.,
MAX_SUPPLY
)
Scope Limitations: Constants are
module-specific
and cannot be declared as
public
or accessed externally.
Visibility: The value of a constant is restricted to its defining module or script.
Examples:
module movement::config {
    const EOnlyAdmin: u64 = 1;
    const ENotHavePermission: u64 = 2;
    const VECTOR_U8: vector<u8> = b"hello";
}
Error Handling
Error Handling in Move
Move provides robust mechanisms for error handling, primarily through two key functions:
abort
: Immediately terminates execution with a specified error code
abort <error_code>; // error_code must be of type u64
assert!
: Evaluates a condition and aborts if it's false
assert!(<boolean_expression>, <error_code>)
These tools allow developers to implement precise error handling, enhancing the reliability and debuggability of Move programs.
Using in Real-World Projects
In real-world projects, error handling is frequently used. For large projects, we combine it with constants to manage errors more optimally, as shown in the example above:
module movement::constants_error_handling_module {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}
In the code above, we can see practical examples of error handling in Move using both the
abort
statement and the
assert!
macro, combined with constant error codes. Let's break it down:
Abort Example
The
ENotHavePermission
constant is defined with a value of 1, representing a specific error condition.
In the
const_error
function, there's a conditional check: if the input
n
equals 5, it triggers an abort with the
ENotHavePermission
error code.
The
abort
statement immediately halts the execution of the function and returns the specified error code (1 in this case).
A test function
test_const_error
is provided to verify this behavior. It's marked with
#[expected_failure(abort_code = 1)]
, indicating that it's expected to fail with the specific abort code 1.
Assert Example
The
ENotEven
constant is defined with a value of 2, representing another error condition.
In the
is_even
function, the
assert!
macro is used to check if the input number is even.
If the assertion fails (i.e., the number is odd), it aborts with the
ENotEven
error code.
Two test functions are provided:
test_is_even_failed
expects failure with abort code 2, while
test_is_even_success
expects successful execution.
This approach to error handling offers several benefits:
Clear error identification: Using named constants for error codes improves code readability and maintainability.
Consistent error reporting: By centralizing error codes as constants, you ensure consistency across your module.
Testability: The
#[expected_failure]
attribute allows you to write tests that specifically check for correct error handling.
Flexibility: Developers can choose between
abort
for immediate termination or
assert!
for condition-based checks.
By combining constants with both the
abort
mechanism and
assert!
macro, Move developers can create robust, self-documenting error handling systems that are easy to maintain, test, and adapt to various scenarios.
Error Handling Advanced
Note: Constants are
module-specific
and cannot be declared as
public
or accessed externally.
In real-world projects, the number of error handling cases can be very large. Additionally, an error may occur in multiple different modules. I have used functions to develop and optimize error handling beyond Move's traditional methods. For example:
module movement::errors {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    public fun get_enot_have_permission(): u64 {
        ENotHavePermission
    }
    public fun get_enot_even(): u64 {
        ENotEven
    }
}
module movement::constants_abort_error {
    use movement::errors;
    fun const_error(n: u64) {
        if (n == 5) {
            abort errors::get_enot_have_permission() // throwing error as the given constant
        }
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
}
module movement::constants_assert_error {
    use movement::errors;
    fun is_even(num: u64) {
        assert!(num % 2 == 0, errors::get_enot_even()); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}
With this approach, you can separate error handling into a dedicated module, making it easier to manage and resulting in cleaner code, as well as enabling reuse across different modules.
Conclusion
In this comprehensive overview of constants and error handling in Move, we've explored several key concepts:
Constants provide immutable values, offering compile-time evaluation, memory optimization, and value semantics.
Proper naming conventions for constants enhance code readability and maintainability.
Error handling in Move primarily relies on the
abort
statement and
assert!
macro.
Combining constants with error handling creates a robust system for managing and reporting errors.
Advanced error handling techniques, such as centralizing error codes in a dedicated module, can improve code organization and reusability.
By mastering these concepts, developers can create more efficient, readable, and maintainable Move programs. Constants and effective error handling are crucial for building robust smart contracts and decentralized applications on blockchain platforms that support Move.
As the Move ecosystem continues to evolve, these fundamental practices will remain essential for writing high-quality, secure code. Developers should strive to implement these patterns consistently in their projects to ensure reliability and ease of maintenance in the long term.
			Key Takeaways
Constants in Move provide immutable values with compile-time evaluation and memory optimization.
Naming conventions for constants enhance code readability (e.g., uppercase for non-error values, camel case with 'E' prefix for error codes).
Error handling utilizes
abort
statements and
assert!
macros for precise control.
Combining constants with error handling creates robust, self-documenting code.
Advanced techniques include centralizing error codes in dedicated modules for improved organization and reusability.
Proper use of constants and error handling is crucial for building secure and maintainable Move programs.
Constants
Overview
Constants in Move are a powerful way to define immutable values within a
module
or
script
. They are declared using the
const
keyword and offer several advantages:
Compile-time evaluation: The constant's value must be determinable at compilation, ensuring efficiency.
Memory optimization: Constants are stored directly in the compiled code, reducing runtime memory usage.
Value semantics: Each use of a constant creates a new copy, preserving data integrity across different parts of your code.
By leveraging constants, developers can create more readable, maintainable, and performant Move programs.
const <NAME>: <TYPE> = <EXPRESSION>;
Naming Conventions
Naming conventions for constants in Move are designed to enhance code readability and maintainability. Here are the key rules:
Initial character: Constants must begin with an uppercase letter (A-Z).
Subsequent characters: After the first letter, you can use:
Uppercase letters (A-Z)
Lowercase letters (a-z)
Digits (0-9)
Underscores (_)
This naming convention helps distinguish constants from other identifiers in your code, making it easier to recognize and use them appropriately throughout your Move programs.
Key Considerations for Constants in Move:
Type Restrictions: Constants are confined to fundamental data types such as
bool
, integer variants (
u8
to
u256
),
address
, and
vector<u8>
.
Naming Conventions:
Error codes: Use upper camel case with an 'E' prefix (e.g.,
EInsufficientFunds
)
Non-error values: Employ upper snake case (e.g.,
MAX_SUPPLY
)
Scope Limitations: Constants are
module-specific
and cannot be declared as
public
or accessed externally.
Visibility: The value of a constant is restricted to its defining module or script.
Examples:
module movement::config {
    const EOnlyAdmin: u64 = 1;
    const ENotHavePermission: u64 = 2;
    const VECTOR_U8: vector<u8> = b"hello";
}
Error Handling
Error Handling in Move
Move provides robust mechanisms for error handling, primarily through two key functions:
abort
: Immediately terminates execution with a specified error code
abort <error_code>; // error_code must be of type u64
assert!
: Evaluates a condition and aborts if it's false
assert!(<boolean_expression>, <error_code>)
These tools allow developers to implement precise error handling, enhancing the reliability and debuggability of Move programs.
Using in Real-World Projects
In real-world projects, error handling is frequently used. For large projects, we combine it with constants to manage errors more optimally, as shown in the example above:
module movement::constants_error_handling_module {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}
In the code above, we can see practical examples of error handling in Move using both the
abort
statement and the
assert!
macro, combined with constant error codes. Let's break it down:
Abort Example
The
ENotHavePermission
constant is defined with a value of 1, representing a specific error condition.
In the
const_error
function, there's a conditional check: if the input
n
equals 5, it triggers an abort with the
ENotHavePermission
error code.
The
abort
statement immediately halts the execution of the function and returns the specified error code (1 in this case).
A test function
test_const_error
is provided to verify this behavior. It's marked with
#[expected_failure(abort_code = 1)]
, indicating that it's expected to fail with the specific abort code 1.
Assert Example
The
ENotEven
constant is defined with a value of 2, representing another error condition.
In the
is_even
function, the
assert!
macro is used to check if the input number is even.
If the assertion fails (i.e., the number is odd), it aborts with the
ENotEven
error code.
Two test functions are provided:
test_is_even_failed
expects failure with abort code 2, while
test_is_even_success
expects successful execution.
This approach to error handling offers several benefits:
Clear error identification: Using named constants for error codes improves code readability and maintainability.
Consistent error reporting: By centralizing error codes as constants, you ensure consistency across your module.
Testability: The
#[expected_failure]
attribute allows you to write tests that specifically check for correct error handling.
Flexibility: Developers can choose between
abort
for immediate termination or
assert!
for condition-based checks.
By combining constants with both the
abort
mechanism and
assert!
macro, Move developers can create robust, self-documenting error handling systems that are easy to maintain, test, and adapt to various scenarios.
Error Handling Advanced
Note: Constants are
module-specific
and cannot be declared as
public
or accessed externally.
In real-world projects, the number of error handling cases can be very large. Additionally, an error may occur in multiple different modules. I have used functions to develop and optimize error handling beyond Move's traditional methods. For example:
module movement::errors {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    public fun get_enot_have_permission(): u64 {
        ENotHavePermission
    }
    public fun get_enot_even(): u64 {
        ENotEven
    }
}
module movement::constants_abort_error {
    use movement::errors;
    fun const_error(n: u64) {
        if (n == 5) {
            abort errors::get_enot_have_permission() // throwing error as the given constant
        }
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
}
module movement::constants_assert_error {
    use movement::errors;
    fun is_even(num: u64) {
        assert!(num % 2 == 0, errors::get_enot_even()); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}
With this approach, you can separate error handling into a dedicated module, making it easier to manage and resulting in cleaner code, as well as enabling reuse across different modules.
Conclusion
In this comprehensive overview of constants and error handling in Move, we've explored several key concepts:
Constants provide immutable values, offering compile-time evaluation, memory optimization, and value semantics.
Proper naming conventions for constants enhance code readability and maintainability.
Error handling in Move primarily relies on the
abort
statement and
assert!
macro.
Combining constants with error handling creates a robust system for managing and reporting errors.
Advanced error handling techniques, such as centralizing error codes in a dedicated module, can improve code organization and reusability.
By mastering these concepts, developers can create more efficient, readable, and maintainable Move programs. Constants and effective error handling are crucial for building robust smart contracts and decentralized applications on blockchain platforms that support Move.
As the Move ecosystem continues to evolve, these fundamental practices will remain essential for writing high-quality, secure code. Developers should strive to implement these patterns consistently in their projects to ensure reliability and ease of maintenance in the long term.
	Key Takeaways
	Key Takeaways
	Constants in Move provide immutable values with compile-time evaluation and memory optimization.
Naming conventions for constants enhance code readability (e.g., uppercase for non-error values, camel case with 'E' prefix for error codes).
Error handling utilizes
abort
statements and
assert!
macros for precise control.
Combining constants with error handling creates robust, self-documenting code.
Advanced techniques include centralizing error codes in dedicated modules for improved organization and reusability.
Proper use of constants and error handling is crucial for building secure and maintainable Move programs.
	Constants in Move provide immutable values with compile-time evaluation and memory optimization.
	Constants in Move provide immutable values with compile-time evaluation and memory optimization.
	Naming conventions for constants enhance code readability (e.g., uppercase for non-error values, camel case with 'E' prefix for error codes).
	Naming conventions for constants enhance code readability (e.g., uppercase for non-error values, camel case with 'E' prefix for error codes).
	Error handling utilizes
abort
statements and
assert!
macros for precise control.
	Error handling utilizes
	<code>abort</code>
	abort
	statements and
	<code>assert!</code>
	assert!
	macros for precise control.
	Combining constants with error handling creates robust, self-documenting code.
	Combining constants with error handling creates robust, self-documenting code.
	Advanced techniques include centralizing error codes in dedicated modules for improved organization and reusability.
	Advanced techniques include centralizing error codes in dedicated modules for improved organization and reusability.
	Proper use of constants and error handling is crucial for building secure and maintainable Move programs.
	Proper use of constants and error handling is crucial for building secure and maintainable Move programs.
Constants
Constants
	Overview
	Overview
	Constants in Move are a powerful way to define immutable values within a
module
or
script
. They are declared using the
const
keyword and offer several advantages:
	Constants in Move are a powerful way to define immutable values within a
	<code>module</code>
	module
	or
	<code>script</code>
	script
	. They are declared using the
	<code>const</code>
	const
	keyword and offer several advantages:
	Compile-time evaluation: The constant's value must be determinable at compilation, ensuring efficiency.
Memory optimization: Constants are stored directly in the compiled code, reducing runtime memory usage.
Value semantics: Each use of a constant creates a new copy, preserving data integrity across different parts of your code.
	Compile-time evaluation: The constant's value must be determinable at compilation, ensuring efficiency.
	Compile-time evaluation: The constant's value must be determinable at compilation, ensuring efficiency.
	Memory optimization: Constants are stored directly in the compiled code, reducing runtime memory usage.
	Memory optimization: Constants are stored directly in the compiled code, reducing runtime memory usage.
	Value semantics: Each use of a constant creates a new copy, preserving data integrity across different parts of your code.
	Value semantics: Each use of a constant creates a new copy, preserving data integrity across different parts of your code.
	By leveraging constants, developers can create more readable, maintainable, and performant Move programs.
	By leveraging constants, developers can create more readable, maintainable, and performant Move programs.
	<code>const <NAME>: <TYPE> = <EXPRESSION>;</code>
	<code>const <NAME>: <TYPE> = <EXPRESSION>;</code>
	const <NAME>: <TYPE> = <EXPRESSION>;
	Naming Conventions
	Naming Conventions
	Naming conventions for constants in Move are designed to enhance code readability and maintainability. Here are the key rules:
	Naming conventions for constants in Move are designed to enhance code readability and maintainability. Here are the key rules:
	Initial character: Constants must begin with an uppercase letter (A-Z).
Subsequent characters: After the first letter, you can use:
Uppercase letters (A-Z)
Lowercase letters (a-z)
Digits (0-9)
Underscores (_)
	Initial character: Constants must begin with an uppercase letter (A-Z).
	Initial character: Constants must begin with an uppercase letter (A-Z).
	Subsequent characters: After the first letter, you can use:
Uppercase letters (A-Z)
Lowercase letters (a-z)
Digits (0-9)
Underscores (_)
	Subsequent characters: After the first letter, you can use:
	Uppercase letters (A-Z)
Lowercase letters (a-z)
Digits (0-9)
Underscores (_)
	Uppercase letters (A-Z)
	Uppercase letters (A-Z)
	Lowercase letters (a-z)
	Lowercase letters (a-z)
	Digits (0-9)
	Digits (0-9)
	Underscores (_)
	Underscores (_)
	This naming convention helps distinguish constants from other identifiers in your code, making it easier to recognize and use them appropriately throughout your Move programs.
	This naming convention helps distinguish constants from other identifiers in your code, making it easier to recognize and use them appropriately throughout your Move programs.
	Key Considerations for Constants in Move:
	Key Considerations for Constants in Move:
	Key Considerations for Constants in Move:
	Type Restrictions: Constants are confined to fundamental data types such as
bool
, integer variants (
u8
to
u256
),
address
, and
vector<u8>
.
Naming Conventions:
Error codes: Use upper camel case with an 'E' prefix (e.g.,
EInsufficientFunds
)
Non-error values: Employ upper snake case (e.g.,
MAX_SUPPLY
)
Scope Limitations: Constants are
module-specific
and cannot be declared as
public
or accessed externally.
Visibility: The value of a constant is restricted to its defining module or script.
	Type Restrictions: Constants are confined to fundamental data types such as
bool
, integer variants (
u8
to
u256
),
address
, and
vector<u8>
.
	Type Restrictions: Constants are confined to fundamental data types such as
	<code>bool</code>
	bool
	, integer variants (
	<code>u8</code>
	u8
	to
	<code>u256</code>
	u256
	),
	<code>address</code>
	address
	, and
	<code>vector<u8></code>
	vector<u8>
	.
	Naming Conventions:
Error codes: Use upper camel case with an 'E' prefix (e.g.,
EInsufficientFunds
)
Non-error values: Employ upper snake case (e.g.,
MAX_SUPPLY
)
	Naming Conventions:
	Error codes: Use upper camel case with an 'E' prefix (e.g.,
EInsufficientFunds
)
Non-error values: Employ upper snake case (e.g.,
MAX_SUPPLY
)
	Error codes: Use upper camel case with an 'E' prefix (e.g.,
EInsufficientFunds
)
	Error codes: Use upper camel case with an 'E' prefix (e.g.,
	<code>EInsufficientFunds</code>
	EInsufficientFunds
	)
	Non-error values: Employ upper snake case (e.g.,
MAX_SUPPLY
)
	Non-error values: Employ upper snake case (e.g.,
	<code>MAX_SUPPLY</code>
	MAX_SUPPLY
	)
	Scope Limitations: Constants are
module-specific
and cannot be declared as
public
or accessed externally.
	Scope Limitations: Constants are
	<code>module-specific</code>
	module-specific
	and cannot be declared as
	<code>public</code>
	public
	or accessed externally.
	Visibility: The value of a constant is restricted to its defining module or script.
	Visibility: The value of a constant is restricted to its defining module or script.
	Examples:
	Examples:
	<code>module movement::config {
    const EOnlyAdmin: u64 = 1;
    const ENotHavePermission: u64 = 2;
    const VECTOR_U8: vector<u8> = b"hello";
}</code>
	<code>module movement::config {
    const EOnlyAdmin: u64 = 1;
    const ENotHavePermission: u64 = 2;
    const VECTOR_U8: vector<u8> = b"hello";
}</code>
	module movement::config {
    const EOnlyAdmin: u64 = 1;
    const ENotHavePermission: u64 = 2;
    const VECTOR_U8: vector<u8> = b"hello";
}
Error Handling
Error Handling
	Error Handling in Move
	Error Handling in Move
	Move provides robust mechanisms for error handling, primarily through two key functions:
	Move provides robust mechanisms for error handling, primarily through two key functions:
	abort
: Immediately terminates execution with a specified error code
abort <error_code>; // error_code must be of type u64
assert!
: Evaluates a condition and aborts if it's false
assert!(<boolean_expression>, <error_code>)
	abort
: Immediately terminates execution with a specified error code
abort <error_code>; // error_code must be of type u64
	abort
: Immediately terminates execution with a specified error code
	abort
	abort
	: Immediately terminates execution with a specified error code
	<code>abort <error_code>; // error_code must be of type u64</code>
	<code>abort <error_code>; // error_code must be of type u64</code>
	abort <error_code>; // error_code must be of type u64
	assert!
: Evaluates a condition and aborts if it's false
assert!(<boolean_expression>, <error_code>)
	assert!
: Evaluates a condition and aborts if it's false
	assert!
	assert!
	: Evaluates a condition and aborts if it's false
	<code>assert!(<boolean_expression>, <error_code>)</code>
	<code>assert!(<boolean_expression>, <error_code>)</code>
	assert!(<boolean_expression>, <error_code>)
	These tools allow developers to implement precise error handling, enhancing the reliability and debuggability of Move programs.
	These tools allow developers to implement precise error handling, enhancing the reliability and debuggability of Move programs.
	Using in Real-World Projects
	Using in Real-World Projects
	In real-world projects, error handling is frequently used. For large projects, we combine it with constants to manage errors more optimally, as shown in the example above:
	In real-world projects, error handling is frequently used. For large projects, we combine it with constants to manage errors more optimally, as shown in the example above:
	<code>module movement::constants_error_handling_module {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}</code>
	<code>module movement::constants_error_handling_module {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}</code>
	module movement::constants_error_handling_module {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}
	In the code above, we can see practical examples of error handling in Move using both the
abort
statement and the
assert!
macro, combined with constant error codes. Let's break it down:
	In the code above, we can see practical examples of error handling in Move using both the
	<code>abort</code>
	abort
	statement and the
	<code>assert!</code>
	assert!
	macro, combined with constant error codes. Let's break it down:
		Abort Example
		Abort Example
		The
ENotHavePermission
constant is defined with a value of 1, representing a specific error condition.
In the
const_error
function, there's a conditional check: if the input
n
equals 5, it triggers an abort with the
ENotHavePermission
error code.
The
abort
statement immediately halts the execution of the function and returns the specified error code (1 in this case).
A test function
test_const_error
is provided to verify this behavior. It's marked with
#[expected_failure(abort_code = 1)]
, indicating that it's expected to fail with the specific abort code 1.
		The
ENotHavePermission
constant is defined with a value of 1, representing a specific error condition.
		The
		<code>ENotHavePermission</code>
		ENotHavePermission
		constant is defined with a value of 1, representing a specific error condition.
		In the
const_error
function, there's a conditional check: if the input
n
equals 5, it triggers an abort with the
ENotHavePermission
error code.
		In the
		<code>const_error</code>
		const_error
		function, there's a conditional check: if the input
		<code>n</code>
		n
		equals 5, it triggers an abort with the
		<code>ENotHavePermission</code>
		ENotHavePermission
		error code.
		The
abort
statement immediately halts the execution of the function and returns the specified error code (1 in this case).
		The
		<code>abort</code>
		abort
		statement immediately halts the execution of the function and returns the specified error code (1 in this case).
		A test function
test_const_error
is provided to verify this behavior. It's marked with
#[expected_failure(abort_code = 1)]
, indicating that it's expected to fail with the specific abort code 1.
		A test function
		<code>test_const_error</code>
		test_const_error
		is provided to verify this behavior. It's marked with
		<code>#[expected_failure(abort_code = 1)]</code>
		#[expected_failure(abort_code = 1)]
		, indicating that it's expected to fail with the specific abort code 1.
		Assert Example
		Assert Example
		The
ENotEven
constant is defined with a value of 2, representing another error condition.
In the
is_even
function, the
assert!
macro is used to check if the input number is even.
If the assertion fails (i.e., the number is odd), it aborts with the
ENotEven
error code.
Two test functions are provided:
test_is_even_failed
expects failure with abort code 2, while
test_is_even_success
expects successful execution.
		The
ENotEven
constant is defined with a value of 2, representing another error condition.
		The
		<code>ENotEven</code>
		ENotEven
		constant is defined with a value of 2, representing another error condition.
		In the
is_even
function, the
assert!
macro is used to check if the input number is even.
		In the
		<code>is_even</code>
		is_even
		function, the
		<code>assert!</code>
		assert!
		macro is used to check if the input number is even.
		If the assertion fails (i.e., the number is odd), it aborts with the
ENotEven
error code.
		If the assertion fails (i.e., the number is odd), it aborts with the
		<code>ENotEven</code>
		ENotEven
		error code.
		Two test functions are provided:
test_is_even_failed
expects failure with abort code 2, while
test_is_even_success
expects successful execution.
		Two test functions are provided:
		<code>test_is_even_failed</code>
		test_is_even_failed
		expects failure with abort code 2, while
		<code>test_is_even_success</code>
		test_is_even_success
		expects successful execution.
		This approach to error handling offers several benefits:
		This approach to error handling offers several benefits:
		Clear error identification: Using named constants for error codes improves code readability and maintainability.
Consistent error reporting: By centralizing error codes as constants, you ensure consistency across your module.
Testability: The
#[expected_failure]
attribute allows you to write tests that specifically check for correct error handling.
Flexibility: Developers can choose between
abort
for immediate termination or
assert!
for condition-based checks.
		Clear error identification: Using named constants for error codes improves code readability and maintainability.
		Clear error identification: Using named constants for error codes improves code readability and maintainability.
		Consistent error reporting: By centralizing error codes as constants, you ensure consistency across your module.
		Consistent error reporting: By centralizing error codes as constants, you ensure consistency across your module.
		Testability: The
#[expected_failure]
attribute allows you to write tests that specifically check for correct error handling.
		Testability: The
		<code>#[expected_failure]</code>
		#[expected_failure]
		attribute allows you to write tests that specifically check for correct error handling.
		Flexibility: Developers can choose between
abort
for immediate termination or
assert!
for condition-based checks.
		Flexibility: Developers can choose between
		<code>abort</code>
		abort
		for immediate termination or
		<code>assert!</code>
		assert!
		for condition-based checks.
		By combining constants with both the
abort
mechanism and
assert!
macro, Move developers can create robust, self-documenting error handling systems that are easy to maintain, test, and adapt to various scenarios.
		By combining constants with both the
		<code>abort</code>
		abort
		mechanism and
		<code>assert!</code>
		assert!
		macro, Move developers can create robust, self-documenting error handling systems that are easy to maintain, test, and adapt to various scenarios.
Error Handling Advanced
Error Handling Advanced
Note: Constants are
module-specific
and cannot be declared as
public
or accessed externally.
Note: Constants are
<code>module-specific</code>
module-specific
and cannot be declared as
<code>public</code>
public
or accessed externally.
In real-world projects, the number of error handling cases can be very large. Additionally, an error may occur in multiple different modules. I have used functions to develop and optimize error handling beyond Move's traditional methods. For example:
In real-world projects, the number of error handling cases can be very large. Additionally, an error may occur in multiple different modules. I have used functions to develop and optimize error handling beyond Move's traditional methods. For example:
<code>module movement::errors {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    public fun get_enot_have_permission(): u64 {
        ENotHavePermission
    }
    public fun get_enot_even(): u64 {
        ENotEven
    }
}</code>
<code>module movement::errors {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    public fun get_enot_have_permission(): u64 {
        ENotHavePermission
    }
    public fun get_enot_even(): u64 {
        ENotEven
    }
}</code>
module movement::errors {
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    public fun get_enot_have_permission(): u64 {
        ENotHavePermission
    }
    public fun get_enot_even(): u64 {
        ENotEven
    }
}
<code>module movement::constants_abort_error {
    use movement::errors;
    fun const_error(n: u64) {
        if (n == 5) {
            abort errors::get_enot_have_permission() // throwing error as the given constant
        }
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
}
module movement::constants_assert_error {
    use movement::errors;
    fun is_even(num: u64) {
        assert!(num % 2 == 0, errors::get_enot_even()); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}</code>
<code>module movement::constants_abort_error {
    use movement::errors;
    fun const_error(n: u64) {
        if (n == 5) {
            abort errors::get_enot_have_permission() // throwing error as the given constant
        }
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
}
module movement::constants_assert_error {
    use movement::errors;
    fun is_even(num: u64) {
        assert!(num % 2 == 0, errors::get_enot_even()); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}</code>
module movement::constants_abort_error {
    use movement::errors;
    fun const_error(n: u64) {
        if (n == 5) {
            abort errors::get_enot_have_permission() // throwing error as the given constant
        }
    }
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        const_error(5);
    }
}
module movement::constants_assert_error {
    use movement::errors;
    fun is_even(num: u64) {
        assert!(num % 2 == 0, errors::get_enot_even()); // throwing error as the given constant
    }
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
}
With this approach, you can separate error handling into a dedicated module, making it easier to manage and resulting in cleaner code, as well as enabling reuse across different modules.
With this approach, you can separate error handling into a dedicated module, making it easier to manage and resulting in cleaner code, as well as enabling reuse across different modules.
Conclusion
Conclusion
In this comprehensive overview of constants and error handling in Move, we've explored several key concepts:
In this comprehensive overview of constants and error handling in Move, we've explored several key concepts:
Constants provide immutable values, offering compile-time evaluation, memory optimization, and value semantics.
Proper naming conventions for constants enhance code readability and maintainability.
Error handling in Move primarily relies on the
abort
statement and
assert!
macro.
Combining constants with error handling creates a robust system for managing and reporting errors.
Advanced error handling techniques, such as centralizing error codes in a dedicated module, can improve code organization and reusability.
Constants provide immutable values, offering compile-time evaluation, memory optimization, and value semantics.
Constants provide immutable values, offering compile-time evaluation, memory optimization, and value semantics.
Proper naming conventions for constants enhance code readability and maintainability.
Proper naming conventions for constants enhance code readability and maintainability.
Error handling in Move primarily relies on the
abort
statement and
assert!
macro.
Error handling in Move primarily relies on the
<code>abort</code>
abort
statement and
<code>assert!</code>
assert!
macro.
Combining constants with error handling creates a robust system for managing and reporting errors.
Combining constants with error handling creates a robust system for managing and reporting errors.
Advanced error handling techniques, such as centralizing error codes in a dedicated module, can improve code organization and reusability.
Advanced error handling techniques, such as centralizing error codes in a dedicated module, can improve code organization and reusability.
By mastering these concepts, developers can create more efficient, readable, and maintainable Move programs. Constants and effective error handling are crucial for building robust smart contracts and decentralized applications on blockchain platforms that support Move.
By mastering these concepts, developers can create more efficient, readable, and maintainable Move programs. Constants and effective error handling are crucial for building robust smart contracts and decentralized applications on blockchain platforms that support Move.
As the Move ecosystem continues to evolve, these fundamental practices will remain essential for writing high-quality, secure code. Developers should strive to implement these patterns consistently in their projects to ensure reliability and ease of maintenance in the long term.
As the Move ecosystem continues to evolve, these fundamental practices will remain essential for writing high-quality, secure code. Developers should strive to implement these patterns consistently in their projects to ensure reliability and ease of maintenance in the long term.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/07-generics-type-and-phantom-type
Generics Type & Phantom Type
Generics Type & Phantom Type
On This Page
Generics in Move: Enhancing Code Flexibility and Reusability
Key Benefits of Generics
Implementing Generics in Move
Generics Function
Generics Structs
Generics in Move: Enhancing Code Flexibility and Reusability
Move's generics feature empowers developers to craft versatile code that adapts to various data types, eliminating the need for type-specific implementations. This powerful concept, akin to generics in languages like Rust or Java, enables the creation of flexible, widely applicable code structures.
Key Benefits of Generics
Promotes code reusability across different data types
Significantly reduces code duplication
Enhances overall code maintainability and readability
Facilitates the development of robust, type-safe abstractions
Implementing Generics in Move
In Move, we typically refer to this concept as "generics" rather than type parameters and arguments. Here's how to leverage this feature:
Declaring Generic Types
Use angle brackets  to define type parameters in function and struct signatures
Example: struct Container { item: T }
Creating Generic Functions
Place type parameters after the function name and before value parameters
Example: public fun identity(x: T): T { x }
Utilize the type parameter T in parameter types, return types, and within the function body
By mastering generics, Move developers can create more efficient, flexible, and maintainable code, elevating the quality of their blockchain applications.
Generics Function
Example: In the code snippet below is a simple example to show the information of a token created from the MoveToken struct.
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
    }
}
Let's imagine a scenario where your application accepts more than one Token for payment in its functions. In this case, the code would be modified as follows.
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    struct MovementToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    fun show_movement_token(token: MovementToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        let movetoken = MovementToken {
            symbol: utf8(b"MOVEMOVE"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_movement_token(movetoken);
    }
}
So if you have about 20 different tokens for payment, your code will be very long, so we will use generic types to upgrade this code as shown below:
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    
		//a generic identity function that takes a value of any type and returns that value unchanged
    fun show_token<T: drop>(token: T) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        let movetoken = MoveToken {
            symbol: utf8(b"MOVEMENT"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        show_token(movetoken);
    }
}
Generics Structs
Type parameters for structures (structs) are placed after the struct name and can be used to name the types of the fields.
struct Foo<T> has copy, drop { x: T }
 
struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
}
On This Page
Generics in Move: Enhancing Code Flexibility and Reusability
Key Benefits of Generics
Implementing Generics in Move
Generics Function
Generics Structs
On This Page
Generics in Move: Enhancing Code Flexibility and Reusability
Key Benefits of Generics
Implementing Generics in Move
Generics Function
Generics Structs
			On This Page
			On This Page
			Generics in Move: Enhancing Code Flexibility and Reusability
Key Benefits of Generics
Implementing Generics in Move
Generics Function
Generics Structs
			Generics in Move: Enhancing Code Flexibility and Reusability
Key Benefits of Generics
Implementing Generics in Move
Generics Function
Generics Structs
			Generics in Move: Enhancing Code Flexibility and Reusability
			Generics in Move: Enhancing Code Flexibility and Reusability
			Generics in Move: Enhancing Code Flexibility and Reusability
			Key Benefits of Generics
Implementing Generics in Move
Generics Function
Generics Structs
			Key Benefits of Generics
			Key Benefits of Generics
			Key Benefits of Generics
			Key Benefits of Generics
			Implementing Generics in Move
			Implementing Generics in Move
			Implementing Generics in Move
			Implementing Generics in Move
			Generics Function
			Generics Function
			Generics Function
			Generics Function
			Generics Structs
			Generics Structs
			Generics Structs
			Generics Structs
			Generics in Move: Enhancing Code Flexibility and Reusability
Move's generics feature empowers developers to craft versatile code that adapts to various data types, eliminating the need for type-specific implementations. This powerful concept, akin to generics in languages like Rust or Java, enables the creation of flexible, widely applicable code structures.
Key Benefits of Generics
Promotes code reusability across different data types
Significantly reduces code duplication
Enhances overall code maintainability and readability
Facilitates the development of robust, type-safe abstractions
Implementing Generics in Move
In Move, we typically refer to this concept as "generics" rather than type parameters and arguments. Here's how to leverage this feature:
Declaring Generic Types
Use angle brackets  to define type parameters in function and struct signatures
Example: struct Container { item: T }
Creating Generic Functions
Place type parameters after the function name and before value parameters
Example: public fun identity(x: T): T { x }
Utilize the type parameter T in parameter types, return types, and within the function body
By mastering generics, Move developers can create more efficient, flexible, and maintainable code, elevating the quality of their blockchain applications.
Generics Function
Example: In the code snippet below is a simple example to show the information of a token created from the MoveToken struct.
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
    }
}
Let's imagine a scenario where your application accepts more than one Token for payment in its functions. In this case, the code would be modified as follows.
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    struct MovementToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    fun show_movement_token(token: MovementToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        let movetoken = MovementToken {
            symbol: utf8(b"MOVEMOVE"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_movement_token(movetoken);
    }
}
So if you have about 20 different tokens for payment, your code will be very long, so we will use generic types to upgrade this code as shown below:
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    
		//a generic identity function that takes a value of any type and returns that value unchanged
    fun show_token<T: drop>(token: T) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        let movetoken = MoveToken {
            symbol: utf8(b"MOVEMENT"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        show_token(movetoken);
    }
}
Generics Structs
Type parameters for structures (structs) are placed after the struct name and can be used to name the types of the fields.
struct Foo<T> has copy, drop { x: T }
 
struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
}
			Generics in Move: Enhancing Code Flexibility and Reusability
Move's generics feature empowers developers to craft versatile code that adapts to various data types, eliminating the need for type-specific implementations. This powerful concept, akin to generics in languages like Rust or Java, enables the creation of flexible, widely applicable code structures.
Key Benefits of Generics
Promotes code reusability across different data types
Significantly reduces code duplication
Enhances overall code maintainability and readability
Facilitates the development of robust, type-safe abstractions
Implementing Generics in Move
In Move, we typically refer to this concept as "generics" rather than type parameters and arguments. Here's how to leverage this feature:
Declaring Generic Types
Use angle brackets  to define type parameters in function and struct signatures
Example: struct Container { item: T }
Creating Generic Functions
Place type parameters after the function name and before value parameters
Example: public fun identity(x: T): T { x }
Utilize the type parameter T in parameter types, return types, and within the function body
By mastering generics, Move developers can create more efficient, flexible, and maintainable code, elevating the quality of their blockchain applications.
Generics Function
Example: In the code snippet below is a simple example to show the information of a token created from the MoveToken struct.
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
    }
}
Let's imagine a scenario where your application accepts more than one Token for payment in its functions. In this case, the code would be modified as follows.
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    struct MovementToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    fun show_movement_token(token: MovementToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        let movetoken = MovementToken {
            symbol: utf8(b"MOVEMOVE"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_movement_token(movetoken);
    }
}
So if you have about 20 different tokens for payment, your code will be very long, so we will use generic types to upgrade this code as shown below:
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    
		//a generic identity function that takes a value of any type and returns that value unchanged
    fun show_token<T: drop>(token: T) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        let movetoken = MoveToken {
            symbol: utf8(b"MOVEMENT"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        show_token(movetoken);
    }
}
Generics Structs
Type parameters for structures (structs) are placed after the struct name and can be used to name the types of the fields.
struct Foo<T> has copy, drop { x: T }
 
struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
}
			Generics in Move: Enhancing Code Flexibility and Reusability
Move's generics feature empowers developers to craft versatile code that adapts to various data types, eliminating the need for type-specific implementations. This powerful concept, akin to generics in languages like Rust or Java, enables the creation of flexible, widely applicable code structures.
Key Benefits of Generics
Promotes code reusability across different data types
Significantly reduces code duplication
Enhances overall code maintainability and readability
Facilitates the development of robust, type-safe abstractions
Implementing Generics in Move
In Move, we typically refer to this concept as "generics" rather than type parameters and arguments. Here's how to leverage this feature:
Declaring Generic Types
Use angle brackets  to define type parameters in function and struct signatures
Example: struct Container { item: T }
Creating Generic Functions
Place type parameters after the function name and before value parameters
Example: public fun identity(x: T): T { x }
Utilize the type parameter T in parameter types, return types, and within the function body
By mastering generics, Move developers can create more efficient, flexible, and maintainable code, elevating the quality of their blockchain applications.
Generics Function
Example: In the code snippet below is a simple example to show the information of a token created from the MoveToken struct.
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
    }
}
Let's imagine a scenario where your application accepts more than one Token for payment in its functions. In this case, the code would be modified as follows.
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    struct MovementToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    fun show_movement_token(token: MovementToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        let movetoken = MovementToken {
            symbol: utf8(b"MOVEMOVE"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_movement_token(movetoken);
    }
}
So if you have about 20 different tokens for payment, your code will be very long, so we will use generic types to upgrade this code as shown below:
module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    
		//a generic identity function that takes a value of any type and returns that value unchanged
    fun show_token<T: drop>(token: T) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        let movetoken = MoveToken {
            symbol: utf8(b"MOVEMENT"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        show_token(movetoken);
    }
}
Generics Structs
Type parameters for structures (structs) are placed after the struct name and can be used to name the types of the fields.
struct Foo<T> has copy, drop { x: T }
 
struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
}
	Generics in Move: Enhancing Code Flexibility and Reusability
	Generics in Move: Enhancing Code Flexibility and Reusability
	Move's generics feature empowers developers to craft versatile code that adapts to various data types, eliminating the need for type-specific implementations. This powerful concept, akin to generics in languages like Rust or Java, enables the creation of flexible, widely applicable code structures.
	Move's generics feature empowers developers to craft versatile code that adapts to various data types, eliminating the need for type-specific implementations. This powerful concept, akin to generics in languages like Rust or Java, enables the creation of flexible, widely applicable code structures.
		Key Benefits of Generics
		Key Benefits of Generics
		Promotes code reusability across different data types
Significantly reduces code duplication
Enhances overall code maintainability and readability
Facilitates the development of robust, type-safe abstractions
		Promotes code reusability across different data types
		Promotes code reusability across different data types
		Significantly reduces code duplication
		Significantly reduces code duplication
		Enhances overall code maintainability and readability
		Enhances overall code maintainability and readability
		Facilitates the development of robust, type-safe abstractions
		Facilitates the development of robust, type-safe abstractions
		Implementing Generics in Move
		Implementing Generics in Move
		In Move, we typically refer to this concept as "generics" rather than type parameters and arguments. Here's how to leverage this feature:
		In Move, we typically refer to this concept as "generics" rather than type parameters and arguments. Here's how to leverage this feature:
		Declaring Generic Types
Use angle brackets  to define type parameters in function and struct signatures
Example: struct Container { item: T }
Creating Generic Functions
Place type parameters after the function name and before value parameters
Example: public fun identity(x: T): T { x }
Utilize the type parameter T in parameter types, return types, and within the function body
		Declaring Generic Types
Use angle brackets  to define type parameters in function and struct signatures
Example: struct Container { item: T }
		Declaring Generic Types
		Use angle brackets  to define type parameters in function and struct signatures
Example: struct Container { item: T }
		Use angle brackets  to define type parameters in function and struct signatures
		Use angle brackets  to define type parameters in function and struct signatures
		Example: struct Container { item: T }
		Example: struct Container { item: T }
		Creating Generic Functions
Place type parameters after the function name and before value parameters
Example: public fun identity(x: T): T { x }
Utilize the type parameter T in parameter types, return types, and within the function body
		Creating Generic Functions
		Place type parameters after the function name and before value parameters
Example: public fun identity(x: T): T { x }
Utilize the type parameter T in parameter types, return types, and within the function body
		Place type parameters after the function name and before value parameters
		Place type parameters after the function name and before value parameters
		Example: public fun identity(x: T): T { x }
		Example: public fun identity(x: T): T { x }
		Utilize the type parameter T in parameter types, return types, and within the function body
		Utilize the type parameter T in parameter types, return types, and within the function body
		By mastering generics, Move developers can create more efficient, flexible, and maintainable code, elevating the quality of their blockchain applications.
		By mastering generics, Move developers can create more efficient, flexible, and maintainable code, elevating the quality of their blockchain applications.
		Generics Function
		Generics Function
		Example: In the code snippet below is a simple example to show the information of a token created from the MoveToken struct.
		Example: In the code snippet below is a simple example to show the information of a token created from the MoveToken struct.
		<code>module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
    }
}</code>
		<code>module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
    }
}</code>
		module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
    }
}
		Let's imagine a scenario where your application accepts more than one Token for payment in its functions. In this case, the code would be modified as follows.
		Let's imagine a scenario where your application accepts more than one Token for payment in its functions. In this case, the code would be modified as follows.
		<code>module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    struct MovementToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    fun show_movement_token(token: MovementToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        let movetoken = MovementToken {
            symbol: utf8(b"MOVEMOVE"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_movement_token(movetoken);
    }
}</code>
		<code>module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    struct MovementToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    fun show_movement_token(token: MovementToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        let movetoken = MovementToken {
            symbol: utf8(b"MOVEMOVE"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_movement_token(movetoken);
    }
}</code>
		module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    struct MovementToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    fun show_token(token: MoveToken) {
        print(&token);
    }
    fun show_movement_token(token: MovementToken) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        let movetoken = MovementToken {
            symbol: utf8(b"MOVEMOVE"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_movement_token(movetoken);
    }
}
		So if you have about 20 different tokens for payment, your code will be very long, so we will use generic types to upgrade this code as shown below:
		So if you have about 20 different tokens for payment, your code will be very long, so we will use generic types to upgrade this code as shown below:
		<code>module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    
		//a generic identity function that takes a value of any type and returns that value unchanged
    fun show_token<T: drop>(token: T) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        let movetoken = MoveToken {
            symbol: utf8(b"MOVEMENT"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        show_token(movetoken);
    }
}</code>
		<code>module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    
		//a generic identity function that takes a value of any type and returns that value unchanged
    fun show_token<T: drop>(token: T) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        let movetoken = MoveToken {
            symbol: utf8(b"MOVEMENT"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        show_token(movetoken);
    }
}</code>
		module movement::generic_type {
    use std::string::{String, utf8};
    use std::debug::print;
    use std::signer;
    struct MoveToken has drop {
        symbol: String,
        name: String,
        decimal: u8,
        total_supply: u128
    }
    
		//a generic identity function that takes a value of any type and returns that value unchanged
    fun show_token<T: drop>(token: T) {
        print(&token);
    }
    #[test]
    fun test_show_all() {
        let token = MoveToken {
            symbol: utf8(b"MOVE"),
            name: utf8(b"Movement"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        let movetoken = MoveToken {
            symbol: utf8(b"MOVEMENT"),
            name: utf8(b"Movement Tokens"),
            decimal: 8,
            total_supply: 1_000_000_000
        };
        show_token(token);
        show_token(movetoken);
    }
}
		Generics Structs
		Generics Structs
		Type parameters for structures (structs) are placed after the struct name and can be used to name the types of the fields.
		Type parameters for structures (structs) are placed after the struct name and can be used to name the types of the fields.
		<code>struct Foo<T> has copy, drop { x: T }
 
struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
}</code>
		<code>struct Foo<T> has copy, drop { x: T }
 
struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
}</code>
		struct Foo<T> has copy, drop { x: T }
 
struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/basic-concepts/08-unit-test
Unit Test
Unit Test
Unit testing in Move introduces powerful annotations to enhance the testing process:
#[test]
: Designates a function as a test case
#[test_only]
: Marks code for exclusive use in testing environments
#[expected_failure]
: Indicates a test that is anticipated to fail
These annotations revolutionize Move's testing capabilities:
The
#[test]
annotation transforms functions into comprehensive test suites
#[test_only]
allows for the creation of modules, functions, or structures dedicated solely to testing purposes, enhancing code organization
With
#[expected_failure]
, developers can proactively identify and manage tests that are designed to fail, improving overall test coverage and reliability
module movement::unit_testing {
    use std::debug::print;
    use std::signer;
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    fun show_address(address: signer) {
        print(&signer::address_of(&address))
    }
    #[test_only]
    fun new_n(): u64 {
        return 5
    }
    // This test function checks if const_error() correctly aborts with the expected error code
    // when given the value 5. It uses #[expected_failure] to indicate that we expect this test to fail.
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        let new_n = new_n();
        const_error(new_n);
    }
    // This test function verifies that is_even() correctly identifies odd numbers
    // and aborts with the expected error code. We use #[expected_failure] here as well.
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    // This test function checks if is_even() correctly handles even numbers without aborting.
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
		
    // This test function demonstrates how to use a custom signer in tests.
    // It checks if show_address() correctly prints the signer's address.
    #[test(myaccount = @0x1)]
    fun test_show_address(myaccount: signer) {
        show_address(myaccount);
    }
}
There are multiple ways to run unit tests using the CLI. By utilizing the
--filter
option, you can flexibly test with
module_name
,
function_name
, or
all
.
movement move test // Running all test function in source
movement move test --filter unit_testing // Running all test function in the module
movement move test --filter test_show_address // Running specific test function
Running Move unit tests
[ PASS ]  constants_error_handling_module::test_const_error
[ PASS ]  constants_error_handling_module::test_is_even_failed
[ PASS ]  constants_error_handling_module::test_is_even_success
[debug]   @0x1
[ PASS ]  constants_error_handling_module::test_show_address
Test result: OK. Total tests: 4; passed: 4; failed: 0
{
  "Result": "Success"
}
Unit testing in Move introduces powerful annotations to enhance the testing process:
#[test]
: Designates a function as a test case
#[test_only]
: Marks code for exclusive use in testing environments
#[expected_failure]
: Indicates a test that is anticipated to fail
These annotations revolutionize Move's testing capabilities:
The
#[test]
annotation transforms functions into comprehensive test suites
#[test_only]
allows for the creation of modules, functions, or structures dedicated solely to testing purposes, enhancing code organization
With
#[expected_failure]
, developers can proactively identify and manage tests that are designed to fail, improving overall test coverage and reliability
module movement::unit_testing {
    use std::debug::print;
    use std::signer;
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    fun show_address(address: signer) {
        print(&signer::address_of(&address))
    }
    #[test_only]
    fun new_n(): u64 {
        return 5
    }
    // This test function checks if const_error() correctly aborts with the expected error code
    // when given the value 5. It uses #[expected_failure] to indicate that we expect this test to fail.
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        let new_n = new_n();
        const_error(new_n);
    }
    // This test function verifies that is_even() correctly identifies odd numbers
    // and aborts with the expected error code. We use #[expected_failure] here as well.
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    // This test function checks if is_even() correctly handles even numbers without aborting.
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
		
    // This test function demonstrates how to use a custom signer in tests.
    // It checks if show_address() correctly prints the signer's address.
    #[test(myaccount = @0x1)]
    fun test_show_address(myaccount: signer) {
        show_address(myaccount);
    }
}
There are multiple ways to run unit tests using the CLI. By utilizing the
--filter
option, you can flexibly test with
module_name
,
function_name
, or
all
.
movement move test // Running all test function in source
movement move test --filter unit_testing // Running all test function in the module
movement move test --filter test_show_address // Running specific test function
Running Move unit tests
[ PASS ]  constants_error_handling_module::test_const_error
[ PASS ]  constants_error_handling_module::test_is_even_failed
[ PASS ]  constants_error_handling_module::test_is_even_success
[debug]   @0x1
[ PASS ]  constants_error_handling_module::test_show_address
Test result: OK. Total tests: 4; passed: 4; failed: 0
{
  "Result": "Success"
}
Unit testing in Move introduces powerful annotations to enhance the testing process:
#[test]
: Designates a function as a test case
#[test_only]
: Marks code for exclusive use in testing environments
#[expected_failure]
: Indicates a test that is anticipated to fail
These annotations revolutionize Move's testing capabilities:
The
#[test]
annotation transforms functions into comprehensive test suites
#[test_only]
allows for the creation of modules, functions, or structures dedicated solely to testing purposes, enhancing code organization
With
#[expected_failure]
, developers can proactively identify and manage tests that are designed to fail, improving overall test coverage and reliability
module movement::unit_testing {
    use std::debug::print;
    use std::signer;
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    fun show_address(address: signer) {
        print(&signer::address_of(&address))
    }
    #[test_only]
    fun new_n(): u64 {
        return 5
    }
    // This test function checks if const_error() correctly aborts with the expected error code
    // when given the value 5. It uses #[expected_failure] to indicate that we expect this test to fail.
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        let new_n = new_n();
        const_error(new_n);
    }
    // This test function verifies that is_even() correctly identifies odd numbers
    // and aborts with the expected error code. We use #[expected_failure] here as well.
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    // This test function checks if is_even() correctly handles even numbers without aborting.
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
		
    // This test function demonstrates how to use a custom signer in tests.
    // It checks if show_address() correctly prints the signer's address.
    #[test(myaccount = @0x1)]
    fun test_show_address(myaccount: signer) {
        show_address(myaccount);
    }
}
There are multiple ways to run unit tests using the CLI. By utilizing the
--filter
option, you can flexibly test with
module_name
,
function_name
, or
all
.
movement move test // Running all test function in source
movement move test --filter unit_testing // Running all test function in the module
movement move test --filter test_show_address // Running specific test function
Running Move unit tests
[ PASS ]  constants_error_handling_module::test_const_error
[ PASS ]  constants_error_handling_module::test_is_even_failed
[ PASS ]  constants_error_handling_module::test_is_even_success
[debug]   @0x1
[ PASS ]  constants_error_handling_module::test_show_address
Test result: OK. Total tests: 4; passed: 4; failed: 0
{
  "Result": "Success"
}
Unit testing in Move introduces powerful annotations to enhance the testing process:
#[test]
: Designates a function as a test case
#[test_only]
: Marks code for exclusive use in testing environments
#[expected_failure]
: Indicates a test that is anticipated to fail
These annotations revolutionize Move's testing capabilities:
The
#[test]
annotation transforms functions into comprehensive test suites
#[test_only]
allows for the creation of modules, functions, or structures dedicated solely to testing purposes, enhancing code organization
With
#[expected_failure]
, developers can proactively identify and manage tests that are designed to fail, improving overall test coverage and reliability
module movement::unit_testing {
    use std::debug::print;
    use std::signer;
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    fun show_address(address: signer) {
        print(&signer::address_of(&address))
    }
    #[test_only]
    fun new_n(): u64 {
        return 5
    }
    // This test function checks if const_error() correctly aborts with the expected error code
    // when given the value 5. It uses #[expected_failure] to indicate that we expect this test to fail.
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        let new_n = new_n();
        const_error(new_n);
    }
    // This test function verifies that is_even() correctly identifies odd numbers
    // and aborts with the expected error code. We use #[expected_failure] here as well.
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    // This test function checks if is_even() correctly handles even numbers without aborting.
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
		
    // This test function demonstrates how to use a custom signer in tests.
    // It checks if show_address() correctly prints the signer's address.
    #[test(myaccount = @0x1)]
    fun test_show_address(myaccount: signer) {
        show_address(myaccount);
    }
}
There are multiple ways to run unit tests using the CLI. By utilizing the
--filter
option, you can flexibly test with
module_name
,
function_name
, or
all
.
movement move test // Running all test function in source
movement move test --filter unit_testing // Running all test function in the module
movement move test --filter test_show_address // Running specific test function
Running Move unit tests
[ PASS ]  constants_error_handling_module::test_const_error
[ PASS ]  constants_error_handling_module::test_is_even_failed
[ PASS ]  constants_error_handling_module::test_is_even_success
[debug]   @0x1
[ PASS ]  constants_error_handling_module::test_show_address
Test result: OK. Total tests: 4; passed: 4; failed: 0
{
  "Result": "Success"
}
Unit testing in Move introduces powerful annotations to enhance the testing process:
Unit testing in Move introduces powerful annotations to enhance the testing process:
#[test]
: Designates a function as a test case
#[test_only]
: Marks code for exclusive use in testing environments
#[expected_failure]
: Indicates a test that is anticipated to fail
#[test]
: Designates a function as a test case
<code>#[test]</code>
#[test]
: Designates a function as a test case
#[test_only]
: Marks code for exclusive use in testing environments
<code>#[test_only]</code>
#[test_only]
: Marks code for exclusive use in testing environments
#[expected_failure]
: Indicates a test that is anticipated to fail
<code>#[expected_failure]</code>
#[expected_failure]
: Indicates a test that is anticipated to fail
These annotations revolutionize Move's testing capabilities:
These annotations revolutionize Move's testing capabilities:
The
#[test]
annotation transforms functions into comprehensive test suites
#[test_only]
allows for the creation of modules, functions, or structures dedicated solely to testing purposes, enhancing code organization
With
#[expected_failure]
, developers can proactively identify and manage tests that are designed to fail, improving overall test coverage and reliability
The
#[test]
annotation transforms functions into comprehensive test suites
The
<code>#[test]</code>
#[test]
annotation transforms functions into comprehensive test suites
#[test_only]
allows for the creation of modules, functions, or structures dedicated solely to testing purposes, enhancing code organization
<code>#[test_only]</code>
#[test_only]
allows for the creation of modules, functions, or structures dedicated solely to testing purposes, enhancing code organization
With
#[expected_failure]
, developers can proactively identify and manage tests that are designed to fail, improving overall test coverage and reliability
With
<code>#[expected_failure]</code>
#[expected_failure]
, developers can proactively identify and manage tests that are designed to fail, improving overall test coverage and reliability
<code>module movement::unit_testing {
    use std::debug::print;
    use std::signer;
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    fun show_address(address: signer) {
        print(&signer::address_of(&address))
    }
    #[test_only]
    fun new_n(): u64 {
        return 5
    }
    // This test function checks if const_error() correctly aborts with the expected error code
    // when given the value 5. It uses #[expected_failure] to indicate that we expect this test to fail.
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        let new_n = new_n();
        const_error(new_n);
    }
    // This test function verifies that is_even() correctly identifies odd numbers
    // and aborts with the expected error code. We use #[expected_failure] here as well.
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    // This test function checks if is_even() correctly handles even numbers without aborting.
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
		
    // This test function demonstrates how to use a custom signer in tests.
    // It checks if show_address() correctly prints the signer's address.
    #[test(myaccount = @0x1)]
    fun test_show_address(myaccount: signer) {
        show_address(myaccount);
    }
}</code>
<code>module movement::unit_testing {
    use std::debug::print;
    use std::signer;
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    fun show_address(address: signer) {
        print(&signer::address_of(&address))
    }
    #[test_only]
    fun new_n(): u64 {
        return 5
    }
    // This test function checks if const_error() correctly aborts with the expected error code
    // when given the value 5. It uses #[expected_failure] to indicate that we expect this test to fail.
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        let new_n = new_n();
        const_error(new_n);
    }
    // This test function verifies that is_even() correctly identifies odd numbers
    // and aborts with the expected error code. We use #[expected_failure] here as well.
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    // This test function checks if is_even() correctly handles even numbers without aborting.
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
		
    // This test function demonstrates how to use a custom signer in tests.
    // It checks if show_address() correctly prints the signer's address.
    #[test(myaccount = @0x1)]
    fun test_show_address(myaccount: signer) {
        show_address(myaccount);
    }
}</code>
module movement::unit_testing {
    use std::debug::print;
    use std::signer;
    const ENotHavePermission: u64 = 1;
    const ENotEven: u64 = 2;
    fun const_error(n: u64) {
        if (n == 5) {
            abort ENotHavePermission // throwing error as the given constant
        }
    }
    fun is_even(num: u64) {
        assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
    }
    fun show_address(address: signer) {
        print(&signer::address_of(&address))
    }
    #[test_only]
    fun new_n(): u64 {
        return 5
    }
    // This test function checks if const_error() correctly aborts with the expected error code
    // when given the value 5. It uses #[expected_failure] to indicate that we expect this test to fail.
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_const_error() {
        let new_n = new_n();
        const_error(new_n);
    }
    // This test function verifies that is_even() correctly identifies odd numbers
    // and aborts with the expected error code. We use #[expected_failure] here as well.
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_is_even_failed() {
        is_even(5);
    }
    // This test function checks if is_even() correctly handles even numbers without aborting.
    #[test]
    fun test_is_even_success() {
        is_even(4);
    }
		
    // This test function demonstrates how to use a custom signer in tests.
    // It checks if show_address() correctly prints the signer's address.
    #[test(myaccount = @0x1)]
    fun test_show_address(myaccount: signer) {
        show_address(myaccount);
    }
}
There are multiple ways to run unit tests using the CLI. By utilizing the
--filter
option, you can flexibly test with
module_name
,
function_name
, or
all
.
There are multiple ways to run unit tests using the CLI. By utilizing the
<code>--filter</code>
--filter
option, you can flexibly test with
<code>module_name</code>
module_name
,
<code>function_name</code>
function_name
, or
<code>all</code>
all
.
<code>movement move test // Running all test function in source
movement move test --filter unit_testing // Running all test function in the module
movement move test --filter test_show_address // Running specific test function</code>
<code>movement move test // Running all test function in source
movement move test --filter unit_testing // Running all test function in the module
movement move test --filter test_show_address // Running specific test function</code>
movement move test // Running all test function in source
movement move test --filter unit_testing // Running all test function in the module
movement move test --filter test_show_address // Running specific test function
<code>Running Move unit tests
[ PASS ]  constants_error_handling_module::test_const_error
[ PASS ]  constants_error_handling_module::test_is_even_failed
[ PASS ]  constants_error_handling_module::test_is_even_success
[debug]   @0x1
[ PASS ]  constants_error_handling_module::test_show_address
Test result: OK. Total tests: 4; passed: 4; failed: 0
{
  "Result": "Success"
}</code>
<code>Running Move unit tests
[ PASS ]  constants_error_handling_module::test_const_error
[ PASS ]  constants_error_handling_module::test_is_even_failed
[ PASS ]  constants_error_handling_module::test_is_even_success
[debug]   @0x1
[ PASS ]  constants_error_handling_module::test_show_address
Test result: OK. Total tests: 4; passed: 4; failed: 0
{
  "Result": "Success"
}</code>
Running Move unit tests
[ PASS ]  constants_error_handling_module::test_const_error
[ PASS ]  constants_error_handling_module::test_is_even_failed
[ PASS ]  constants_error_handling_module::test_is_even_success
[debug]   @0x1
[ PASS ]  constants_error_handling_module::test_show_address
Test result: OK. Total tests: 4; passed: 4; failed: 0
{
  "Result": "Success"
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move
Advanced Move
Advanced Move
Take your understanding of Move to the next level with advanced concepts. Learn about storage operations, resource management, and smart object design to build robust applications on the Movement ecosystem.
Take your understanding of Move to the next level with advanced concepts. Learn about storage operations, resource management, and smart object design to build robust applications on the Movement ecosystem.
Start
Start
Local Storage & Global Storage Operations
Start
Deploy & Call function on chain
Start
Writing Reading resources to user accounts
Start
Destroying a resource
Start
Resource Groups
Start
Events
Start
Objects
Start
Smart Vector
Start
Smart Tables
Start
Resource Account
Start
Local Storage & Global Storage Operations
Start
Local Storage & Global Storage Operations
Start
Local Storage & Global Storage Operations
Local Storage & Global Storage Operations
Start
Start
Deploy & Call function on chain
Start
Deploy & Call function on chain
Start
Deploy & Call function on chain
Deploy & Call function on chain
Start
Start
Writing Reading resources to user accounts
Start
Writing Reading resources to user accounts
Start
Writing Reading resources to user accounts
Writing Reading resources to user accounts
Start
Start
Destroying a resource
Start
Destroying a resource
Start
Destroying a resource
Destroying a resource
Start
Start
Resource Groups
Start
Resource Groups
Start
Resource Groups
Resource Groups
Start
Start
Events
Start
Events
Start
Events
Events
Start
Start
Objects
Start
Objects
Start
Objects
Objects
Start
Start
Smart Vector
Start
Smart Vector
Start
Smart Vector
Smart Vector
Start
Start
Smart Tables
Start
Smart Tables
Start
Smart Tables
Smart Tables
Start
Start
Resource Account
Start
Resource Account
Start
Resource Account
Resource Account
Start
Start

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/01-local-storage-and-global-storage-operations
Local Storage & Global Storage Operations
Local Storage & Global Storage Operations
On This Page
Summary
Overview
Local Storage ( Local Variable )
Global Storage
Example Code:
Delete Resource
Full Code
Understanding the 'acquires' Keyword in Move
Purpose of 'acquires'
How it Works
Example Usage
Important Notes
Summary
Move is a Resource-Oriented Programming language focusing on resources rather than accounts
Local storage uses the
let
keyword for variables with limited scope and lifespan
Global storage provides persistent data storage on the blockchain using a tree-like structure
Global storage operations include
move_to
,
move_from
,
borrow_global
,
borrow_global_mut
, and
exists
Resources in global storage require the
key
ability and must be owned by an address
The
drop
ability allows resources to be removed from global storage
Move programs can read from and write to global storage, but cannot access external resources
Overview
Move is a Resource-Oriented Programming (
ROP
) language, where the entire system centers around resources instead of accounts as in many traditional blockchains, also known as
Resource-Centric
.
In the topic below, we will explore how Global Storage and Local Storage work in Move, and how you can create data stored in these two storage types.
Local Storage ( Local Variable )
In Move, local variables operate within a specific scope and have a limited lifespan. They are declared using the
let
keyword and possess unique characteristics:
Scope: Variables are confined to the block where they are defined
Shadowing: New declarations can overshadow existing variables with the same name
Mutability: Values can be modified directly or through mutable references
Flexibility: They can hold various data types, from simple integers to complex structures
module movement::local_storage {
    fun local_variables(){
        let b: u8;
        let c = false;
        let d = b"hello world";
        let e: u64 = 10_000;
    }
}
All the variables mentioned above are created within the
local_variables
function. As a result, they only exist within the function's scope. When this function ends, all variables within it will be
dropped
.
Additionally, we can create resources and structs as local storage through a struct ability in
move
called "drop". This ability allows the struct or resource to be dropped after the function ends, aligning with the characteristics of local variables you've read about above.
For example:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer;
    struct LocalData has drop {
        value: u64
    }
    public entry fun new_local(value: u64) {
        let data = LocalData {
            value: value
        };
        let local_var = b"Local Storage Data";
        print(&data);
        print(&local_var);
    }
    #[test]
    fun test_new_local() {
        new_local(10);
    }
}
In the
new_local
function, you can see that after the
LocalData
resource is created, it's not owned by anyone and isn't transferred anywhere. This means that when the new_local function ends,
LocalData
will be dropped. For the Move compiler to allow this,
LocalData
must have the
drop
ability and must not have the
key
ability.
Global Storage
Global storage in Move:
Enables persistent data storage on the blockchain
Maintains long-term data accessibility across transactions and contracts
Uses a tree-like structure for efficient organization and retrieval
Key-value pairing system for precise data management
Move programs interact with global storage by:
Reading existing data
Writing new or updated information
Limitations:
Cannot access external resources (e.g., filesystems, networks)
Ensures data manipulations occur within the blockchain's controlled environment
Maintains security and consistency across the system
struct GlobalStorage {
  resources: Map<(address, ResourceType), ResourceValue>
  modules: Map<(address, ModuleName), ModuleBytecode>
}
Let's examine the example below for a clearer understanding:
module movement::local_global_storage {
    use std::debug::print;
    struct GlobalData has key {
        value: u64
    }
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
In the code above, after initializing
GlobalData
and storing it in a variable called data, if you stop here, the compiler will throw an error when you build. This is because
GlobalData
contains the
key
ability. Consequently, this data needs to be stored in global storage. However, to store it in global storage, you must assign this Resource an owner in the form of a Map. In this case, we'll store it under the signer who called this function. The result of the function will create a resource and transfer it to the address of the caller.
Here's the
GlobalStorage
data after you initialize it using the
new_global
function:
{
  "0x40264b8d01986e70c79999a189e4c4043aad3ec970d00a095cf29b2916eda04d::local_global_storage::GlobalData": {
    "value": "10"
  }
}
For global data, you can only access it through these native functions provided by Move:
| Operation | Description | Aborts? |
| --- | --- | --- |
|
move_to<T>(&signer,T)
| Publish
T
under
signer.address
| If
signer.address
already holds a
T
|
|
move_from<T>(address): T
| Remove
T
from
address
and return it | If
address
does not hold a
T
|
|
borrow_global_mut<T>(address): &mut T
| Return a mutable reference to the
T
stored under
address
| If
address
does not hold a
T
|
|
borrow_global<T>(address): &T
| Return an immutable reference to the
T
stored under
address
| If
address
does not hold a
T
|
|
exists<T>(address): bool
| Return
true
if a
T
is stored under
address
| Never |
Example Code:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Delete Resource
The
move_from
function is a crucial part of resource management in Move. It allows for the removal of a resource from an account or address. However, there's an important caveat: the resource must have the "drop" ability to be used with
move_from
. This requirement serves as a safety mechanism, preventing accidental or unauthorized deletion of resources.
Key points to understand:
Resources without the "drop" ability cannot be removed, ensuring their permanence.
This feature gives developers fine-grained control over resource lifecycle management.
It's particularly useful for creating persistent resources that should remain intact throughout a contract's lifetime.
By implementing this safeguard, Move enhances the security and predictability of smart contracts, allowing developers to design more robust and controlled resource management systems.
Drop Ability
struct GlobalData has key, drop {
    value: u64
}
move_from
public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}
Full Code
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
Running test:
movement move test -f local_global_storage
Result:
Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Understanding the 'acquires' Keyword in Move
The 'acquires' keyword in Move is an important concept related to global storage operations. Here's what you need to know about it:
Purpose of 'acquires'
The 'acquires' keyword is used to declare that a function may access (or "acquire") a specific resource from global storage. It's a way of explicitly stating which global resources a function intends to use.
How it Works
Declaration: When you define a function that needs to access a global resource, you add 'acquires' followed by the resource type after the function signature.
Compiler Check: The Move compiler uses this information to ensure that the function only accesses the declared resources, preventing unintended access to other global resources.
Safety: It helps in preventing race conditions and ensures safe concurrent execution of transactions.
Example Usage
public fun read_global_data(addr: address): u64 acquires GlobalData {
    borrow_global<GlobalData>(addr).value
}
In this example, the function declares that it will acquire the 'GlobalData' resource from global storage.
Important Notes
Multiple Resources: A function can acquire multiple resources by listing them after 'acquires', separated by commas.
Nested Calls: If a function calls another function that acquires a resource, the calling function must also declare that it acquires that resource.
Compiler Enforcement: The Move compiler will throw an error if a function tries to access a global resource without declaring it with 'acquires'.
By using 'acquires', Move provides a clear and safe way to manage access to global storage, enhancing the security and predictability of smart contracts.
On This Page
Summary
Overview
Local Storage ( Local Variable )
Global Storage
Example Code:
Delete Resource
Full Code
Understanding the 'acquires' Keyword in Move
Purpose of 'acquires'
How it Works
Example Usage
Important Notes
On This Page
Summary
Overview
Local Storage ( Local Variable )
Global Storage
Example Code:
Delete Resource
Full Code
Understanding the 'acquires' Keyword in Move
Purpose of 'acquires'
How it Works
Example Usage
Important Notes
			On This Page
			On This Page
			Summary
Overview
Local Storage ( Local Variable )
Global Storage
Example Code:
Delete Resource
Full Code
Understanding the 'acquires' Keyword in Move
Purpose of 'acquires'
How it Works
Example Usage
Important Notes
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			Local Storage ( Local Variable )
Global Storage
Example Code:
Delete Resource
Full Code
			Local Storage ( Local Variable )
			Local Storage ( Local Variable )
			Local Storage ( Local Variable )
			Global Storage
Example Code:
Delete Resource
Full Code
			Global Storage
			Global Storage
			Global Storage
			Global Storage
			Example Code:
			Example Code:
			Example Code:
			Example Code:
			Delete Resource
			Delete Resource
			Delete Resource
			Delete Resource
			Full Code
			Full Code
			Full Code
			Full Code
			Understanding the 'acquires' Keyword in Move
Purpose of 'acquires'
How it Works
Example Usage
Important Notes
			Understanding the 'acquires' Keyword in Move
			Understanding the 'acquires' Keyword in Move
			Understanding the 'acquires' Keyword in Move
			Purpose of 'acquires'
How it Works
Example Usage
Important Notes
			Purpose of 'acquires'
			Purpose of 'acquires'
			Purpose of 'acquires'
			Purpose of 'acquires'
			How it Works
			How it Works
			How it Works
			How it Works
			Example Usage
			Example Usage
			Example Usage
			Example Usage
			Important Notes
			Important Notes
			Important Notes
			Important Notes
			Summary
Move is a Resource-Oriented Programming language focusing on resources rather than accounts
Local storage uses the
let
keyword for variables with limited scope and lifespan
Global storage provides persistent data storage on the blockchain using a tree-like structure
Global storage operations include
move_to
,
move_from
,
borrow_global
,
borrow_global_mut
, and
exists
Resources in global storage require the
key
ability and must be owned by an address
The
drop
ability allows resources to be removed from global storage
Move programs can read from and write to global storage, but cannot access external resources
Overview
Move is a Resource-Oriented Programming (
ROP
) language, where the entire system centers around resources instead of accounts as in many traditional blockchains, also known as
Resource-Centric
.
In the topic below, we will explore how Global Storage and Local Storage work in Move, and how you can create data stored in these two storage types.
Local Storage ( Local Variable )
In Move, local variables operate within a specific scope and have a limited lifespan. They are declared using the
let
keyword and possess unique characteristics:
Scope: Variables are confined to the block where they are defined
Shadowing: New declarations can overshadow existing variables with the same name
Mutability: Values can be modified directly or through mutable references
Flexibility: They can hold various data types, from simple integers to complex structures
module movement::local_storage {
    fun local_variables(){
        let b: u8;
        let c = false;
        let d = b"hello world";
        let e: u64 = 10_000;
    }
}
All the variables mentioned above are created within the
local_variables
function. As a result, they only exist within the function's scope. When this function ends, all variables within it will be
dropped
.
Additionally, we can create resources and structs as local storage through a struct ability in
move
called "drop". This ability allows the struct or resource to be dropped after the function ends, aligning with the characteristics of local variables you've read about above.
For example:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer;
    struct LocalData has drop {
        value: u64
    }
    public entry fun new_local(value: u64) {
        let data = LocalData {
            value: value
        };
        let local_var = b"Local Storage Data";
        print(&data);
        print(&local_var);
    }
    #[test]
    fun test_new_local() {
        new_local(10);
    }
}
In the
new_local
function, you can see that after the
LocalData
resource is created, it's not owned by anyone and isn't transferred anywhere. This means that when the new_local function ends,
LocalData
will be dropped. For the Move compiler to allow this,
LocalData
must have the
drop
ability and must not have the
key
ability.
Global Storage
Global storage in Move:
Enables persistent data storage on the blockchain
Maintains long-term data accessibility across transactions and contracts
Uses a tree-like structure for efficient organization and retrieval
Key-value pairing system for precise data management
Move programs interact with global storage by:
Reading existing data
Writing new or updated information
Limitations:
Cannot access external resources (e.g., filesystems, networks)
Ensures data manipulations occur within the blockchain's controlled environment
Maintains security and consistency across the system
struct GlobalStorage {
  resources: Map<(address, ResourceType), ResourceValue>
  modules: Map<(address, ModuleName), ModuleBytecode>
}
Let's examine the example below for a clearer understanding:
module movement::local_global_storage {
    use std::debug::print;
    struct GlobalData has key {
        value: u64
    }
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
In the code above, after initializing
GlobalData
and storing it in a variable called data, if you stop here, the compiler will throw an error when you build. This is because
GlobalData
contains the
key
ability. Consequently, this data needs to be stored in global storage. However, to store it in global storage, you must assign this Resource an owner in the form of a Map. In this case, we'll store it under the signer who called this function. The result of the function will create a resource and transfer it to the address of the caller.
Here's the
GlobalStorage
data after you initialize it using the
new_global
function:
{
  "0x40264b8d01986e70c79999a189e4c4043aad3ec970d00a095cf29b2916eda04d::local_global_storage::GlobalData": {
    "value": "10"
  }
}
For global data, you can only access it through these native functions provided by Move:
| Operation | Description | Aborts? |
| --- | --- | --- |
|
move_to<T>(&signer,T)
| Publish
T
under
signer.address
| If
signer.address
already holds a
T
|
|
move_from<T>(address): T
| Remove
T
from
address
and return it | If
address
does not hold a
T
|
|
borrow_global_mut<T>(address): &mut T
| Return a mutable reference to the
T
stored under
address
| If
address
does not hold a
T
|
|
borrow_global<T>(address): &T
| Return an immutable reference to the
T
stored under
address
| If
address
does not hold a
T
|
|
exists<T>(address): bool
| Return
true
if a
T
is stored under
address
| Never |
Example Code:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Delete Resource
The
move_from
function is a crucial part of resource management in Move. It allows for the removal of a resource from an account or address. However, there's an important caveat: the resource must have the "drop" ability to be used with
move_from
. This requirement serves as a safety mechanism, preventing accidental or unauthorized deletion of resources.
Key points to understand:
Resources without the "drop" ability cannot be removed, ensuring their permanence.
This feature gives developers fine-grained control over resource lifecycle management.
It's particularly useful for creating persistent resources that should remain intact throughout a contract's lifetime.
By implementing this safeguard, Move enhances the security and predictability of smart contracts, allowing developers to design more robust and controlled resource management systems.
Drop Ability
struct GlobalData has key, drop {
    value: u64
}
move_from
public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}
Full Code
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
Running test:
movement move test -f local_global_storage
Result:
Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Understanding the 'acquires' Keyword in Move
The 'acquires' keyword in Move is an important concept related to global storage operations. Here's what you need to know about it:
Purpose of 'acquires'
The 'acquires' keyword is used to declare that a function may access (or "acquire") a specific resource from global storage. It's a way of explicitly stating which global resources a function intends to use.
How it Works
Declaration: When you define a function that needs to access a global resource, you add 'acquires' followed by the resource type after the function signature.
Compiler Check: The Move compiler uses this information to ensure that the function only accesses the declared resources, preventing unintended access to other global resources.
Safety: It helps in preventing race conditions and ensures safe concurrent execution of transactions.
Example Usage
public fun read_global_data(addr: address): u64 acquires GlobalData {
    borrow_global<GlobalData>(addr).value
}
In this example, the function declares that it will acquire the 'GlobalData' resource from global storage.
Important Notes
Multiple Resources: A function can acquire multiple resources by listing them after 'acquires', separated by commas.
Nested Calls: If a function calls another function that acquires a resource, the calling function must also declare that it acquires that resource.
Compiler Enforcement: The Move compiler will throw an error if a function tries to access a global resource without declaring it with 'acquires'.
By using 'acquires', Move provides a clear and safe way to manage access to global storage, enhancing the security and predictability of smart contracts.
			Summary
Move is a Resource-Oriented Programming language focusing on resources rather than accounts
Local storage uses the
let
keyword for variables with limited scope and lifespan
Global storage provides persistent data storage on the blockchain using a tree-like structure
Global storage operations include
move_to
,
move_from
,
borrow_global
,
borrow_global_mut
, and
exists
Resources in global storage require the
key
ability and must be owned by an address
The
drop
ability allows resources to be removed from global storage
Move programs can read from and write to global storage, but cannot access external resources
Overview
Move is a Resource-Oriented Programming (
ROP
) language, where the entire system centers around resources instead of accounts as in many traditional blockchains, also known as
Resource-Centric
.
In the topic below, we will explore how Global Storage and Local Storage work in Move, and how you can create data stored in these two storage types.
Local Storage ( Local Variable )
In Move, local variables operate within a specific scope and have a limited lifespan. They are declared using the
let
keyword and possess unique characteristics:
Scope: Variables are confined to the block where they are defined
Shadowing: New declarations can overshadow existing variables with the same name
Mutability: Values can be modified directly or through mutable references
Flexibility: They can hold various data types, from simple integers to complex structures
module movement::local_storage {
    fun local_variables(){
        let b: u8;
        let c = false;
        let d = b"hello world";
        let e: u64 = 10_000;
    }
}
All the variables mentioned above are created within the
local_variables
function. As a result, they only exist within the function's scope. When this function ends, all variables within it will be
dropped
.
Additionally, we can create resources and structs as local storage through a struct ability in
move
called "drop". This ability allows the struct or resource to be dropped after the function ends, aligning with the characteristics of local variables you've read about above.
For example:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer;
    struct LocalData has drop {
        value: u64
    }
    public entry fun new_local(value: u64) {
        let data = LocalData {
            value: value
        };
        let local_var = b"Local Storage Data";
        print(&data);
        print(&local_var);
    }
    #[test]
    fun test_new_local() {
        new_local(10);
    }
}
In the
new_local
function, you can see that after the
LocalData
resource is created, it's not owned by anyone and isn't transferred anywhere. This means that when the new_local function ends,
LocalData
will be dropped. For the Move compiler to allow this,
LocalData
must have the
drop
ability and must not have the
key
ability.
Global Storage
Global storage in Move:
Enables persistent data storage on the blockchain
Maintains long-term data accessibility across transactions and contracts
Uses a tree-like structure for efficient organization and retrieval
Key-value pairing system for precise data management
Move programs interact with global storage by:
Reading existing data
Writing new or updated information
Limitations:
Cannot access external resources (e.g., filesystems, networks)
Ensures data manipulations occur within the blockchain's controlled environment
Maintains security and consistency across the system
struct GlobalStorage {
  resources: Map<(address, ResourceType), ResourceValue>
  modules: Map<(address, ModuleName), ModuleBytecode>
}
Let's examine the example below for a clearer understanding:
module movement::local_global_storage {
    use std::debug::print;
    struct GlobalData has key {
        value: u64
    }
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
In the code above, after initializing
GlobalData
and storing it in a variable called data, if you stop here, the compiler will throw an error when you build. This is because
GlobalData
contains the
key
ability. Consequently, this data needs to be stored in global storage. However, to store it in global storage, you must assign this Resource an owner in the form of a Map. In this case, we'll store it under the signer who called this function. The result of the function will create a resource and transfer it to the address of the caller.
Here's the
GlobalStorage
data after you initialize it using the
new_global
function:
{
  "0x40264b8d01986e70c79999a189e4c4043aad3ec970d00a095cf29b2916eda04d::local_global_storage::GlobalData": {
    "value": "10"
  }
}
For global data, you can only access it through these native functions provided by Move:
| Operation | Description | Aborts? |
| --- | --- | --- |
|
move_to<T>(&signer,T)
| Publish
T
under
signer.address
| If
signer.address
already holds a
T
|
|
move_from<T>(address): T
| Remove
T
from
address
and return it | If
address
does not hold a
T
|
|
borrow_global_mut<T>(address): &mut T
| Return a mutable reference to the
T
stored under
address
| If
address
does not hold a
T
|
|
borrow_global<T>(address): &T
| Return an immutable reference to the
T
stored under
address
| If
address
does not hold a
T
|
|
exists<T>(address): bool
| Return
true
if a
T
is stored under
address
| Never |
Example Code:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Delete Resource
The
move_from
function is a crucial part of resource management in Move. It allows for the removal of a resource from an account or address. However, there's an important caveat: the resource must have the "drop" ability to be used with
move_from
. This requirement serves as a safety mechanism, preventing accidental or unauthorized deletion of resources.
Key points to understand:
Resources without the "drop" ability cannot be removed, ensuring their permanence.
This feature gives developers fine-grained control over resource lifecycle management.
It's particularly useful for creating persistent resources that should remain intact throughout a contract's lifetime.
By implementing this safeguard, Move enhances the security and predictability of smart contracts, allowing developers to design more robust and controlled resource management systems.
Drop Ability
struct GlobalData has key, drop {
    value: u64
}
move_from
public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}
Full Code
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
Running test:
movement move test -f local_global_storage
Result:
Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Understanding the 'acquires' Keyword in Move
The 'acquires' keyword in Move is an important concept related to global storage operations. Here's what you need to know about it:
Purpose of 'acquires'
The 'acquires' keyword is used to declare that a function may access (or "acquire") a specific resource from global storage. It's a way of explicitly stating which global resources a function intends to use.
How it Works
Declaration: When you define a function that needs to access a global resource, you add 'acquires' followed by the resource type after the function signature.
Compiler Check: The Move compiler uses this information to ensure that the function only accesses the declared resources, preventing unintended access to other global resources.
Safety: It helps in preventing race conditions and ensures safe concurrent execution of transactions.
Example Usage
public fun read_global_data(addr: address): u64 acquires GlobalData {
    borrow_global<GlobalData>(addr).value
}
In this example, the function declares that it will acquire the 'GlobalData' resource from global storage.
Important Notes
Multiple Resources: A function can acquire multiple resources by listing them after 'acquires', separated by commas.
Nested Calls: If a function calls another function that acquires a resource, the calling function must also declare that it acquires that resource.
Compiler Enforcement: The Move compiler will throw an error if a function tries to access a global resource without declaring it with 'acquires'.
By using 'acquires', Move provides a clear and safe way to manage access to global storage, enhancing the security and predictability of smart contracts.
			Summary
Move is a Resource-Oriented Programming language focusing on resources rather than accounts
Local storage uses the
let
keyword for variables with limited scope and lifespan
Global storage provides persistent data storage on the blockchain using a tree-like structure
Global storage operations include
move_to
,
move_from
,
borrow_global
,
borrow_global_mut
, and
exists
Resources in global storage require the
key
ability and must be owned by an address
The
drop
ability allows resources to be removed from global storage
Move programs can read from and write to global storage, but cannot access external resources
Overview
Move is a Resource-Oriented Programming (
ROP
) language, where the entire system centers around resources instead of accounts as in many traditional blockchains, also known as
Resource-Centric
.
In the topic below, we will explore how Global Storage and Local Storage work in Move, and how you can create data stored in these two storage types.
Local Storage ( Local Variable )
In Move, local variables operate within a specific scope and have a limited lifespan. They are declared using the
let
keyword and possess unique characteristics:
Scope: Variables are confined to the block where they are defined
Shadowing: New declarations can overshadow existing variables with the same name
Mutability: Values can be modified directly or through mutable references
Flexibility: They can hold various data types, from simple integers to complex structures
module movement::local_storage {
    fun local_variables(){
        let b: u8;
        let c = false;
        let d = b"hello world";
        let e: u64 = 10_000;
    }
}
All the variables mentioned above are created within the
local_variables
function. As a result, they only exist within the function's scope. When this function ends, all variables within it will be
dropped
.
Additionally, we can create resources and structs as local storage through a struct ability in
move
called "drop". This ability allows the struct or resource to be dropped after the function ends, aligning with the characteristics of local variables you've read about above.
For example:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer;
    struct LocalData has drop {
        value: u64
    }
    public entry fun new_local(value: u64) {
        let data = LocalData {
            value: value
        };
        let local_var = b"Local Storage Data";
        print(&data);
        print(&local_var);
    }
    #[test]
    fun test_new_local() {
        new_local(10);
    }
}
In the
new_local
function, you can see that after the
LocalData
resource is created, it's not owned by anyone and isn't transferred anywhere. This means that when the new_local function ends,
LocalData
will be dropped. For the Move compiler to allow this,
LocalData
must have the
drop
ability and must not have the
key
ability.
Global Storage
Global storage in Move:
Enables persistent data storage on the blockchain
Maintains long-term data accessibility across transactions and contracts
Uses a tree-like structure for efficient organization and retrieval
Key-value pairing system for precise data management
Move programs interact with global storage by:
Reading existing data
Writing new or updated information
Limitations:
Cannot access external resources (e.g., filesystems, networks)
Ensures data manipulations occur within the blockchain's controlled environment
Maintains security and consistency across the system
struct GlobalStorage {
  resources: Map<(address, ResourceType), ResourceValue>
  modules: Map<(address, ModuleName), ModuleBytecode>
}
Let's examine the example below for a clearer understanding:
module movement::local_global_storage {
    use std::debug::print;
    struct GlobalData has key {
        value: u64
    }
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
In the code above, after initializing
GlobalData
and storing it in a variable called data, if you stop here, the compiler will throw an error when you build. This is because
GlobalData
contains the
key
ability. Consequently, this data needs to be stored in global storage. However, to store it in global storage, you must assign this Resource an owner in the form of a Map. In this case, we'll store it under the signer who called this function. The result of the function will create a resource and transfer it to the address of the caller.
Here's the
GlobalStorage
data after you initialize it using the
new_global
function:
{
  "0x40264b8d01986e70c79999a189e4c4043aad3ec970d00a095cf29b2916eda04d::local_global_storage::GlobalData": {
    "value": "10"
  }
}
For global data, you can only access it through these native functions provided by Move:
| Operation | Description | Aborts? |
| --- | --- | --- |
|
move_to<T>(&signer,T)
| Publish
T
under
signer.address
| If
signer.address
already holds a
T
|
|
move_from<T>(address): T
| Remove
T
from
address
and return it | If
address
does not hold a
T
|
|
borrow_global_mut<T>(address): &mut T
| Return a mutable reference to the
T
stored under
address
| If
address
does not hold a
T
|
|
borrow_global<T>(address): &T
| Return an immutable reference to the
T
stored under
address
| If
address
does not hold a
T
|
|
exists<T>(address): bool
| Return
true
if a
T
is stored under
address
| Never |
Example Code:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Delete Resource
The
move_from
function is a crucial part of resource management in Move. It allows for the removal of a resource from an account or address. However, there's an important caveat: the resource must have the "drop" ability to be used with
move_from
. This requirement serves as a safety mechanism, preventing accidental or unauthorized deletion of resources.
Key points to understand:
Resources without the "drop" ability cannot be removed, ensuring their permanence.
This feature gives developers fine-grained control over resource lifecycle management.
It's particularly useful for creating persistent resources that should remain intact throughout a contract's lifetime.
By implementing this safeguard, Move enhances the security and predictability of smart contracts, allowing developers to design more robust and controlled resource management systems.
Drop Ability
struct GlobalData has key, drop {
    value: u64
}
move_from
public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}
Full Code
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
Running test:
movement move test -f local_global_storage
Result:
Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Understanding the 'acquires' Keyword in Move
The 'acquires' keyword in Move is an important concept related to global storage operations. Here's what you need to know about it:
Purpose of 'acquires'
The 'acquires' keyword is used to declare that a function may access (or "acquire") a specific resource from global storage. It's a way of explicitly stating which global resources a function intends to use.
How it Works
Declaration: When you define a function that needs to access a global resource, you add 'acquires' followed by the resource type after the function signature.
Compiler Check: The Move compiler uses this information to ensure that the function only accesses the declared resources, preventing unintended access to other global resources.
Safety: It helps in preventing race conditions and ensures safe concurrent execution of transactions.
Example Usage
public fun read_global_data(addr: address): u64 acquires GlobalData {
    borrow_global<GlobalData>(addr).value
}
In this example, the function declares that it will acquire the 'GlobalData' resource from global storage.
Important Notes
Multiple Resources: A function can acquire multiple resources by listing them after 'acquires', separated by commas.
Nested Calls: If a function calls another function that acquires a resource, the calling function must also declare that it acquires that resource.
Compiler Enforcement: The Move compiler will throw an error if a function tries to access a global resource without declaring it with 'acquires'.
By using 'acquires', Move provides a clear and safe way to manage access to global storage, enhancing the security and predictability of smart contracts.
	Summary
	Summary
	Move is a Resource-Oriented Programming language focusing on resources rather than accounts
Local storage uses the
let
keyword for variables with limited scope and lifespan
Global storage provides persistent data storage on the blockchain using a tree-like structure
Global storage operations include
move_to
,
move_from
,
borrow_global
,
borrow_global_mut
, and
exists
Resources in global storage require the
key
ability and must be owned by an address
The
drop
ability allows resources to be removed from global storage
Move programs can read from and write to global storage, but cannot access external resources
	Move is a Resource-Oriented Programming language focusing on resources rather than accounts
	Move is a Resource-Oriented Programming language focusing on resources rather than accounts
	Local storage uses the
let
keyword for variables with limited scope and lifespan
	Local storage uses the
	<code>let</code>
	let
	keyword for variables with limited scope and lifespan
	Global storage provides persistent data storage on the blockchain using a tree-like structure
	Global storage provides persistent data storage on the blockchain using a tree-like structure
	Global storage operations include
move_to
,
move_from
,
borrow_global
,
borrow_global_mut
, and
exists
	Global storage operations include
	<code>move_to</code>
	move_to
	,
	<code>move_from</code>
	move_from
	,
	<code>borrow_global</code>
	borrow_global
	,
	<code>borrow_global_mut</code>
	borrow_global_mut
	, and
	<code>exists</code>
	exists
	Resources in global storage require the
key
ability and must be owned by an address
	Resources in global storage require the
	<code>key</code>
	key
	ability and must be owned by an address
	The
drop
ability allows resources to be removed from global storage
	The
	<code>drop</code>
	drop
	ability allows resources to be removed from global storage
	Move programs can read from and write to global storage, but cannot access external resources
	Move programs can read from and write to global storage, but cannot access external resources
	Overview
	Overview
	Move is a Resource-Oriented Programming (
ROP
) language, where the entire system centers around resources instead of accounts as in many traditional blockchains, also known as
Resource-Centric
.
	Move is a Resource-Oriented Programming (
	<code>ROP</code>
	ROP
	) language, where the entire system centers around resources instead of accounts as in many traditional blockchains, also known as
	<code>Resource-Centric</code>
	Resource-Centric
	.
	In the topic below, we will explore how Global Storage and Local Storage work in Move, and how you can create data stored in these two storage types.
	In the topic below, we will explore how Global Storage and Local Storage work in Move, and how you can create data stored in these two storage types.
	Local Storage ( Local Variable )
	Local Storage ( Local Variable )
	In Move, local variables operate within a specific scope and have a limited lifespan. They are declared using the
let
keyword and possess unique characteristics:
	In Move, local variables operate within a specific scope and have a limited lifespan. They are declared using the
	<code>let</code>
	let
	keyword and possess unique characteristics:
	Scope: Variables are confined to the block where they are defined
Shadowing: New declarations can overshadow existing variables with the same name
Mutability: Values can be modified directly or through mutable references
Flexibility: They can hold various data types, from simple integers to complex structures
	Scope: Variables are confined to the block where they are defined
	Scope: Variables are confined to the block where they are defined
	Shadowing: New declarations can overshadow existing variables with the same name
	Shadowing: New declarations can overshadow existing variables with the same name
	Mutability: Values can be modified directly or through mutable references
	Mutability: Values can be modified directly or through mutable references
	Flexibility: They can hold various data types, from simple integers to complex structures
	Flexibility: They can hold various data types, from simple integers to complex structures
	<code>module movement::local_storage {
    fun local_variables(){
        let b: u8;
        let c = false;
        let d = b"hello world";
        let e: u64 = 10_000;
    }
}</code>
	<code>module movement::local_storage {
    fun local_variables(){
        let b: u8;
        let c = false;
        let d = b"hello world";
        let e: u64 = 10_000;
    }
}</code>
	module movement::local_storage {
    fun local_variables(){
        let b: u8;
        let c = false;
        let d = b"hello world";
        let e: u64 = 10_000;
    }
}
	All the variables mentioned above are created within the
local_variables
function. As a result, they only exist within the function's scope. When this function ends, all variables within it will be
dropped
.
	All the variables mentioned above are created within the
	<code>local_variables</code>
	local_variables
	function. As a result, they only exist within the function's scope. When this function ends, all variables within it will be
	<code>dropped</code>
	dropped
	.
	Additionally, we can create resources and structs as local storage through a struct ability in
move
called "drop". This ability allows the struct or resource to be dropped after the function ends, aligning with the characteristics of local variables you've read about above.
	Additionally, we can create resources and structs as local storage through a struct ability in
	<code>move</code>
	move
	called "drop". This ability allows the struct or resource to be dropped after the function ends, aligning with the characteristics of local variables you've read about above.
	For example:
	For example:
	<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer;
    struct LocalData has drop {
        value: u64
    }
    public entry fun new_local(value: u64) {
        let data = LocalData {
            value: value
        };
        let local_var = b"Local Storage Data";
        print(&data);
        print(&local_var);
    }
    #[test]
    fun test_new_local() {
        new_local(10);
    }
}</code>
	<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer;
    struct LocalData has drop {
        value: u64
    }
    public entry fun new_local(value: u64) {
        let data = LocalData {
            value: value
        };
        let local_var = b"Local Storage Data";
        print(&data);
        print(&local_var);
    }
    #[test]
    fun test_new_local() {
        new_local(10);
    }
}</code>
	module movement::local_global_storage {
    use std::debug::print;
    use std::signer;
    struct LocalData has drop {
        value: u64
    }
    public entry fun new_local(value: u64) {
        let data = LocalData {
            value: value
        };
        let local_var = b"Local Storage Data";
        print(&data);
        print(&local_var);
    }
    #[test]
    fun test_new_local() {
        new_local(10);
    }
}
	In the
new_local
function, you can see that after the
LocalData
resource is created, it's not owned by anyone and isn't transferred anywhere. This means that when the new_local function ends,
LocalData
will be dropped. For the Move compiler to allow this,
LocalData
must have the
drop
ability and must not have the
key
ability.
	In the
	<code>new_local</code>
	new_local
	function, you can see that after the
	<code>LocalData</code>
	LocalData
	resource is created, it's not owned by anyone and isn't transferred anywhere. This means that when the new_local function ends,
	<code>LocalData</code>
	LocalData
	will be dropped. For the Move compiler to allow this,
	<code>LocalData</code>
	LocalData
	must have the
	<code>drop</code>
	drop
	ability and must not have the
	<code>key</code>
	key
	ability.
		Global Storage
		Global Storage
		Global storage in Move:
		Global storage in Move:
		Global storage in Move:
		Enables persistent data storage on the blockchain
Maintains long-term data accessibility across transactions and contracts
Uses a tree-like structure for efficient organization and retrieval
Key-value pairing system for precise data management
		Enables persistent data storage on the blockchain
		Enables persistent data storage on the blockchain
		Maintains long-term data accessibility across transactions and contracts
		Maintains long-term data accessibility across transactions and contracts
		Uses a tree-like structure for efficient organization and retrieval
		Uses a tree-like structure for efficient organization and retrieval
		Key-value pairing system for precise data management
		Key-value pairing system for precise data management
		Move programs interact with global storage by:
		Move programs interact with global storage by:
		Move programs interact with global storage by:
		Reading existing data
Writing new or updated information
		Reading existing data
		Reading existing data
		Writing new or updated information
		Writing new or updated information
		Limitations:
		Limitations:
		Limitations:
		Cannot access external resources (e.g., filesystems, networks)
Ensures data manipulations occur within the blockchain's controlled environment
Maintains security and consistency across the system
		Cannot access external resources (e.g., filesystems, networks)
		Cannot access external resources (e.g., filesystems, networks)
		Ensures data manipulations occur within the blockchain's controlled environment
		Ensures data manipulations occur within the blockchain's controlled environment
		Maintains security and consistency across the system
		Maintains security and consistency across the system
		<code>struct GlobalStorage {
  resources: Map<(address, ResourceType), ResourceValue>
  modules: Map<(address, ModuleName), ModuleBytecode>
}</code>
		<code>struct GlobalStorage {
  resources: Map<(address, ResourceType), ResourceValue>
  modules: Map<(address, ModuleName), ModuleBytecode>
}</code>
		struct GlobalStorage {
  resources: Map<(address, ResourceType), ResourceValue>
  modules: Map<(address, ModuleName), ModuleBytecode>
}
		Let's examine the example below for a clearer understanding:
		Let's examine the example below for a clearer understanding:
		<code>module movement::local_global_storage {
    use std::debug::print;
    struct GlobalData has key {
        value: u64
    }
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}</code>
		<code>module movement::local_global_storage {
    use std::debug::print;
    struct GlobalData has key {
        value: u64
    }
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}</code>
		module movement::local_global_storage {
    use std::debug::print;
    struct GlobalData has key {
        value: u64
    }
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
		In the code above, after initializing
GlobalData
and storing it in a variable called data, if you stop here, the compiler will throw an error when you build. This is because
GlobalData
contains the
key
ability. Consequently, this data needs to be stored in global storage. However, to store it in global storage, you must assign this Resource an owner in the form of a Map. In this case, we'll store it under the signer who called this function. The result of the function will create a resource and transfer it to the address of the caller.
		In the code above, after initializing
		<code>GlobalData</code>
		GlobalData
		and storing it in a variable called data, if you stop here, the compiler will throw an error when you build. This is because
		<code>GlobalData</code>
		GlobalData
		contains the
		<code>key</code>
		key
		ability. Consequently, this data needs to be stored in global storage. However, to store it in global storage, you must assign this Resource an owner in the form of a Map. In this case, we'll store it under the signer who called this function. The result of the function will create a resource and transfer it to the address of the caller.
		Here's the
GlobalStorage
data after you initialize it using the
new_global
function:
		Here's the
		<code>GlobalStorage</code>
		GlobalStorage
		data after you initialize it using the
		<code>new_global</code>
		new_global
		function:
		<code>{
  "0x40264b8d01986e70c79999a189e4c4043aad3ec970d00a095cf29b2916eda04d::local_global_storage::GlobalData": {
    "value": "10"
  }
}</code>
		<code>{
  "0x40264b8d01986e70c79999a189e4c4043aad3ec970d00a095cf29b2916eda04d::local_global_storage::GlobalData": {
    "value": "10"
  }
}</code>
		{
  "0x40264b8d01986e70c79999a189e4c4043aad3ec970d00a095cf29b2916eda04d::local_global_storage::GlobalData": {
    "value": "10"
  }
}
		For global data, you can only access it through these native functions provided by Move:
		For global data, you can only access it through these native functions provided by Move:
		| Operation | Description | Aborts? |
| --- | --- | --- |
|
move_to<T>(&signer,T)
| Publish
T
under
signer.address
| If
signer.address
already holds a
T
|
|
move_from<T>(address): T
| Remove
T
from
address
and return it | If
address
does not hold a
T
|
|
borrow_global_mut<T>(address): &mut T
| Return a mutable reference to the
T
stored under
address
| If
address
does not hold a
T
|
|
borrow_global<T>(address): &T
| Return an immutable reference to the
T
stored under
address
| If
address
does not hold a
T
|
|
exists<T>(address): bool
| Return
true
if a
T
is stored under
address
| Never |
		| Operation | Description | Aborts? |
| --- | --- | --- |
|
		<code>move_to<T>(&signer,T)</code>
		move_to<T>(&signer,T)
		| Publish
		<code>T</code>
		T
		under
		<code>signer.address</code>
		signer.address
		| If
		<code>signer.address</code>
		signer.address
		already holds a
		<code>T</code>
		T
		|
|
		<code>move_from<T>(address): T</code>
		move_from<T>(address): T
		| Remove
		<code>T</code>
		T
		from
		<code>address</code>
		address
		and return it | If
		<code>address</code>
		address
		does not hold a
		<code>T</code>
		T
		|
|
		<code>borrow_global_mut<T>(address): &mut T</code>
		borrow_global_mut<T>(address): &mut T
		| Return a mutable reference to the
		<code>T</code>
		T
		stored under
		<code>address</code>
		address
		| If
		<code>address</code>
		address
		does not hold a
		<code>T</code>
		T
		|
|
		<code>borrow_global<T>(address): &T</code>
		borrow_global<T>(address): &T
		| Return an immutable reference to the
		<code>T</code>
		T
		stored under
		<code>address</code>
		address
		| If
		<code>address</code>
		address
		does not hold a
		<code>T</code>
		T
		|
|
		<code>exists<T>(address): bool</code>
		exists<T>(address): bool
		| Return
		<code>true</code>
		true
		if a
		<code>T</code>
		T
		is stored under
		<code>address</code>
		address
		| Never |
		Example Code:
		Example Code:
		<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}</code>
		<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}</code>
		module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
		Delete Resource
		Delete Resource
		The
move_from
function is a crucial part of resource management in Move. It allows for the removal of a resource from an account or address. However, there's an important caveat: the resource must have the "drop" ability to be used with
move_from
. This requirement serves as a safety mechanism, preventing accidental or unauthorized deletion of resources.
		The
		<code>move_from</code>
		move_from
		function is a crucial part of resource management in Move. It allows for the removal of a resource from an account or address. However, there's an important caveat: the resource must have the "drop" ability to be used with
		<code>move_from</code>
		move_from
		. This requirement serves as a safety mechanism, preventing accidental or unauthorized deletion of resources.
		Key points to understand:
		Key points to understand:
		Resources without the "drop" ability cannot be removed, ensuring their permanence.
This feature gives developers fine-grained control over resource lifecycle management.
It's particularly useful for creating persistent resources that should remain intact throughout a contract's lifetime.
		Resources without the "drop" ability cannot be removed, ensuring their permanence.
		Resources without the "drop" ability cannot be removed, ensuring their permanence.
		This feature gives developers fine-grained control over resource lifecycle management.
		This feature gives developers fine-grained control over resource lifecycle management.
		It's particularly useful for creating persistent resources that should remain intact throughout a contract's lifetime.
		It's particularly useful for creating persistent resources that should remain intact throughout a contract's lifetime.
		By implementing this safeguard, Move enhances the security and predictability of smart contracts, allowing developers to design more robust and controlled resource management systems.
		By implementing this safeguard, Move enhances the security and predictability of smart contracts, allowing developers to design more robust and controlled resource management systems.
		Drop Ability
		Drop Ability
		Drop Ability
		<code>struct GlobalData has key, drop {
    value: u64
}</code>
		<code>struct GlobalData has key, drop {
    value: u64
}</code>
		struct GlobalData has key, drop {
    value: u64
}
		move_from
		move_from
		move_from
		<code>public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}</code>
		<code>public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}</code>
		public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}
		Full Code
		Full Code
		<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}</code>
		<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}</code>
		module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
		Running test:
		Running test:
		Running test:
		<code>movement move test -f local_global_storage</code>
		<code>movement move test -f local_global_storage</code>
		movement move test -f local_global_storage
		Result:
		Result:
		Result:
		<code>Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}</code>
		<code>Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}</code>
		Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
	Understanding the 'acquires' Keyword in Move
	Understanding the 'acquires' Keyword in Move
	The 'acquires' keyword in Move is an important concept related to global storage operations. Here's what you need to know about it:
	The 'acquires' keyword in Move is an important concept related to global storage operations. Here's what you need to know about it:
		Purpose of 'acquires'
		Purpose of 'acquires'
		The 'acquires' keyword is used to declare that a function may access (or "acquire") a specific resource from global storage. It's a way of explicitly stating which global resources a function intends to use.
		The 'acquires' keyword is used to declare that a function may access (or "acquire") a specific resource from global storage. It's a way of explicitly stating which global resources a function intends to use.
		How it Works
		How it Works
		Declaration: When you define a function that needs to access a global resource, you add 'acquires' followed by the resource type after the function signature.
Compiler Check: The Move compiler uses this information to ensure that the function only accesses the declared resources, preventing unintended access to other global resources.
Safety: It helps in preventing race conditions and ensures safe concurrent execution of transactions.
		Declaration: When you define a function that needs to access a global resource, you add 'acquires' followed by the resource type after the function signature.
		Declaration: When you define a function that needs to access a global resource, you add 'acquires' followed by the resource type after the function signature.
		Compiler Check: The Move compiler uses this information to ensure that the function only accesses the declared resources, preventing unintended access to other global resources.
		Compiler Check: The Move compiler uses this information to ensure that the function only accesses the declared resources, preventing unintended access to other global resources.
		Safety: It helps in preventing race conditions and ensures safe concurrent execution of transactions.
		Safety: It helps in preventing race conditions and ensures safe concurrent execution of transactions.
		Example Usage
		Example Usage
		<code>public fun read_global_data(addr: address): u64 acquires GlobalData {
    borrow_global<GlobalData>(addr).value
}</code>
		<code>public fun read_global_data(addr: address): u64 acquires GlobalData {
    borrow_global<GlobalData>(addr).value
}</code>
		public fun read_global_data(addr: address): u64 acquires GlobalData {
    borrow_global<GlobalData>(addr).value
}
		In this example, the function declares that it will acquire the 'GlobalData' resource from global storage.
		In this example, the function declares that it will acquire the 'GlobalData' resource from global storage.
		Important Notes
		Important Notes
		Multiple Resources: A function can acquire multiple resources by listing them after 'acquires', separated by commas.
Nested Calls: If a function calls another function that acquires a resource, the calling function must also declare that it acquires that resource.
Compiler Enforcement: The Move compiler will throw an error if a function tries to access a global resource without declaring it with 'acquires'.
		Multiple Resources: A function can acquire multiple resources by listing them after 'acquires', separated by commas.
		Multiple Resources: A function can acquire multiple resources by listing them after 'acquires', separated by commas.
		Nested Calls: If a function calls another function that acquires a resource, the calling function must also declare that it acquires that resource.
		Nested Calls: If a function calls another function that acquires a resource, the calling function must also declare that it acquires that resource.
		Compiler Enforcement: The Move compiler will throw an error if a function tries to access a global resource without declaring it with 'acquires'.
		Compiler Enforcement: The Move compiler will throw an error if a function tries to access a global resource without declaring it with 'acquires'.
		By using 'acquires', Move provides a clear and safe way to manage access to global storage, enhancing the security and predictability of smart contracts.
		By using 'acquires', Move provides a clear and safe way to manage access to global storage, enhancing the security and predictability of smart contracts.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/02-deploy-and-call-function-on-chain
Deploy & Call function on
Deploy & Call function on
On This Page
Summary
Overview
1. Setup Movement Environment
2. Initialize Project
3. Create a Move file in sources/name.move
Summary
Explores deploying modules and calling on-chain functions on the Movement testnet
Covers setup of Movement environment and project initialization
Demonstrates creating and publishing a Move smart contract
Shows how to interact with deployed modules using the Movement explorer
Focuses on understanding on-chain operations and global storage in Move
Provides step-by-step instructions for developers new to the Movement ecosystem
Overview
To better understand how on-chain operations or global storage work, we will explore together the process of deploying modules (smart contracts) on the Movement testnet, and then try calling on-chain functions through the explorer to gain a clearer understanding of them.
1. Setup Movement Environment
First, you need to set up your development environment. Follow the guide in the Movement documentation to set up the Suzuka network.
https://docs.movementnetwork.xyz/devs/getstarted
2. Initialize Project
Initialize your Aptos profile
for package development and add Movement as a custom network:
aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
❯ aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.suzuka.movementlabs.xyz/v1
Enter your faucet endpoint [Current: None | No input: Skip (or keep the existing one if present) | 'skip' to not use a faucet]
    
No faucet url given, skipping faucet...
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Aptos CLI is now set up for account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4?network=custom
 Run `aptos --help` for more information about commands
{
  "Result": "Success"
}
In the returned result, we will have the account:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
. This will be the account you'll use to execute default functions and deploy code. Alternatively, you can check these details in the
/.aptos/config.yaml
file.
---
profiles:
  default:
    network: Custom
    private_key: "0x7423d9d69830987a371836e6ea417a5a5626c119ab9c2a868e85cb890e114587"
    public_key: "0x4d2491d2c2ead56335cd960c484cf8a3ab9c4a6476fc0b9b6ef6a8dfa1e7c566"
    account: 7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
    rest_url: "https://aptos.testnet.suzuka.movementlabs.xyz/v1"
Initialize your move project
movement move init --name hello_blockchain
3. Create a Move file in sources/name.move
Initialize a .move file in the sources/ folder and copy the code from the previous topic into it:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Modify Move.toml
[package]
name = "move-101"
version = "1.0.0"
authors = []
[addresses]
# Change your address you created in step 1
movement = "0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4" 
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
Publish your module to the blockchain
movement move publish --named-addresses movement=default
If executed successfully, the result will appear as shown below:
Compiling, may take a little while to download git dependencies...
UPDATING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING move-101
package size 1945 bytes
Transaction submitted: https://explorer.aptoslabs.com/txn/0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596?network=custom
{
  "Result": {
    "transaction_hash": "0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596",
    "gas_used": 1689,
    "gas_unit_price": 100,
    "sender": "7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727447905936816,
    "version": 258811098,
    "vm_status": "Executed successfully"
  }
}
Check the transaction on the Movement testnet explorer using this link: https://explorer.movementlabs.xyz/?network=testnet
Alternatively, you can search using the account address and navigate to the "Modules" tab:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
Run and View will list the functions available in your module.
On This Page
Summary
Overview
1. Setup Movement Environment
2. Initialize Project
3. Create a Move file in sources/name.move
On This Page
Summary
Overview
1. Setup Movement Environment
2. Initialize Project
3. Create a Move file in sources/name.move
			On This Page
			On This Page
			Summary
Overview
1. Setup Movement Environment
2. Initialize Project
3. Create a Move file in sources/name.move
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			1. Setup Movement Environment
			1. Setup Movement Environment
			1. Setup Movement Environment
			1. Setup Movement Environment
			2. Initialize Project
			2. Initialize Project
			2. Initialize Project
			2. Initialize Project
			3. Create a Move file in sources/name.move
			3. Create a Move file in sources/name.move
			3. Create a Move file in sources/name.move
			3. Create a Move file in sources/name.move
			Summary
Explores deploying modules and calling on-chain functions on the Movement testnet
Covers setup of Movement environment and project initialization
Demonstrates creating and publishing a Move smart contract
Shows how to interact with deployed modules using the Movement explorer
Focuses on understanding on-chain operations and global storage in Move
Provides step-by-step instructions for developers new to the Movement ecosystem
Overview
To better understand how on-chain operations or global storage work, we will explore together the process of deploying modules (smart contracts) on the Movement testnet, and then try calling on-chain functions through the explorer to gain a clearer understanding of them.
1. Setup Movement Environment
First, you need to set up your development environment. Follow the guide in the Movement documentation to set up the Suzuka network.
https://docs.movementnetwork.xyz/devs/getstarted
2. Initialize Project
Initialize your Aptos profile
for package development and add Movement as a custom network:
aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
❯ aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.suzuka.movementlabs.xyz/v1
Enter your faucet endpoint [Current: None | No input: Skip (or keep the existing one if present) | 'skip' to not use a faucet]
    
No faucet url given, skipping faucet...
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Aptos CLI is now set up for account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4?network=custom
 Run `aptos --help` for more information about commands
{
  "Result": "Success"
}
In the returned result, we will have the account:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
. This will be the account you'll use to execute default functions and deploy code. Alternatively, you can check these details in the
/.aptos/config.yaml
file.
---
profiles:
  default:
    network: Custom
    private_key: "0x7423d9d69830987a371836e6ea417a5a5626c119ab9c2a868e85cb890e114587"
    public_key: "0x4d2491d2c2ead56335cd960c484cf8a3ab9c4a6476fc0b9b6ef6a8dfa1e7c566"
    account: 7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
    rest_url: "https://aptos.testnet.suzuka.movementlabs.xyz/v1"
Initialize your move project
movement move init --name hello_blockchain
3. Create a Move file in sources/name.move
Initialize a .move file in the sources/ folder and copy the code from the previous topic into it:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Modify Move.toml
[package]
name = "move-101"
version = "1.0.0"
authors = []
[addresses]
# Change your address you created in step 1
movement = "0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4" 
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
Publish your module to the blockchain
movement move publish --named-addresses movement=default
If executed successfully, the result will appear as shown below:
Compiling, may take a little while to download git dependencies...
UPDATING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING move-101
package size 1945 bytes
Transaction submitted: https://explorer.aptoslabs.com/txn/0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596?network=custom
{
  "Result": {
    "transaction_hash": "0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596",
    "gas_used": 1689,
    "gas_unit_price": 100,
    "sender": "7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727447905936816,
    "version": 258811098,
    "vm_status": "Executed successfully"
  }
}
Check the transaction on the Movement testnet explorer using this link: https://explorer.movementlabs.xyz/?network=testnet
Alternatively, you can search using the account address and navigate to the "Modules" tab:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
Run and View will list the functions available in your module.
			Summary
Explores deploying modules and calling on-chain functions on the Movement testnet
Covers setup of Movement environment and project initialization
Demonstrates creating and publishing a Move smart contract
Shows how to interact with deployed modules using the Movement explorer
Focuses on understanding on-chain operations and global storage in Move
Provides step-by-step instructions for developers new to the Movement ecosystem
Overview
To better understand how on-chain operations or global storage work, we will explore together the process of deploying modules (smart contracts) on the Movement testnet, and then try calling on-chain functions through the explorer to gain a clearer understanding of them.
1. Setup Movement Environment
First, you need to set up your development environment. Follow the guide in the Movement documentation to set up the Suzuka network.
https://docs.movementnetwork.xyz/devs/getstarted
2. Initialize Project
Initialize your Aptos profile
for package development and add Movement as a custom network:
aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
❯ aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.suzuka.movementlabs.xyz/v1
Enter your faucet endpoint [Current: None | No input: Skip (or keep the existing one if present) | 'skip' to not use a faucet]
    
No faucet url given, skipping faucet...
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Aptos CLI is now set up for account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4?network=custom
 Run `aptos --help` for more information about commands
{
  "Result": "Success"
}
In the returned result, we will have the account:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
. This will be the account you'll use to execute default functions and deploy code. Alternatively, you can check these details in the
/.aptos/config.yaml
file.
---
profiles:
  default:
    network: Custom
    private_key: "0x7423d9d69830987a371836e6ea417a5a5626c119ab9c2a868e85cb890e114587"
    public_key: "0x4d2491d2c2ead56335cd960c484cf8a3ab9c4a6476fc0b9b6ef6a8dfa1e7c566"
    account: 7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
    rest_url: "https://aptos.testnet.suzuka.movementlabs.xyz/v1"
Initialize your move project
movement move init --name hello_blockchain
3. Create a Move file in sources/name.move
Initialize a .move file in the sources/ folder and copy the code from the previous topic into it:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Modify Move.toml
[package]
name = "move-101"
version = "1.0.0"
authors = []
[addresses]
# Change your address you created in step 1
movement = "0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4" 
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
Publish your module to the blockchain
movement move publish --named-addresses movement=default
If executed successfully, the result will appear as shown below:
Compiling, may take a little while to download git dependencies...
UPDATING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING move-101
package size 1945 bytes
Transaction submitted: https://explorer.aptoslabs.com/txn/0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596?network=custom
{
  "Result": {
    "transaction_hash": "0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596",
    "gas_used": 1689,
    "gas_unit_price": 100,
    "sender": "7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727447905936816,
    "version": 258811098,
    "vm_status": "Executed successfully"
  }
}
Check the transaction on the Movement testnet explorer using this link: https://explorer.movementlabs.xyz/?network=testnet
Alternatively, you can search using the account address and navigate to the "Modules" tab:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
Run and View will list the functions available in your module.
			Summary
Explores deploying modules and calling on-chain functions on the Movement testnet
Covers setup of Movement environment and project initialization
Demonstrates creating and publishing a Move smart contract
Shows how to interact with deployed modules using the Movement explorer
Focuses on understanding on-chain operations and global storage in Move
Provides step-by-step instructions for developers new to the Movement ecosystem
Overview
To better understand how on-chain operations or global storage work, we will explore together the process of deploying modules (smart contracts) on the Movement testnet, and then try calling on-chain functions through the explorer to gain a clearer understanding of them.
1. Setup Movement Environment
First, you need to set up your development environment. Follow the guide in the Movement documentation to set up the Suzuka network.
https://docs.movementnetwork.xyz/devs/getstarted
2. Initialize Project
Initialize your Aptos profile
for package development and add Movement as a custom network:
aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
❯ aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.suzuka.movementlabs.xyz/v1
Enter your faucet endpoint [Current: None | No input: Skip (or keep the existing one if present) | 'skip' to not use a faucet]
    
No faucet url given, skipping faucet...
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Aptos CLI is now set up for account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4?network=custom
 Run `aptos --help` for more information about commands
{
  "Result": "Success"
}
In the returned result, we will have the account:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
. This will be the account you'll use to execute default functions and deploy code. Alternatively, you can check these details in the
/.aptos/config.yaml
file.
---
profiles:
  default:
    network: Custom
    private_key: "0x7423d9d69830987a371836e6ea417a5a5626c119ab9c2a868e85cb890e114587"
    public_key: "0x4d2491d2c2ead56335cd960c484cf8a3ab9c4a6476fc0b9b6ef6a8dfa1e7c566"
    account: 7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
    rest_url: "https://aptos.testnet.suzuka.movementlabs.xyz/v1"
Initialize your move project
movement move init --name hello_blockchain
3. Create a Move file in sources/name.move
Initialize a .move file in the sources/ folder and copy the code from the previous topic into it:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Modify Move.toml
[package]
name = "move-101"
version = "1.0.0"
authors = []
[addresses]
# Change your address you created in step 1
movement = "0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4" 
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
Publish your module to the blockchain
movement move publish --named-addresses movement=default
If executed successfully, the result will appear as shown below:
Compiling, may take a little while to download git dependencies...
UPDATING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING move-101
package size 1945 bytes
Transaction submitted: https://explorer.aptoslabs.com/txn/0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596?network=custom
{
  "Result": {
    "transaction_hash": "0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596",
    "gas_used": 1689,
    "gas_unit_price": 100,
    "sender": "7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727447905936816,
    "version": 258811098,
    "vm_status": "Executed successfully"
  }
}
Check the transaction on the Movement testnet explorer using this link: https://explorer.movementlabs.xyz/?network=testnet
Alternatively, you can search using the account address and navigate to the "Modules" tab:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
Run and View will list the functions available in your module.
	Summary
	Summary
	Explores deploying modules and calling on-chain functions on the Movement testnet
Covers setup of Movement environment and project initialization
Demonstrates creating and publishing a Move smart contract
Shows how to interact with deployed modules using the Movement explorer
Focuses on understanding on-chain operations and global storage in Move
Provides step-by-step instructions for developers new to the Movement ecosystem
	Explores deploying modules and calling on-chain functions on the Movement testnet
	Explores deploying modules and calling on-chain functions on the Movement testnet
	Covers setup of Movement environment and project initialization
	Covers setup of Movement environment and project initialization
	Demonstrates creating and publishing a Move smart contract
	Demonstrates creating and publishing a Move smart contract
	Shows how to interact with deployed modules using the Movement explorer
	Shows how to interact with deployed modules using the Movement explorer
	Focuses on understanding on-chain operations and global storage in Move
	Focuses on understanding on-chain operations and global storage in Move
	Provides step-by-step instructions for developers new to the Movement ecosystem
	Provides step-by-step instructions for developers new to the Movement ecosystem
	Overview
	Overview
	To better understand how on-chain operations or global storage work, we will explore together the process of deploying modules (smart contracts) on the Movement testnet, and then try calling on-chain functions through the explorer to gain a clearer understanding of them.
	To better understand how on-chain operations or global storage work, we will explore together the process of deploying modules (smart contracts) on the Movement testnet, and then try calling on-chain functions through the explorer to gain a clearer understanding of them.
	1. Setup Movement Environment
	1. Setup Movement Environment
	First, you need to set up your development environment. Follow the guide in the Movement documentation to set up the Suzuka network.
	First, you need to set up your development environment. Follow the guide in the Movement documentation to set up the Suzuka network.
	https://docs.movementnetwork.xyz/devs/getstarted
	https://docs.movementnetwork.xyz/devs/getstarted
	2. Initialize Project
	2. Initialize Project
	Initialize your Aptos profile
for package development and add Movement as a custom network:
	Initialize your Aptos profile
for package development and add Movement as a custom network:
	Initialize your Aptos profile
	Initialize your Aptos profile
	for package development and add Movement as a custom network:
	<code>aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1</code>
	<code>aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1</code>
	aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
	<code>❯ aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.suzuka.movementlabs.xyz/v1
Enter your faucet endpoint [Current: None | No input: Skip (or keep the existing one if present) | 'skip' to not use a faucet]
    
No faucet url given, skipping faucet...
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Aptos CLI is now set up for account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4?network=custom
 Run `aptos --help` for more information about commands
{
  "Result": "Success"
}</code>
	<code>❯ aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.suzuka.movementlabs.xyz/v1
Enter your faucet endpoint [Current: None | No input: Skip (or keep the existing one if present) | 'skip' to not use a faucet]
    
No faucet url given, skipping faucet...
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Aptos CLI is now set up for account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4?network=custom
 Run `aptos --help` for more information about commands
{
  "Result": "Success"
}</code>
	❯ aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.suzuka.movementlabs.xyz/v1
Enter your faucet endpoint [Current: None | No input: Skip (or keep the existing one if present) | 'skip' to not use a faucet]
    
No faucet url given, skipping faucet...
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]
No key given, generating key...
Account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 has been initialized locally, but you must transfer coins to it to create the account onchain
---
Aptos CLI is now set up for account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 as profile default!
 See the account here: https://explorer.aptoslabs.com/account/0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4?network=custom
 Run `aptos --help` for more information about commands
{
  "Result": "Success"
}
	In the returned result, we will have the account:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
. This will be the account you'll use to execute default functions and deploy code. Alternatively, you can check these details in the
/.aptos/config.yaml
file.
	In the returned result, we will have the account:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
. This will be the account you'll use to execute default functions and deploy code. Alternatively, you can check these details in the
/.aptos/config.yaml
file.
	In the returned result, we will have the account:
	<code>0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4</code>
	0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
	. This will be the account you'll use to execute default functions and deploy code. Alternatively, you can check these details in the
	<code>/.aptos/config.yaml</code>
	/.aptos/config.yaml
	file.
	<code>---
profiles:
  default:
    network: Custom
    private_key: "0x7423d9d69830987a371836e6ea417a5a5626c119ab9c2a868e85cb890e114587"
    public_key: "0x4d2491d2c2ead56335cd960c484cf8a3ab9c4a6476fc0b9b6ef6a8dfa1e7c566"
    account: 7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
    rest_url: "https://aptos.testnet.suzuka.movementlabs.xyz/v1"</code>
	<code>---
profiles:
  default:
    network: Custom
    private_key: "0x7423d9d69830987a371836e6ea417a5a5626c119ab9c2a868e85cb890e114587"
    public_key: "0x4d2491d2c2ead56335cd960c484cf8a3ab9c4a6476fc0b9b6ef6a8dfa1e7c566"
    account: 7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
    rest_url: "https://aptos.testnet.suzuka.movementlabs.xyz/v1"</code>
	---
profiles:
  default:
    network: Custom
    private_key: "0x7423d9d69830987a371836e6ea417a5a5626c119ab9c2a868e85cb890e114587"
    public_key: "0x4d2491d2c2ead56335cd960c484cf8a3ab9c4a6476fc0b9b6ef6a8dfa1e7c566"
    account: 7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
    rest_url: "https://aptos.testnet.suzuka.movementlabs.xyz/v1"
	Initialize your move project
	Initialize your move project
	Initialize your move project
	<code>movement move init --name hello_blockchain</code>
	<code>movement move init --name hello_blockchain</code>
	movement move init --name hello_blockchain
	3. Create a Move file in sources/name.move
	3. Create a Move file in sources/name.move
	Initialize a .move file in the sources/ folder and copy the code from the previous topic into it:
	Initialize a .move file in the sources/ folder and copy the code from the previous topic into it:
	<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}</code>
	<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}</code>
	module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
	Modify Move.toml
	Modify Move.toml
	Modify Move.toml
	<code>[package]
name = "move-101"
version = "1.0.0"
authors = []
[addresses]
# Change your address you created in step 1
movement = "0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4" 
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]</code>
	<code>[package]
name = "move-101"
version = "1.0.0"
authors = []
[addresses]
# Change your address you created in step 1
movement = "0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4" 
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]</code>
	[package]
name = "move-101"
version = "1.0.0"
authors = []
[addresses]
# Change your address you created in step 1
movement = "0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4" 
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
	Publish your module to the blockchain
	Publish your module to the blockchain
	Publish your module to the blockchain
	<code>movement move publish --named-addresses movement=default</code>
	<code>movement move publish --named-addresses movement=default</code>
	movement move publish --named-addresses movement=default
	If executed successfully, the result will appear as shown below:
	If executed successfully, the result will appear as shown below:
	If executed successfully, the result will appear as shown below:
	<code>Compiling, may take a little while to download git dependencies...
UPDATING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING move-101
package size 1945 bytes
Transaction submitted: https://explorer.aptoslabs.com/txn/0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596?network=custom
{
  "Result": {
    "transaction_hash": "0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596",
    "gas_used": 1689,
    "gas_unit_price": 100,
    "sender": "7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727447905936816,
    "version": 258811098,
    "vm_status": "Executed successfully"
  }
}</code>
	<code>Compiling, may take a little while to download git dependencies...
UPDATING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING move-101
package size 1945 bytes
Transaction submitted: https://explorer.aptoslabs.com/txn/0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596?network=custom
{
  "Result": {
    "transaction_hash": "0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596",
    "gas_used": 1689,
    "gas_unit_price": 100,
    "sender": "7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727447905936816,
    "version": 258811098,
    "vm_status": "Executed successfully"
  }
}</code>
	Compiling, may take a little while to download git dependencies...
UPDATING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING move-101
package size 1945 bytes
Transaction submitted: https://explorer.aptoslabs.com/txn/0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596?network=custom
{
  "Result": {
    "transaction_hash": "0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596",
    "gas_used": 1689,
    "gas_unit_price": 100,
    "sender": "7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1727447905936816,
    "version": 258811098,
    "vm_status": "Executed successfully"
  }
}
	Check the transaction on the Movement testnet explorer using this link: https://explorer.movementlabs.xyz/?network=testnet
Alternatively, you can search using the account address and navigate to the "Modules" tab:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
Run and View will list the functions available in your module.
	Check the transaction on the Movement testnet explorer using this link: https://explorer.movementlabs.xyz/?network=testnet
	Check the transaction on the Movement testnet explorer using this link: https://explorer.movementlabs.xyz/?network=testnet
	Check the transaction on the Movement testnet explorer using this link: https://explorer.movementlabs.xyz/?network=testnet
	Alternatively, you can search using the account address and navigate to the "Modules" tab:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
	Alternatively, you can search using the account address and navigate to the "Modules" tab:
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
	Alternatively, you can search using the account address and navigate to the "Modules" tab:
	<code>0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4</code>
	0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
	Run and View will list the functions available in your module.
	Run and View will list the functions available in your module.
	Run and View will list the functions available in your module.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/03-writing-reading-resources-to-user-accounts
Writing Reading resources to user accounts
Writing Reading resources to user accounts
On This Page
Summary
Writing/Reading resources
1. Struct Definition
2. Error Constant
3. Function to Create Global Storage
4. Function to Modify Global Storage
5. Function to Check Global Storage Existence
6. Function to Read from Global Storage
Using Global Storage in Move
Summary
Key points about global storage in Move:
Global storage allows persistent data storage associated with addresses
Resources stored in global storage must have the 'key' ability
Use 'move_to' to store data and 'borrow_global' to access it
Always check if a resource exists before attempting to access it
Mutable access requires
borrow_global_mut
and proper access control
The 'acquires' keyword is necessary for functions that access global storage
Writing/Reading resources
Based on the previous topic, we've learned how to create a resource and store it in global storage. Now, let's explore how to access and interact with data in global storage.
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Running test:
movement move test -f test_new_global
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Let's break down the code and explain it step by step:
1. Struct Definition
struct GlobalData has key {
        value: u64
}
Here, we define a struct called
GlobalData
with the
key
ability, allowing it to be stored in global storage. It contains a single field
value
of type
u64
.
2. Error Constant
const EResourceNotExist: u64 = 33;
This defines an error code that will be used when a resource doesn't exist in global storage.
3. Function to Create Global Storage
public entry fun new_global(signer: &signer, value: u64) {
    let data = GlobalData {
        value: value
    } ;
    move_to(signer, data);
}
This function creates a new
GlobalData
instance and moves it to the signer's address in global storage.
4. Function to Modify Global Storage
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut&lt;GlobalData&gt;(addr).value;
    *value_reference = *value_reference + value;
}
This function modifies the value in global storage. It first checks if the resource exists, then borrows a mutable reference to update the value.
5. Function to Check Global Storage Existence
public fun check_global_storage_exists(addr: address): bool {
    exists&lt;GlobalData&gt;(addr)
}
This function checks if
GlobalData
exists at a given address.
6. Function to Read from Global Storage
#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = borrow_global&lt;GlobalData&gt;(addr);
    value_reference.value
}
This function reads the value from global storage. It first checks if the resource exists, then borrows an immutable reference to read the value.
Using Global Storage in Move
Create a new global storage entry:
Use the
new_global
function, providing a signer and an initial value.
This stores the data under the signer's address.
Check if global storage exists:
Use the
check_global_storage_exists
function, passing an address.
This returns a boolean indicating whether the data exists.
Modify data in global storage:
Use the
change_value_from_global_storage
function.
This function adds the provided value to the existing value in storage.
Read data from global storage:
Use the
get_value_from_global_storage
function, passing an address.
This returns the current value stored at that address.
By following these steps, you can effectively work with global storage in Move, ensuring proper data management and access across your smart contract.
On This Page
Summary
Writing/Reading resources
1. Struct Definition
2. Error Constant
3. Function to Create Global Storage
4. Function to Modify Global Storage
5. Function to Check Global Storage Existence
6. Function to Read from Global Storage
Using Global Storage in Move
On This Page
Summary
Writing/Reading resources
1. Struct Definition
2. Error Constant
3. Function to Create Global Storage
4. Function to Modify Global Storage
5. Function to Check Global Storage Existence
6. Function to Read from Global Storage
Using Global Storage in Move
			On This Page
			On This Page
			Summary
Writing/Reading resources
1. Struct Definition
2. Error Constant
3. Function to Create Global Storage
4. Function to Modify Global Storage
5. Function to Check Global Storage Existence
6. Function to Read from Global Storage
Using Global Storage in Move
			Summary
			Summary
			Summary
			Summary
			Writing/Reading resources
1. Struct Definition
2. Error Constant
3. Function to Create Global Storage
4. Function to Modify Global Storage
5. Function to Check Global Storage Existence
6. Function to Read from Global Storage
Using Global Storage in Move
			Writing/Reading resources
			Writing/Reading resources
			Writing/Reading resources
			1. Struct Definition
2. Error Constant
3. Function to Create Global Storage
4. Function to Modify Global Storage
5. Function to Check Global Storage Existence
6. Function to Read from Global Storage
Using Global Storage in Move
			1. Struct Definition
			1. Struct Definition
			1. Struct Definition
			1. Struct Definition
			2. Error Constant
			2. Error Constant
			2. Error Constant
			2. Error Constant
			3. Function to Create Global Storage
			3. Function to Create Global Storage
			3. Function to Create Global Storage
			3. Function to Create Global Storage
			4. Function to Modify Global Storage
			4. Function to Modify Global Storage
			4. Function to Modify Global Storage
			4. Function to Modify Global Storage
			5. Function to Check Global Storage Existence
			5. Function to Check Global Storage Existence
			5. Function to Check Global Storage Existence
			5. Function to Check Global Storage Existence
			6. Function to Read from Global Storage
			6. Function to Read from Global Storage
			6. Function to Read from Global Storage
			6. Function to Read from Global Storage
			Using Global Storage in Move
			Using Global Storage in Move
			Using Global Storage in Move
			Using Global Storage in Move
			Summary
Key points about global storage in Move:
Global storage allows persistent data storage associated with addresses
Resources stored in global storage must have the 'key' ability
Use 'move_to' to store data and 'borrow_global' to access it
Always check if a resource exists before attempting to access it
Mutable access requires
borrow_global_mut
and proper access control
The 'acquires' keyword is necessary for functions that access global storage
Writing/Reading resources
Based on the previous topic, we've learned how to create a resource and store it in global storage. Now, let's explore how to access and interact with data in global storage.
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Running test:
movement move test -f test_new_global
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Let's break down the code and explain it step by step:
1. Struct Definition
struct GlobalData has key {
        value: u64
}
Here, we define a struct called
GlobalData
with the
key
ability, allowing it to be stored in global storage. It contains a single field
value
of type
u64
.
2. Error Constant
const EResourceNotExist: u64 = 33;
This defines an error code that will be used when a resource doesn't exist in global storage.
3. Function to Create Global Storage
public entry fun new_global(signer: &signer, value: u64) {
    let data = GlobalData {
        value: value
    } ;
    move_to(signer, data);
}
This function creates a new
GlobalData
instance and moves it to the signer's address in global storage.
4. Function to Modify Global Storage
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut&lt;GlobalData&gt;(addr).value;
    *value_reference = *value_reference + value;
}
This function modifies the value in global storage. It first checks if the resource exists, then borrows a mutable reference to update the value.
5. Function to Check Global Storage Existence
public fun check_global_storage_exists(addr: address): bool {
    exists&lt;GlobalData&gt;(addr)
}
This function checks if
GlobalData
exists at a given address.
6. Function to Read from Global Storage
#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = borrow_global&lt;GlobalData&gt;(addr);
    value_reference.value
}
This function reads the value from global storage. It first checks if the resource exists, then borrows an immutable reference to read the value.
Using Global Storage in Move
Create a new global storage entry:
Use the
new_global
function, providing a signer and an initial value.
This stores the data under the signer's address.
Check if global storage exists:
Use the
check_global_storage_exists
function, passing an address.
This returns a boolean indicating whether the data exists.
Modify data in global storage:
Use the
change_value_from_global_storage
function.
This function adds the provided value to the existing value in storage.
Read data from global storage:
Use the
get_value_from_global_storage
function, passing an address.
This returns the current value stored at that address.
By following these steps, you can effectively work with global storage in Move, ensuring proper data management and access across your smart contract.
			Summary
Key points about global storage in Move:
Global storage allows persistent data storage associated with addresses
Resources stored in global storage must have the 'key' ability
Use 'move_to' to store data and 'borrow_global' to access it
Always check if a resource exists before attempting to access it
Mutable access requires
borrow_global_mut
and proper access control
The 'acquires' keyword is necessary for functions that access global storage
Writing/Reading resources
Based on the previous topic, we've learned how to create a resource and store it in global storage. Now, let's explore how to access and interact with data in global storage.
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Running test:
movement move test -f test_new_global
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Let's break down the code and explain it step by step:
1. Struct Definition
struct GlobalData has key {
        value: u64
}
Here, we define a struct called
GlobalData
with the
key
ability, allowing it to be stored in global storage. It contains a single field
value
of type
u64
.
2. Error Constant
const EResourceNotExist: u64 = 33;
This defines an error code that will be used when a resource doesn't exist in global storage.
3. Function to Create Global Storage
public entry fun new_global(signer: &signer, value: u64) {
    let data = GlobalData {
        value: value
    } ;
    move_to(signer, data);
}
This function creates a new
GlobalData
instance and moves it to the signer's address in global storage.
4. Function to Modify Global Storage
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut&lt;GlobalData&gt;(addr).value;
    *value_reference = *value_reference + value;
}
This function modifies the value in global storage. It first checks if the resource exists, then borrows a mutable reference to update the value.
5. Function to Check Global Storage Existence
public fun check_global_storage_exists(addr: address): bool {
    exists&lt;GlobalData&gt;(addr)
}
This function checks if
GlobalData
exists at a given address.
6. Function to Read from Global Storage
#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = borrow_global&lt;GlobalData&gt;(addr);
    value_reference.value
}
This function reads the value from global storage. It first checks if the resource exists, then borrows an immutable reference to read the value.
Using Global Storage in Move
Create a new global storage entry:
Use the
new_global
function, providing a signer and an initial value.
This stores the data under the signer's address.
Check if global storage exists:
Use the
check_global_storage_exists
function, passing an address.
This returns a boolean indicating whether the data exists.
Modify data in global storage:
Use the
change_value_from_global_storage
function.
This function adds the provided value to the existing value in storage.
Read data from global storage:
Use the
get_value_from_global_storage
function, passing an address.
This returns the current value stored at that address.
By following these steps, you can effectively work with global storage in Move, ensuring proper data management and access across your smart contract.
			Summary
Key points about global storage in Move:
Global storage allows persistent data storage associated with addresses
Resources stored in global storage must have the 'key' ability
Use 'move_to' to store data and 'borrow_global' to access it
Always check if a resource exists before attempting to access it
Mutable access requires
borrow_global_mut
and proper access control
The 'acquires' keyword is necessary for functions that access global storage
Writing/Reading resources
Based on the previous topic, we've learned how to create a resource and store it in global storage. Now, let's explore how to access and interact with data in global storage.
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
Running test:
movement move test -f test_new_global
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
Let's break down the code and explain it step by step:
1. Struct Definition
struct GlobalData has key {
        value: u64
}
Here, we define a struct called
GlobalData
with the
key
ability, allowing it to be stored in global storage. It contains a single field
value
of type
u64
.
2. Error Constant
const EResourceNotExist: u64 = 33;
This defines an error code that will be used when a resource doesn't exist in global storage.
3. Function to Create Global Storage
public entry fun new_global(signer: &signer, value: u64) {
    let data = GlobalData {
        value: value
    } ;
    move_to(signer, data);
}
This function creates a new
GlobalData
instance and moves it to the signer's address in global storage.
4. Function to Modify Global Storage
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut&lt;GlobalData&gt;(addr).value;
    *value_reference = *value_reference + value;
}
This function modifies the value in global storage. It first checks if the resource exists, then borrows a mutable reference to update the value.
5. Function to Check Global Storage Existence
public fun check_global_storage_exists(addr: address): bool {
    exists&lt;GlobalData&gt;(addr)
}
This function checks if
GlobalData
exists at a given address.
6. Function to Read from Global Storage
#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = borrow_global&lt;GlobalData&gt;(addr);
    value_reference.value
}
This function reads the value from global storage. It first checks if the resource exists, then borrows an immutable reference to read the value.
Using Global Storage in Move
Create a new global storage entry:
Use the
new_global
function, providing a signer and an initial value.
This stores the data under the signer's address.
Check if global storage exists:
Use the
check_global_storage_exists
function, passing an address.
This returns a boolean indicating whether the data exists.
Modify data in global storage:
Use the
change_value_from_global_storage
function.
This function adds the provided value to the existing value in storage.
Read data from global storage:
Use the
get_value_from_global_storage
function, passing an address.
This returns the current value stored at that address.
By following these steps, you can effectively work with global storage in Move, ensuring proper data management and access across your smart contract.
	Summary
	Summary
	Key points about global storage in Move:
	Key points about global storage in Move:
	Global storage allows persistent data storage associated with addresses
Resources stored in global storage must have the 'key' ability
Use 'move_to' to store data and 'borrow_global' to access it
Always check if a resource exists before attempting to access it
Mutable access requires
borrow_global_mut
and proper access control
The 'acquires' keyword is necessary for functions that access global storage
	Global storage allows persistent data storage associated with addresses
	Global storage allows persistent data storage associated with addresses
	Resources stored in global storage must have the 'key' ability
	Resources stored in global storage must have the 'key' ability
	Use 'move_to' to store data and 'borrow_global' to access it
	Use 'move_to' to store data and 'borrow_global' to access it
	Always check if a resource exists before attempting to access it
	Always check if a resource exists before attempting to access it
	Mutable access requires
borrow_global_mut
and proper access control
	Mutable access requires
	<code>borrow_global_mut</code>
	borrow_global_mut
	and proper access control
	The 'acquires' keyword is necessary for functions that access global storage
	The 'acquires' keyword is necessary for functions that access global storage
	Writing/Reading resources
	Writing/Reading resources
	Based on the previous topic, we've learned how to create a resource and store it in global storage. Now, let's explore how to access and interact with data in global storage.
	Based on the previous topic, we've learned how to create a resource and store it in global storage. Now, let's explore how to access and interact with data in global storage.
	<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}</code>
	<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}</code>
	module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        value_reference.value
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
}
	Running test:
	Running test:
	Running test:
	<code>movement move test -f test_new_global</code>
	<code>movement move test -f test_new_global</code>
	movement move test -f test_new_global
	Result:
	Result:
	Result:
	<code>Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	<code>Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
	Let's break down the code and explain it step by step:
	Let's break down the code and explain it step by step:
		1. Struct Definition
		1. Struct Definition
		<code>struct GlobalData has key {
        value: u64
}</code>
		<code>struct GlobalData has key {
        value: u64
}</code>
		struct GlobalData has key {
        value: u64
}
		Here, we define a struct called
GlobalData
with the
key
ability, allowing it to be stored in global storage. It contains a single field
value
of type
u64
.
		Here, we define a struct called
		<code>GlobalData</code>
		GlobalData
		with the
		<code>key</code>
		key
		ability, allowing it to be stored in global storage. It contains a single field
		<code>value</code>
		value
		of type
		<code>u64</code>
		u64
		.
		2. Error Constant
		2. Error Constant
		<code>const EResourceNotExist: u64 = 33;</code>
		<code>const EResourceNotExist: u64 = 33;</code>
		const EResourceNotExist: u64 = 33;
		This defines an error code that will be used when a resource doesn't exist in global storage.
		This defines an error code that will be used when a resource doesn't exist in global storage.
		3. Function to Create Global Storage
		3. Function to Create Global Storage
		<code>public entry fun new_global(signer: &signer, value: u64) {
    let data = GlobalData {
        value: value
    } ;
    move_to(signer, data);
}</code>
		<code>public entry fun new_global(signer: &signer, value: u64) {
    let data = GlobalData {
        value: value
    } ;
    move_to(signer, data);
}</code>
		public entry fun new_global(signer: &signer, value: u64) {
    let data = GlobalData {
        value: value
    } ;
    move_to(signer, data);
}
		This function creates a new
GlobalData
instance and moves it to the signer's address in global storage.
		This function creates a new
		<code>GlobalData</code>
		GlobalData
		instance and moves it to the signer's address in global storage.
		4. Function to Modify Global Storage
		4. Function to Modify Global Storage
		<code>public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut&lt;GlobalData&gt;(addr).value;
    *value_reference = *value_reference + value;
}</code>
		<code>public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut&lt;GlobalData&gt;(addr).value;
    *value_reference = *value_reference + value;
}</code>
		public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut&lt;GlobalData&gt;(addr).value;
    *value_reference = *value_reference + value;
}
		This function modifies the value in global storage. It first checks if the resource exists, then borrows a mutable reference to update the value.
		This function modifies the value in global storage. It first checks if the resource exists, then borrows a mutable reference to update the value.
		5. Function to Check Global Storage Existence
		5. Function to Check Global Storage Existence
		<code>public fun check_global_storage_exists(addr: address): bool {
    exists&lt;GlobalData&gt;(addr)
}</code>
		<code>public fun check_global_storage_exists(addr: address): bool {
    exists&lt;GlobalData&gt;(addr)
}</code>
		public fun check_global_storage_exists(addr: address): bool {
    exists&lt;GlobalData&gt;(addr)
}
		This function checks if
GlobalData
exists at a given address.
		This function checks if
		<code>GlobalData</code>
		GlobalData
		exists at a given address.
		6. Function to Read from Global Storage
		6. Function to Read from Global Storage
		<code>#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = borrow_global&lt;GlobalData&gt;(addr);
    value_reference.value
}</code>
		<code>#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = borrow_global&lt;GlobalData&gt;(addr);
    value_reference.value
}</code>
		#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = borrow_global&lt;GlobalData&gt;(addr);
    value_reference.value
}
		This function reads the value from global storage. It first checks if the resource exists, then borrows an immutable reference to read the value.
		This function reads the value from global storage. It first checks if the resource exists, then borrows an immutable reference to read the value.
		Using Global Storage in Move
		Using Global Storage in Move
		Create a new global storage entry:
Use the
new_global
function, providing a signer and an initial value.
This stores the data under the signer's address.
Check if global storage exists:
Use the
check_global_storage_exists
function, passing an address.
This returns a boolean indicating whether the data exists.
Modify data in global storage:
Use the
change_value_from_global_storage
function.
This function adds the provided value to the existing value in storage.
Read data from global storage:
Use the
get_value_from_global_storage
function, passing an address.
This returns the current value stored at that address.
		Create a new global storage entry:
Use the
new_global
function, providing a signer and an initial value.
This stores the data under the signer's address.
		Create a new global storage entry:
		Use the
new_global
function, providing a signer and an initial value.
This stores the data under the signer's address.
		Use the
new_global
function, providing a signer and an initial value.
		Use the
		<code>new_global</code>
		new_global
		function, providing a signer and an initial value.
		This stores the data under the signer's address.
		This stores the data under the signer's address.
		Check if global storage exists:
Use the
check_global_storage_exists
function, passing an address.
This returns a boolean indicating whether the data exists.
		Check if global storage exists:
		Use the
check_global_storage_exists
function, passing an address.
This returns a boolean indicating whether the data exists.
		Use the
check_global_storage_exists
function, passing an address.
		Use the
		<code>check_global_storage_exists</code>
		check_global_storage_exists
		function, passing an address.
		This returns a boolean indicating whether the data exists.
		This returns a boolean indicating whether the data exists.
		Modify data in global storage:
Use the
change_value_from_global_storage
function.
This function adds the provided value to the existing value in storage.
		Modify data in global storage:
		Use the
change_value_from_global_storage
function.
This function adds the provided value to the existing value in storage.
		Use the
change_value_from_global_storage
function.
		Use the
		<code>change_value_from_global_storage</code>
		change_value_from_global_storage
		function.
		This function adds the provided value to the existing value in storage.
		This function adds the provided value to the existing value in storage.
		Read data from global storage:
Use the
get_value_from_global_storage
function, passing an address.
This returns the current value stored at that address.
		Read data from global storage:
		Use the
get_value_from_global_storage
function, passing an address.
This returns the current value stored at that address.
		Use the
get_value_from_global_storage
function, passing an address.
		Use the
		<code>get_value_from_global_storage</code>
		get_value_from_global_storage
		function, passing an address.
		This returns the current value stored at that address.
		This returns the current value stored at that address.
		By following these steps, you can effectively work with global storage in Move, ensuring proper data management and access across your smart contract.
		By following these steps, you can effectively work with global storage in Move, ensuring proper data management and access across your smart contract.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/04-destroying-a-resource
Destroying a resource
Destroying a resource
On This Page
Full Code
Key Takeaways:
The
move_from
function removes a resource from an account or address.
Resources must have the "drop" ability to use
move_from
.
The "drop" ability prevents unintentional deletion of resources.
It allows control over whether resources can be deleted or should persist.
The code demonstrates how to implement and use
move_from
in a Move module.
The module includes functions for creating, modifying, and removing global storage.
Among the provided functions in the previous topics, we haven't yet discussed
move_from
. This function removes a resource from an account or address. It's crucial to note that to use
move_from
for a resource, you must ensure the resource has the "drop" ability. Without this, the compiler will throw an error. This safeguard prevents resources from being unintentionally deleted, either accidentally or in cases where you want resources to remain permanent. It allows you to control whether resources can be deleted or should persist indefinitely.
Drop Ability
struct GlobalData has key, drop {
    value: u64
}
move_from
public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}
Full Code
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
Running test:
movement move test -f local_global_storage
Result:
Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
On This Page
Full Code
On This Page
Full Code
			On This Page
			On This Page
			Full Code
			Full Code
			Full Code
			Full Code
			Full Code
			Key Takeaways:
The
move_from
function removes a resource from an account or address.
Resources must have the "drop" ability to use
move_from
.
The "drop" ability prevents unintentional deletion of resources.
It allows control over whether resources can be deleted or should persist.
The code demonstrates how to implement and use
move_from
in a Move module.
The module includes functions for creating, modifying, and removing global storage.
Among the provided functions in the previous topics, we haven't yet discussed
move_from
. This function removes a resource from an account or address. It's crucial to note that to use
move_from
for a resource, you must ensure the resource has the "drop" ability. Without this, the compiler will throw an error. This safeguard prevents resources from being unintentionally deleted, either accidentally or in cases where you want resources to remain permanent. It allows you to control whether resources can be deleted or should persist indefinitely.
Drop Ability
struct GlobalData has key, drop {
    value: u64
}
move_from
public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}
Full Code
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
Running test:
movement move test -f local_global_storage
Result:
Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
			Key Takeaways:
The
move_from
function removes a resource from an account or address.
Resources must have the "drop" ability to use
move_from
.
The "drop" ability prevents unintentional deletion of resources.
It allows control over whether resources can be deleted or should persist.
The code demonstrates how to implement and use
move_from
in a Move module.
The module includes functions for creating, modifying, and removing global storage.
Among the provided functions in the previous topics, we haven't yet discussed
move_from
. This function removes a resource from an account or address. It's crucial to note that to use
move_from
for a resource, you must ensure the resource has the "drop" ability. Without this, the compiler will throw an error. This safeguard prevents resources from being unintentionally deleted, either accidentally or in cases where you want resources to remain permanent. It allows you to control whether resources can be deleted or should persist indefinitely.
Drop Ability
struct GlobalData has key, drop {
    value: u64
}
move_from
public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}
Full Code
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
Running test:
movement move test -f local_global_storage
Result:
Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
			Key Takeaways:
The
move_from
function removes a resource from an account or address.
Resources must have the "drop" ability to use
move_from
.
The "drop" ability prevents unintentional deletion of resources.
It allows control over whether resources can be deleted or should persist.
The code demonstrates how to implement and use
move_from
in a Move module.
The module includes functions for creating, modifying, and removing global storage.
Among the provided functions in the previous topics, we haven't yet discussed
move_from
. This function removes a resource from an account or address. It's crucial to note that to use
move_from
for a resource, you must ensure the resource has the "drop" ability. Without this, the compiler will throw an error. This safeguard prevents resources from being unintentionally deleted, either accidentally or in cases where you want resources to remain permanent. It allows you to control whether resources can be deleted or should persist indefinitely.
Drop Ability
struct GlobalData has key, drop {
    value: u64
}
move_from
public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}
Full Code
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
Running test:
movement move test -f local_global_storage
Result:
Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
			Key Takeaways:
			Key Takeaways:
			Key Takeaways:
			The
move_from
function removes a resource from an account or address.
Resources must have the "drop" ability to use
move_from
.
The "drop" ability prevents unintentional deletion of resources.
It allows control over whether resources can be deleted or should persist.
The code demonstrates how to implement and use
move_from
in a Move module.
The module includes functions for creating, modifying, and removing global storage.
			The
move_from
function removes a resource from an account or address.
			The
			<code>move_from</code>
			move_from
			function removes a resource from an account or address.
			Resources must have the "drop" ability to use
move_from
.
			Resources must have the "drop" ability to use
			<code>move_from</code>
			move_from
			.
			The "drop" ability prevents unintentional deletion of resources.
			The "drop" ability prevents unintentional deletion of resources.
			It allows control over whether resources can be deleted or should persist.
			It allows control over whether resources can be deleted or should persist.
			The code demonstrates how to implement and use
move_from
in a Move module.
			The code demonstrates how to implement and use
			<code>move_from</code>
			move_from
			in a Move module.
			The module includes functions for creating, modifying, and removing global storage.
			The module includes functions for creating, modifying, and removing global storage.
			Among the provided functions in the previous topics, we haven't yet discussed
move_from
. This function removes a resource from an account or address. It's crucial to note that to use
move_from
for a resource, you must ensure the resource has the "drop" ability. Without this, the compiler will throw an error. This safeguard prevents resources from being unintentionally deleted, either accidentally or in cases where you want resources to remain permanent. It allows you to control whether resources can be deleted or should persist indefinitely.
			Among the provided functions in the previous topics, we haven't yet discussed
			<code>move_from</code>
			move_from
			. This function removes a resource from an account or address. It's crucial to note that to use
			<code>move_from</code>
			move_from
			for a resource, you must ensure the resource has the "drop" ability. Without this, the compiler will throw an error. This safeguard prevents resources from being unintentionally deleted, either accidentally or in cases where you want resources to remain permanent. It allows you to control whether resources can be deleted or should persist indefinitely.
			Drop Ability
			Drop Ability
			Drop Ability
			<code>struct GlobalData has key, drop {
    value: u64
}</code>
			<code>struct GlobalData has key, drop {
    value: u64
}</code>
			struct GlobalData has key, drop {
    value: u64
}
			move_from
			move_from
			move_from
			<code>public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}</code>
			<code>public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}</code>
			public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
    let rev = move_from<GlobalData>(address_of(account));
}
		Full Code
		Full Code
		<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}</code>
		<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}</code>
		module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
		Running test:
		Running test:
		Running test:
		<code>movement move test -f local_global_storage</code>
		<code>movement move test -f local_global_storage</code>
		movement move test -f local_global_storage
		Result:
		Result:
		Result:
		<code>Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}</code>
		<code>Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}</code>
		Running Move unit tests
[debug] 20
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_change_value_global
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_storage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/05-resource-groups
Resource Groups
Resource Groups
Summary:
Resource groups in Move allow grouping of multiple resources with different fields.
They function similarly to regular resources but offer more efficient storage.
Resources in a group are stored close together in global storage memory.
This proximity ensures quicker queries and reduced processing costs.
The code example demonstrates creating and using resource groups with multiple fields.
Resource groups are a current solution for complex resources, with
objects
feature planned for future optimization.
In real-world projects, sometimes one of your resources will have many different fields. Although in the future we may use the
objects
feature to optimize complex resources (which will be shared in upcoming topics), for now we can also create resources and group them together in a group. Below is an example:
module movement::resource_group {
    use std::string::{utf8, String};
    use std::signer::address_of;
    #[resource_group(scope = global)]
    struct MovementGroup {}
    #[resource_group_member(group = MovementGroup)]
    struct Group1 has key {
        field1: u64,
        field2: String,
        field3: address,
        field4: bool
    }
    #[resource_group_member(group = MovementGroup)]
    struct Group2 has key {
        field5: u64,
        field6: String,
        field7: address,
        field8: bool
    }
    public entry fun create_group_resource(account: &signer) {
        let addr = address_of(account);
        let group1 = Group1 {
            field1: 100,
            field2: utf8(b"hello"),
            field3: addr,
            field4: true
        };
        move_to(account, group1);
        let group2 = Group2 {
            field5: 200,
            field6: utf8(b"hello 2"),
            field7: addr,
            field8: false
        };
        move_to(account, group2);
    }
    #[view]
    public fun get_gresource_one(addr: address): u64 acquires Group1 {
        borrow_global<Group1>(addr).field1
    }
    #[view]
    public fun get_gresource_two(addr: address): u64 acquires Group2 {
        borrow_global<Group2>(addr).field5
    }
    #[test(account = @0x1)]
    fun test_create_group(account: &signer){
        create_group_resource(account);
    }
}
Running test:
movement move test -f test_create_group
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::resource_group::test_create_group
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
In terms of functionality and usage, Resource groups are not different from regular resources—they only support more efficient storage. In the memory of global storage, these resources are stored close to each other, ensuring quick queries and reduced processing costs/fee.
Summary:
Resource groups in Move allow grouping of multiple resources with different fields.
They function similarly to regular resources but offer more efficient storage.
Resources in a group are stored close together in global storage memory.
This proximity ensures quicker queries and reduced processing costs.
The code example demonstrates creating and using resource groups with multiple fields.
Resource groups are a current solution for complex resources, with
objects
feature planned for future optimization.
In real-world projects, sometimes one of your resources will have many different fields. Although in the future we may use the
objects
feature to optimize complex resources (which will be shared in upcoming topics), for now we can also create resources and group them together in a group. Below is an example:
module movement::resource_group {
    use std::string::{utf8, String};
    use std::signer::address_of;
    #[resource_group(scope = global)]
    struct MovementGroup {}
    #[resource_group_member(group = MovementGroup)]
    struct Group1 has key {
        field1: u64,
        field2: String,
        field3: address,
        field4: bool
    }
    #[resource_group_member(group = MovementGroup)]
    struct Group2 has key {
        field5: u64,
        field6: String,
        field7: address,
        field8: bool
    }
    public entry fun create_group_resource(account: &signer) {
        let addr = address_of(account);
        let group1 = Group1 {
            field1: 100,
            field2: utf8(b"hello"),
            field3: addr,
            field4: true
        };
        move_to(account, group1);
        let group2 = Group2 {
            field5: 200,
            field6: utf8(b"hello 2"),
            field7: addr,
            field8: false
        };
        move_to(account, group2);
    }
    #[view]
    public fun get_gresource_one(addr: address): u64 acquires Group1 {
        borrow_global<Group1>(addr).field1
    }
    #[view]
    public fun get_gresource_two(addr: address): u64 acquires Group2 {
        borrow_global<Group2>(addr).field5
    }
    #[test(account = @0x1)]
    fun test_create_group(account: &signer){
        create_group_resource(account);
    }
}
Running test:
movement move test -f test_create_group
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::resource_group::test_create_group
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
In terms of functionality and usage, Resource groups are not different from regular resources—they only support more efficient storage. In the memory of global storage, these resources are stored close to each other, ensuring quick queries and reduced processing costs/fee.
Summary:
Resource groups in Move allow grouping of multiple resources with different fields.
They function similarly to regular resources but offer more efficient storage.
Resources in a group are stored close together in global storage memory.
This proximity ensures quicker queries and reduced processing costs.
The code example demonstrates creating and using resource groups with multiple fields.
Resource groups are a current solution for complex resources, with
objects
feature planned for future optimization.
In real-world projects, sometimes one of your resources will have many different fields. Although in the future we may use the
objects
feature to optimize complex resources (which will be shared in upcoming topics), for now we can also create resources and group them together in a group. Below is an example:
module movement::resource_group {
    use std::string::{utf8, String};
    use std::signer::address_of;
    #[resource_group(scope = global)]
    struct MovementGroup {}
    #[resource_group_member(group = MovementGroup)]
    struct Group1 has key {
        field1: u64,
        field2: String,
        field3: address,
        field4: bool
    }
    #[resource_group_member(group = MovementGroup)]
    struct Group2 has key {
        field5: u64,
        field6: String,
        field7: address,
        field8: bool
    }
    public entry fun create_group_resource(account: &signer) {
        let addr = address_of(account);
        let group1 = Group1 {
            field1: 100,
            field2: utf8(b"hello"),
            field3: addr,
            field4: true
        };
        move_to(account, group1);
        let group2 = Group2 {
            field5: 200,
            field6: utf8(b"hello 2"),
            field7: addr,
            field8: false
        };
        move_to(account, group2);
    }
    #[view]
    public fun get_gresource_one(addr: address): u64 acquires Group1 {
        borrow_global<Group1>(addr).field1
    }
    #[view]
    public fun get_gresource_two(addr: address): u64 acquires Group2 {
        borrow_global<Group2>(addr).field5
    }
    #[test(account = @0x1)]
    fun test_create_group(account: &signer){
        create_group_resource(account);
    }
}
Running test:
movement move test -f test_create_group
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::resource_group::test_create_group
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
In terms of functionality and usage, Resource groups are not different from regular resources—they only support more efficient storage. In the memory of global storage, these resources are stored close to each other, ensuring quick queries and reduced processing costs/fee.
Summary:
Resource groups in Move allow grouping of multiple resources with different fields.
They function similarly to regular resources but offer more efficient storage.
Resources in a group are stored close together in global storage memory.
This proximity ensures quicker queries and reduced processing costs.
The code example demonstrates creating and using resource groups with multiple fields.
Resource groups are a current solution for complex resources, with
objects
feature planned for future optimization.
In real-world projects, sometimes one of your resources will have many different fields. Although in the future we may use the
objects
feature to optimize complex resources (which will be shared in upcoming topics), for now we can also create resources and group them together in a group. Below is an example:
module movement::resource_group {
    use std::string::{utf8, String};
    use std::signer::address_of;
    #[resource_group(scope = global)]
    struct MovementGroup {}
    #[resource_group_member(group = MovementGroup)]
    struct Group1 has key {
        field1: u64,
        field2: String,
        field3: address,
        field4: bool
    }
    #[resource_group_member(group = MovementGroup)]
    struct Group2 has key {
        field5: u64,
        field6: String,
        field7: address,
        field8: bool
    }
    public entry fun create_group_resource(account: &signer) {
        let addr = address_of(account);
        let group1 = Group1 {
            field1: 100,
            field2: utf8(b"hello"),
            field3: addr,
            field4: true
        };
        move_to(account, group1);
        let group2 = Group2 {
            field5: 200,
            field6: utf8(b"hello 2"),
            field7: addr,
            field8: false
        };
        move_to(account, group2);
    }
    #[view]
    public fun get_gresource_one(addr: address): u64 acquires Group1 {
        borrow_global<Group1>(addr).field1
    }
    #[view]
    public fun get_gresource_two(addr: address): u64 acquires Group2 {
        borrow_global<Group2>(addr).field5
    }
    #[test(account = @0x1)]
    fun test_create_group(account: &signer){
        create_group_resource(account);
    }
}
Running test:
movement move test -f test_create_group
Result:
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::resource_group::test_create_group
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
In terms of functionality and usage, Resource groups are not different from regular resources—they only support more efficient storage. In the memory of global storage, these resources are stored close to each other, ensuring quick queries and reduced processing costs/fee.
Summary:
Summary:
Summary:
Resource groups in Move allow grouping of multiple resources with different fields.
They function similarly to regular resources but offer more efficient storage.
Resources in a group are stored close together in global storage memory.
This proximity ensures quicker queries and reduced processing costs.
The code example demonstrates creating and using resource groups with multiple fields.
Resource groups are a current solution for complex resources, with
objects
feature planned for future optimization.
Resource groups in Move allow grouping of multiple resources with different fields.
Resource groups in Move allow grouping of multiple resources with different fields.
They function similarly to regular resources but offer more efficient storage.
They function similarly to regular resources but offer more efficient storage.
Resources in a group are stored close together in global storage memory.
Resources in a group are stored close together in global storage memory.
This proximity ensures quicker queries and reduced processing costs.
This proximity ensures quicker queries and reduced processing costs.
The code example demonstrates creating and using resource groups with multiple fields.
The code example demonstrates creating and using resource groups with multiple fields.
Resource groups are a current solution for complex resources, with
objects
feature planned for future optimization.
Resource groups are a current solution for complex resources, with
<code>objects</code>
objects
feature planned for future optimization.
In real-world projects, sometimes one of your resources will have many different fields. Although in the future we may use the
objects
feature to optimize complex resources (which will be shared in upcoming topics), for now we can also create resources and group them together in a group. Below is an example:
In real-world projects, sometimes one of your resources will have many different fields. Although in the future we may use the
<code>objects</code>
objects
feature to optimize complex resources (which will be shared in upcoming topics), for now we can also create resources and group them together in a group. Below is an example:
<code>module movement::resource_group {
    use std::string::{utf8, String};
    use std::signer::address_of;
    #[resource_group(scope = global)]
    struct MovementGroup {}
    #[resource_group_member(group = MovementGroup)]
    struct Group1 has key {
        field1: u64,
        field2: String,
        field3: address,
        field4: bool
    }
    #[resource_group_member(group = MovementGroup)]
    struct Group2 has key {
        field5: u64,
        field6: String,
        field7: address,
        field8: bool
    }
    public entry fun create_group_resource(account: &signer) {
        let addr = address_of(account);
        let group1 = Group1 {
            field1: 100,
            field2: utf8(b"hello"),
            field3: addr,
            field4: true
        };
        move_to(account, group1);
        let group2 = Group2 {
            field5: 200,
            field6: utf8(b"hello 2"),
            field7: addr,
            field8: false
        };
        move_to(account, group2);
    }
    #[view]
    public fun get_gresource_one(addr: address): u64 acquires Group1 {
        borrow_global<Group1>(addr).field1
    }
    #[view]
    public fun get_gresource_two(addr: address): u64 acquires Group2 {
        borrow_global<Group2>(addr).field5
    }
    #[test(account = @0x1)]
    fun test_create_group(account: &signer){
        create_group_resource(account);
    }
}</code>
<code>module movement::resource_group {
    use std::string::{utf8, String};
    use std::signer::address_of;
    #[resource_group(scope = global)]
    struct MovementGroup {}
    #[resource_group_member(group = MovementGroup)]
    struct Group1 has key {
        field1: u64,
        field2: String,
        field3: address,
        field4: bool
    }
    #[resource_group_member(group = MovementGroup)]
    struct Group2 has key {
        field5: u64,
        field6: String,
        field7: address,
        field8: bool
    }
    public entry fun create_group_resource(account: &signer) {
        let addr = address_of(account);
        let group1 = Group1 {
            field1: 100,
            field2: utf8(b"hello"),
            field3: addr,
            field4: true
        };
        move_to(account, group1);
        let group2 = Group2 {
            field5: 200,
            field6: utf8(b"hello 2"),
            field7: addr,
            field8: false
        };
        move_to(account, group2);
    }
    #[view]
    public fun get_gresource_one(addr: address): u64 acquires Group1 {
        borrow_global<Group1>(addr).field1
    }
    #[view]
    public fun get_gresource_two(addr: address): u64 acquires Group2 {
        borrow_global<Group2>(addr).field5
    }
    #[test(account = @0x1)]
    fun test_create_group(account: &signer){
        create_group_resource(account);
    }
}</code>
module movement::resource_group {
    use std::string::{utf8, String};
    use std::signer::address_of;
    #[resource_group(scope = global)]
    struct MovementGroup {}
    #[resource_group_member(group = MovementGroup)]
    struct Group1 has key {
        field1: u64,
        field2: String,
        field3: address,
        field4: bool
    }
    #[resource_group_member(group = MovementGroup)]
    struct Group2 has key {
        field5: u64,
        field6: String,
        field7: address,
        field8: bool
    }
    public entry fun create_group_resource(account: &signer) {
        let addr = address_of(account);
        let group1 = Group1 {
            field1: 100,
            field2: utf8(b"hello"),
            field3: addr,
            field4: true
        };
        move_to(account, group1);
        let group2 = Group2 {
            field5: 200,
            field6: utf8(b"hello 2"),
            field7: addr,
            field8: false
        };
        move_to(account, group2);
    }
    #[view]
    public fun get_gresource_one(addr: address): u64 acquires Group1 {
        borrow_global<Group1>(addr).field1
    }
    #[view]
    public fun get_gresource_two(addr: address): u64 acquires Group2 {
        borrow_global<Group2>(addr).field5
    }
    #[test(account = @0x1)]
    fun test_create_group(account: &signer){
        create_group_resource(account);
    }
}
Running test:
Running test:
Running test:
<code>movement move test -f test_create_group</code>
<code>movement move test -f test_create_group</code>
movement move test -f test_create_group
Result:
Result:
Result:
<code>Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::resource_group::test_create_group
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
<code>Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::resource_group::test_create_group
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
Running Move unit tests
[ PASS    ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::resource_group::test_create_group
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
In terms of functionality and usage, Resource groups are not different from regular resources—they only support more efficient storage. In the memory of global storage, these resources are stored close to each other, ensuring quick queries and reduced processing costs/fee.
In terms of functionality and usage, Resource groups are not different from regular resources—they only support more efficient storage. In the memory of global storage, these resources are stored close to each other, ensuring quick queries and reduced processing costs/fee.
In terms of functionality and usage, Resource groups are not different from regular resources—they only support more efficient storage. In the memory of global storage, these resources are stored close to each other, ensuring quick queries and reduced processing costs/fee.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/06-events
Events
Events
On This Page
Summary
Overview
Summary
Key Points:
Events are crucial functions in smart contracts for capturing and communicating occurrences within modules.
They enable back-end systems to differentiate activities and execute various tasks like sending notifications or performing off-chain calculations.
Event structs are defined with 'drop' and 'store' abilities, using the #[event] macro.
The event::emit function is called after function execution to create an event.
Events can contain specific information, such as values and executor addresses, visible in transaction details.
Implementation involves modifying existing functions to include event emission.
Overview
Events are one of the crucial functions in most smart contracts. They help back-end systems capture events that have occurred and are occurring on your modules (smart contracts). You can harness the power of Events to create distinct messages. These messages can contain various information and data from your modules. Your back-end can use these messages to differentiate activities and execute various tasks on your application, such as sending notifications or performing off-chain calculations
Returning to the example code for local and global storage:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
To create an event when executing a function, we need to define structs with the 'drop' and 'store' abilities. Additionally, we use the #[event] macro to inform the compiler that this struct is intended for creating events.
#[event]
struct EventChangeValue has drop, store {
    value: u64,
    executor: address
}
Then we call
event::emit
after the function has finished executing.
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
    *value_reference = *value_reference + value;
    event::emit(EventChangeValue {
        value,
        executor: addr
    });
}
After execution is complete, you can check the transaction and you will see an event with 2 pieces of information: executor and value
On This Page
Summary
Overview
On This Page
Summary
Overview
			On This Page
			On This Page
			Summary
Overview
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			Summary
Key Points:
Events are crucial functions in smart contracts for capturing and communicating occurrences within modules.
They enable back-end systems to differentiate activities and execute various tasks like sending notifications or performing off-chain calculations.
Event structs are defined with 'drop' and 'store' abilities, using the #[event] macro.
The event::emit function is called after function execution to create an event.
Events can contain specific information, such as values and executor addresses, visible in transaction details.
Implementation involves modifying existing functions to include event emission.
Overview
Events are one of the crucial functions in most smart contracts. They help back-end systems capture events that have occurred and are occurring on your modules (smart contracts). You can harness the power of Events to create distinct messages. These messages can contain various information and data from your modules. Your back-end can use these messages to differentiate activities and execute various tasks on your application, such as sending notifications or performing off-chain calculations
Returning to the example code for local and global storage:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
To create an event when executing a function, we need to define structs with the 'drop' and 'store' abilities. Additionally, we use the #[event] macro to inform the compiler that this struct is intended for creating events.
#[event]
struct EventChangeValue has drop, store {
    value: u64,
    executor: address
}
Then we call
event::emit
after the function has finished executing.
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
    *value_reference = *value_reference + value;
    event::emit(EventChangeValue {
        value,
        executor: addr
    });
}
After execution is complete, you can check the transaction and you will see an event with 2 pieces of information: executor and value
			Summary
Key Points:
Events are crucial functions in smart contracts for capturing and communicating occurrences within modules.
They enable back-end systems to differentiate activities and execute various tasks like sending notifications or performing off-chain calculations.
Event structs are defined with 'drop' and 'store' abilities, using the #[event] macro.
The event::emit function is called after function execution to create an event.
Events can contain specific information, such as values and executor addresses, visible in transaction details.
Implementation involves modifying existing functions to include event emission.
Overview
Events are one of the crucial functions in most smart contracts. They help back-end systems capture events that have occurred and are occurring on your modules (smart contracts). You can harness the power of Events to create distinct messages. These messages can contain various information and data from your modules. Your back-end can use these messages to differentiate activities and execute various tasks on your application, such as sending notifications or performing off-chain calculations
Returning to the example code for local and global storage:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
To create an event when executing a function, we need to define structs with the 'drop' and 'store' abilities. Additionally, we use the #[event] macro to inform the compiler that this struct is intended for creating events.
#[event]
struct EventChangeValue has drop, store {
    value: u64,
    executor: address
}
Then we call
event::emit
after the function has finished executing.
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
    *value_reference = *value_reference + value;
    event::emit(EventChangeValue {
        value,
        executor: addr
    });
}
After execution is complete, you can check the transaction and you will see an event with 2 pieces of information: executor and value
			Summary
Key Points:
Events are crucial functions in smart contracts for capturing and communicating occurrences within modules.
They enable back-end systems to differentiate activities and execute various tasks like sending notifications or performing off-chain calculations.
Event structs are defined with 'drop' and 'store' abilities, using the #[event] macro.
The event::emit function is called after function execution to create an event.
Events can contain specific information, such as values and executor addresses, visible in transaction details.
Implementation involves modifying existing functions to include event emission.
Overview
Events are one of the crucial functions in most smart contracts. They help back-end systems capture events that have occurred and are occurring on your modules (smart contracts). You can harness the power of Events to create distinct messages. These messages can contain various information and data from your modules. Your back-end can use these messages to differentiate activities and execute various tasks on your application, such as sending notifications or performing off-chain calculations
Returning to the example code for local and global storage:
module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
To create an event when executing a function, we need to define structs with the 'drop' and 'store' abilities. Additionally, we use the #[event] macro to inform the compiler that this struct is intended for creating events.
#[event]
struct EventChangeValue has drop, store {
    value: u64,
    executor: address
}
Then we call
event::emit
after the function has finished executing.
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
    *value_reference = *value_reference + value;
    event::emit(EventChangeValue {
        value,
        executor: addr
    });
}
After execution is complete, you can check the transaction and you will see an event with 2 pieces of information: executor and value
	Summary
	Summary
	Key Points:
	Key Points:
	Key Points:
	Events are crucial functions in smart contracts for capturing and communicating occurrences within modules.
They enable back-end systems to differentiate activities and execute various tasks like sending notifications or performing off-chain calculations.
Event structs are defined with 'drop' and 'store' abilities, using the #[event] macro.
The event::emit function is called after function execution to create an event.
Events can contain specific information, such as values and executor addresses, visible in transaction details.
Implementation involves modifying existing functions to include event emission.
	Events are crucial functions in smart contracts for capturing and communicating occurrences within modules.
	Events are crucial functions in smart contracts for capturing and communicating occurrences within modules.
	They enable back-end systems to differentiate activities and execute various tasks like sending notifications or performing off-chain calculations.
	They enable back-end systems to differentiate activities and execute various tasks like sending notifications or performing off-chain calculations.
	Event structs are defined with 'drop' and 'store' abilities, using the #[event] macro.
	Event structs are defined with 'drop' and 'store' abilities, using the #[event] macro.
	The event::emit function is called after function execution to create an event.
	The event::emit function is called after function execution to create an event.
	Events can contain specific information, such as values and executor addresses, visible in transaction details.
	Events can contain specific information, such as values and executor addresses, visible in transaction details.
	Implementation involves modifying existing functions to include event emission.
	Implementation involves modifying existing functions to include event emission.
	Overview
	Overview
	Events are one of the crucial functions in most smart contracts. They help back-end systems capture events that have occurred and are occurring on your modules (smart contracts). You can harness the power of Events to create distinct messages. These messages can contain various information and data from your modules. Your back-end can use these messages to differentiate activities and execute various tasks on your application, such as sending notifications or performing off-chain calculations
	Events are one of the crucial functions in most smart contracts. They help back-end systems capture events that have occurred and are occurring on your modules (smart contracts). You can harness the power of Events to create distinct messages. These messages can contain various information and data from your modules. Your back-end can use these messages to differentiate activities and execute various tasks on your application, such as sending notifications or performing off-chain calculations
	Returning to the example code for local and global storage:
	Returning to the example code for local and global storage:
	Returning to the example code for local and global storage:
	<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}</code>
	<code>module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}</code>
	module movement::local_global_storage {
    use std::debug::print;
    use std::signer::address_of;
    struct GlobalData has key, drop {
        value: u64
    }
    const EResourceNotExist: u64 = 33;
    const ENotEqual: u64 = 10;
    public entry fun new_global(signer: &signer, value: u64) {
        let data = GlobalData {
            value: value
        } ;
        move_to(signer, data);
    }
    public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
        let addr = address_of(signer);
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
        *value_reference = *value_reference + value;
    }
    public fun check_global_storage_exists(addr: address): bool {
        exists<GlobalData>(addr)
    }
    #[view]
    public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
        if (!check_global_storage_exists(addr)) {
            abort EResourceNotExist
        };
        let value_reference = borrow_global<GlobalData>(addr);
        print(&value_reference.value);
        value_reference.value
    }
    public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData {
        let rev = move_from<GlobalData>(address_of(account));
    }
    #[test(account = @0x1)]
    fun test_new_global(account: &signer) {
        new_global(account, 10);
    }
    #[test(account = @0x1)]
    fun test_change_value_global(account: &signer) acquires GlobalData {
        new_global(account, 10);
        change_value_from_global_storage(account, 10); // value should be equal 20
        let value = get_value_from_global_storage(address_of(account));
        assert!(value == 20, ENotEqual);
        // remove resource
        remove_resource_from_global_storage(account);
        assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
    }
}
	To create an event when executing a function, we need to define structs with the 'drop' and 'store' abilities. Additionally, we use the #[event] macro to inform the compiler that this struct is intended for creating events.
	To create an event when executing a function, we need to define structs with the 'drop' and 'store' abilities. Additionally, we use the #[event] macro to inform the compiler that this struct is intended for creating events.
	<code>#[event]
struct EventChangeValue has drop, store {
    value: u64,
    executor: address
}</code>
	<code>#[event]
struct EventChangeValue has drop, store {
    value: u64,
    executor: address
}</code>
	#[event]
struct EventChangeValue has drop, store {
    value: u64,
    executor: address
}
	Then we call
event::emit
after the function has finished executing.
	Then we call
	<code>event::emit</code>
	event::emit
	after the function has finished executing.
	<code>public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
    *value_reference = *value_reference + value;
    event::emit(EventChangeValue {
        value,
        executor: addr
    });
}</code>
	<code>public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
    *value_reference = *value_reference + value;
    event::emit(EventChangeValue {
        value,
        executor: addr
    });
}</code>
	public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires GlobalData {
    let addr = address_of(signer);
    if (!check_global_storage_exists(addr)) {
        abort EResourceNotExist
    };
    let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
    *value_reference = *value_reference + value;
    event::emit(EventChangeValue {
        value,
        executor: addr
    });
}
	After execution is complete, you can check the transaction and you will see an event with 2 pieces of information: executor and value
	After execution is complete, you can check the transaction and you will see an event with 2 pieces of information: executor and value

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/07-objects
Objects
Objects
Start
Start
Using ExtendRef
Start
Address Object & Create Object
Start
Object Permissions   ObjectRefs
Start
Named Objects
Start
Using TransferRef
Start
Using DeleteRef
Start
Object Ownership & Transfer Object
Start
Using ExtendRef
Start
Using ExtendRef
Start
Using ExtendRef
Using ExtendRef
Start
Start
Address Object & Create Object
Start
Address Object & Create Object
Start
Address Object & Create Object
Address Object & Create Object
Start
Start
Object Permissions   ObjectRefs
Start
Object Permissions   ObjectRefs
Start
Object Permissions   ObjectRefs
Object Permissions   ObjectRefs
Start
Start
Named Objects
Start
Named Objects
Start
Named Objects
Named Objects
Start
Start
Using TransferRef
Start
Using TransferRef
Start
Using TransferRef
Using TransferRef
Start
Start
Using DeleteRef
Start
Using DeleteRef
Start
Using DeleteRef
Using DeleteRef
Start
Start
Object Ownership & Transfer Object
Start
Object Ownership & Transfer Object
Start
Object Ownership & Transfer Object
Object Ownership & Transfer Object
Start
Start

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/07-objects/01-using-extendref
Using ExtendRef
Using ExtendRef
On This Page
Summary
Why ExtendRef?
Use Cases for ExtendRef
How to Use ExtendRef
Important Considerations
Common Pitfalls to Avoid
Full Code
Summary
ExtendRef
in Aptos Move allows generating a signer for an object after creation
Key use cases include adding ownership capabilities and enhancing object functionality
Implementation involves storing, retrieving, and using ExtendRef with
object::generate_signer()
Important to use
ExtendRef
judiciously and protect it carefully
Common pitfalls include exposing ExtendRef publicly and unnecessary usage
Proper use of
ExtendRef
enables flexible and safe extension of object functionality
Why ExtendRef?
ExtendRef
allows us to generate a signer for an object after it has been created. This is crucial because:
A signer can only be created once using ConstructorRef when the object is initialized.
After object creation, we lose access to ConstructorRef.
Use Cases for ExtendRef
Adding ownership capabilities to objects
Enhancing object functionality post-creation
Facilitating digital asset operations
How to Use ExtendRef
Store ExtendRef: When creating an object, store ExtendRef in a field of the object.
Retrieve ExtendRef: Write a function to retrieve ExtendRef from the object.
Use ExtendRef: Use
object::generate_signer()
to create a signer from ExtendRef.
In this example, we'll create an ExtendRef and store it in a separate resource, which we'll use for future extension purposes.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject { extend_ref });
}
In the code above, we initialize two resources: MovementObject and ControllerObject. We create a separate object to store these two resources independently. In the future, if I want to add more resources, I'll use the ExtendRef in ControllerObject to do so.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct NewObject has key {
    new_value: u64
}
I'm creating an additional resource to add to the object address that I created in the
init_module
function, and I'm creating a function to add this resource.
// This function adds a new object to an existing object using ExtendRef
// Parameters:
//   - owner: The signer who owns the object
//   - obj: The object to which we want to add a new object
// The function does the following:
public fun add_new_object(owner: &signer, obj: Object&lt;MovementObject&gt;) acquires ControllerObject {
    // 1. Verifies that the owner is indeed the owner of the object
    let addr = address_of(owner);
    assert!(object::is_owner(obj, addr), 1);
    
    // 2. Retrieves the ExtendRef from the ControllerObject
    let object_address = object::object_address(&obj);
    let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
    
    // 3. Generates a signer for the object using the ExtendRef
    let object_signer = object::generate_signer_for_extending(extend_ref);
    
    // 4. Creates and moves a new NewObject to the object's address
    move_to(&object_signer, NewObject { new_value: 50 });
}
The test case for this scenario will be:
#[test(account = @0x1)]
fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
    test_init_module(account);
    let addr = address_of(account);
    let obj = get_object(addr);
    add_new_object(account, obj);
    let movement_object_address = get_object_address(addr);
    assert!(exists<NewObject>(movement_object_address), 0);
    let new_object_data = borrow_global<NewObject>(movement_object_address);
    assert!(new_object_data.new_value == 50, 1);
}
Important Considerations
Only use ExtendRef when necessary.
Protect ExtendRef carefully as it allows creating the object's signer.
Thoroughly check access to functions using ExtendRef.
Common Pitfalls to Avoid
Don't expose ExtendRef publicly without proper safeguards.
Avoid unnecessary use of ExtendRef when simpler alternatives exist.
Don't forget to handle potential errors when using ExtendRef.
By leveraging ExtendRef, you can flexibly and safely extend object functionality in Move.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject { extend_ref });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    #[test(account = @0x1)]
    fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        add_new_object(account, obj);
        let movement_object_address = get_object_address(addr);
        assert!(exists<NewObject>(movement_object_address), 0);
        let new_object_data = borrow_global<NewObject>(movement_object_address);
        assert!(new_object_data.new_value == 50, 1);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
On This Page
Summary
Why ExtendRef?
Use Cases for ExtendRef
How to Use ExtendRef
Important Considerations
Common Pitfalls to Avoid
Full Code
On This Page
Summary
Why ExtendRef?
Use Cases for ExtendRef
How to Use ExtendRef
Important Considerations
Common Pitfalls to Avoid
Full Code
			On This Page
			On This Page
			Summary
Why ExtendRef?
Use Cases for ExtendRef
How to Use ExtendRef
Important Considerations
Common Pitfalls to Avoid
Full Code
			Summary
			Summary
			Summary
			Summary
			Why ExtendRef?
			Why ExtendRef?
			Why ExtendRef?
			Why ExtendRef?
			Use Cases for ExtendRef
			Use Cases for ExtendRef
			Use Cases for ExtendRef
			Use Cases for ExtendRef
			How to Use ExtendRef
			How to Use ExtendRef
			How to Use ExtendRef
			How to Use ExtendRef
			Important Considerations
			Important Considerations
			Important Considerations
			Important Considerations
			Common Pitfalls to Avoid
Full Code
			Common Pitfalls to Avoid
			Common Pitfalls to Avoid
			Common Pitfalls to Avoid
			Full Code
			Full Code
			Full Code
			Full Code
			Full Code
			Summary
ExtendRef
in Aptos Move allows generating a signer for an object after creation
Key use cases include adding ownership capabilities and enhancing object functionality
Implementation involves storing, retrieving, and using ExtendRef with
object::generate_signer()
Important to use
ExtendRef
judiciously and protect it carefully
Common pitfalls include exposing ExtendRef publicly and unnecessary usage
Proper use of
ExtendRef
enables flexible and safe extension of object functionality
Why ExtendRef?
ExtendRef
allows us to generate a signer for an object after it has been created. This is crucial because:
A signer can only be created once using ConstructorRef when the object is initialized.
After object creation, we lose access to ConstructorRef.
Use Cases for ExtendRef
Adding ownership capabilities to objects
Enhancing object functionality post-creation
Facilitating digital asset operations
How to Use ExtendRef
Store ExtendRef: When creating an object, store ExtendRef in a field of the object.
Retrieve ExtendRef: Write a function to retrieve ExtendRef from the object.
Use ExtendRef: Use
object::generate_signer()
to create a signer from ExtendRef.
In this example, we'll create an ExtendRef and store it in a separate resource, which we'll use for future extension purposes.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject { extend_ref });
}
In the code above, we initialize two resources: MovementObject and ControllerObject. We create a separate object to store these two resources independently. In the future, if I want to add more resources, I'll use the ExtendRef in ControllerObject to do so.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct NewObject has key {
    new_value: u64
}
I'm creating an additional resource to add to the object address that I created in the
init_module
function, and I'm creating a function to add this resource.
// This function adds a new object to an existing object using ExtendRef
// Parameters:
//   - owner: The signer who owns the object
//   - obj: The object to which we want to add a new object
// The function does the following:
public fun add_new_object(owner: &signer, obj: Object&lt;MovementObject&gt;) acquires ControllerObject {
    // 1. Verifies that the owner is indeed the owner of the object
    let addr = address_of(owner);
    assert!(object::is_owner(obj, addr), 1);
    
    // 2. Retrieves the ExtendRef from the ControllerObject
    let object_address = object::object_address(&obj);
    let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
    
    // 3. Generates a signer for the object using the ExtendRef
    let object_signer = object::generate_signer_for_extending(extend_ref);
    
    // 4. Creates and moves a new NewObject to the object's address
    move_to(&object_signer, NewObject { new_value: 50 });
}
The test case for this scenario will be:
#[test(account = @0x1)]
fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
    test_init_module(account);
    let addr = address_of(account);
    let obj = get_object(addr);
    add_new_object(account, obj);
    let movement_object_address = get_object_address(addr);
    assert!(exists<NewObject>(movement_object_address), 0);
    let new_object_data = borrow_global<NewObject>(movement_object_address);
    assert!(new_object_data.new_value == 50, 1);
}
Important Considerations
Only use ExtendRef when necessary.
Protect ExtendRef carefully as it allows creating the object's signer.
Thoroughly check access to functions using ExtendRef.
Common Pitfalls to Avoid
Don't expose ExtendRef publicly without proper safeguards.
Avoid unnecessary use of ExtendRef when simpler alternatives exist.
Don't forget to handle potential errors when using ExtendRef.
By leveraging ExtendRef, you can flexibly and safely extend object functionality in Move.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject { extend_ref });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    #[test(account = @0x1)]
    fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        add_new_object(account, obj);
        let movement_object_address = get_object_address(addr);
        assert!(exists<NewObject>(movement_object_address), 0);
        let new_object_data = borrow_global<NewObject>(movement_object_address);
        assert!(new_object_data.new_value == 50, 1);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
			Summary
ExtendRef
in Aptos Move allows generating a signer for an object after creation
Key use cases include adding ownership capabilities and enhancing object functionality
Implementation involves storing, retrieving, and using ExtendRef with
object::generate_signer()
Important to use
ExtendRef
judiciously and protect it carefully
Common pitfalls include exposing ExtendRef publicly and unnecessary usage
Proper use of
ExtendRef
enables flexible and safe extension of object functionality
Why ExtendRef?
ExtendRef
allows us to generate a signer for an object after it has been created. This is crucial because:
A signer can only be created once using ConstructorRef when the object is initialized.
After object creation, we lose access to ConstructorRef.
Use Cases for ExtendRef
Adding ownership capabilities to objects
Enhancing object functionality post-creation
Facilitating digital asset operations
How to Use ExtendRef
Store ExtendRef: When creating an object, store ExtendRef in a field of the object.
Retrieve ExtendRef: Write a function to retrieve ExtendRef from the object.
Use ExtendRef: Use
object::generate_signer()
to create a signer from ExtendRef.
In this example, we'll create an ExtendRef and store it in a separate resource, which we'll use for future extension purposes.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject { extend_ref });
}
In the code above, we initialize two resources: MovementObject and ControllerObject. We create a separate object to store these two resources independently. In the future, if I want to add more resources, I'll use the ExtendRef in ControllerObject to do so.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct NewObject has key {
    new_value: u64
}
I'm creating an additional resource to add to the object address that I created in the
init_module
function, and I'm creating a function to add this resource.
// This function adds a new object to an existing object using ExtendRef
// Parameters:
//   - owner: The signer who owns the object
//   - obj: The object to which we want to add a new object
// The function does the following:
public fun add_new_object(owner: &signer, obj: Object&lt;MovementObject&gt;) acquires ControllerObject {
    // 1. Verifies that the owner is indeed the owner of the object
    let addr = address_of(owner);
    assert!(object::is_owner(obj, addr), 1);
    
    // 2. Retrieves the ExtendRef from the ControllerObject
    let object_address = object::object_address(&obj);
    let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
    
    // 3. Generates a signer for the object using the ExtendRef
    let object_signer = object::generate_signer_for_extending(extend_ref);
    
    // 4. Creates and moves a new NewObject to the object's address
    move_to(&object_signer, NewObject { new_value: 50 });
}
The test case for this scenario will be:
#[test(account = @0x1)]
fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
    test_init_module(account);
    let addr = address_of(account);
    let obj = get_object(addr);
    add_new_object(account, obj);
    let movement_object_address = get_object_address(addr);
    assert!(exists<NewObject>(movement_object_address), 0);
    let new_object_data = borrow_global<NewObject>(movement_object_address);
    assert!(new_object_data.new_value == 50, 1);
}
Important Considerations
Only use ExtendRef when necessary.
Protect ExtendRef carefully as it allows creating the object's signer.
Thoroughly check access to functions using ExtendRef.
Common Pitfalls to Avoid
Don't expose ExtendRef publicly without proper safeguards.
Avoid unnecessary use of ExtendRef when simpler alternatives exist.
Don't forget to handle potential errors when using ExtendRef.
By leveraging ExtendRef, you can flexibly and safely extend object functionality in Move.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject { extend_ref });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    #[test(account = @0x1)]
    fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        add_new_object(account, obj);
        let movement_object_address = get_object_address(addr);
        assert!(exists<NewObject>(movement_object_address), 0);
        let new_object_data = borrow_global<NewObject>(movement_object_address);
        assert!(new_object_data.new_value == 50, 1);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
			Summary
ExtendRef
in Aptos Move allows generating a signer for an object after creation
Key use cases include adding ownership capabilities and enhancing object functionality
Implementation involves storing, retrieving, and using ExtendRef with
object::generate_signer()
Important to use
ExtendRef
judiciously and protect it carefully
Common pitfalls include exposing ExtendRef publicly and unnecessary usage
Proper use of
ExtendRef
enables flexible and safe extension of object functionality
Why ExtendRef?
ExtendRef
allows us to generate a signer for an object after it has been created. This is crucial because:
A signer can only be created once using ConstructorRef when the object is initialized.
After object creation, we lose access to ConstructorRef.
Use Cases for ExtendRef
Adding ownership capabilities to objects
Enhancing object functionality post-creation
Facilitating digital asset operations
How to Use ExtendRef
Store ExtendRef: When creating an object, store ExtendRef in a field of the object.
Retrieve ExtendRef: Write a function to retrieve ExtendRef from the object.
Use ExtendRef: Use
object::generate_signer()
to create a signer from ExtendRef.
In this example, we'll create an ExtendRef and store it in a separate resource, which we'll use for future extension purposes.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject { extend_ref });
}
In the code above, we initialize two resources: MovementObject and ControllerObject. We create a separate object to store these two resources independently. In the future, if I want to add more resources, I'll use the ExtendRef in ControllerObject to do so.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct NewObject has key {
    new_value: u64
}
I'm creating an additional resource to add to the object address that I created in the
init_module
function, and I'm creating a function to add this resource.
// This function adds a new object to an existing object using ExtendRef
// Parameters:
//   - owner: The signer who owns the object
//   - obj: The object to which we want to add a new object
// The function does the following:
public fun add_new_object(owner: &signer, obj: Object&lt;MovementObject&gt;) acquires ControllerObject {
    // 1. Verifies that the owner is indeed the owner of the object
    let addr = address_of(owner);
    assert!(object::is_owner(obj, addr), 1);
    
    // 2. Retrieves the ExtendRef from the ControllerObject
    let object_address = object::object_address(&obj);
    let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
    
    // 3. Generates a signer for the object using the ExtendRef
    let object_signer = object::generate_signer_for_extending(extend_ref);
    
    // 4. Creates and moves a new NewObject to the object's address
    move_to(&object_signer, NewObject { new_value: 50 });
}
The test case for this scenario will be:
#[test(account = @0x1)]
fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
    test_init_module(account);
    let addr = address_of(account);
    let obj = get_object(addr);
    add_new_object(account, obj);
    let movement_object_address = get_object_address(addr);
    assert!(exists<NewObject>(movement_object_address), 0);
    let new_object_data = borrow_global<NewObject>(movement_object_address);
    assert!(new_object_data.new_value == 50, 1);
}
Important Considerations
Only use ExtendRef when necessary.
Protect ExtendRef carefully as it allows creating the object's signer.
Thoroughly check access to functions using ExtendRef.
Common Pitfalls to Avoid
Don't expose ExtendRef publicly without proper safeguards.
Avoid unnecessary use of ExtendRef when simpler alternatives exist.
Don't forget to handle potential errors when using ExtendRef.
By leveraging ExtendRef, you can flexibly and safely extend object functionality in Move.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject { extend_ref });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    #[test(account = @0x1)]
    fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        add_new_object(account, obj);
        let movement_object_address = get_object_address(addr);
        assert!(exists<NewObject>(movement_object_address), 0);
        let new_object_data = borrow_global<NewObject>(movement_object_address);
        assert!(new_object_data.new_value == 50, 1);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
	Summary
	Summary
	ExtendRef
in Aptos Move allows generating a signer for an object after creation
Key use cases include adding ownership capabilities and enhancing object functionality
Implementation involves storing, retrieving, and using ExtendRef with
object::generate_signer()
Important to use
ExtendRef
judiciously and protect it carefully
Common pitfalls include exposing ExtendRef publicly and unnecessary usage
Proper use of
ExtendRef
enables flexible and safe extension of object functionality
	ExtendRef
in Aptos Move allows generating a signer for an object after creation
	<code>ExtendRef</code>
	ExtendRef
	in Aptos Move allows generating a signer for an object after creation
	Key use cases include adding ownership capabilities and enhancing object functionality
	Key use cases include adding ownership capabilities and enhancing object functionality
	Implementation involves storing, retrieving, and using ExtendRef with
object::generate_signer()
	Implementation involves storing, retrieving, and using ExtendRef with
	<code>object::generate_signer()</code>
	object::generate_signer()
	Important to use
ExtendRef
judiciously and protect it carefully
	Important to use
	<code>ExtendRef</code>
	ExtendRef
	judiciously and protect it carefully
	Common pitfalls include exposing ExtendRef publicly and unnecessary usage
	Common pitfalls include exposing ExtendRef publicly and unnecessary usage
	Proper use of
ExtendRef
enables flexible and safe extension of object functionality
	Proper use of
	<code>ExtendRef</code>
	ExtendRef
	enables flexible and safe extension of object functionality
	Why ExtendRef?
	Why ExtendRef?
	ExtendRef
allows us to generate a signer for an object after it has been created. This is crucial because:
	<code>ExtendRef</code>
	ExtendRef
	allows us to generate a signer for an object after it has been created. This is crucial because:
	A signer can only be created once using ConstructorRef when the object is initialized.
After object creation, we lose access to ConstructorRef.
	A signer can only be created once using ConstructorRef when the object is initialized.
	A signer can only be created once using ConstructorRef when the object is initialized.
	After object creation, we lose access to ConstructorRef.
	After object creation, we lose access to ConstructorRef.
	Use Cases for ExtendRef
	Use Cases for ExtendRef
	Adding ownership capabilities to objects
Enhancing object functionality post-creation
Facilitating digital asset operations
	Adding ownership capabilities to objects
	Adding ownership capabilities to objects
	Enhancing object functionality post-creation
	Enhancing object functionality post-creation
	Facilitating digital asset operations
	Facilitating digital asset operations
	How to Use ExtendRef
	How to Use ExtendRef
	Store ExtendRef: When creating an object, store ExtendRef in a field of the object.
Retrieve ExtendRef: Write a function to retrieve ExtendRef from the object.
Use ExtendRef: Use
object::generate_signer()
to create a signer from ExtendRef.
	Store ExtendRef: When creating an object, store ExtendRef in a field of the object.
	Store ExtendRef: When creating an object, store ExtendRef in a field of the object.
	Retrieve ExtendRef: Write a function to retrieve ExtendRef from the object.
	Retrieve ExtendRef: Write a function to retrieve ExtendRef from the object.
	Use ExtendRef: Use
object::generate_signer()
to create a signer from ExtendRef.
	Use ExtendRef: Use
	<code>object::generate_signer()</code>
	object::generate_signer()
	to create a signer from ExtendRef.
	In this example, we'll create an ExtendRef and store it in a separate resource, which we'll use for future extension purposes.
	In this example, we'll create an ExtendRef and store it in a separate resource, which we'll use for future extension purposes.
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject { extend_ref });
}</code>
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject { extend_ref });
}</code>
	#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject { extend_ref });
}
	In the code above, we initialize two resources: MovementObject and ControllerObject. We create a separate object to store these two resources independently. In the future, if I want to add more resources, I'll use the ExtendRef in ControllerObject to do so.
	In the code above, we initialize two resources: MovementObject and ControllerObject. We create a separate object to store these two resources independently. In the future, if I want to add more resources, I'll use the ExtendRef in ControllerObject to do so.
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct NewObject has key {
    new_value: u64
}</code>
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct NewObject has key {
    new_value: u64
}</code>
	#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct NewObject has key {
    new_value: u64
}
	I'm creating an additional resource to add to the object address that I created in the
init_module
function, and I'm creating a function to add this resource.
	I'm creating an additional resource to add to the object address that I created in the
	<code>init_module</code>
	init_module
	function, and I'm creating a function to add this resource.
	<code>// This function adds a new object to an existing object using ExtendRef
// Parameters:
//   - owner: The signer who owns the object
//   - obj: The object to which we want to add a new object
// The function does the following:
public fun add_new_object(owner: &signer, obj: Object&lt;MovementObject&gt;) acquires ControllerObject {
    // 1. Verifies that the owner is indeed the owner of the object
    let addr = address_of(owner);
    assert!(object::is_owner(obj, addr), 1);
    
    // 2. Retrieves the ExtendRef from the ControllerObject
    let object_address = object::object_address(&obj);
    let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
    
    // 3. Generates a signer for the object using the ExtendRef
    let object_signer = object::generate_signer_for_extending(extend_ref);
    
    // 4. Creates and moves a new NewObject to the object's address
    move_to(&object_signer, NewObject { new_value: 50 });
}</code>
	<code>// This function adds a new object to an existing object using ExtendRef
// Parameters:
//   - owner: The signer who owns the object
//   - obj: The object to which we want to add a new object
// The function does the following:
public fun add_new_object(owner: &signer, obj: Object&lt;MovementObject&gt;) acquires ControllerObject {
    // 1. Verifies that the owner is indeed the owner of the object
    let addr = address_of(owner);
    assert!(object::is_owner(obj, addr), 1);
    
    // 2. Retrieves the ExtendRef from the ControllerObject
    let object_address = object::object_address(&obj);
    let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
    
    // 3. Generates a signer for the object using the ExtendRef
    let object_signer = object::generate_signer_for_extending(extend_ref);
    
    // 4. Creates and moves a new NewObject to the object's address
    move_to(&object_signer, NewObject { new_value: 50 });
}</code>
	// This function adds a new object to an existing object using ExtendRef
// Parameters:
//   - owner: The signer who owns the object
//   - obj: The object to which we want to add a new object
// The function does the following:
public fun add_new_object(owner: &signer, obj: Object&lt;MovementObject&gt;) acquires ControllerObject {
    // 1. Verifies that the owner is indeed the owner of the object
    let addr = address_of(owner);
    assert!(object::is_owner(obj, addr), 1);
    
    // 2. Retrieves the ExtendRef from the ControllerObject
    let object_address = object::object_address(&obj);
    let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
    
    // 3. Generates a signer for the object using the ExtendRef
    let object_signer = object::generate_signer_for_extending(extend_ref);
    
    // 4. Creates and moves a new NewObject to the object's address
    move_to(&object_signer, NewObject { new_value: 50 });
}
	The test case for this scenario will be:
	The test case for this scenario will be:
	<code>#[test(account = @0x1)]
fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
    test_init_module(account);
    let addr = address_of(account);
    let obj = get_object(addr);
    add_new_object(account, obj);
    let movement_object_address = get_object_address(addr);
    assert!(exists<NewObject>(movement_object_address), 0);
    let new_object_data = borrow_global<NewObject>(movement_object_address);
    assert!(new_object_data.new_value == 50, 1);
}</code>
	<code>#[test(account = @0x1)]
fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
    test_init_module(account);
    let addr = address_of(account);
    let obj = get_object(addr);
    add_new_object(account, obj);
    let movement_object_address = get_object_address(addr);
    assert!(exists<NewObject>(movement_object_address), 0);
    let new_object_data = borrow_global<NewObject>(movement_object_address);
    assert!(new_object_data.new_value == 50, 1);
}</code>
	#[test(account = @0x1)]
fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
    test_init_module(account);
    let addr = address_of(account);
    let obj = get_object(addr);
    add_new_object(account, obj);
    let movement_object_address = get_object_address(addr);
    assert!(exists<NewObject>(movement_object_address), 0);
    let new_object_data = borrow_global<NewObject>(movement_object_address);
    assert!(new_object_data.new_value == 50, 1);
}
	Important Considerations
	Important Considerations
	Only use ExtendRef when necessary.
Protect ExtendRef carefully as it allows creating the object's signer.
Thoroughly check access to functions using ExtendRef.
	Only use ExtendRef when necessary.
	Only use ExtendRef when necessary.
	Protect ExtendRef carefully as it allows creating the object's signer.
	Protect ExtendRef carefully as it allows creating the object's signer.
	Thoroughly check access to functions using ExtendRef.
	Thoroughly check access to functions using ExtendRef.
	Common Pitfalls to Avoid
	Common Pitfalls to Avoid
	Don't expose ExtendRef publicly without proper safeguards.
Avoid unnecessary use of ExtendRef when simpler alternatives exist.
Don't forget to handle potential errors when using ExtendRef.
	Don't expose ExtendRef publicly without proper safeguards.
	Don't expose ExtendRef publicly without proper safeguards.
	Avoid unnecessary use of ExtendRef when simpler alternatives exist.
	Avoid unnecessary use of ExtendRef when simpler alternatives exist.
	Don't forget to handle potential errors when using ExtendRef.
	Don't forget to handle potential errors when using ExtendRef.
	By leveraging ExtendRef, you can flexibly and safely extend object functionality in Move.
	By leveraging ExtendRef, you can flexibly and safely extend object functionality in Move.
		Full Code
		Full Code
		<code>module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject { extend_ref });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    #[test(account = @0x1)]
    fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        add_new_object(account, obj);
        let movement_object_address = get_object_address(addr);
        assert!(exists<NewObject>(movement_object_address), 0);
        let new_object_data = borrow_global<NewObject>(movement_object_address);
        assert!(new_object_data.new_value == 50, 1);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}</code>
		<code>module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject { extend_ref });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    #[test(account = @0x1)]
    fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        add_new_object(account, obj);
        let movement_object_address = get_object_address(addr);
        assert!(exists<NewObject>(movement_object_address), 0);
        let new_object_data = borrow_global<NewObject>(movement_object_address);
        assert!(new_object_data.new_value == 50, 1);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}</code>
		module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject { extend_ref });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    #[test(account = @0x1)]
    fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        add_new_object(account, obj);
        let movement_object_address = get_object_address(addr);
        assert!(exists<NewObject>(movement_object_address), 0);
        let new_object_data = borrow_global<NewObject>(movement_object_address);
        assert!(new_object_data.new_value == 50, 1);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/07-objects/02-address-object-and-create-object
Address Object & Create Object
Address Object & Create Object
On This Page
Summary
What is Object?
Limitations of Structs
Create a Object
Summary
Objects are a key feature in the
aptos_framework
, enhancing code flexibility and adaptability.
They address limitations of structs such as lack of stable identity, limited extensibility, and data overload.
Objects maintain stable references, allow potential future extensions, and improve data organization.
Creation involves using functions like
object::create_object
, which generates a unique address for storing resources.
The process includes getting the owner's address, creating the object, generating an object signer, and moving the object to its address.
Different types of objects (normal, named, sticky) can be created with varying properties of deletability and address determinism.
What is Object?
Objects are one of the most exciting features of the aptos_framework. They make your code extremely flexible and help developers be more adaptable in designing and developing products. Objects are also used in many of Aptos' standard code implementations, such as Digital Assets, Coins, and Fungible Tokens.
In this lesson, we will explore what objects are and how they work.
Limitations of Structs
Reflecting on our previous lessons about structs, we can see that while using structs and a resource-centric approach has made Move very flexible, there are still several limitations:
Lack of Stable Identity: Structs can move freely between resources, making them difficult to track consistently.
Limited Extensibility: Once defined, structs cannot be easily extended with new fields, even in upgradable modules.
Data Overload: Storing numerous resources in accounts can lead to clutter, making it challenging to locate relevant data for specific decentralized applications (dApps).
Using objects in this way allows us to:
Maintain a stable reference to our data via the object's address.
Potentially extend the object's functionality in future upgrades.
Keep related data grouped together, improving organization.
Create a Object
module movement::object_module_entry {
    use aptos_framework::object;
    use std::debug::print;
    use std::signer;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ExampleObject has key {
        value: u64
    }
    public entry fun example_object(user: &signer, value: u64) {
        let owner_address = signer::address_of(user);
        print(&owner_address);
        let example_object_constructor_ref = &object::create_object(owner_address);
        print(example_object_constructor_ref);
        let object_signer = &object::generate_signer(example_object_constructor_ref);
        print(object_signer);
        move_to(object_signer, ExampleObject { value });
        let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
        print(&address_object);
    }
    #[test(account = @0x1)]
    fun test_example_object(account: &signer) {
        example_object(account, 10);
    }
}
Function Signature:
public entry fun example_object(user: &signer, value: u64)
This function takes two parameters: a reference to a signer (the user) and a u64 value.
Get the owner's address:
let owner_address = signer::address_of(user);
This step retrieves the address of the signer and prints it.
Create an object:
let example_object_constructor_ref = &object::create_object(owner_address);
Here, a new object is created using the
create_object
function from the
object
module. The constructor reference is stored. This function returns a randomly generated and unique object address. This address will be used to store resources instead of storing them directly in the user's address. This approach reduces the storage burden on user accounts, making it more optimized and flexible.
Generate an object signer:
let object_signer = &object::generate_signer(example_object_constructor_ref);
This step generates a signer for the object using the constructor reference.
Move the ExampleObject to the object's address:
move_to(object_signer, ExampleObject { value });
This moves an instance of
ExampleObject
with the given value to the address of the object signer.
Get the object's address:
let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
Finally, the function retrieves the address of the created object using the constructor reference and prints it.
[debug] @0x1 // Address Signer
[debug] 0x1::object::ConstructorRef { // Create address object
  self: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a,
  can_delete: true
}
[debug] signer(@0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a) // signer
[debug] @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
Additionally, instead of retrieving the object's address, you can also directly obtain the object through this function:
let object_info = object::object_from_constructor_ref<ExampleObject>(example_object_constructor_ref);
Finally, the test results will return additional inner objects of that struct:
[debug] 0x1::object::Object<0x6f409ba3234fa3b9a8baf7d442709ef51f39284f35dd7c06360fa0b55a0cd690::object_module_entry::ExampleObject> {
  inner: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
}
In addition to the
object::create_object
function, we have other functions to create objects:
object::create_object
: A
normal Object |
This type is
deletable
and has a
random address
object::create_named_object
: A
named Object |
This type is **
not** deletable
and has a
deterministic address
object::create_sticky_object
: A
sticky Object |
This type is also **
not** deletable
and has a
random address
On This Page
Summary
What is Object?
Limitations of Structs
Create a Object
On This Page
Summary
What is Object?
Limitations of Structs
Create a Object
			On This Page
			On This Page
			Summary
What is Object?
Limitations of Structs
Create a Object
			Summary
			Summary
			Summary
			Summary
			What is Object?
			What is Object?
			What is Object?
			What is Object?
			Limitations of Structs
			Limitations of Structs
			Limitations of Structs
			Limitations of Structs
			Create a Object
			Create a Object
			Create a Object
			Create a Object
			Summary
Objects are a key feature in the
aptos_framework
, enhancing code flexibility and adaptability.
They address limitations of structs such as lack of stable identity, limited extensibility, and data overload.
Objects maintain stable references, allow potential future extensions, and improve data organization.
Creation involves using functions like
object::create_object
, which generates a unique address for storing resources.
The process includes getting the owner's address, creating the object, generating an object signer, and moving the object to its address.
Different types of objects (normal, named, sticky) can be created with varying properties of deletability and address determinism.
What is Object?
Objects are one of the most exciting features of the aptos_framework. They make your code extremely flexible and help developers be more adaptable in designing and developing products. Objects are also used in many of Aptos' standard code implementations, such as Digital Assets, Coins, and Fungible Tokens.
In this lesson, we will explore what objects are and how they work.
Limitations of Structs
Reflecting on our previous lessons about structs, we can see that while using structs and a resource-centric approach has made Move very flexible, there are still several limitations:
Lack of Stable Identity: Structs can move freely between resources, making them difficult to track consistently.
Limited Extensibility: Once defined, structs cannot be easily extended with new fields, even in upgradable modules.
Data Overload: Storing numerous resources in accounts can lead to clutter, making it challenging to locate relevant data for specific decentralized applications (dApps).
Using objects in this way allows us to:
Maintain a stable reference to our data via the object's address.
Potentially extend the object's functionality in future upgrades.
Keep related data grouped together, improving organization.
Create a Object
module movement::object_module_entry {
    use aptos_framework::object;
    use std::debug::print;
    use std::signer;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ExampleObject has key {
        value: u64
    }
    public entry fun example_object(user: &signer, value: u64) {
        let owner_address = signer::address_of(user);
        print(&owner_address);
        let example_object_constructor_ref = &object::create_object(owner_address);
        print(example_object_constructor_ref);
        let object_signer = &object::generate_signer(example_object_constructor_ref);
        print(object_signer);
        move_to(object_signer, ExampleObject { value });
        let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
        print(&address_object);
    }
    #[test(account = @0x1)]
    fun test_example_object(account: &signer) {
        example_object(account, 10);
    }
}
Function Signature:
public entry fun example_object(user: &signer, value: u64)
This function takes two parameters: a reference to a signer (the user) and a u64 value.
Get the owner's address:
let owner_address = signer::address_of(user);
This step retrieves the address of the signer and prints it.
Create an object:
let example_object_constructor_ref = &object::create_object(owner_address);
Here, a new object is created using the
create_object
function from the
object
module. The constructor reference is stored. This function returns a randomly generated and unique object address. This address will be used to store resources instead of storing them directly in the user's address. This approach reduces the storage burden on user accounts, making it more optimized and flexible.
Generate an object signer:
let object_signer = &object::generate_signer(example_object_constructor_ref);
This step generates a signer for the object using the constructor reference.
Move the ExampleObject to the object's address:
move_to(object_signer, ExampleObject { value });
This moves an instance of
ExampleObject
with the given value to the address of the object signer.
Get the object's address:
let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
Finally, the function retrieves the address of the created object using the constructor reference and prints it.
[debug] @0x1 // Address Signer
[debug] 0x1::object::ConstructorRef { // Create address object
  self: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a,
  can_delete: true
}
[debug] signer(@0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a) // signer
[debug] @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
Additionally, instead of retrieving the object's address, you can also directly obtain the object through this function:
let object_info = object::object_from_constructor_ref<ExampleObject>(example_object_constructor_ref);
Finally, the test results will return additional inner objects of that struct:
[debug] 0x1::object::Object<0x6f409ba3234fa3b9a8baf7d442709ef51f39284f35dd7c06360fa0b55a0cd690::object_module_entry::ExampleObject> {
  inner: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
}
In addition to the
object::create_object
function, we have other functions to create objects:
object::create_object
: A
normal Object |
This type is
deletable
and has a
random address
object::create_named_object
: A
named Object |
This type is **
not** deletable
and has a
deterministic address
object::create_sticky_object
: A
sticky Object |
This type is also **
not** deletable
and has a
random address
			Summary
Objects are a key feature in the
aptos_framework
, enhancing code flexibility and adaptability.
They address limitations of structs such as lack of stable identity, limited extensibility, and data overload.
Objects maintain stable references, allow potential future extensions, and improve data organization.
Creation involves using functions like
object::create_object
, which generates a unique address for storing resources.
The process includes getting the owner's address, creating the object, generating an object signer, and moving the object to its address.
Different types of objects (normal, named, sticky) can be created with varying properties of deletability and address determinism.
What is Object?
Objects are one of the most exciting features of the aptos_framework. They make your code extremely flexible and help developers be more adaptable in designing and developing products. Objects are also used in many of Aptos' standard code implementations, such as Digital Assets, Coins, and Fungible Tokens.
In this lesson, we will explore what objects are and how they work.
Limitations of Structs
Reflecting on our previous lessons about structs, we can see that while using structs and a resource-centric approach has made Move very flexible, there are still several limitations:
Lack of Stable Identity: Structs can move freely between resources, making them difficult to track consistently.
Limited Extensibility: Once defined, structs cannot be easily extended with new fields, even in upgradable modules.
Data Overload: Storing numerous resources in accounts can lead to clutter, making it challenging to locate relevant data for specific decentralized applications (dApps).
Using objects in this way allows us to:
Maintain a stable reference to our data via the object's address.
Potentially extend the object's functionality in future upgrades.
Keep related data grouped together, improving organization.
Create a Object
module movement::object_module_entry {
    use aptos_framework::object;
    use std::debug::print;
    use std::signer;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ExampleObject has key {
        value: u64
    }
    public entry fun example_object(user: &signer, value: u64) {
        let owner_address = signer::address_of(user);
        print(&owner_address);
        let example_object_constructor_ref = &object::create_object(owner_address);
        print(example_object_constructor_ref);
        let object_signer = &object::generate_signer(example_object_constructor_ref);
        print(object_signer);
        move_to(object_signer, ExampleObject { value });
        let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
        print(&address_object);
    }
    #[test(account = @0x1)]
    fun test_example_object(account: &signer) {
        example_object(account, 10);
    }
}
Function Signature:
public entry fun example_object(user: &signer, value: u64)
This function takes two parameters: a reference to a signer (the user) and a u64 value.
Get the owner's address:
let owner_address = signer::address_of(user);
This step retrieves the address of the signer and prints it.
Create an object:
let example_object_constructor_ref = &object::create_object(owner_address);
Here, a new object is created using the
create_object
function from the
object
module. The constructor reference is stored. This function returns a randomly generated and unique object address. This address will be used to store resources instead of storing them directly in the user's address. This approach reduces the storage burden on user accounts, making it more optimized and flexible.
Generate an object signer:
let object_signer = &object::generate_signer(example_object_constructor_ref);
This step generates a signer for the object using the constructor reference.
Move the ExampleObject to the object's address:
move_to(object_signer, ExampleObject { value });
This moves an instance of
ExampleObject
with the given value to the address of the object signer.
Get the object's address:
let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
Finally, the function retrieves the address of the created object using the constructor reference and prints it.
[debug] @0x1 // Address Signer
[debug] 0x1::object::ConstructorRef { // Create address object
  self: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a,
  can_delete: true
}
[debug] signer(@0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a) // signer
[debug] @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
Additionally, instead of retrieving the object's address, you can also directly obtain the object through this function:
let object_info = object::object_from_constructor_ref<ExampleObject>(example_object_constructor_ref);
Finally, the test results will return additional inner objects of that struct:
[debug] 0x1::object::Object<0x6f409ba3234fa3b9a8baf7d442709ef51f39284f35dd7c06360fa0b55a0cd690::object_module_entry::ExampleObject> {
  inner: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
}
In addition to the
object::create_object
function, we have other functions to create objects:
object::create_object
: A
normal Object |
This type is
deletable
and has a
random address
object::create_named_object
: A
named Object |
This type is **
not** deletable
and has a
deterministic address
object::create_sticky_object
: A
sticky Object |
This type is also **
not** deletable
and has a
random address
			Summary
Objects are a key feature in the
aptos_framework
, enhancing code flexibility and adaptability.
They address limitations of structs such as lack of stable identity, limited extensibility, and data overload.
Objects maintain stable references, allow potential future extensions, and improve data organization.
Creation involves using functions like
object::create_object
, which generates a unique address for storing resources.
The process includes getting the owner's address, creating the object, generating an object signer, and moving the object to its address.
Different types of objects (normal, named, sticky) can be created with varying properties of deletability and address determinism.
What is Object?
Objects are one of the most exciting features of the aptos_framework. They make your code extremely flexible and help developers be more adaptable in designing and developing products. Objects are also used in many of Aptos' standard code implementations, such as Digital Assets, Coins, and Fungible Tokens.
In this lesson, we will explore what objects are and how they work.
Limitations of Structs
Reflecting on our previous lessons about structs, we can see that while using structs and a resource-centric approach has made Move very flexible, there are still several limitations:
Lack of Stable Identity: Structs can move freely between resources, making them difficult to track consistently.
Limited Extensibility: Once defined, structs cannot be easily extended with new fields, even in upgradable modules.
Data Overload: Storing numerous resources in accounts can lead to clutter, making it challenging to locate relevant data for specific decentralized applications (dApps).
Using objects in this way allows us to:
Maintain a stable reference to our data via the object's address.
Potentially extend the object's functionality in future upgrades.
Keep related data grouped together, improving organization.
Create a Object
module movement::object_module_entry {
    use aptos_framework::object;
    use std::debug::print;
    use std::signer;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ExampleObject has key {
        value: u64
    }
    public entry fun example_object(user: &signer, value: u64) {
        let owner_address = signer::address_of(user);
        print(&owner_address);
        let example_object_constructor_ref = &object::create_object(owner_address);
        print(example_object_constructor_ref);
        let object_signer = &object::generate_signer(example_object_constructor_ref);
        print(object_signer);
        move_to(object_signer, ExampleObject { value });
        let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
        print(&address_object);
    }
    #[test(account = @0x1)]
    fun test_example_object(account: &signer) {
        example_object(account, 10);
    }
}
Function Signature:
public entry fun example_object(user: &signer, value: u64)
This function takes two parameters: a reference to a signer (the user) and a u64 value.
Get the owner's address:
let owner_address = signer::address_of(user);
This step retrieves the address of the signer and prints it.
Create an object:
let example_object_constructor_ref = &object::create_object(owner_address);
Here, a new object is created using the
create_object
function from the
object
module. The constructor reference is stored. This function returns a randomly generated and unique object address. This address will be used to store resources instead of storing them directly in the user's address. This approach reduces the storage burden on user accounts, making it more optimized and flexible.
Generate an object signer:
let object_signer = &object::generate_signer(example_object_constructor_ref);
This step generates a signer for the object using the constructor reference.
Move the ExampleObject to the object's address:
move_to(object_signer, ExampleObject { value });
This moves an instance of
ExampleObject
with the given value to the address of the object signer.
Get the object's address:
let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
Finally, the function retrieves the address of the created object using the constructor reference and prints it.
[debug] @0x1 // Address Signer
[debug] 0x1::object::ConstructorRef { // Create address object
  self: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a,
  can_delete: true
}
[debug] signer(@0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a) // signer
[debug] @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
Additionally, instead of retrieving the object's address, you can also directly obtain the object through this function:
let object_info = object::object_from_constructor_ref<ExampleObject>(example_object_constructor_ref);
Finally, the test results will return additional inner objects of that struct:
[debug] 0x1::object::Object<0x6f409ba3234fa3b9a8baf7d442709ef51f39284f35dd7c06360fa0b55a0cd690::object_module_entry::ExampleObject> {
  inner: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
}
In addition to the
object::create_object
function, we have other functions to create objects:
object::create_object
: A
normal Object |
This type is
deletable
and has a
random address
object::create_named_object
: A
named Object |
This type is **
not** deletable
and has a
deterministic address
object::create_sticky_object
: A
sticky Object |
This type is also **
not** deletable
and has a
random address
	Summary
	Summary
	Objects are a key feature in the
aptos_framework
, enhancing code flexibility and adaptability.
They address limitations of structs such as lack of stable identity, limited extensibility, and data overload.
Objects maintain stable references, allow potential future extensions, and improve data organization.
Creation involves using functions like
object::create_object
, which generates a unique address for storing resources.
The process includes getting the owner's address, creating the object, generating an object signer, and moving the object to its address.
Different types of objects (normal, named, sticky) can be created with varying properties of deletability and address determinism.
	Objects are a key feature in the
aptos_framework
, enhancing code flexibility and adaptability.
	Objects are a key feature in the
	<code>aptos_framework</code>
	aptos_framework
	, enhancing code flexibility and adaptability.
	They address limitations of structs such as lack of stable identity, limited extensibility, and data overload.
	They address limitations of structs such as lack of stable identity, limited extensibility, and data overload.
	Objects maintain stable references, allow potential future extensions, and improve data organization.
	Objects maintain stable references, allow potential future extensions, and improve data organization.
	Creation involves using functions like
object::create_object
, which generates a unique address for storing resources.
	Creation involves using functions like
	<code>object::create_object</code>
	object::create_object
	, which generates a unique address for storing resources.
	The process includes getting the owner's address, creating the object, generating an object signer, and moving the object to its address.
	The process includes getting the owner's address, creating the object, generating an object signer, and moving the object to its address.
	Different types of objects (normal, named, sticky) can be created with varying properties of deletability and address determinism.
	Different types of objects (normal, named, sticky) can be created with varying properties of deletability and address determinism.
	What is Object?
	What is Object?
	Objects are one of the most exciting features of the aptos_framework. They make your code extremely flexible and help developers be more adaptable in designing and developing products. Objects are also used in many of Aptos' standard code implementations, such as Digital Assets, Coins, and Fungible Tokens.
	Objects are one of the most exciting features of the aptos_framework. They make your code extremely flexible and help developers be more adaptable in designing and developing products. Objects are also used in many of Aptos' standard code implementations, such as Digital Assets, Coins, and Fungible Tokens.
	In this lesson, we will explore what objects are and how they work.
	In this lesson, we will explore what objects are and how they work.
	Limitations of Structs
	Limitations of Structs
	Reflecting on our previous lessons about structs, we can see that while using structs and a resource-centric approach has made Move very flexible, there are still several limitations:
	Reflecting on our previous lessons about structs, we can see that while using structs and a resource-centric approach has made Move very flexible, there are still several limitations:
	Lack of Stable Identity: Structs can move freely between resources, making them difficult to track consistently.
Limited Extensibility: Once defined, structs cannot be easily extended with new fields, even in upgradable modules.
Data Overload: Storing numerous resources in accounts can lead to clutter, making it challenging to locate relevant data for specific decentralized applications (dApps).
	Lack of Stable Identity: Structs can move freely between resources, making them difficult to track consistently.
	Lack of Stable Identity: Structs can move freely between resources, making them difficult to track consistently.
	Limited Extensibility: Once defined, structs cannot be easily extended with new fields, even in upgradable modules.
	Limited Extensibility: Once defined, structs cannot be easily extended with new fields, even in upgradable modules.
	Data Overload: Storing numerous resources in accounts can lead to clutter, making it challenging to locate relevant data for specific decentralized applications (dApps).
	Data Overload: Storing numerous resources in accounts can lead to clutter, making it challenging to locate relevant data for specific decentralized applications (dApps).
	Using objects in this way allows us to:
	Using objects in this way allows us to:
	Using objects in this way allows us to:
	Maintain a stable reference to our data via the object's address.
Potentially extend the object's functionality in future upgrades.
Keep related data grouped together, improving organization.
	Maintain a stable reference to our data via the object's address.
	Maintain a stable reference to our data via the object's address.
	Potentially extend the object's functionality in future upgrades.
	Potentially extend the object's functionality in future upgrades.
	Keep related data grouped together, improving organization.
	Keep related data grouped together, improving organization.
	Create a Object
	Create a Object
	<code>module movement::object_module_entry {
    use aptos_framework::object;
    use std::debug::print;
    use std::signer;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ExampleObject has key {
        value: u64
    }
    public entry fun example_object(user: &signer, value: u64) {
        let owner_address = signer::address_of(user);
        print(&owner_address);
        let example_object_constructor_ref = &object::create_object(owner_address);
        print(example_object_constructor_ref);
        let object_signer = &object::generate_signer(example_object_constructor_ref);
        print(object_signer);
        move_to(object_signer, ExampleObject { value });
        let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
        print(&address_object);
    }
    #[test(account = @0x1)]
    fun test_example_object(account: &signer) {
        example_object(account, 10);
    }
}</code>
	<code>module movement::object_module_entry {
    use aptos_framework::object;
    use std::debug::print;
    use std::signer;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ExampleObject has key {
        value: u64
    }
    public entry fun example_object(user: &signer, value: u64) {
        let owner_address = signer::address_of(user);
        print(&owner_address);
        let example_object_constructor_ref = &object::create_object(owner_address);
        print(example_object_constructor_ref);
        let object_signer = &object::generate_signer(example_object_constructor_ref);
        print(object_signer);
        move_to(object_signer, ExampleObject { value });
        let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
        print(&address_object);
    }
    #[test(account = @0x1)]
    fun test_example_object(account: &signer) {
        example_object(account, 10);
    }
}</code>
	module movement::object_module_entry {
    use aptos_framework::object;
    use std::debug::print;
    use std::signer;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ExampleObject has key {
        value: u64
    }
    public entry fun example_object(user: &signer, value: u64) {
        let owner_address = signer::address_of(user);
        print(&owner_address);
        let example_object_constructor_ref = &object::create_object(owner_address);
        print(example_object_constructor_ref);
        let object_signer = &object::generate_signer(example_object_constructor_ref);
        print(object_signer);
        move_to(object_signer, ExampleObject { value });
        let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
        print(&address_object);
    }
    #[test(account = @0x1)]
    fun test_example_object(account: &signer) {
        example_object(account, 10);
    }
}
	Function Signature:
	Function Signature:
	Function Signature:
	<code>public entry fun example_object(user: &signer, value: u64)</code>
	<code>public entry fun example_object(user: &signer, value: u64)</code>
	public entry fun example_object(user: &signer, value: u64)
	This function takes two parameters: a reference to a signer (the user) and a u64 value.
	This function takes two parameters: a reference to a signer (the user) and a u64 value.
	Get the owner's address:
	Get the owner's address:
	Get the owner's address:
	<code>let owner_address = signer::address_of(user);</code>
	<code>let owner_address = signer::address_of(user);</code>
	let owner_address = signer::address_of(user);
	This step retrieves the address of the signer and prints it.
	This step retrieves the address of the signer and prints it.
	Create an object:
	Create an object:
	Create an object:
	<code>let example_object_constructor_ref = &object::create_object(owner_address);</code>
	<code>let example_object_constructor_ref = &object::create_object(owner_address);</code>
	let example_object_constructor_ref = &object::create_object(owner_address);
	Here, a new object is created using the
create_object
function from the
object
module. The constructor reference is stored. This function returns a randomly generated and unique object address. This address will be used to store resources instead of storing them directly in the user's address. This approach reduces the storage burden on user accounts, making it more optimized and flexible.
	Here, a new object is created using the
	<code>create_object</code>
	create_object
	function from the
	<code>object</code>
	object
	module. The constructor reference is stored. This function returns a randomly generated and unique object address. This address will be used to store resources instead of storing them directly in the user's address. This approach reduces the storage burden on user accounts, making it more optimized and flexible.
	Generate an object signer:
	Generate an object signer:
	Generate an object signer:
	<code>let object_signer = &object::generate_signer(example_object_constructor_ref);</code>
	<code>let object_signer = &object::generate_signer(example_object_constructor_ref);</code>
	let object_signer = &object::generate_signer(example_object_constructor_ref);
	This step generates a signer for the object using the constructor reference.
	This step generates a signer for the object using the constructor reference.
	Move the ExampleObject to the object's address:
	Move the ExampleObject to the object's address:
	Move the ExampleObject to the object's address:
	<code>move_to(object_signer, ExampleObject { value });</code>
	<code>move_to(object_signer, ExampleObject { value });</code>
	move_to(object_signer, ExampleObject { value });
	This moves an instance of
ExampleObject
with the given value to the address of the object signer.
	This moves an instance of
	<code>ExampleObject</code>
	ExampleObject
	with the given value to the address of the object signer.
	Get the object's address:
	Get the object's address:
	Get the object's address:
	<code>let address_object = object::address_from_constructor_ref(example_object_constructor_ref);</code>
	<code>let address_object = object::address_from_constructor_ref(example_object_constructor_ref);</code>
	let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
	Finally, the function retrieves the address of the created object using the constructor reference and prints it.
	Finally, the function retrieves the address of the created object using the constructor reference and prints it.
	<code>[debug] @0x1 // Address Signer
[debug] 0x1::object::ConstructorRef { // Create address object
  self: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a,
  can_delete: true
}
[debug] signer(@0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a) // signer
[debug] @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a</code>
	<code>[debug] @0x1 // Address Signer
[debug] 0x1::object::ConstructorRef { // Create address object
  self: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a,
  can_delete: true
}
[debug] signer(@0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a) // signer
[debug] @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a</code>
	[debug] @0x1 // Address Signer
[debug] 0x1::object::ConstructorRef { // Create address object
  self: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a,
  can_delete: true
}
[debug] signer(@0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a) // signer
[debug] @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
	Additionally, instead of retrieving the object's address, you can also directly obtain the object through this function:
	Additionally, instead of retrieving the object's address, you can also directly obtain the object through this function:
	Additionally, instead of retrieving the object's address, you can also directly obtain the object through this function:
	<code>let object_info = object::object_from_constructor_ref<ExampleObject>(example_object_constructor_ref);</code>
	<code>let object_info = object::object_from_constructor_ref<ExampleObject>(example_object_constructor_ref);</code>
	let object_info = object::object_from_constructor_ref<ExampleObject>(example_object_constructor_ref);
	Finally, the test results will return additional inner objects of that struct:
	Finally, the test results will return additional inner objects of that struct:
	<code>[debug] 0x1::object::Object<0x6f409ba3234fa3b9a8baf7d442709ef51f39284f35dd7c06360fa0b55a0cd690::object_module_entry::ExampleObject> {
  inner: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
}</code>
	<code>[debug] 0x1::object::Object<0x6f409ba3234fa3b9a8baf7d442709ef51f39284f35dd7c06360fa0b55a0cd690::object_module_entry::ExampleObject> {
  inner: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
}</code>
	[debug] 0x1::object::Object<0x6f409ba3234fa3b9a8baf7d442709ef51f39284f35dd7c06360fa0b55a0cd690::object_module_entry::ExampleObject> {
  inner: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
}
	In addition to the
object::create_object
function, we have other functions to create objects:
	In addition to the
	<code>object::create_object</code>
	object::create_object
	function, we have other functions to create objects:
	object::create_object
: A
normal Object |
This type is
deletable
and has a
random address
object::create_named_object
: A
named Object |
This type is **
not** deletable
and has a
deterministic address
object::create_sticky_object
: A
sticky Object |
This type is also **
not** deletable
and has a
random address
	object::create_object
: A
normal Object |
This type is
deletable
and has a
random address
	<code>object::create_object</code>
	object::create_object
	: A
	normal Object |
	normal Object |
	This type is
	<code>deletable</code>
	deletable
	and has a
	<code>random address</code>
	random address
	object::create_named_object
: A
named Object |
This type is **
not** deletable
and has a
deterministic address
	<code>object::create_named_object</code>
	object::create_named_object
	: A
	named Object |
	named Object |
	This type is **
	<code>not** deletable</code>
	not** deletable
	and has a
	<code>deterministic address</code>
	deterministic address
	object::create_sticky_object
: A
sticky Object |
This type is also **
not** deletable
and has a
random address
	<code>object::create_sticky_object</code>
	object::create_sticky_object
	: A
	sticky Object |
	sticky Object |
	This type is also **
	<code>not** deletable</code>
	not** deletable
	and has a
	<code>random address</code>
	random address

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/07-objects/03-object-permissions-objectrefs
Object Permissions
Object Permissions
On This Page
Summary
Understanding ObjectRefs in Move
What are ObjectRefs?
Types of ObjectRefs
Practical Application
Summary
ObjectRefs are permissions for object management in Move
Three types:
ExtendRef
,
TransferRef
, and
DeleteRef
ExtendRef
allows signer generation after object creation
TransferRef
enables object transfer without owner's signer
DeleteRef
is used for object deletion
ObjectRefs are generated from
ConstructorRef
during object creation
Practical example demonstrates generating and storing refs
Understanding ObjectRefs is crucial for effective object management in Move
Understanding ObjectRefs in Move
In this tutorial, we'll explore ObjectRefs, which are crucial for managing objects in Move. We'll cover three types of ObjectRefs and their uses.
What are ObjectRefs?
ObjectRefs are permissions or capabilities for object management, generated from ConstructorRef during object creation. They're different from Object references.
Types of ObjectRefs
ExtendRef:
Allows signer generation after object creation.
Can be stored for future use
Offers more flexibility than ConstructorRef
TransferRef:
Enables object transfer without owner's signer.
Can transfer object to a different address
Can 'freeze' an object, preventing further transfers
DeleteRef:
Used for object deletion.
Can be stored
One-time use capability
Practical Application
In the next section, we'll walk through a step-by-step example of generating and storing these refs. This hands-on approach will help solidify your understanding of ObjectRefs and their practical uses in Move programming.
use aptos_framework::object::{Self, Object, ExtendRef, DeleteRef, TransferRef};
const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10,
        extend_ref: object::generate_extend_ref(state_object_constructor_ref),
        transfer_ref: object::generate_transfer_ref(state_object_constructor_ref),
        delete_ref: object::generate_delete_ref(state_object_constructor_ref)
    });
}
On This Page
Summary
Understanding ObjectRefs in Move
What are ObjectRefs?
Types of ObjectRefs
Practical Application
On This Page
Summary
Understanding ObjectRefs in Move
What are ObjectRefs?
Types of ObjectRefs
Practical Application
			On This Page
			On This Page
			Summary
Understanding ObjectRefs in Move
What are ObjectRefs?
Types of ObjectRefs
Practical Application
			Summary
			Summary
			Summary
			Summary
			Understanding ObjectRefs in Move
What are ObjectRefs?
Types of ObjectRefs
Practical Application
			Understanding ObjectRefs in Move
			Understanding ObjectRefs in Move
			Understanding ObjectRefs in Move
			What are ObjectRefs?
Types of ObjectRefs
Practical Application
			What are ObjectRefs?
			What are ObjectRefs?
			What are ObjectRefs?
			What are ObjectRefs?
			Types of ObjectRefs
			Types of ObjectRefs
			Types of ObjectRefs
			Types of ObjectRefs
			Practical Application
			Practical Application
			Practical Application
			Practical Application
			Summary
ObjectRefs are permissions for object management in Move
Three types:
ExtendRef
,
TransferRef
, and
DeleteRef
ExtendRef
allows signer generation after object creation
TransferRef
enables object transfer without owner's signer
DeleteRef
is used for object deletion
ObjectRefs are generated from
ConstructorRef
during object creation
Practical example demonstrates generating and storing refs
Understanding ObjectRefs is crucial for effective object management in Move
Understanding ObjectRefs in Move
In this tutorial, we'll explore ObjectRefs, which are crucial for managing objects in Move. We'll cover three types of ObjectRefs and their uses.
What are ObjectRefs?
ObjectRefs are permissions or capabilities for object management, generated from ConstructorRef during object creation. They're different from Object references.
Types of ObjectRefs
ExtendRef:
Allows signer generation after object creation.
Can be stored for future use
Offers more flexibility than ConstructorRef
TransferRef:
Enables object transfer without owner's signer.
Can transfer object to a different address
Can 'freeze' an object, preventing further transfers
DeleteRef:
Used for object deletion.
Can be stored
One-time use capability
Practical Application
In the next section, we'll walk through a step-by-step example of generating and storing these refs. This hands-on approach will help solidify your understanding of ObjectRefs and their practical uses in Move programming.
use aptos_framework::object::{Self, Object, ExtendRef, DeleteRef, TransferRef};
const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10,
        extend_ref: object::generate_extend_ref(state_object_constructor_ref),
        transfer_ref: object::generate_transfer_ref(state_object_constructor_ref),
        delete_ref: object::generate_delete_ref(state_object_constructor_ref)
    });
}
			Summary
ObjectRefs are permissions for object management in Move
Three types:
ExtendRef
,
TransferRef
, and
DeleteRef
ExtendRef
allows signer generation after object creation
TransferRef
enables object transfer without owner's signer
DeleteRef
is used for object deletion
ObjectRefs are generated from
ConstructorRef
during object creation
Practical example demonstrates generating and storing refs
Understanding ObjectRefs is crucial for effective object management in Move
Understanding ObjectRefs in Move
In this tutorial, we'll explore ObjectRefs, which are crucial for managing objects in Move. We'll cover three types of ObjectRefs and their uses.
What are ObjectRefs?
ObjectRefs are permissions or capabilities for object management, generated from ConstructorRef during object creation. They're different from Object references.
Types of ObjectRefs
ExtendRef:
Allows signer generation after object creation.
Can be stored for future use
Offers more flexibility than ConstructorRef
TransferRef:
Enables object transfer without owner's signer.
Can transfer object to a different address
Can 'freeze' an object, preventing further transfers
DeleteRef:
Used for object deletion.
Can be stored
One-time use capability
Practical Application
In the next section, we'll walk through a step-by-step example of generating and storing these refs. This hands-on approach will help solidify your understanding of ObjectRefs and their practical uses in Move programming.
use aptos_framework::object::{Self, Object, ExtendRef, DeleteRef, TransferRef};
const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10,
        extend_ref: object::generate_extend_ref(state_object_constructor_ref),
        transfer_ref: object::generate_transfer_ref(state_object_constructor_ref),
        delete_ref: object::generate_delete_ref(state_object_constructor_ref)
    });
}
			Summary
ObjectRefs are permissions for object management in Move
Three types:
ExtendRef
,
TransferRef
, and
DeleteRef
ExtendRef
allows signer generation after object creation
TransferRef
enables object transfer without owner's signer
DeleteRef
is used for object deletion
ObjectRefs are generated from
ConstructorRef
during object creation
Practical example demonstrates generating and storing refs
Understanding ObjectRefs is crucial for effective object management in Move
Understanding ObjectRefs in Move
In this tutorial, we'll explore ObjectRefs, which are crucial for managing objects in Move. We'll cover three types of ObjectRefs and their uses.
What are ObjectRefs?
ObjectRefs are permissions or capabilities for object management, generated from ConstructorRef during object creation. They're different from Object references.
Types of ObjectRefs
ExtendRef:
Allows signer generation after object creation.
Can be stored for future use
Offers more flexibility than ConstructorRef
TransferRef:
Enables object transfer without owner's signer.
Can transfer object to a different address
Can 'freeze' an object, preventing further transfers
DeleteRef:
Used for object deletion.
Can be stored
One-time use capability
Practical Application
In the next section, we'll walk through a step-by-step example of generating and storing these refs. This hands-on approach will help solidify your understanding of ObjectRefs and their practical uses in Move programming.
use aptos_framework::object::{Self, Object, ExtendRef, DeleteRef, TransferRef};
const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10,
        extend_ref: object::generate_extend_ref(state_object_constructor_ref),
        transfer_ref: object::generate_transfer_ref(state_object_constructor_ref),
        delete_ref: object::generate_delete_ref(state_object_constructor_ref)
    });
}
	Summary
	Summary
	ObjectRefs are permissions for object management in Move
Three types:
ExtendRef
,
TransferRef
, and
DeleteRef
ExtendRef
allows signer generation after object creation
TransferRef
enables object transfer without owner's signer
DeleteRef
is used for object deletion
ObjectRefs are generated from
ConstructorRef
during object creation
Practical example demonstrates generating and storing refs
Understanding ObjectRefs is crucial for effective object management in Move
	ObjectRefs are permissions for object management in Move
	ObjectRefs are permissions for object management in Move
	Three types:
ExtendRef
,
TransferRef
, and
DeleteRef
	Three types:
	<code>ExtendRef</code>
	ExtendRef
	,
	<code>TransferRef</code>
	TransferRef
	, and
	<code>DeleteRef</code>
	DeleteRef
	ExtendRef
allows signer generation after object creation
	<code>ExtendRef</code>
	ExtendRef
	allows signer generation after object creation
	TransferRef
enables object transfer without owner's signer
	<code>TransferRef</code>
	TransferRef
	enables object transfer without owner's signer
	DeleteRef
is used for object deletion
	<code>DeleteRef</code>
	DeleteRef
	is used for object deletion
	ObjectRefs are generated from
ConstructorRef
during object creation
	ObjectRefs are generated from
	<code>ConstructorRef</code>
	ConstructorRef
	during object creation
	Practical example demonstrates generating and storing refs
	Practical example demonstrates generating and storing refs
	Understanding ObjectRefs is crucial for effective object management in Move
	Understanding ObjectRefs is crucial for effective object management in Move
	Understanding ObjectRefs in Move
	Understanding ObjectRefs in Move
	In this tutorial, we'll explore ObjectRefs, which are crucial for managing objects in Move. We'll cover three types of ObjectRefs and their uses.
	In this tutorial, we'll explore ObjectRefs, which are crucial for managing objects in Move. We'll cover three types of ObjectRefs and their uses.
		What are ObjectRefs?
		What are ObjectRefs?
		ObjectRefs are permissions or capabilities for object management, generated from ConstructorRef during object creation. They're different from Object references.
		ObjectRefs are permissions or capabilities for object management, generated from ConstructorRef during object creation. They're different from Object references.
		Types of ObjectRefs
		Types of ObjectRefs
		ExtendRef:
Allows signer generation after object creation.
Can be stored for future use
Offers more flexibility than ConstructorRef
TransferRef:
Enables object transfer without owner's signer.
Can transfer object to a different address
Can 'freeze' an object, preventing further transfers
DeleteRef:
Used for object deletion.
Can be stored
One-time use capability
		ExtendRef:
Allows signer generation after object creation.
Can be stored for future use
Offers more flexibility than ConstructorRef
		ExtendRef:
		ExtendRef:
		Allows signer generation after object creation.
		Can be stored for future use
Offers more flexibility than ConstructorRef
		Can be stored for future use
		Can be stored for future use
		Offers more flexibility than ConstructorRef
		Offers more flexibility than ConstructorRef
		TransferRef:
Enables object transfer without owner's signer.
Can transfer object to a different address
Can 'freeze' an object, preventing further transfers
		TransferRef:
		TransferRef:
		Enables object transfer without owner's signer.
		Can transfer object to a different address
Can 'freeze' an object, preventing further transfers
		Can transfer object to a different address
		Can transfer object to a different address
		Can 'freeze' an object, preventing further transfers
		Can 'freeze' an object, preventing further transfers
		DeleteRef:
Used for object deletion.
Can be stored
One-time use capability
		DeleteRef:
		DeleteRef:
		Used for object deletion.
		Can be stored
One-time use capability
		Can be stored
		Can be stored
		One-time use capability
		One-time use capability
		Practical Application
		Practical Application
		In the next section, we'll walk through a step-by-step example of generating and storing these refs. This hands-on approach will help solidify your understanding of ObjectRefs and their practical uses in Move programming.
		In the next section, we'll walk through a step-by-step example of generating and storing these refs. This hands-on approach will help solidify your understanding of ObjectRefs and their practical uses in Move programming.
		<code>use aptos_framework::object::{Self, Object, ExtendRef, DeleteRef, TransferRef};</code>
		<code>use aptos_framework::object::{Self, Object, ExtendRef, DeleteRef, TransferRef};</code>
		use aptos_framework::object::{Self, Object, ExtendRef, DeleteRef, TransferRef};
		<code>const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10,
        extend_ref: object::generate_extend_ref(state_object_constructor_ref),
        transfer_ref: object::generate_transfer_ref(state_object_constructor_ref),
        delete_ref: object::generate_delete_ref(state_object_constructor_ref)
    });
}</code>
		<code>const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10,
        extend_ref: object::generate_extend_ref(state_object_constructor_ref),
        transfer_ref: object::generate_transfer_ref(state_object_constructor_ref),
        delete_ref: object::generate_delete_ref(state_object_constructor_ref)
    });
}</code>
		const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10,
        extend_ref: object::generate_extend_ref(state_object_constructor_ref),
        transfer_ref: object::generate_transfer_ref(state_object_constructor_ref),
        delete_ref: object::generate_delete_ref(state_object_constructor_ref)
    });
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/07-objects/04-named-objects
Named Objects
Named Objects
On This Page
Summary
Named Object
Modify & Retrieve Object Value
Full Code
Function Descriptions
1. init_module(owner: &signer)
2. get_object_address(owner: address): address
3. get_value(owner: address): u64
4. set_value(owner: address, new_value: u64)
Test Functions
Summary
Named objects in Move allow for easy retrieval and manipulation of object data
The module demonstrates creation, retrieval, and modification of a Object
Named objects use a fixed address, making them more convenient than default or sticky objects
The module includes test functions to verify correct behavior of main functions
Global storage methods like
borrow_global
and
borrow_global_mut
are used to access object data
Named Object
In the previous section, we learned about three types of Objects, among which named objects will likely be the type we use most often because we can initialize an object address that is fixed and can be easily retrieved through the Object Name Address. As for default objects and sticky objects, both create a random address. This makes it difficult to use them for querying or listing information, but they also have their uses in certain cases.
In this section, we will use named objects to easily obtain the address for storing an object.
module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let owner = address_of(account);
        let addr = get_object_address(owner);
        print(&addr);
    }
}
[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622 // Object Address
By using named objects, we can easily access the object and perform changes or view data.
Modify & Retrieve Object Value
To modify and retrieve data from objects, we still use global storage methods like
borrow_global
and
borrow_global_mut
.
public fun get_value(owner: address): u64 acquires MovementObject {
    borrow_global<MovementObject>(get_object_address(owner)).value
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
    spider_dna.value = new_value;
}
Full Code
module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
        spider_dna.value = new_value;
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
Function Descriptions
1. init_module(owner: &signer)
This function initializes the module by creating a named object and setting its initial value.
Creates a named object using
object::create_named_object
Generates a signer for the object using
object::generate_signer
Moves a
MovementObject
with an initial value of 10 to the object's address
2. get_object_address(owner: address): address
This function retrieves the address of the named object for a given owner.
Uses
object::create_object_address
to calculate the object's address
Returns the calculated address
3. get_value(owner: address): u64
This function retrieves the current value stored in the MovementObject for a given owner.
Calls
get_object_address
to get the object's address
Uses
borrow_global
to access the MovementObject at the calculated address
Returns the
value
field from the MovementObject
4. set_value(owner: address, new_value: u64)
This function updates the value stored in the MovementObject for a given owner.
Calls
get_object_address
to get the object's address
Uses
borrow_global_mut
to get a mutable reference to the MovementObject
Updates the
value
field with the new value
Test Functions
The module includes several test functions to verify the correct behavior of the main functions:
test_init_module
: Initializes the module for testing
test_get_object_address
: Tests the
get_object_address
function
test_get_object
: Tests the
get_value
function
test_set_object
: Tests the
set_value
function
On This Page
Summary
Named Object
Modify & Retrieve Object Value
Full Code
Function Descriptions
1. init_module(owner: &signer)
2. get_object_address(owner: address): address
3. get_value(owner: address): u64
4. set_value(owner: address, new_value: u64)
Test Functions
On This Page
Summary
Named Object
Modify & Retrieve Object Value
Full Code
Function Descriptions
1. init_module(owner: &signer)
2. get_object_address(owner: address): address
3. get_value(owner: address): u64
4. set_value(owner: address, new_value: u64)
Test Functions
			On This Page
			On This Page
			Summary
Named Object
Modify & Retrieve Object Value
Full Code
Function Descriptions
1. init_module(owner: &signer)
2. get_object_address(owner: address): address
3. get_value(owner: address): u64
4. set_value(owner: address, new_value: u64)
Test Functions
			Summary
			Summary
			Summary
			Summary
			Named Object
Modify & Retrieve Object Value
			Named Object
			Named Object
			Named Object
			Modify & Retrieve Object Value
			Modify & Retrieve Object Value
			Modify & Retrieve Object Value
			Modify & Retrieve Object Value
			Modify & Retrieve Object Value
			Full Code
			Full Code
			Full Code
			Full Code
			Function Descriptions
1. init_module(owner: &signer)
2. get_object_address(owner: address): address
3. get_value(owner: address): u64
4. set_value(owner: address, new_value: u64)
Test Functions
			Function Descriptions
			Function Descriptions
			Function Descriptions
			1. init_module(owner: &signer)
2. get_object_address(owner: address): address
3. get_value(owner: address): u64
4. set_value(owner: address, new_value: u64)
Test Functions
			1. init_module(owner: &signer)
			1. init_module(owner: &signer)
			1. init_module(owner: &signer)
			1. init_module(owner: &signer)
			2. get_object_address(owner: address): address
			2. get_object_address(owner: address): address
			2. get_object_address(owner: address): address
			2. get_object_address(owner: address): address
			3. get_value(owner: address): u64
			3. get_value(owner: address): u64
			3. get_value(owner: address): u64
			3. get_value(owner: address): u64
			4. set_value(owner: address, new_value: u64)
			4. set_value(owner: address, new_value: u64)
			4. set_value(owner: address, new_value: u64)
			4. set_value(owner: address, new_value: u64)
			Test Functions
			Test Functions
			Test Functions
			Test Functions
			Summary
Named objects in Move allow for easy retrieval and manipulation of object data
The module demonstrates creation, retrieval, and modification of a Object
Named objects use a fixed address, making them more convenient than default or sticky objects
The module includes test functions to verify correct behavior of main functions
Global storage methods like
borrow_global
and
borrow_global_mut
are used to access object data
Named Object
In the previous section, we learned about three types of Objects, among which named objects will likely be the type we use most often because we can initialize an object address that is fixed and can be easily retrieved through the Object Name Address. As for default objects and sticky objects, both create a random address. This makes it difficult to use them for querying or listing information, but they also have their uses in certain cases.
In this section, we will use named objects to easily obtain the address for storing an object.
module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let owner = address_of(account);
        let addr = get_object_address(owner);
        print(&addr);
    }
}
[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622 // Object Address
By using named objects, we can easily access the object and perform changes or view data.
Modify & Retrieve Object Value
To modify and retrieve data from objects, we still use global storage methods like
borrow_global
and
borrow_global_mut
.
public fun get_value(owner: address): u64 acquires MovementObject {
    borrow_global<MovementObject>(get_object_address(owner)).value
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
    spider_dna.value = new_value;
}
Full Code
module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
        spider_dna.value = new_value;
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
Function Descriptions
1. init_module(owner: &signer)
This function initializes the module by creating a named object and setting its initial value.
Creates a named object using
object::create_named_object
Generates a signer for the object using
object::generate_signer
Moves a
MovementObject
with an initial value of 10 to the object's address
2. get_object_address(owner: address): address
This function retrieves the address of the named object for a given owner.
Uses
object::create_object_address
to calculate the object's address
Returns the calculated address
3. get_value(owner: address): u64
This function retrieves the current value stored in the MovementObject for a given owner.
Calls
get_object_address
to get the object's address
Uses
borrow_global
to access the MovementObject at the calculated address
Returns the
value
field from the MovementObject
4. set_value(owner: address, new_value: u64)
This function updates the value stored in the MovementObject for a given owner.
Calls
get_object_address
to get the object's address
Uses
borrow_global_mut
to get a mutable reference to the MovementObject
Updates the
value
field with the new value
Test Functions
The module includes several test functions to verify the correct behavior of the main functions:
test_init_module
: Initializes the module for testing
test_get_object_address
: Tests the
get_object_address
function
test_get_object
: Tests the
get_value
function
test_set_object
: Tests the
set_value
function
			Summary
Named objects in Move allow for easy retrieval and manipulation of object data
The module demonstrates creation, retrieval, and modification of a Object
Named objects use a fixed address, making them more convenient than default or sticky objects
The module includes test functions to verify correct behavior of main functions
Global storage methods like
borrow_global
and
borrow_global_mut
are used to access object data
Named Object
In the previous section, we learned about three types of Objects, among which named objects will likely be the type we use most often because we can initialize an object address that is fixed and can be easily retrieved through the Object Name Address. As for default objects and sticky objects, both create a random address. This makes it difficult to use them for querying or listing information, but they also have their uses in certain cases.
In this section, we will use named objects to easily obtain the address for storing an object.
module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let owner = address_of(account);
        let addr = get_object_address(owner);
        print(&addr);
    }
}
[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622 // Object Address
By using named objects, we can easily access the object and perform changes or view data.
Modify & Retrieve Object Value
To modify and retrieve data from objects, we still use global storage methods like
borrow_global
and
borrow_global_mut
.
public fun get_value(owner: address): u64 acquires MovementObject {
    borrow_global<MovementObject>(get_object_address(owner)).value
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
    spider_dna.value = new_value;
}
Full Code
module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
        spider_dna.value = new_value;
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
Function Descriptions
1. init_module(owner: &signer)
This function initializes the module by creating a named object and setting its initial value.
Creates a named object using
object::create_named_object
Generates a signer for the object using
object::generate_signer
Moves a
MovementObject
with an initial value of 10 to the object's address
2. get_object_address(owner: address): address
This function retrieves the address of the named object for a given owner.
Uses
object::create_object_address
to calculate the object's address
Returns the calculated address
3. get_value(owner: address): u64
This function retrieves the current value stored in the MovementObject for a given owner.
Calls
get_object_address
to get the object's address
Uses
borrow_global
to access the MovementObject at the calculated address
Returns the
value
field from the MovementObject
4. set_value(owner: address, new_value: u64)
This function updates the value stored in the MovementObject for a given owner.
Calls
get_object_address
to get the object's address
Uses
borrow_global_mut
to get a mutable reference to the MovementObject
Updates the
value
field with the new value
Test Functions
The module includes several test functions to verify the correct behavior of the main functions:
test_init_module
: Initializes the module for testing
test_get_object_address
: Tests the
get_object_address
function
test_get_object
: Tests the
get_value
function
test_set_object
: Tests the
set_value
function
			Summary
Named objects in Move allow for easy retrieval and manipulation of object data
The module demonstrates creation, retrieval, and modification of a Object
Named objects use a fixed address, making them more convenient than default or sticky objects
The module includes test functions to verify correct behavior of main functions
Global storage methods like
borrow_global
and
borrow_global_mut
are used to access object data
Named Object
In the previous section, we learned about three types of Objects, among which named objects will likely be the type we use most often because we can initialize an object address that is fixed and can be easily retrieved through the Object Name Address. As for default objects and sticky objects, both create a random address. This makes it difficult to use them for querying or listing information, but they also have their uses in certain cases.
In this section, we will use named objects to easily obtain the address for storing an object.
module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let owner = address_of(account);
        let addr = get_object_address(owner);
        print(&addr);
    }
}
[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622 // Object Address
By using named objects, we can easily access the object and perform changes or view data.
Modify & Retrieve Object Value
To modify and retrieve data from objects, we still use global storage methods like
borrow_global
and
borrow_global_mut
.
public fun get_value(owner: address): u64 acquires MovementObject {
    borrow_global<MovementObject>(get_object_address(owner)).value
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
    spider_dna.value = new_value;
}
Full Code
module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
        spider_dna.value = new_value;
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
Function Descriptions
1. init_module(owner: &signer)
This function initializes the module by creating a named object and setting its initial value.
Creates a named object using
object::create_named_object
Generates a signer for the object using
object::generate_signer
Moves a
MovementObject
with an initial value of 10 to the object's address
2. get_object_address(owner: address): address
This function retrieves the address of the named object for a given owner.
Uses
object::create_object_address
to calculate the object's address
Returns the calculated address
3. get_value(owner: address): u64
This function retrieves the current value stored in the MovementObject for a given owner.
Calls
get_object_address
to get the object's address
Uses
borrow_global
to access the MovementObject at the calculated address
Returns the
value
field from the MovementObject
4. set_value(owner: address, new_value: u64)
This function updates the value stored in the MovementObject for a given owner.
Calls
get_object_address
to get the object's address
Uses
borrow_global_mut
to get a mutable reference to the MovementObject
Updates the
value
field with the new value
Test Functions
The module includes several test functions to verify the correct behavior of the main functions:
test_init_module
: Initializes the module for testing
test_get_object_address
: Tests the
get_object_address
function
test_get_object
: Tests the
get_value
function
test_set_object
: Tests the
set_value
function
	Summary
	Summary
	Named objects in Move allow for easy retrieval and manipulation of object data
The module demonstrates creation, retrieval, and modification of a Object
Named objects use a fixed address, making them more convenient than default or sticky objects
The module includes test functions to verify correct behavior of main functions
Global storage methods like
borrow_global
and
borrow_global_mut
are used to access object data
	Named objects in Move allow for easy retrieval and manipulation of object data
	Named objects in Move allow for easy retrieval and manipulation of object data
	The module demonstrates creation, retrieval, and modification of a Object
	The module demonstrates creation, retrieval, and modification of a Object
	Named objects use a fixed address, making them more convenient than default or sticky objects
	Named objects use a fixed address, making them more convenient than default or sticky objects
	The module includes test functions to verify correct behavior of main functions
	The module includes test functions to verify correct behavior of main functions
	Global storage methods like
borrow_global
and
borrow_global_mut
are used to access object data
	Global storage methods like
	<code>borrow_global</code>
	borrow_global
	and
	<code>borrow_global_mut</code>
	borrow_global_mut
	are used to access object data
	Named Object
	Named Object
	In the previous section, we learned about three types of Objects, among which named objects will likely be the type we use most often because we can initialize an object address that is fixed and can be easily retrieved through the Object Name Address. As for default objects and sticky objects, both create a random address. This makes it difficult to use them for querying or listing information, but they also have their uses in certain cases.
	In the previous section, we learned about three types of Objects, among which named objects will likely be the type we use most often because we can initialize an object address that is fixed and can be easily retrieved through the Object Name Address. As for default objects and sticky objects, both create a random address. This makes it difficult to use them for querying or listing information, but they also have their uses in certain cases.
	In this section, we will use named objects to easily obtain the address for storing an object.
	In this section, we will use named objects to easily obtain the address for storing an object.
	<code>module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let owner = address_of(account);
        let addr = get_object_address(owner);
        print(&addr);
    }
}</code>
	<code>module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let owner = address_of(account);
        let addr = get_object_address(owner);
        print(&addr);
    }
}</code>
	module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let owner = address_of(account);
        let addr = get_object_address(owner);
        print(&addr);
    }
}
	<code>[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622 // Object Address</code>
	<code>[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622 // Object Address</code>
	[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622 // Object Address
	By using named objects, we can easily access the object and perform changes or view data.
	By using named objects, we can easily access the object and perform changes or view data.
		Modify & Retrieve Object Value
		Modify & Retrieve Object Value
		To modify and retrieve data from objects, we still use global storage methods like
borrow_global
and
borrow_global_mut
.
		To modify and retrieve data from objects, we still use global storage methods like
		<code>borrow_global</code>
		borrow_global
		and
		<code>borrow_global_mut</code>
		borrow_global_mut
		.
		<code>public fun get_value(owner: address): u64 acquires MovementObject {
    borrow_global<MovementObject>(get_object_address(owner)).value
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
    spider_dna.value = new_value;
}</code>
		<code>public fun get_value(owner: address): u64 acquires MovementObject {
    borrow_global<MovementObject>(get_object_address(owner)).value
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
    spider_dna.value = new_value;
}</code>
		public fun get_value(owner: address): u64 acquires MovementObject {
    borrow_global<MovementObject>(get_object_address(owner)).value
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
    spider_dna.value = new_value;
}
	Full Code
	Full Code
	<code>module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
        spider_dna.value = new_value;
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}</code>
	<code>module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
        spider_dna.value = new_value;
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}</code>
	module movement::object_module_entry {
    use aptos_framework::object;
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
        spider_dna.value = new_value;
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
	Function Descriptions
	Function Descriptions
		1. init_module(owner: &signer)
		1. init_module(owner: &signer)
		This function initializes the module by creating a named object and setting its initial value.
		This function initializes the module by creating a named object and setting its initial value.
		Creates a named object using
object::create_named_object
Generates a signer for the object using
object::generate_signer
Moves a
MovementObject
with an initial value of 10 to the object's address
		Creates a named object using
object::create_named_object
		Creates a named object using
		<code>object::create_named_object</code>
		object::create_named_object
		Generates a signer for the object using
object::generate_signer
		Generates a signer for the object using
		<code>object::generate_signer</code>
		object::generate_signer
		Moves a
MovementObject
with an initial value of 10 to the object's address
		Moves a
		<code>MovementObject</code>
		MovementObject
		with an initial value of 10 to the object's address
		2. get_object_address(owner: address): address
		2. get_object_address(owner: address): address
		This function retrieves the address of the named object for a given owner.
		This function retrieves the address of the named object for a given owner.
		Uses
object::create_object_address
to calculate the object's address
Returns the calculated address
		Uses
object::create_object_address
to calculate the object's address
		Uses
		<code>object::create_object_address</code>
		object::create_object_address
		to calculate the object's address
		Returns the calculated address
		Returns the calculated address
		3. get_value(owner: address): u64
		3. get_value(owner: address): u64
		This function retrieves the current value stored in the MovementObject for a given owner.
		This function retrieves the current value stored in the MovementObject for a given owner.
		Calls
get_object_address
to get the object's address
Uses
borrow_global
to access the MovementObject at the calculated address
Returns the
value
field from the MovementObject
		Calls
get_object_address
to get the object's address
		Calls
		<code>get_object_address</code>
		get_object_address
		to get the object's address
		Uses
borrow_global
to access the MovementObject at the calculated address
		Uses
		<code>borrow_global</code>
		borrow_global
		to access the MovementObject at the calculated address
		Returns the
value
field from the MovementObject
		Returns the
		<code>value</code>
		value
		field from the MovementObject
		4. set_value(owner: address, new_value: u64)
		4. set_value(owner: address, new_value: u64)
		This function updates the value stored in the MovementObject for a given owner.
		This function updates the value stored in the MovementObject for a given owner.
		Calls
get_object_address
to get the object's address
Uses
borrow_global_mut
to get a mutable reference to the MovementObject
Updates the
value
field with the new value
		Calls
get_object_address
to get the object's address
		Calls
		<code>get_object_address</code>
		get_object_address
		to get the object's address
		Uses
borrow_global_mut
to get a mutable reference to the MovementObject
		Uses
		<code>borrow_global_mut</code>
		borrow_global_mut
		to get a mutable reference to the MovementObject
		Updates the
value
field with the new value
		Updates the
		<code>value</code>
		value
		field with the new value
		Test Functions
		Test Functions
		The module includes several test functions to verify the correct behavior of the main functions:
		The module includes several test functions to verify the correct behavior of the main functions:
		test_init_module
: Initializes the module for testing
test_get_object_address
: Tests the
get_object_address
function
test_get_object
: Tests the
get_value
function
test_set_object
: Tests the
set_value
function
		test_init_module
: Initializes the module for testing
		<code>test_init_module</code>
		test_init_module
		: Initializes the module for testing
		test_get_object_address
: Tests the
get_object_address
function
		<code>test_get_object_address</code>
		test_get_object_address
		: Tests the
		<code>get_object_address</code>
		get_object_address
		function
		test_get_object
: Tests the
get_value
function
		<code>test_get_object</code>
		test_get_object
		: Tests the
		<code>get_value</code>
		get_value
		function
		test_set_object
: Tests the
set_value
function
		<code>test_set_object</code>
		test_set_object
		: Tests the
		<code>set_value</code>
		set_value
		function

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/07-objects/05-using-transferref
Using TransferRef
Using TransferRef
On This Page
Transferring Objects Without the Owner's Signer
Implementing Controlled Transfers
Conclusion
Summary
TransferRef provides an alternative method for object transfer without the owner's signer.
Objects can be frozen or unfrozen using
disable_ungated_transfer
and
enable_ungated_transfer
.
LinearTransferRef allows for controlled, one-time transfers of objects.
TransferRef
is a capability that gives you fine-grained control over object transfers. It allows you to:
Enable or disable transfers
Implement controlled transfers
Transfer objects without the owner's signer
Transferring Objects Without the Owner's Signer
While ExtendRef allows for transfer functions without the owner's signer, TransferRef offers an alternative method for object transfer.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref
    });
}
We can then use
transfer_with_ref
to execute the object transfer:
public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
    let object_signer = object::generate_linear_transfer_ref(transfer_ref);
    object::transfer_with_ref(object_signer, new_owner);
}
Freezing and Unfreezing Objects
A key feature of TransferRef in real-world projects is managing object transferability. We can freeze or unfreeze specific objects, which is particularly useful for protecting an object or using it for a specific purpose.
fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::disable_ungated_transfer(transfer_ref);
}
fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::enable_ungated_transfer(transfer_ref);
}
Let's break down the process of using TransferRef for object transfer:
Create a TransferRef:
In the
init_module
function, generate a TransferRef using
object::generate_transfer_ref(state_object_constructor_ref)
.
Store the TransferRef:
Store this TransferRef in the ControllerObject struct, then move it to the object's address.
Implement the transfer function:
In the
transfer_new_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Generate a linear transfer ref using
object::generate_linear_transfer_ref(transfer_ref)
.
c. Use
object::transfer_with_ref
to transfer the object to the new owner.
Freezing an object:
To disable transfers, use the
freeze_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Call
object::disable_ungated_transfer(transfer_ref)
to freeze the object.
Unfreezing an object:
To re-enable transfers, use the
unfreeze_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Call
object::enable_ungated_transfer(transfer_ref)
to unfreeze the object.
By following these steps, you can effectively manage object transfers and control their transferability using TransferRef.
Implementing Controlled Transfers
For more precise control over transfers, you can use LinearTransferRef:
linear_transfer_ref: Option&lt;LinearTransferRef&gt;
implements a controlled transfer mechanism for objects in Aptos Move. Here's a breakdown:
LinearTransferRef
:
A special type of transfer reference in Aptos Move.
Allows for a single, one-time transfer of an object.
Once used, the
LinearTransferRef
is consumed and cannot be reused.
Option<LinearTransferRef>
:
Option
is a Move type that allows a value to either exist or not.
Using
Option
represents the state of the
LinearTransferRef
: either present (Some) or absent (None).
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ObjectController has key {
    transfer_ref: TransferRef,
    linear_transfer_ref: Option<LinearTransferRef>,
}
fun allow_single_transfer(object: Object<ObjectController>) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = object::generate_linear_transfer_ref(&controller.transfer_ref);
    option::fill(&mut controller.linear_transfer_ref, linear_transfer_ref);
}
fun transfer(owner: &signer, object: Object<ObjectController>, new_owner: address) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = option::extract(&mut controller.linear_transfer_ref);
    object::transfer_with_ref(linear_transfer_ref, new_owner);
}
Purpose of use:
Transfer Control:
Using
Option&lt;LinearTransferRef&gt;
controls when transfers are allowed.
When
linear_transfer_ref
is
None
, no transfer can occur.
When it's
Some(LinearTransferRef)
, a single transfer can be executed.
One-time Transfer:
Each
LinearTransferRef
can only be used once.
After use, it's consumed, and
linear_transfer_ref
returns to the
None
state.
Security and Control:
This mechanism enables implementation of complex transfer policies.
For example, allowing transfers only under specific conditions or within a certain timeframe.
Conclusion
TransferRef is a powerful tool in Aptos Move that provides fine-grained control over object transfers. By leveraging TransferRef, you can implement sophisticated transfer logic, enhance security, and create more flexible smart contracts.
Always consider the security implications when implementing transfer logic, and thoroughly test your code before deployment.
On This Page
Transferring Objects Without the Owner's Signer
Implementing Controlled Transfers
Conclusion
On This Page
Transferring Objects Without the Owner's Signer
Implementing Controlled Transfers
Conclusion
			On This Page
			On This Page
			Transferring Objects Without the Owner's Signer
Implementing Controlled Transfers
Conclusion
			Transferring Objects Without the Owner's Signer
			Transferring Objects Without the Owner's Signer
			Transferring Objects Without the Owner's Signer
			Transferring Objects Without the Owner's Signer
			Implementing Controlled Transfers
			Implementing Controlled Transfers
			Implementing Controlled Transfers
			Implementing Controlled Transfers
			Conclusion
			Conclusion
			Conclusion
			Conclusion
			Summary
TransferRef provides an alternative method for object transfer without the owner's signer.
Objects can be frozen or unfrozen using
disable_ungated_transfer
and
enable_ungated_transfer
.
LinearTransferRef allows for controlled, one-time transfers of objects.
TransferRef
is a capability that gives you fine-grained control over object transfers. It allows you to:
Enable or disable transfers
Implement controlled transfers
Transfer objects without the owner's signer
Transferring Objects Without the Owner's Signer
While ExtendRef allows for transfer functions without the owner's signer, TransferRef offers an alternative method for object transfer.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref
    });
}
We can then use
transfer_with_ref
to execute the object transfer:
public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
    let object_signer = object::generate_linear_transfer_ref(transfer_ref);
    object::transfer_with_ref(object_signer, new_owner);
}
Freezing and Unfreezing Objects
A key feature of TransferRef in real-world projects is managing object transferability. We can freeze or unfreeze specific objects, which is particularly useful for protecting an object or using it for a specific purpose.
fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::disable_ungated_transfer(transfer_ref);
}
fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::enable_ungated_transfer(transfer_ref);
}
Let's break down the process of using TransferRef for object transfer:
Create a TransferRef:
In the
init_module
function, generate a TransferRef using
object::generate_transfer_ref(state_object_constructor_ref)
.
Store the TransferRef:
Store this TransferRef in the ControllerObject struct, then move it to the object's address.
Implement the transfer function:
In the
transfer_new_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Generate a linear transfer ref using
object::generate_linear_transfer_ref(transfer_ref)
.
c. Use
object::transfer_with_ref
to transfer the object to the new owner.
Freezing an object:
To disable transfers, use the
freeze_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Call
object::disable_ungated_transfer(transfer_ref)
to freeze the object.
Unfreezing an object:
To re-enable transfers, use the
unfreeze_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Call
object::enable_ungated_transfer(transfer_ref)
to unfreeze the object.
By following these steps, you can effectively manage object transfers and control their transferability using TransferRef.
Implementing Controlled Transfers
For more precise control over transfers, you can use LinearTransferRef:
linear_transfer_ref: Option&lt;LinearTransferRef&gt;
implements a controlled transfer mechanism for objects in Aptos Move. Here's a breakdown:
LinearTransferRef
:
A special type of transfer reference in Aptos Move.
Allows for a single, one-time transfer of an object.
Once used, the
LinearTransferRef
is consumed and cannot be reused.
Option<LinearTransferRef>
:
Option
is a Move type that allows a value to either exist or not.
Using
Option
represents the state of the
LinearTransferRef
: either present (Some) or absent (None).
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ObjectController has key {
    transfer_ref: TransferRef,
    linear_transfer_ref: Option<LinearTransferRef>,
}
fun allow_single_transfer(object: Object<ObjectController>) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = object::generate_linear_transfer_ref(&controller.transfer_ref);
    option::fill(&mut controller.linear_transfer_ref, linear_transfer_ref);
}
fun transfer(owner: &signer, object: Object<ObjectController>, new_owner: address) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = option::extract(&mut controller.linear_transfer_ref);
    object::transfer_with_ref(linear_transfer_ref, new_owner);
}
Purpose of use:
Transfer Control:
Using
Option&lt;LinearTransferRef&gt;
controls when transfers are allowed.
When
linear_transfer_ref
is
None
, no transfer can occur.
When it's
Some(LinearTransferRef)
, a single transfer can be executed.
One-time Transfer:
Each
LinearTransferRef
can only be used once.
After use, it's consumed, and
linear_transfer_ref
returns to the
None
state.
Security and Control:
This mechanism enables implementation of complex transfer policies.
For example, allowing transfers only under specific conditions or within a certain timeframe.
Conclusion
TransferRef is a powerful tool in Aptos Move that provides fine-grained control over object transfers. By leveraging TransferRef, you can implement sophisticated transfer logic, enhance security, and create more flexible smart contracts.
Always consider the security implications when implementing transfer logic, and thoroughly test your code before deployment.
			Summary
TransferRef provides an alternative method for object transfer without the owner's signer.
Objects can be frozen or unfrozen using
disable_ungated_transfer
and
enable_ungated_transfer
.
LinearTransferRef allows for controlled, one-time transfers of objects.
TransferRef
is a capability that gives you fine-grained control over object transfers. It allows you to:
Enable or disable transfers
Implement controlled transfers
Transfer objects without the owner's signer
Transferring Objects Without the Owner's Signer
While ExtendRef allows for transfer functions without the owner's signer, TransferRef offers an alternative method for object transfer.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref
    });
}
We can then use
transfer_with_ref
to execute the object transfer:
public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
    let object_signer = object::generate_linear_transfer_ref(transfer_ref);
    object::transfer_with_ref(object_signer, new_owner);
}
Freezing and Unfreezing Objects
A key feature of TransferRef in real-world projects is managing object transferability. We can freeze or unfreeze specific objects, which is particularly useful for protecting an object or using it for a specific purpose.
fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::disable_ungated_transfer(transfer_ref);
}
fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::enable_ungated_transfer(transfer_ref);
}
Let's break down the process of using TransferRef for object transfer:
Create a TransferRef:
In the
init_module
function, generate a TransferRef using
object::generate_transfer_ref(state_object_constructor_ref)
.
Store the TransferRef:
Store this TransferRef in the ControllerObject struct, then move it to the object's address.
Implement the transfer function:
In the
transfer_new_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Generate a linear transfer ref using
object::generate_linear_transfer_ref(transfer_ref)
.
c. Use
object::transfer_with_ref
to transfer the object to the new owner.
Freezing an object:
To disable transfers, use the
freeze_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Call
object::disable_ungated_transfer(transfer_ref)
to freeze the object.
Unfreezing an object:
To re-enable transfers, use the
unfreeze_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Call
object::enable_ungated_transfer(transfer_ref)
to unfreeze the object.
By following these steps, you can effectively manage object transfers and control their transferability using TransferRef.
Implementing Controlled Transfers
For more precise control over transfers, you can use LinearTransferRef:
linear_transfer_ref: Option&lt;LinearTransferRef&gt;
implements a controlled transfer mechanism for objects in Aptos Move. Here's a breakdown:
LinearTransferRef
:
A special type of transfer reference in Aptos Move.
Allows for a single, one-time transfer of an object.
Once used, the
LinearTransferRef
is consumed and cannot be reused.
Option<LinearTransferRef>
:
Option
is a Move type that allows a value to either exist or not.
Using
Option
represents the state of the
LinearTransferRef
: either present (Some) or absent (None).
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ObjectController has key {
    transfer_ref: TransferRef,
    linear_transfer_ref: Option<LinearTransferRef>,
}
fun allow_single_transfer(object: Object<ObjectController>) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = object::generate_linear_transfer_ref(&controller.transfer_ref);
    option::fill(&mut controller.linear_transfer_ref, linear_transfer_ref);
}
fun transfer(owner: &signer, object: Object<ObjectController>, new_owner: address) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = option::extract(&mut controller.linear_transfer_ref);
    object::transfer_with_ref(linear_transfer_ref, new_owner);
}
Purpose of use:
Transfer Control:
Using
Option&lt;LinearTransferRef&gt;
controls when transfers are allowed.
When
linear_transfer_ref
is
None
, no transfer can occur.
When it's
Some(LinearTransferRef)
, a single transfer can be executed.
One-time Transfer:
Each
LinearTransferRef
can only be used once.
After use, it's consumed, and
linear_transfer_ref
returns to the
None
state.
Security and Control:
This mechanism enables implementation of complex transfer policies.
For example, allowing transfers only under specific conditions or within a certain timeframe.
Conclusion
TransferRef is a powerful tool in Aptos Move that provides fine-grained control over object transfers. By leveraging TransferRef, you can implement sophisticated transfer logic, enhance security, and create more flexible smart contracts.
Always consider the security implications when implementing transfer logic, and thoroughly test your code before deployment.
			Summary
TransferRef provides an alternative method for object transfer without the owner's signer.
Objects can be frozen or unfrozen using
disable_ungated_transfer
and
enable_ungated_transfer
.
LinearTransferRef allows for controlled, one-time transfers of objects.
TransferRef
is a capability that gives you fine-grained control over object transfers. It allows you to:
Enable or disable transfers
Implement controlled transfers
Transfer objects without the owner's signer
Transferring Objects Without the Owner's Signer
While ExtendRef allows for transfer functions without the owner's signer, TransferRef offers an alternative method for object transfer.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref
    });
}
We can then use
transfer_with_ref
to execute the object transfer:
public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
    let object_signer = object::generate_linear_transfer_ref(transfer_ref);
    object::transfer_with_ref(object_signer, new_owner);
}
Freezing and Unfreezing Objects
A key feature of TransferRef in real-world projects is managing object transferability. We can freeze or unfreeze specific objects, which is particularly useful for protecting an object or using it for a specific purpose.
fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::disable_ungated_transfer(transfer_ref);
}
fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::enable_ungated_transfer(transfer_ref);
}
Let's break down the process of using TransferRef for object transfer:
Create a TransferRef:
In the
init_module
function, generate a TransferRef using
object::generate_transfer_ref(state_object_constructor_ref)
.
Store the TransferRef:
Store this TransferRef in the ControllerObject struct, then move it to the object's address.
Implement the transfer function:
In the
transfer_new_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Generate a linear transfer ref using
object::generate_linear_transfer_ref(transfer_ref)
.
c. Use
object::transfer_with_ref
to transfer the object to the new owner.
Freezing an object:
To disable transfers, use the
freeze_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Call
object::disable_ungated_transfer(transfer_ref)
to freeze the object.
Unfreezing an object:
To re-enable transfers, use the
unfreeze_object
function:
a. Retrieve the TransferRef from the ControllerObject.
b. Call
object::enable_ungated_transfer(transfer_ref)
to unfreeze the object.
By following these steps, you can effectively manage object transfers and control their transferability using TransferRef.
Implementing Controlled Transfers
For more precise control over transfers, you can use LinearTransferRef:
linear_transfer_ref: Option&lt;LinearTransferRef&gt;
implements a controlled transfer mechanism for objects in Aptos Move. Here's a breakdown:
LinearTransferRef
:
A special type of transfer reference in Aptos Move.
Allows for a single, one-time transfer of an object.
Once used, the
LinearTransferRef
is consumed and cannot be reused.
Option<LinearTransferRef>
:
Option
is a Move type that allows a value to either exist or not.
Using
Option
represents the state of the
LinearTransferRef
: either present (Some) or absent (None).
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ObjectController has key {
    transfer_ref: TransferRef,
    linear_transfer_ref: Option<LinearTransferRef>,
}
fun allow_single_transfer(object: Object<ObjectController>) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = object::generate_linear_transfer_ref(&controller.transfer_ref);
    option::fill(&mut controller.linear_transfer_ref, linear_transfer_ref);
}
fun transfer(owner: &signer, object: Object<ObjectController>, new_owner: address) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = option::extract(&mut controller.linear_transfer_ref);
    object::transfer_with_ref(linear_transfer_ref, new_owner);
}
Purpose of use:
Transfer Control:
Using
Option&lt;LinearTransferRef&gt;
controls when transfers are allowed.
When
linear_transfer_ref
is
None
, no transfer can occur.
When it's
Some(LinearTransferRef)
, a single transfer can be executed.
One-time Transfer:
Each
LinearTransferRef
can only be used once.
After use, it's consumed, and
linear_transfer_ref
returns to the
None
state.
Security and Control:
This mechanism enables implementation of complex transfer policies.
For example, allowing transfers only under specific conditions or within a certain timeframe.
Conclusion
TransferRef is a powerful tool in Aptos Move that provides fine-grained control over object transfers. By leveraging TransferRef, you can implement sophisticated transfer logic, enhance security, and create more flexible smart contracts.
Always consider the security implications when implementing transfer logic, and thoroughly test your code before deployment.
			Summary
			Summary
			Summary
			TransferRef provides an alternative method for object transfer without the owner's signer.
Objects can be frozen or unfrozen using
disable_ungated_transfer
and
enable_ungated_transfer
.
LinearTransferRef allows for controlled, one-time transfers of objects.
TransferRef
is a capability that gives you fine-grained control over object transfers. It allows you to:
Enable or disable transfers
Implement controlled transfers
Transfer objects without the owner's signer
			TransferRef provides an alternative method for object transfer without the owner's signer.
			TransferRef provides an alternative method for object transfer without the owner's signer.
			Objects can be frozen or unfrozen using
disable_ungated_transfer
and
enable_ungated_transfer
.
			Objects can be frozen or unfrozen using
			<code>disable_ungated_transfer</code>
			disable_ungated_transfer
			and
			<code>enable_ungated_transfer</code>
			enable_ungated_transfer
			.
			LinearTransferRef allows for controlled, one-time transfers of objects.
			LinearTransferRef allows for controlled, one-time transfers of objects.
			TransferRef
is a capability that gives you fine-grained control over object transfers. It allows you to:
Enable or disable transfers
Implement controlled transfers
Transfer objects without the owner's signer
			<code>TransferRef</code>
			TransferRef
			is a capability that gives you fine-grained control over object transfers. It allows you to:
			Enable or disable transfers
Implement controlled transfers
Transfer objects without the owner's signer
			Enable or disable transfers
			Enable or disable transfers
			Implement controlled transfers
			Implement controlled transfers
			Transfer objects without the owner's signer
			Transfer objects without the owner's signer
	Transferring Objects Without the Owner's Signer
	Transferring Objects Without the Owner's Signer
	While ExtendRef allows for transfer functions without the owner's signer, TransferRef offers an alternative method for object transfer.
	While ExtendRef allows for transfer functions without the owner's signer, TransferRef offers an alternative method for object transfer.
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref
    });
}</code>
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref
    });
}</code>
	#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
}
fun init_module(owner: &signer) {
    let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = &object::generate_signer(state_object_constructor_ref);
    move_to(state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
    move_to(state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref
    });
}
	We can then use
transfer_with_ref
to execute the object transfer:
	We can then use
	<code>transfer_with_ref</code>
	transfer_with_ref
	to execute the object transfer:
	<code>public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
    let object_signer = object::generate_linear_transfer_ref(transfer_ref);
    object::transfer_with_ref(object_signer, new_owner);
}</code>
	<code>public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
    let object_signer = object::generate_linear_transfer_ref(transfer_ref);
    object::transfer_with_ref(object_signer, new_owner);
}</code>
	public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
    let object_signer = object::generate_linear_transfer_ref(transfer_ref);
    object::transfer_with_ref(object_signer, new_owner);
}
		Freezing and Unfreezing Objects
		Freezing and Unfreezing Objects
		Freezing and Unfreezing Objects
		A key feature of TransferRef in real-world projects is managing object transferability. We can freeze or unfreeze specific objects, which is particularly useful for protecting an object or using it for a specific purpose.
		A key feature of TransferRef in real-world projects is managing object transferability. We can freeze or unfreeze specific objects, which is particularly useful for protecting an object or using it for a specific purpose.
		<code>fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::disable_ungated_transfer(transfer_ref);
}
fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::enable_ungated_transfer(transfer_ref);
}</code>
		<code>fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::disable_ungated_transfer(transfer_ref);
}
fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::enable_ungated_transfer(transfer_ref);
}</code>
		fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::disable_ungated_transfer(transfer_ref);
}
fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
    let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
    object::enable_ungated_transfer(transfer_ref);
}
		Let's break down the process of using TransferRef for object transfer:
		Let's break down the process of using TransferRef for object transfer:
		Create a TransferRef:
In the
init_module
function, generate a TransferRef using
object::generate_transfer_ref(state_object_constructor_ref)
.
Store the TransferRef:
Store this TransferRef in the ControllerObject struct, then move it to the object's address.
Implement the transfer function:
In the
transfer_new_object
function:
		Create a TransferRef:
In the
init_module
function, generate a TransferRef using
object::generate_transfer_ref(state_object_constructor_ref)
.
		Create a TransferRef:
		Create a TransferRef:
		In the
		<code>init_module</code>
		init_module
		function, generate a TransferRef using
		<code>object::generate_transfer_ref(state_object_constructor_ref)</code>
		object::generate_transfer_ref(state_object_constructor_ref)
		.
		Store the TransferRef:
Store this TransferRef in the ControllerObject struct, then move it to the object's address.
		Store the TransferRef:
		Store the TransferRef:
		Store this TransferRef in the ControllerObject struct, then move it to the object's address.
		Implement the transfer function:
In the
transfer_new_object
function:
		Implement the transfer function:
		Implement the transfer function:
		In the
		<code>transfer_new_object</code>
		transfer_new_object
		function:
		a. Retrieve the TransferRef from the ControllerObject.
b. Generate a linear transfer ref using
object::generate_linear_transfer_ref(transfer_ref)
.
c. Use
object::transfer_with_ref
to transfer the object to the new owner.
		a. Retrieve the TransferRef from the ControllerObject.
		a. Retrieve the TransferRef from the ControllerObject.
		b. Generate a linear transfer ref using
object::generate_linear_transfer_ref(transfer_ref)
.
		b. Generate a linear transfer ref using
		<code>object::generate_linear_transfer_ref(transfer_ref)</code>
		object::generate_linear_transfer_ref(transfer_ref)
		.
		c. Use
object::transfer_with_ref
to transfer the object to the new owner.
		c. Use
		<code>object::transfer_with_ref</code>
		object::transfer_with_ref
		to transfer the object to the new owner.
		Freezing an object:
To disable transfers, use the
freeze_object
function:
		Freezing an object:
To disable transfers, use the
freeze_object
function:
		Freezing an object:
		Freezing an object:
		To disable transfers, use the
		<code>freeze_object</code>
		freeze_object
		function:
		a. Retrieve the TransferRef from the ControllerObject.
b. Call
object::disable_ungated_transfer(transfer_ref)
to freeze the object.
		a. Retrieve the TransferRef from the ControllerObject.
		a. Retrieve the TransferRef from the ControllerObject.
		b. Call
object::disable_ungated_transfer(transfer_ref)
to freeze the object.
		b. Call
		<code>object::disable_ungated_transfer(transfer_ref)</code>
		object::disable_ungated_transfer(transfer_ref)
		to freeze the object.
		Unfreezing an object:
To re-enable transfers, use the
unfreeze_object
function:
		Unfreezing an object:
To re-enable transfers, use the
unfreeze_object
function:
		Unfreezing an object:
		Unfreezing an object:
		To re-enable transfers, use the
		<code>unfreeze_object</code>
		unfreeze_object
		function:
		a. Retrieve the TransferRef from the ControllerObject.
b. Call
object::enable_ungated_transfer(transfer_ref)
to unfreeze the object.
		a. Retrieve the TransferRef from the ControllerObject.
		a. Retrieve the TransferRef from the ControllerObject.
		b. Call
object::enable_ungated_transfer(transfer_ref)
to unfreeze the object.
		b. Call
		<code>object::enable_ungated_transfer(transfer_ref)</code>
		object::enable_ungated_transfer(transfer_ref)
		to unfreeze the object.
		By following these steps, you can effectively manage object transfers and control their transferability using TransferRef.
		By following these steps, you can effectively manage object transfers and control their transferability using TransferRef.
	Implementing Controlled Transfers
	Implementing Controlled Transfers
	For more precise control over transfers, you can use LinearTransferRef:
	For more precise control over transfers, you can use LinearTransferRef:
	linear_transfer_ref: Option&lt;LinearTransferRef&gt;
implements a controlled transfer mechanism for objects in Aptos Move. Here's a breakdown:
	<code>linear_transfer_ref: Option&lt;LinearTransferRef&gt;</code>
	linear_transfer_ref: Option&lt;LinearTransferRef&gt;
	implements a controlled transfer mechanism for objects in Aptos Move. Here's a breakdown:
	LinearTransferRef
:
A special type of transfer reference in Aptos Move.
Allows for a single, one-time transfer of an object.
Once used, the
LinearTransferRef
is consumed and cannot be reused.
Option<LinearTransferRef>
:
Option
is a Move type that allows a value to either exist or not.
Using
Option
represents the state of the
LinearTransferRef
: either present (Some) or absent (None).
	LinearTransferRef
:
A special type of transfer reference in Aptos Move.
Allows for a single, one-time transfer of an object.
Once used, the
LinearTransferRef
is consumed and cannot be reused.
	<code>LinearTransferRef</code>
	LinearTransferRef
	:
	A special type of transfer reference in Aptos Move.
Allows for a single, one-time transfer of an object.
Once used, the
LinearTransferRef
is consumed and cannot be reused.
	A special type of transfer reference in Aptos Move.
	A special type of transfer reference in Aptos Move.
	Allows for a single, one-time transfer of an object.
	Allows for a single, one-time transfer of an object.
	Once used, the
LinearTransferRef
is consumed and cannot be reused.
	Once used, the
	<code>LinearTransferRef</code>
	LinearTransferRef
	is consumed and cannot be reused.
	Option<LinearTransferRef>
:
Option
is a Move type that allows a value to either exist or not.
Using
Option
represents the state of the
LinearTransferRef
: either present (Some) or absent (None).
	<code>Option<LinearTransferRef></code>
	Option<LinearTransferRef>
	:
	Option
is a Move type that allows a value to either exist or not.
Using
Option
represents the state of the
LinearTransferRef
: either present (Some) or absent (None).
	Option
is a Move type that allows a value to either exist or not.
	<code>Option</code>
	Option
	is a Move type that allows a value to either exist or not.
	Using
Option
represents the state of the
LinearTransferRef
: either present (Some) or absent (None).
	Using
	<code>Option</code>
	Option
	represents the state of the
	<code>LinearTransferRef</code>
	LinearTransferRef
	: either present (Some) or absent (None).
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ObjectController has key {
    transfer_ref: TransferRef,
    linear_transfer_ref: Option<LinearTransferRef>,
}
fun allow_single_transfer(object: Object<ObjectController>) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = object::generate_linear_transfer_ref(&controller.transfer_ref);
    option::fill(&mut controller.linear_transfer_ref, linear_transfer_ref);
}
fun transfer(owner: &signer, object: Object<ObjectController>, new_owner: address) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = option::extract(&mut controller.linear_transfer_ref);
    object::transfer_with_ref(linear_transfer_ref, new_owner);
}</code>
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ObjectController has key {
    transfer_ref: TransferRef,
    linear_transfer_ref: Option<LinearTransferRef>,
}
fun allow_single_transfer(object: Object<ObjectController>) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = object::generate_linear_transfer_ref(&controller.transfer_ref);
    option::fill(&mut controller.linear_transfer_ref, linear_transfer_ref);
}
fun transfer(owner: &signer, object: Object<ObjectController>, new_owner: address) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = option::extract(&mut controller.linear_transfer_ref);
    object::transfer_with_ref(linear_transfer_ref, new_owner);
}</code>
	#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ObjectController has key {
    transfer_ref: TransferRef,
    linear_transfer_ref: Option<LinearTransferRef>,
}
fun allow_single_transfer(object: Object<ObjectController>) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = object::generate_linear_transfer_ref(&controller.transfer_ref);
    option::fill(&mut controller.linear_transfer_ref, linear_transfer_ref);
}
fun transfer(owner: &signer, object: Object<ObjectController>, new_owner: address) acquires ObjectController {
    let object_address = object::object_address(&object);
    let controller = borrow_global_mut<ObjectController>(object_address);
    let linear_transfer_ref = option::extract(&mut controller.linear_transfer_ref);
    object::transfer_with_ref(linear_transfer_ref, new_owner);
}
	Purpose of use:
	Purpose of use:
	Transfer Control:
Using
Option&lt;LinearTransferRef&gt;
controls when transfers are allowed.
When
linear_transfer_ref
is
None
, no transfer can occur.
When it's
Some(LinearTransferRef)
, a single transfer can be executed.
One-time Transfer:
Each
LinearTransferRef
can only be used once.
After use, it's consumed, and
linear_transfer_ref
returns to the
None
state.
Security and Control:
This mechanism enables implementation of complex transfer policies.
For example, allowing transfers only under specific conditions or within a certain timeframe.
	Transfer Control:
Using
Option&lt;LinearTransferRef&gt;
controls when transfers are allowed.
When
linear_transfer_ref
is
None
, no transfer can occur.
When it's
Some(LinearTransferRef)
, a single transfer can be executed.
	Transfer Control:
	Using
Option&lt;LinearTransferRef&gt;
controls when transfers are allowed.
When
linear_transfer_ref
is
None
, no transfer can occur.
When it's
Some(LinearTransferRef)
, a single transfer can be executed.
	Using
Option&lt;LinearTransferRef&gt;
controls when transfers are allowed.
	Using
	<code>Option&lt;LinearTransferRef&gt;</code>
	Option&lt;LinearTransferRef&gt;
	controls when transfers are allowed.
	When
linear_transfer_ref
is
None
, no transfer can occur.
	When
	<code>linear_transfer_ref</code>
	linear_transfer_ref
	is
	<code>None</code>
	None
	, no transfer can occur.
	When it's
Some(LinearTransferRef)
, a single transfer can be executed.
	When it's
	<code>Some(LinearTransferRef)</code>
	Some(LinearTransferRef)
	, a single transfer can be executed.
	One-time Transfer:
Each
LinearTransferRef
can only be used once.
After use, it's consumed, and
linear_transfer_ref
returns to the
None
state.
	One-time Transfer:
	Each
LinearTransferRef
can only be used once.
After use, it's consumed, and
linear_transfer_ref
returns to the
None
state.
	Each
LinearTransferRef
can only be used once.
	Each
	<code>LinearTransferRef</code>
	LinearTransferRef
	can only be used once.
	After use, it's consumed, and
linear_transfer_ref
returns to the
None
state.
	After use, it's consumed, and
	<code>linear_transfer_ref</code>
	linear_transfer_ref
	returns to the
	<code>None</code>
	None
	state.
	Security and Control:
This mechanism enables implementation of complex transfer policies.
For example, allowing transfers only under specific conditions or within a certain timeframe.
	Security and Control:
	This mechanism enables implementation of complex transfer policies.
For example, allowing transfers only under specific conditions or within a certain timeframe.
	This mechanism enables implementation of complex transfer policies.
	This mechanism enables implementation of complex transfer policies.
	For example, allowing transfers only under specific conditions or within a certain timeframe.
	For example, allowing transfers only under specific conditions or within a certain timeframe.
	Conclusion
	Conclusion
	TransferRef is a powerful tool in Aptos Move that provides fine-grained control over object transfers. By leveraging TransferRef, you can implement sophisticated transfer logic, enhance security, and create more flexible smart contracts.
	TransferRef is a powerful tool in Aptos Move that provides fine-grained control over object transfers. By leveraging TransferRef, you can implement sophisticated transfer logic, enhance security, and create more flexible smart contracts.
	Always consider the security implications when implementing transfer logic, and thoroughly test your code before deployment.
	Always consider the security implications when implementing transfer logic, and thoroughly test your code before deployment.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/07-objects/06-using-deleteref
Using DeleteRef
Using DeleteRef
On This Page
Summary
Overview
Defining Structs
Initializing the Module
Conclusion
Full Code
Summary
Object deletion in Aptos Move is implemented using the
DeleteRef
concept.
A
DeleteRef
must be created during object initialization for objects that can be deleted.
The module demonstrates creating objects with customizable properties (transferrable, controllable, deletable).
ExtendRef
,
TransferRef
, and
DeleteRef
are used to manage object behavior.
Object deletion respects ownership, allowing only the owner to delete an object.
This approach provides fine-grained control over object lifecycle and permissions in Aptos Move smart contracts.
Overview
Object deletion is a crucial feature in data management, serving two primary purposes: decluttering your workspace and reclaiming storage resources. To facilitate this process, we introduce the concept of a
DeleteRef
.
A
DeleteRef
is a specialized reference that must be established during the object's creation phase. This preemptive approach ensures that only objects intended for potential deletion are equipped with this capability. It's important to note that not all objects are eligible for deletion, and attempting to create a
DeleteRef
for such non-deletable objects will result in an error.
Defining Structs
Next, let's define our structs:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef,
}
MovementObject
is our main object that holds a value.
ControllerObject
holds the references that control the object's behavior.
Initializing the Module
The
init_module
function sets up our initial object:
fun init_module(owner: &signer) {
    let state_object_constructor_ref = object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = object::generate_signer(&state_object_constructor_ref);
    move_to(&state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(&state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(&state_object_constructor_ref);
    let delete_ref = object::generate_delete_ref(&state_object_constructor_ref);
    move_to(&state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref,
        delete_ref,
    });
}
This function creates a named object, moves a
MovementObject
to it, and then creates and stores the control references in a
ControllerObject
.
This function allows you to:
Create objects that may or may not be transferrable.
Make objects controllable (by storing the control references).
Optionally allow objects to be deletable.
Similar to TransferRef and ExtendRef, when you use DeleteRef, you'll retrieve it from within the ControllerObject to execute the deletion.
public entry fun delete(
    caller: &signer,
    object: Object<ControllerObject>,
) acquires ControllerObject {
    // Only let caller delete
    let caller_address = signer::address_of(caller);
    assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
    let object_address = object::object_address(object);
    // Retrieve the delete ref, it is consumed so it must be extracted
    // from the resource
    let ControllerObject {
        extend_ref: _,
        transfer_ref: _,
        delete_ref,
    } = move_from<ControllerObject>(object_address);
    // Delete the object forever!
    object::delete(delete_ref);
}
This function:
Checks if the caller is the owner of the object.
Retrieves and consumes the
ControllerObject
.
Uses the
DeleteRef
to delete the object.
Conclusion
This module demonstrates advanced object control in Aptos Move:
We can create objects with customizable properties (transferrable, controllable, deletable).
We use
ExtendRef
,
TransferRef
, and
DeleteRef
to manage object behavior.
We implement a deletion mechanism that respects object ownership.
By using these techniques, you can create more flexible and secure smart contracts in Aptos Move, giving you fine-grained control over object lifecycle and permissions.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    const E_NOT_OWNER: u64 = 0;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef,
        transfer_ref: TransferRef,
        delete_ref: DeleteRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
        let delete_ref = object::generate_delete_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject {
            extend_ref,
            transfer_ref,
            delete_ref
        });
    }
    fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::disable_ungated_transfer(transfer_ref);
    }
    fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::enable_ungated_transfer(transfer_ref);
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
        let object_signer = object::generate_linear_transfer_ref(transfer_ref);
        object::transfer_with_ref(object_signer, new_owner);
    }
    public entry fun delete(
        caller: &signer,
        object: Object<ControllerObject>,
    ) acquires ControllerObject {
        // Only let caller delete
        let caller_address = address_of(caller);
        assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
        let object_address = object::object_address(&object);
        // Retrieve the delete ref, it is consumed so it must be extracted
        // from the resource
        let ControllerObject {
            extend_ref: _,
            transfer_ref: _,
            delete_ref,
        } = move_from<ControllerObject>(object_address);
        // Delete the object forever!
        object::delete(delete_ref);
    }
}
On This Page
Summary
Overview
Defining Structs
Initializing the Module
Conclusion
Full Code
On This Page
Summary
Overview
Defining Structs
Initializing the Module
Conclusion
Full Code
			On This Page
			On This Page
			Summary
Overview
Defining Structs
Initializing the Module
Conclusion
Full Code
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			Defining Structs
			Defining Structs
			Defining Structs
			Defining Structs
			Initializing the Module
			Initializing the Module
			Initializing the Module
			Initializing the Module
			Conclusion
			Conclusion
			Conclusion
			Conclusion
			Full Code
			Full Code
			Full Code
			Full Code
			Summary
Object deletion in Aptos Move is implemented using the
DeleteRef
concept.
A
DeleteRef
must be created during object initialization for objects that can be deleted.
The module demonstrates creating objects with customizable properties (transferrable, controllable, deletable).
ExtendRef
,
TransferRef
, and
DeleteRef
are used to manage object behavior.
Object deletion respects ownership, allowing only the owner to delete an object.
This approach provides fine-grained control over object lifecycle and permissions in Aptos Move smart contracts.
Overview
Object deletion is a crucial feature in data management, serving two primary purposes: decluttering your workspace and reclaiming storage resources. To facilitate this process, we introduce the concept of a
DeleteRef
.
A
DeleteRef
is a specialized reference that must be established during the object's creation phase. This preemptive approach ensures that only objects intended for potential deletion are equipped with this capability. It's important to note that not all objects are eligible for deletion, and attempting to create a
DeleteRef
for such non-deletable objects will result in an error.
Defining Structs
Next, let's define our structs:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef,
}
MovementObject
is our main object that holds a value.
ControllerObject
holds the references that control the object's behavior.
Initializing the Module
The
init_module
function sets up our initial object:
fun init_module(owner: &signer) {
    let state_object_constructor_ref = object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = object::generate_signer(&state_object_constructor_ref);
    move_to(&state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(&state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(&state_object_constructor_ref);
    let delete_ref = object::generate_delete_ref(&state_object_constructor_ref);
    move_to(&state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref,
        delete_ref,
    });
}
This function creates a named object, moves a
MovementObject
to it, and then creates and stores the control references in a
ControllerObject
.
This function allows you to:
Create objects that may or may not be transferrable.
Make objects controllable (by storing the control references).
Optionally allow objects to be deletable.
Similar to TransferRef and ExtendRef, when you use DeleteRef, you'll retrieve it from within the ControllerObject to execute the deletion.
public entry fun delete(
    caller: &signer,
    object: Object<ControllerObject>,
) acquires ControllerObject {
    // Only let caller delete
    let caller_address = signer::address_of(caller);
    assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
    let object_address = object::object_address(object);
    // Retrieve the delete ref, it is consumed so it must be extracted
    // from the resource
    let ControllerObject {
        extend_ref: _,
        transfer_ref: _,
        delete_ref,
    } = move_from<ControllerObject>(object_address);
    // Delete the object forever!
    object::delete(delete_ref);
}
This function:
Checks if the caller is the owner of the object.
Retrieves and consumes the
ControllerObject
.
Uses the
DeleteRef
to delete the object.
Conclusion
This module demonstrates advanced object control in Aptos Move:
We can create objects with customizable properties (transferrable, controllable, deletable).
We use
ExtendRef
,
TransferRef
, and
DeleteRef
to manage object behavior.
We implement a deletion mechanism that respects object ownership.
By using these techniques, you can create more flexible and secure smart contracts in Aptos Move, giving you fine-grained control over object lifecycle and permissions.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    const E_NOT_OWNER: u64 = 0;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef,
        transfer_ref: TransferRef,
        delete_ref: DeleteRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
        let delete_ref = object::generate_delete_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject {
            extend_ref,
            transfer_ref,
            delete_ref
        });
    }
    fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::disable_ungated_transfer(transfer_ref);
    }
    fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::enable_ungated_transfer(transfer_ref);
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
        let object_signer = object::generate_linear_transfer_ref(transfer_ref);
        object::transfer_with_ref(object_signer, new_owner);
    }
    public entry fun delete(
        caller: &signer,
        object: Object<ControllerObject>,
    ) acquires ControllerObject {
        // Only let caller delete
        let caller_address = address_of(caller);
        assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
        let object_address = object::object_address(&object);
        // Retrieve the delete ref, it is consumed so it must be extracted
        // from the resource
        let ControllerObject {
            extend_ref: _,
            transfer_ref: _,
            delete_ref,
        } = move_from<ControllerObject>(object_address);
        // Delete the object forever!
        object::delete(delete_ref);
    }
}
			Summary
Object deletion in Aptos Move is implemented using the
DeleteRef
concept.
A
DeleteRef
must be created during object initialization for objects that can be deleted.
The module demonstrates creating objects with customizable properties (transferrable, controllable, deletable).
ExtendRef
,
TransferRef
, and
DeleteRef
are used to manage object behavior.
Object deletion respects ownership, allowing only the owner to delete an object.
This approach provides fine-grained control over object lifecycle and permissions in Aptos Move smart contracts.
Overview
Object deletion is a crucial feature in data management, serving two primary purposes: decluttering your workspace and reclaiming storage resources. To facilitate this process, we introduce the concept of a
DeleteRef
.
A
DeleteRef
is a specialized reference that must be established during the object's creation phase. This preemptive approach ensures that only objects intended for potential deletion are equipped with this capability. It's important to note that not all objects are eligible for deletion, and attempting to create a
DeleteRef
for such non-deletable objects will result in an error.
Defining Structs
Next, let's define our structs:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef,
}
MovementObject
is our main object that holds a value.
ControllerObject
holds the references that control the object's behavior.
Initializing the Module
The
init_module
function sets up our initial object:
fun init_module(owner: &signer) {
    let state_object_constructor_ref = object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = object::generate_signer(&state_object_constructor_ref);
    move_to(&state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(&state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(&state_object_constructor_ref);
    let delete_ref = object::generate_delete_ref(&state_object_constructor_ref);
    move_to(&state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref,
        delete_ref,
    });
}
This function creates a named object, moves a
MovementObject
to it, and then creates and stores the control references in a
ControllerObject
.
This function allows you to:
Create objects that may or may not be transferrable.
Make objects controllable (by storing the control references).
Optionally allow objects to be deletable.
Similar to TransferRef and ExtendRef, when you use DeleteRef, you'll retrieve it from within the ControllerObject to execute the deletion.
public entry fun delete(
    caller: &signer,
    object: Object<ControllerObject>,
) acquires ControllerObject {
    // Only let caller delete
    let caller_address = signer::address_of(caller);
    assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
    let object_address = object::object_address(object);
    // Retrieve the delete ref, it is consumed so it must be extracted
    // from the resource
    let ControllerObject {
        extend_ref: _,
        transfer_ref: _,
        delete_ref,
    } = move_from<ControllerObject>(object_address);
    // Delete the object forever!
    object::delete(delete_ref);
}
This function:
Checks if the caller is the owner of the object.
Retrieves and consumes the
ControllerObject
.
Uses the
DeleteRef
to delete the object.
Conclusion
This module demonstrates advanced object control in Aptos Move:
We can create objects with customizable properties (transferrable, controllable, deletable).
We use
ExtendRef
,
TransferRef
, and
DeleteRef
to manage object behavior.
We implement a deletion mechanism that respects object ownership.
By using these techniques, you can create more flexible and secure smart contracts in Aptos Move, giving you fine-grained control over object lifecycle and permissions.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    const E_NOT_OWNER: u64 = 0;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef,
        transfer_ref: TransferRef,
        delete_ref: DeleteRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
        let delete_ref = object::generate_delete_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject {
            extend_ref,
            transfer_ref,
            delete_ref
        });
    }
    fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::disable_ungated_transfer(transfer_ref);
    }
    fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::enable_ungated_transfer(transfer_ref);
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
        let object_signer = object::generate_linear_transfer_ref(transfer_ref);
        object::transfer_with_ref(object_signer, new_owner);
    }
    public entry fun delete(
        caller: &signer,
        object: Object<ControllerObject>,
    ) acquires ControllerObject {
        // Only let caller delete
        let caller_address = address_of(caller);
        assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
        let object_address = object::object_address(&object);
        // Retrieve the delete ref, it is consumed so it must be extracted
        // from the resource
        let ControllerObject {
            extend_ref: _,
            transfer_ref: _,
            delete_ref,
        } = move_from<ControllerObject>(object_address);
        // Delete the object forever!
        object::delete(delete_ref);
    }
}
			Summary
Object deletion in Aptos Move is implemented using the
DeleteRef
concept.
A
DeleteRef
must be created during object initialization for objects that can be deleted.
The module demonstrates creating objects with customizable properties (transferrable, controllable, deletable).
ExtendRef
,
TransferRef
, and
DeleteRef
are used to manage object behavior.
Object deletion respects ownership, allowing only the owner to delete an object.
This approach provides fine-grained control over object lifecycle and permissions in Aptos Move smart contracts.
Overview
Object deletion is a crucial feature in data management, serving two primary purposes: decluttering your workspace and reclaiming storage resources. To facilitate this process, we introduce the concept of a
DeleteRef
.
A
DeleteRef
is a specialized reference that must be established during the object's creation phase. This preemptive approach ensures that only objects intended for potential deletion are equipped with this capability. It's important to note that not all objects are eligible for deletion, and attempting to create a
DeleteRef
for such non-deletable objects will result in an error.
Defining Structs
Next, let's define our structs:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef,
}
MovementObject
is our main object that holds a value.
ControllerObject
holds the references that control the object's behavior.
Initializing the Module
The
init_module
function sets up our initial object:
fun init_module(owner: &signer) {
    let state_object_constructor_ref = object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = object::generate_signer(&state_object_constructor_ref);
    move_to(&state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(&state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(&state_object_constructor_ref);
    let delete_ref = object::generate_delete_ref(&state_object_constructor_ref);
    move_to(&state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref,
        delete_ref,
    });
}
This function creates a named object, moves a
MovementObject
to it, and then creates and stores the control references in a
ControllerObject
.
This function allows you to:
Create objects that may or may not be transferrable.
Make objects controllable (by storing the control references).
Optionally allow objects to be deletable.
Similar to TransferRef and ExtendRef, when you use DeleteRef, you'll retrieve it from within the ControllerObject to execute the deletion.
public entry fun delete(
    caller: &signer,
    object: Object<ControllerObject>,
) acquires ControllerObject {
    // Only let caller delete
    let caller_address = signer::address_of(caller);
    assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
    let object_address = object::object_address(object);
    // Retrieve the delete ref, it is consumed so it must be extracted
    // from the resource
    let ControllerObject {
        extend_ref: _,
        transfer_ref: _,
        delete_ref,
    } = move_from<ControllerObject>(object_address);
    // Delete the object forever!
    object::delete(delete_ref);
}
This function:
Checks if the caller is the owner of the object.
Retrieves and consumes the
ControllerObject
.
Uses the
DeleteRef
to delete the object.
Conclusion
This module demonstrates advanced object control in Aptos Move:
We can create objects with customizable properties (transferrable, controllable, deletable).
We use
ExtendRef
,
TransferRef
, and
DeleteRef
to manage object behavior.
We implement a deletion mechanism that respects object ownership.
By using these techniques, you can create more flexible and secure smart contracts in Aptos Move, giving you fine-grained control over object lifecycle and permissions.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    const E_NOT_OWNER: u64 = 0;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef,
        transfer_ref: TransferRef,
        delete_ref: DeleteRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
        let delete_ref = object::generate_delete_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject {
            extend_ref,
            transfer_ref,
            delete_ref
        });
    }
    fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::disable_ungated_transfer(transfer_ref);
    }
    fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::enable_ungated_transfer(transfer_ref);
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
        let object_signer = object::generate_linear_transfer_ref(transfer_ref);
        object::transfer_with_ref(object_signer, new_owner);
    }
    public entry fun delete(
        caller: &signer,
        object: Object<ControllerObject>,
    ) acquires ControllerObject {
        // Only let caller delete
        let caller_address = address_of(caller);
        assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
        let object_address = object::object_address(&object);
        // Retrieve the delete ref, it is consumed so it must be extracted
        // from the resource
        let ControllerObject {
            extend_ref: _,
            transfer_ref: _,
            delete_ref,
        } = move_from<ControllerObject>(object_address);
        // Delete the object forever!
        object::delete(delete_ref);
    }
}
	Summary
	Summary
	Object deletion in Aptos Move is implemented using the
DeleteRef
concept.
A
DeleteRef
must be created during object initialization for objects that can be deleted.
The module demonstrates creating objects with customizable properties (transferrable, controllable, deletable).
ExtendRef
,
TransferRef
, and
DeleteRef
are used to manage object behavior.
Object deletion respects ownership, allowing only the owner to delete an object.
This approach provides fine-grained control over object lifecycle and permissions in Aptos Move smart contracts.
	Object deletion in Aptos Move is implemented using the
DeleteRef
concept.
	Object deletion in Aptos Move is implemented using the
	<code>DeleteRef</code>
	DeleteRef
	concept.
	A
DeleteRef
must be created during object initialization for objects that can be deleted.
	A
	<code>DeleteRef</code>
	DeleteRef
	must be created during object initialization for objects that can be deleted.
	The module demonstrates creating objects with customizable properties (transferrable, controllable, deletable).
	The module demonstrates creating objects with customizable properties (transferrable, controllable, deletable).
	ExtendRef
,
TransferRef
, and
DeleteRef
are used to manage object behavior.
	<code>ExtendRef</code>
	ExtendRef
	,
	<code>TransferRef</code>
	TransferRef
	, and
	<code>DeleteRef</code>
	DeleteRef
	are used to manage object behavior.
	Object deletion respects ownership, allowing only the owner to delete an object.
	Object deletion respects ownership, allowing only the owner to delete an object.
	This approach provides fine-grained control over object lifecycle and permissions in Aptos Move smart contracts.
	This approach provides fine-grained control over object lifecycle and permissions in Aptos Move smart contracts.
	Overview
	Overview
	Object deletion is a crucial feature in data management, serving two primary purposes: decluttering your workspace and reclaiming storage resources. To facilitate this process, we introduce the concept of a
DeleteRef
.
	Object deletion is a crucial feature in data management, serving two primary purposes: decluttering your workspace and reclaiming storage resources. To facilitate this process, we introduce the concept of a
	<code>DeleteRef</code>
	DeleteRef
	.
	A
DeleteRef
is a specialized reference that must be established during the object's creation phase. This preemptive approach ensures that only objects intended for potential deletion are equipped with this capability. It's important to note that not all objects are eligible for deletion, and attempting to create a
DeleteRef
for such non-deletable objects will result in an error.
	A
	<code>DeleteRef</code>
	DeleteRef
	is a specialized reference that must be established during the object's creation phase. This preemptive approach ensures that only objects intended for potential deletion are equipped with this capability. It's important to note that not all objects are eligible for deletion, and attempting to create a
	<code>DeleteRef</code>
	DeleteRef
	for such non-deletable objects will result in an error.
	Defining Structs
	Defining Structs
	Next, let's define our structs:
	Next, let's define our structs:
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef,
}</code>
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef,
}</code>
	#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
    value: u64,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
    extend_ref: ExtendRef,
    transfer_ref: TransferRef,
    delete_ref: DeleteRef,
}
	MovementObject
is our main object that holds a value.
ControllerObject
holds the references that control the object's behavior.
	MovementObject
is our main object that holds a value.
	<code>MovementObject</code>
	MovementObject
	is our main object that holds a value.
	ControllerObject
holds the references that control the object's behavior.
	<code>ControllerObject</code>
	ControllerObject
	holds the references that control the object's behavior.
	Initializing the Module
	Initializing the Module
	The
init_module
function sets up our initial object:
	The
	<code>init_module</code>
	init_module
	function sets up our initial object:
	<code>fun init_module(owner: &signer) {
    let state_object_constructor_ref = object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = object::generate_signer(&state_object_constructor_ref);
    move_to(&state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(&state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(&state_object_constructor_ref);
    let delete_ref = object::generate_delete_ref(&state_object_constructor_ref);
    move_to(&state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref,
        delete_ref,
    });
}</code>
	<code>fun init_module(owner: &signer) {
    let state_object_constructor_ref = object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = object::generate_signer(&state_object_constructor_ref);
    move_to(&state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(&state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(&state_object_constructor_ref);
    let delete_ref = object::generate_delete_ref(&state_object_constructor_ref);
    move_to(&state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref,
        delete_ref,
    });
}</code>
	fun init_module(owner: &signer) {
    let state_object_constructor_ref = object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
    let state_object_signer = object::generate_signer(&state_object_constructor_ref);
    move_to(&state_object_signer, MovementObject {
        value: 10
    });
    let extend_ref = object::generate_extend_ref(&state_object_constructor_ref);
    let transfer_ref = object::generate_transfer_ref(&state_object_constructor_ref);
    let delete_ref = object::generate_delete_ref(&state_object_constructor_ref);
    move_to(&state_object_signer, ControllerObject {
        extend_ref,
        transfer_ref,
        delete_ref,
    });
}
	This function creates a named object, moves a
MovementObject
to it, and then creates and stores the control references in a
ControllerObject
.
	This function creates a named object, moves a
	<code>MovementObject</code>
	MovementObject
	to it, and then creates and stores the control references in a
	<code>ControllerObject</code>
	ControllerObject
	.
	This function allows you to:
	This function allows you to:
	Create objects that may or may not be transferrable.
Make objects controllable (by storing the control references).
Optionally allow objects to be deletable.
	Create objects that may or may not be transferrable.
	Create objects that may or may not be transferrable.
	Make objects controllable (by storing the control references).
	Make objects controllable (by storing the control references).
	Optionally allow objects to be deletable.
	Optionally allow objects to be deletable.
	Similar to TransferRef and ExtendRef, when you use DeleteRef, you'll retrieve it from within the ControllerObject to execute the deletion.
	Similar to TransferRef and ExtendRef, when you use DeleteRef, you'll retrieve it from within the ControllerObject to execute the deletion.
	<code>public entry fun delete(
    caller: &signer,
    object: Object<ControllerObject>,
) acquires ControllerObject {
    // Only let caller delete
    let caller_address = signer::address_of(caller);
    assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
    let object_address = object::object_address(object);
    // Retrieve the delete ref, it is consumed so it must be extracted
    // from the resource
    let ControllerObject {
        extend_ref: _,
        transfer_ref: _,
        delete_ref,
    } = move_from<ControllerObject>(object_address);
    // Delete the object forever!
    object::delete(delete_ref);
}</code>
	<code>public entry fun delete(
    caller: &signer,
    object: Object<ControllerObject>,
) acquires ControllerObject {
    // Only let caller delete
    let caller_address = signer::address_of(caller);
    assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
    let object_address = object::object_address(object);
    // Retrieve the delete ref, it is consumed so it must be extracted
    // from the resource
    let ControllerObject {
        extend_ref: _,
        transfer_ref: _,
        delete_ref,
    } = move_from<ControllerObject>(object_address);
    // Delete the object forever!
    object::delete(delete_ref);
}</code>
	public entry fun delete(
    caller: &signer,
    object: Object<ControllerObject>,
) acquires ControllerObject {
    // Only let caller delete
    let caller_address = signer::address_of(caller);
    assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
    let object_address = object::object_address(object);
    // Retrieve the delete ref, it is consumed so it must be extracted
    // from the resource
    let ControllerObject {
        extend_ref: _,
        transfer_ref: _,
        delete_ref,
    } = move_from<ControllerObject>(object_address);
    // Delete the object forever!
    object::delete(delete_ref);
}
	This function:
	This function:
	Checks if the caller is the owner of the object.
Retrieves and consumes the
ControllerObject
.
Uses the
DeleteRef
to delete the object.
	Checks if the caller is the owner of the object.
	Checks if the caller is the owner of the object.
	Retrieves and consumes the
ControllerObject
.
	Retrieves and consumes the
	<code>ControllerObject</code>
	ControllerObject
	.
	Uses the
DeleteRef
to delete the object.
	Uses the
	<code>DeleteRef</code>
	DeleteRef
	to delete the object.
	Conclusion
	Conclusion
	This module demonstrates advanced object control in Aptos Move:
	This module demonstrates advanced object control in Aptos Move:
	We can create objects with customizable properties (transferrable, controllable, deletable).
We use
ExtendRef
,
TransferRef
, and
DeleteRef
to manage object behavior.
We implement a deletion mechanism that respects object ownership.
	We can create objects with customizable properties (transferrable, controllable, deletable).
	We can create objects with customizable properties (transferrable, controllable, deletable).
	We use
ExtendRef
,
TransferRef
, and
DeleteRef
to manage object behavior.
	We use
	<code>ExtendRef</code>
	ExtendRef
	,
	<code>TransferRef</code>
	TransferRef
	, and
	<code>DeleteRef</code>
	DeleteRef
	to manage object behavior.
	We implement a deletion mechanism that respects object ownership.
	We implement a deletion mechanism that respects object ownership.
	By using these techniques, you can create more flexible and secure smart contracts in Aptos Move, giving you fine-grained control over object lifecycle and permissions.
	By using these techniques, you can create more flexible and secure smart contracts in Aptos Move, giving you fine-grained control over object lifecycle and permissions.
	Full Code
	Full Code
	<code>module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    const E_NOT_OWNER: u64 = 0;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef,
        transfer_ref: TransferRef,
        delete_ref: DeleteRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
        let delete_ref = object::generate_delete_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject {
            extend_ref,
            transfer_ref,
            delete_ref
        });
    }
    fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::disable_ungated_transfer(transfer_ref);
    }
    fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::enable_ungated_transfer(transfer_ref);
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
        let object_signer = object::generate_linear_transfer_ref(transfer_ref);
        object::transfer_with_ref(object_signer, new_owner);
    }
    public entry fun delete(
        caller: &signer,
        object: Object<ControllerObject>,
    ) acquires ControllerObject {
        // Only let caller delete
        let caller_address = address_of(caller);
        assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
        let object_address = object::object_address(&object);
        // Retrieve the delete ref, it is consumed so it must be extracted
        // from the resource
        let ControllerObject {
            extend_ref: _,
            transfer_ref: _,
            delete_ref,
        } = move_from<ControllerObject>(object_address);
        // Delete the object forever!
        object::delete(delete_ref);
    }
}</code>
	<code>module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    const E_NOT_OWNER: u64 = 0;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef,
        transfer_ref: TransferRef,
        delete_ref: DeleteRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
        let delete_ref = object::generate_delete_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject {
            extend_ref,
            transfer_ref,
            delete_ref
        });
    }
    fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::disable_ungated_transfer(transfer_ref);
    }
    fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::enable_ungated_transfer(transfer_ref);
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
        let object_signer = object::generate_linear_transfer_ref(transfer_ref);
        object::transfer_with_ref(object_signer, new_owner);
    }
    public entry fun delete(
        caller: &signer,
        object: Object<ControllerObject>,
    ) acquires ControllerObject {
        // Only let caller delete
        let caller_address = address_of(caller);
        assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
        let object_address = object::object_address(&object);
        // Retrieve the delete ref, it is consumed so it must be extracted
        // from the resource
        let ControllerObject {
            extend_ref: _,
            transfer_ref: _,
            delete_ref,
        } = move_from<ControllerObject>(object_address);
        // Delete the object forever!
        object::delete(delete_ref);
    }
}</code>
	module movement::object_module_entry {
    use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    const E_NOT_OWNER: u64 = 0;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct NewObject has key {
        new_value: u64
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ControllerObject has key {
        extend_ref: ExtendRef,
        transfer_ref: TransferRef,
        delete_ref: DeleteRef
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
        let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
        let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
        let delete_ref = object::generate_delete_ref(state_object_constructor_ref);
        move_to(state_object_signer, ControllerObject {
            extend_ref,
            transfer_ref,
            delete_ref
        });
    }
    fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::disable_ungated_transfer(transfer_ref);
    }
    fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
        object::enable_ungated_transfer(transfer_ref);
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires ControllerObject {
        let addr = address_of(owner);
        assert!(object::is_owner(obj, addr), 1);
        let object_address = object::object_address(&obj);
        let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
        let object_signer = object::generate_signer_for_extending(extend_ref);
        move_to(&object_signer, NewObject { new_value: 50 });
    }
    public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject {
        let transfer_ref = &borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
        let object_signer = object::generate_linear_transfer_ref(transfer_ref);
        object::transfer_with_ref(object_signer, new_owner);
    }
    public entry fun delete(
        caller: &signer,
        object: Object<ControllerObject>,
    ) acquires ControllerObject {
        // Only let caller delete
        let caller_address = address_of(caller);
        assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
        let object_address = object::object_address(&object);
        // Retrieve the delete ref, it is consumed so it must be extracted
        // from the resource
        let ControllerObject {
            extend_ref: _,
            transfer_ref: _,
            delete_ref,
        } = move_from<ControllerObject>(object_address);
        // Delete the object forever!
        object::delete(delete_ref);
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/07-objects/07-object-ownership-and-transfer-object
Object Ownership & Transfer Object
Object Ownership & Transfer Object
On This Page
Summary
Implementing Object Ownership
Step 1: Update the  function
Step 2: Set the owner address
Step 3: Implement ownership checks
Step 4: Transfer Object
Full Code
Summary
Implements object ownership in a Rust module for creating and managing movement objects
Sets owner address during object creation
Implements ownership checks for functions like
set_value
Demonstrates how to retrieve the owner's address of an object
Implements a
transfer_obj
function to change object ownership
Includes test functions to verify object creation, value setting, and ownership transfer
Implementing Object Ownership
Now that we understand the concept of object ownership, let's apply it to our movement creation function. This will allow us to assign specific owners to each movement object we create.
Step 1: Update the
set_value
function
First, let's modify the
set_value
function to include an owner parameter:
public fun set_value(owner: address, value: u64): Object<MovementObject> {
    // ... existing code ...
}
Step 2: Set the owner address
Next, we'll update the object creation to use the provided is_owner address:
object::is_owner(owner, signer::address_of(owner)
Step 3: Implement ownership checks
Now that we have assigned an owner, we can implement functions that only the owner can call. For example, a function to train the movement object:
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    assert!(object::is_owner(owner, signer::address_of(owner)), 1); // Only the owner can transfer it
    let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
    object_data.value = new_value;
}
Alternatively, you can easily check the owner of an object using the function:
object::owner(movement_object)
#[view]
public fun get_owner_object(obj: Object<MovementObject>): address {
    object::owner(obj)
}
We'll add another test to demonstrate how to retrieve the address of the object we've created.
#[test(account = @0x1)]
fun test_get_owner_object_address(account: &signer)  {
    test_init_module(account);
    let addr = address_of(account);
    let value = get_object(addr);
    let get_owner = get_owner_object(value);
    print(&get_owner);
}
Result:
[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622
Step 4: Transfer Object
To transfer an object, we need the following information:
object::transfer(current_owner_address, movement_object, new_owner_address)
public fun transfer_obj(owner: &signer, new_owner: address) {
    let owner_addr = address_of(owner); // get current owner address
    let obj = get_object(owner_addr); // get Object<MovementObject>
    assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
    object::transfer(owner, obj, new_owner); // Transfer
}
#[test(account = @0x1, new_owner = @0x2)]
fun test_transfer_object(account: &signer, new_owner: address)  {
    test_init_module(account);
    transfer_obj(account, new_owner);
}
By implementing these steps, we've successfully integrated object ownership into our movement creation and training functions. This allows for more secure and personalized interactions with the movement objects in our module.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
On This Page
Summary
Implementing Object Ownership
Step 1: Update the  function
Step 2: Set the owner address
Step 3: Implement ownership checks
Step 4: Transfer Object
Full Code
On This Page
Summary
Implementing Object Ownership
Step 1: Update the  function
Step 2: Set the owner address
Step 3: Implement ownership checks
Step 4: Transfer Object
Full Code
			On This Page
			On This Page
			Summary
Implementing Object Ownership
Step 1: Update the  function
Step 2: Set the owner address
Step 3: Implement ownership checks
Step 4: Transfer Object
Full Code
			Summary
			Summary
			Summary
			Summary
			Implementing Object Ownership
Step 1: Update the  function
Step 2: Set the owner address
Step 3: Implement ownership checks
Step 4: Transfer Object
			Implementing Object Ownership
			Implementing Object Ownership
			Implementing Object Ownership
			Step 1: Update the  function
Step 2: Set the owner address
Step 3: Implement ownership checks
Step 4: Transfer Object
			Step 1: Update the  function
			Step 1: Update the  function
			Step 1: Update the  function
			Step 1: Update the  function
			Step 2: Set the owner address
			Step 2: Set the owner address
			Step 2: Set the owner address
			Step 2: Set the owner address
			Step 3: Implement ownership checks
			Step 3: Implement ownership checks
			Step 3: Implement ownership checks
			Step 3: Implement ownership checks
			Step 4: Transfer Object
			Step 4: Transfer Object
			Step 4: Transfer Object
			Step 4: Transfer Object
			Full Code
			Full Code
			Full Code
			Full Code
			Summary
Implements object ownership in a Rust module for creating and managing movement objects
Sets owner address during object creation
Implements ownership checks for functions like
set_value
Demonstrates how to retrieve the owner's address of an object
Implements a
transfer_obj
function to change object ownership
Includes test functions to verify object creation, value setting, and ownership transfer
Implementing Object Ownership
Now that we understand the concept of object ownership, let's apply it to our movement creation function. This will allow us to assign specific owners to each movement object we create.
Step 1: Update the
set_value
function
First, let's modify the
set_value
function to include an owner parameter:
public fun set_value(owner: address, value: u64): Object<MovementObject> {
    // ... existing code ...
}
Step 2: Set the owner address
Next, we'll update the object creation to use the provided is_owner address:
object::is_owner(owner, signer::address_of(owner)
Step 3: Implement ownership checks
Now that we have assigned an owner, we can implement functions that only the owner can call. For example, a function to train the movement object:
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    assert!(object::is_owner(owner, signer::address_of(owner)), 1); // Only the owner can transfer it
    let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
    object_data.value = new_value;
}
Alternatively, you can easily check the owner of an object using the function:
object::owner(movement_object)
#[view]
public fun get_owner_object(obj: Object<MovementObject>): address {
    object::owner(obj)
}
We'll add another test to demonstrate how to retrieve the address of the object we've created.
#[test(account = @0x1)]
fun test_get_owner_object_address(account: &signer)  {
    test_init_module(account);
    let addr = address_of(account);
    let value = get_object(addr);
    let get_owner = get_owner_object(value);
    print(&get_owner);
}
Result:
[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622
Step 4: Transfer Object
To transfer an object, we need the following information:
object::transfer(current_owner_address, movement_object, new_owner_address)
public fun transfer_obj(owner: &signer, new_owner: address) {
    let owner_addr = address_of(owner); // get current owner address
    let obj = get_object(owner_addr); // get Object<MovementObject>
    assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
    object::transfer(owner, obj, new_owner); // Transfer
}
#[test(account = @0x1, new_owner = @0x2)]
fun test_transfer_object(account: &signer, new_owner: address)  {
    test_init_module(account);
    transfer_obj(account, new_owner);
}
By implementing these steps, we've successfully integrated object ownership into our movement creation and training functions. This allows for more secure and personalized interactions with the movement objects in our module.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
			Summary
Implements object ownership in a Rust module for creating and managing movement objects
Sets owner address during object creation
Implements ownership checks for functions like
set_value
Demonstrates how to retrieve the owner's address of an object
Implements a
transfer_obj
function to change object ownership
Includes test functions to verify object creation, value setting, and ownership transfer
Implementing Object Ownership
Now that we understand the concept of object ownership, let's apply it to our movement creation function. This will allow us to assign specific owners to each movement object we create.
Step 1: Update the
set_value
function
First, let's modify the
set_value
function to include an owner parameter:
public fun set_value(owner: address, value: u64): Object<MovementObject> {
    // ... existing code ...
}
Step 2: Set the owner address
Next, we'll update the object creation to use the provided is_owner address:
object::is_owner(owner, signer::address_of(owner)
Step 3: Implement ownership checks
Now that we have assigned an owner, we can implement functions that only the owner can call. For example, a function to train the movement object:
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    assert!(object::is_owner(owner, signer::address_of(owner)), 1); // Only the owner can transfer it
    let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
    object_data.value = new_value;
}
Alternatively, you can easily check the owner of an object using the function:
object::owner(movement_object)
#[view]
public fun get_owner_object(obj: Object<MovementObject>): address {
    object::owner(obj)
}
We'll add another test to demonstrate how to retrieve the address of the object we've created.
#[test(account = @0x1)]
fun test_get_owner_object_address(account: &signer)  {
    test_init_module(account);
    let addr = address_of(account);
    let value = get_object(addr);
    let get_owner = get_owner_object(value);
    print(&get_owner);
}
Result:
[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622
Step 4: Transfer Object
To transfer an object, we need the following information:
object::transfer(current_owner_address, movement_object, new_owner_address)
public fun transfer_obj(owner: &signer, new_owner: address) {
    let owner_addr = address_of(owner); // get current owner address
    let obj = get_object(owner_addr); // get Object<MovementObject>
    assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
    object::transfer(owner, obj, new_owner); // Transfer
}
#[test(account = @0x1, new_owner = @0x2)]
fun test_transfer_object(account: &signer, new_owner: address)  {
    test_init_module(account);
    transfer_obj(account, new_owner);
}
By implementing these steps, we've successfully integrated object ownership into our movement creation and training functions. This allows for more secure and personalized interactions with the movement objects in our module.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
			Summary
Implements object ownership in a Rust module for creating and managing movement objects
Sets owner address during object creation
Implements ownership checks for functions like
set_value
Demonstrates how to retrieve the owner's address of an object
Implements a
transfer_obj
function to change object ownership
Includes test functions to verify object creation, value setting, and ownership transfer
Implementing Object Ownership
Now that we understand the concept of object ownership, let's apply it to our movement creation function. This will allow us to assign specific owners to each movement object we create.
Step 1: Update the
set_value
function
First, let's modify the
set_value
function to include an owner parameter:
public fun set_value(owner: address, value: u64): Object<MovementObject> {
    // ... existing code ...
}
Step 2: Set the owner address
Next, we'll update the object creation to use the provided is_owner address:
object::is_owner(owner, signer::address_of(owner)
Step 3: Implement ownership checks
Now that we have assigned an owner, we can implement functions that only the owner can call. For example, a function to train the movement object:
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    assert!(object::is_owner(owner, signer::address_of(owner)), 1); // Only the owner can transfer it
    let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
    object_data.value = new_value;
}
Alternatively, you can easily check the owner of an object using the function:
object::owner(movement_object)
#[view]
public fun get_owner_object(obj: Object<MovementObject>): address {
    object::owner(obj)
}
We'll add another test to demonstrate how to retrieve the address of the object we've created.
#[test(account = @0x1)]
fun test_get_owner_object_address(account: &signer)  {
    test_init_module(account);
    let addr = address_of(account);
    let value = get_object(addr);
    let get_owner = get_owner_object(value);
    print(&get_owner);
}
Result:
[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622
Step 4: Transfer Object
To transfer an object, we need the following information:
object::transfer(current_owner_address, movement_object, new_owner_address)
public fun transfer_obj(owner: &signer, new_owner: address) {
    let owner_addr = address_of(owner); // get current owner address
    let obj = get_object(owner_addr); // get Object<MovementObject>
    assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
    object::transfer(owner, obj, new_owner); // Transfer
}
#[test(account = @0x1, new_owner = @0x2)]
fun test_transfer_object(account: &signer, new_owner: address)  {
    test_init_module(account);
    transfer_obj(account, new_owner);
}
By implementing these steps, we've successfully integrated object ownership into our movement creation and training functions. This allows for more secure and personalized interactions with the movement objects in our module.
Full Code
module movement::object_module_entry {
    use aptos_framework::object::{Self, Object};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}
	Summary
	Summary
	Implements object ownership in a Rust module for creating and managing movement objects
Sets owner address during object creation
Implements ownership checks for functions like
set_value
Demonstrates how to retrieve the owner's address of an object
Implements a
transfer_obj
function to change object ownership
Includes test functions to verify object creation, value setting, and ownership transfer
	Implements object ownership in a Rust module for creating and managing movement objects
	Implements object ownership in a Rust module for creating and managing movement objects
	Sets owner address during object creation
	Sets owner address during object creation
	Implements ownership checks for functions like
set_value
	Implements ownership checks for functions like
	<code>set_value</code>
	set_value
	Demonstrates how to retrieve the owner's address of an object
	Demonstrates how to retrieve the owner's address of an object
	Implements a
transfer_obj
function to change object ownership
	Implements a
	<code>transfer_obj</code>
	transfer_obj
	function to change object ownership
	Includes test functions to verify object creation, value setting, and ownership transfer
	Includes test functions to verify object creation, value setting, and ownership transfer
	Implementing Object Ownership
	Implementing Object Ownership
	Now that we understand the concept of object ownership, let's apply it to our movement creation function. This will allow us to assign specific owners to each movement object we create.
	Now that we understand the concept of object ownership, let's apply it to our movement creation function. This will allow us to assign specific owners to each movement object we create.
		Step 1: Update the set_value function
		Step 1: Update the
		<code>set_value</code>
		set_value
		function
		First, let's modify the
set_value
function to include an owner parameter:
		First, let's modify the
		<code>set_value</code>
		set_value
		function to include an owner parameter:
		<code>public fun set_value(owner: address, value: u64): Object<MovementObject> {
    // ... existing code ...
}</code>
		<code>public fun set_value(owner: address, value: u64): Object<MovementObject> {
    // ... existing code ...
}</code>
		public fun set_value(owner: address, value: u64): Object<MovementObject> {
    // ... existing code ...
}
		Step 2: Set the owner address
		Step 2: Set the owner address
		Next, we'll update the object creation to use the provided is_owner address:
		Next, we'll update the object creation to use the provided is_owner address:
		<code>object::is_owner(owner, signer::address_of(owner)</code>
		<code>object::is_owner(owner, signer::address_of(owner)</code>
		object::is_owner(owner, signer::address_of(owner)
		Step 3: Implement ownership checks
		Step 3: Implement ownership checks
		Now that we have assigned an owner, we can implement functions that only the owner can call. For example, a function to train the movement object:
		Now that we have assigned an owner, we can implement functions that only the owner can call. For example, a function to train the movement object:
		<code>public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    assert!(object::is_owner(owner, signer::address_of(owner)), 1); // Only the owner can transfer it
    let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
    object_data.value = new_value;
}</code>
		<code>public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    assert!(object::is_owner(owner, signer::address_of(owner)), 1); // Only the owner can transfer it
    let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
    object_data.value = new_value;
}</code>
		public fun set_value(owner: address, new_value: u64) acquires MovementObject {
    assert!(object::is_owner(owner, signer::address_of(owner)), 1); // Only the owner can transfer it
    let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
    object_data.value = new_value;
}
		Alternatively, you can easily check the owner of an object using the function:
object::owner(movement_object)
		Alternatively, you can easily check the owner of an object using the function:
		<code>object::owner(movement_object)</code>
		object::owner(movement_object)
		<code>#[view]
public fun get_owner_object(obj: Object<MovementObject>): address {
    object::owner(obj)
}</code>
		<code>#[view]
public fun get_owner_object(obj: Object<MovementObject>): address {
    object::owner(obj)
}</code>
		#[view]
public fun get_owner_object(obj: Object<MovementObject>): address {
    object::owner(obj)
}
		We'll add another test to demonstrate how to retrieve the address of the object we've created.
		We'll add another test to demonstrate how to retrieve the address of the object we've created.
		<code>#[test(account = @0x1)]
fun test_get_owner_object_address(account: &signer)  {
    test_init_module(account);
    let addr = address_of(account);
    let value = get_object(addr);
    let get_owner = get_owner_object(value);
    print(&get_owner);
}</code>
		<code>#[test(account = @0x1)]
fun test_get_owner_object_address(account: &signer)  {
    test_init_module(account);
    let addr = address_of(account);
    let value = get_object(addr);
    let get_owner = get_owner_object(value);
    print(&get_owner);
}</code>
		#[test(account = @0x1)]
fun test_get_owner_object_address(account: &signer)  {
    test_init_module(account);
    let addr = address_of(account);
    let value = get_object(addr);
    let get_owner = get_owner_object(value);
    print(&get_owner);
}
		Result:
		Result:
		<code>[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622</code>
		<code>[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622</code>
		[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622
		Step 4: Transfer Object
		Step 4: Transfer Object
		To transfer an object, we need the following information:
object::transfer(current_owner_address, movement_object, new_owner_address)
		To transfer an object, we need the following information:
		<code>object::transfer(current_owner_address, movement_object, new_owner_address)</code>
		object::transfer(current_owner_address, movement_object, new_owner_address)
		<code>public fun transfer_obj(owner: &signer, new_owner: address) {
    let owner_addr = address_of(owner); // get current owner address
    let obj = get_object(owner_addr); // get Object<MovementObject>
    assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
    object::transfer(owner, obj, new_owner); // Transfer
}
#[test(account = @0x1, new_owner = @0x2)]
fun test_transfer_object(account: &signer, new_owner: address)  {
    test_init_module(account);
    transfer_obj(account, new_owner);
}</code>
		<code>public fun transfer_obj(owner: &signer, new_owner: address) {
    let owner_addr = address_of(owner); // get current owner address
    let obj = get_object(owner_addr); // get Object<MovementObject>
    assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
    object::transfer(owner, obj, new_owner); // Transfer
}
#[test(account = @0x1, new_owner = @0x2)]
fun test_transfer_object(account: &signer, new_owner: address)  {
    test_init_module(account);
    transfer_obj(account, new_owner);
}</code>
		public fun transfer_obj(owner: &signer, new_owner: address) {
    let owner_addr = address_of(owner); // get current owner address
    let obj = get_object(owner_addr); // get Object<MovementObject>
    assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
    object::transfer(owner, obj, new_owner); // Transfer
}
#[test(account = @0x1, new_owner = @0x2)]
fun test_transfer_object(account: &signer, new_owner: address)  {
    test_init_module(account);
    transfer_obj(account, new_owner);
}
		By implementing these steps, we've successfully integrated object ownership into our movement creation and training functions. This allows for more secure and personalized interactions with the movement objects in our module.
		By implementing these steps, we've successfully integrated object ownership into our movement creation and training functions. This allows for more secure and personalized interactions with the movement objects in our module.
	Full Code
	Full Code
	<code>module movement::object_module_entry {
    use aptos_framework::object::{Self, Object};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}</code>
	<code>module movement::object_module_entry {
    use aptos_framework::object::{Self, Object};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}</code>
	module movement::object_module_entry {
    use aptos_framework::object::{Self, Object};
    use std::signer::address_of;
    use std::debug::print;
    const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementObject has key {
        value: u64
    }
    fun init_module(owner: &signer) {
        let state_object_constructor_ref = &object::create_named_object(owner, MOVEMENT_OBJECT_NAME);
        let state_object_signer = &object::generate_signer(state_object_constructor_ref);
        move_to(state_object_signer, MovementObject {
            value: 10
        });
    }
    #[test_only]
    fun test_init_module(onwer: &signer) {
        init_module(onwer);
    }
    #[view]
    public fun get_object_address(owner: address): address {
        object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
    }
    #[view]
    public fun get_object(owner: address): Object<MovementObject> {
        object::address_to_object(get_object_address(owner))
    }
    public fun get_value(owner: address): u64 acquires MovementObject {
        borrow_global<MovementObject>(get_object_address(owner)).value
    }
    #[view]
    public fun get_owner_object(obj: Object<MovementObject>): address {
        object::owner(obj)
    }
    public fun set_value(owner: address, new_value: u64) acquires MovementObject {
        let obj = get_object(owner);
        assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can transfer/modify it
        let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
        object_data.value = new_value;
    }
    public fun transfer_obj(owner: &signer, new_owner: address) {
        let owner_addr = address_of(owner);
        let obj = get_object(owner_addr);
        assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can transfer/modify it
        object::transfer(owner, obj, new_owner);
    }
    #[test(account = @0x1, new_owner = @0x2)]
    fun test_transfer_object(account: &signer, new_owner: address)  {
        test_init_module(account);
        transfer_obj(account, new_owner);
    }
    #[test(account = @0x1)]
    fun test_get_owner_object_address(account: &signer)  {
        test_init_module(account);
        let addr = address_of(account);
        let obj = get_object(addr);
        let get_owner = get_owner_object(obj);
        print(&get_owner);
    }
    #[test(account = @0x1)]
    fun test_get_object_address(account: &signer) {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_object_address(addr);
        print(&value);
    }
    #[test(account = @0x1)]
    fun test_get_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        let value = get_value(addr);
        assert!(value == 10, 0);
    }
    #[test(account = @0x1)]
    fun test_set_object(account: &signer) acquires MovementObject {
        test_init_module(account);
        let addr = address_of(account);
        set_value(addr, 20);
        let value = get_value(addr);
        assert!(value == 20, 1);
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/08-smart-vector
Smart Vector
Smart Vector
On This Page
Summary
Overview
Create a Smart Vector
Running Test
How Smart Vector works
Additional Smart Vector Functions
Summary
Smart Vector is an advanced data structure in the Aptos Framework designed to optimize data management in large-scale applications.
It combines the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses.
Smart Vector uses a bucket system to efficiently store and access large amounts of data, potentially reducing gas fees and improving performance.
The structure automatically divides elements into multiple buckets, optimizing both reading and writing processes.
Smart Vector offers a solution to performance bottlenecks often encountered when scaling applications with conventional data structures.
Implementation involves creating a SmartVector, adding elements, and storing it within a custom struct in the account's storage.
Overview
As you progress beyond the foundational P0 course, you'll encounter more complex data management challenges. While vectors and simple maps serve well for small-scale projects, they often fall short when handling larger datasets. To effectively scale your applications, it's crucial to adopt more advanced data structures.
One common pitfall in software development is underestimating the performance impact of data growth. As your application expands, operations that were once swift on vectors and simple maps can become significant bottlenecks, leading to increased processing time and resource consumption.
Conventional tables present an alternative strategy, offering pinpoint access to specific data elements. While this granular control can be beneficial, it's essential to weigh the storage costs associated with expanding these tables.
This is where smart tables and smart vector, a cutting-edge feature of the Aptos Framework, come into play. These sophisticated data structures are engineered to harness the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses. By leveraging smart tables & smart vector, developers can streamline data management, potentially reducing gas fees and boosting overall system performance.
Create a Smart Vector
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
}
Module Declaration:
module movement::smart_vector_module {
    // Module contents
}
This declares a new module named "smart_vector_module" within the "movement" package.
Importing the Smart Vector:
use aptos_std::smart_vector::{Self, SmartVector};
This line imports the SmartVector type and its associated functions from the Aptos standard library.
Defining a Custom Struct:
struct MovementObject has key {
    value: SmartVector<u64>;
}
This defines a new struct called MovementObject with a SmartVector of unsigned 64-bit integers (u64) as its value.
Initializing the Module:
fun init_module(caller: &signer) {
    // Function body
}
This function is called when the module is first published. It takes a reference to the signer (account) publishing the module.
Creating a New Smart Vector:
let smartvec = smart_vector::new<u64>();
This creates a new SmartVector that will hold u64 values.
Adding Elements to the Smart Vector:
smart_vector::push_back(&mut smartvec, 1);
smart_vector::push_back(&mut smartvec, 2);
smart_vector::push_back(&mut smartvec, 3);
These lines add the values 1, 2, and 3 to the end of the SmartVector.
Creating and Storing the MovementObject:
move_to(caller, MovementObject {
    value: smartvec
});
This creates a new MovementObject with the SmartVector we just populated, and stores it in the account's storage.
Running Test
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}
Running test:
movement move test -f test_get_length
Result:
Running Move unit tests
[debug] 3
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::test_get_length
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
How Smart Vector works
If you deploy modules and create a smart vector object, you can check the account data and you'll see an object like this:
{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": []
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "1",
        "2",
        "3"
      ]
    }
  }
}
Here, the smart vector stores data in
bucket
s, allowing it to hold a large number of elements while optimizing gas costs for users. Each
bucket
is a standard vector that stores the elements of the smart vector.
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        let i = 0;
        while (i <= 1000) {
            smart_vector::push_back(&mut smartvec, i);
            i = i + 1;
        };
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}
In the example above, I input 1000 elements using a
while loop
. When checking the result with the command
movement account list
, you'll see the following output:
{
  "0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": [
          {
            "bucket_size": "128",
            "buckets": {
              "inner": {
                "handle": "0xfb918a6dc3e0db1a6bef0ebdf53554f0fc759c01018c5012071fe2c4a86e8b80"
              },
              "length": "8"
            },
            "end_index": "983"
          }
        ]
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17"
      ]
    }
  }
},
Here, the smart vector automatically divides elements into multiple buckets. For example, when you access elements from 0-100, it only accesses the bucket containing those specific elements. This approach optimizes both the reading and writing processes of the smart vector.
Additional Smart Vector Functions
| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
new
| None | Creates an empty SmartVector |
SmartVector<T>
|
|
empty
| None | Creates an empty SmartVector (deprecated) |
SmartVector<T>
|
|
empty_with_config
|
inline_capacity: u64
,
bucket_size: u64
| Creates an empty SmartVector with custom configuration |
SmartVector<T>
|
|
singleton
|
element: T
| Creates a SmartVector with a single element |
SmartVector<T>
|
|
destroy_empty
|
self: SmartVector<T>
| Destroys an empty SmartVector | None |
|
destroy
|
self: SmartVector<T>
| Destroys a SmartVector | None |
|
clear
|
self: &mut SmartVector<T>
| Clears all elements from a SmartVector | None |
|
borrow
|
self: &SmartVector<T>
,
i: u64
| Borrows the i-th element |
&T
|
|
borrow_mut
|
self: &mut SmartVector<T>
,
i: u64
| Mutably borrows the i-th element |
&mut T
|
|
append
|
self: &mut SmartVector<T>
,
other: SmartVector<T>
| Moves all elements from other to self | None |
|
add_all
|
self: &mut SmartVector<T>
,
vals: vector<T>
| Adds multiple values to the vector | None |
|
to_vector
|
self: &SmartVector<T>
| Converts SmartVector to a native vector |
vector<T>
|
|
push_back
|
self: &mut SmartVector<T>
,
val: T
| Adds an element to the end | None |
|
pop_back
|
self: &mut SmartVector<T>
| Removes and returns the last element |
T
|
|
remove
|
self: &mut SmartVector<T>
,
i: u64
| Removes and returns the i-th element |
T
|
|
swap_remove
|
self: &mut SmartVector<T>
,
i: u64
| Swaps the i-th element with the last and removes it |
T
|
|
swap
|
self: &mut SmartVector<T>
,
i: u64
,
j: u64
| Swaps the i-th and j-th elements | None |
|
reverse
|
self: &mut SmartVector<T>
| Reverses the order of elements | None |
|
index_of
|
self: &SmartVector<T>
,
val: &T
| Finds the index of an element |
(bool, u64)
|
|
contains
|
self: &SmartVector<T>
,
val: &T
| Checks if an element exists |
bool
|
|
length
|
self: &SmartVector<T>
| Returns the number of elements |
u64
|
|
is_empty
|
self: &SmartVector<T>
| Checks if the vector is empty |
bool
|
|
for_each
|
self: SmartVector<T>
,
f: \|T\|
| Applies a function to each element, consuming the vector | None |
|
for_each_reverse
|
self: SmartVector<T>
,
f: \|T\|
| Applies a function to each element in reverse order, consuming the vector | None |
|
for_each_ref
|
self: &SmartVector<T>
,
f: \|&T\|
| Applies a function to a reference of each element | None |
|
for_each_mut
|
self: &mut SmartVector<T>
,
f: \|&mut T\|
| Applies a function to a mutable reference of each element | None |
|
enumerate_ref
|
self: &SmartVector<T>
,
f: \|(u64, &T)\|
| Applies a function to each element with its index | None |
|
enumerate_mut
|
self: &mut SmartVector<T>
,
f: \|(u64, &mut T)\|
| Applies a function to each mutable element with its index | None |
|
fold
|
self: SmartVector<T>
,
init: Accumulator
,
f: \|(Accumulator, T)\|Accumulator
| Folds the vector into an accumulated value |
Accumulator
|
|
foldr
|
self: SmartVector<T>
,
init: Accumulator
,
f: \|(T, Accumulator)\|Accumulator
| Folds the vector in reverse order into an accumulated value |
Accumulator
|
|
map_ref
|
self: &SmartVector<T1>
,
f: \|&T1\|T2
| Maps a function over references of the elements |
SmartVector<T2>
|
|
map
|
self: SmartVector<T1>
,
f: \|T1\|T2
| Maps a function over the elements |
SmartVector<T2>
|
|
filter
|
self: SmartVector<T>
,
p: \|&T\|bool
| Filters elements based on a predicate |
SmartVector<T>
|
|
zip
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|
| Zips two SmartVectors and applies a function to each pair | None |
|
zip_reverse
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|
| Zips two SmartVectors in reverse and applies a function to each pair | None |
|
zip_ref
|
self: &SmartVector<T1>
,
v2: &SmartVector<T2>
,
f: \|(&T1, &T2)\|
| Zips references of two SmartVectors and applies a function to each pair | None |
|
zip_mut
|
self: &mut SmartVector<T1>
,
v2: &mut SmartVector<T2>
,
f: \|(&mut T1, &mut T2)\|
| Zips mutable references of two SmartVectors and applies a function to each pair | None |
|
zip_map
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|NewT
| Zips two SmartVectors and maps a function over the pairs |
SmartVector<NewT>
|
|
zip_map_ref
|
self: &SmartVector<T1>
,
v2: &SmartVector<T2>
,
f: \|(&T1, &T2)\|NewT
| Zips references of two SmartVectors and maps a function over the pairs |
SmartVector<NewT>
|
On This Page
Summary
Overview
Create a Smart Vector
Running Test
How Smart Vector works
Additional Smart Vector Functions
On This Page
Summary
Overview
Create a Smart Vector
Running Test
How Smart Vector works
Additional Smart Vector Functions
			On This Page
			On This Page
			Summary
Overview
Create a Smart Vector
Running Test
How Smart Vector works
Additional Smart Vector Functions
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			Create a Smart Vector
			Create a Smart Vector
			Create a Smart Vector
			Create a Smart Vector
			Running Test
			Running Test
			Running Test
			Running Test
			How Smart Vector works
			How Smart Vector works
			How Smart Vector works
			How Smart Vector works
			Additional Smart Vector Functions
			Additional Smart Vector Functions
			Additional Smart Vector Functions
			Additional Smart Vector Functions
			Summary
Smart Vector is an advanced data structure in the Aptos Framework designed to optimize data management in large-scale applications.
It combines the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses.
Smart Vector uses a bucket system to efficiently store and access large amounts of data, potentially reducing gas fees and improving performance.
The structure automatically divides elements into multiple buckets, optimizing both reading and writing processes.
Smart Vector offers a solution to performance bottlenecks often encountered when scaling applications with conventional data structures.
Implementation involves creating a SmartVector, adding elements, and storing it within a custom struct in the account's storage.
Overview
As you progress beyond the foundational P0 course, you'll encounter more complex data management challenges. While vectors and simple maps serve well for small-scale projects, they often fall short when handling larger datasets. To effectively scale your applications, it's crucial to adopt more advanced data structures.
One common pitfall in software development is underestimating the performance impact of data growth. As your application expands, operations that were once swift on vectors and simple maps can become significant bottlenecks, leading to increased processing time and resource consumption.
Conventional tables present an alternative strategy, offering pinpoint access to specific data elements. While this granular control can be beneficial, it's essential to weigh the storage costs associated with expanding these tables.
This is where smart tables and smart vector, a cutting-edge feature of the Aptos Framework, come into play. These sophisticated data structures are engineered to harness the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses. By leveraging smart tables & smart vector, developers can streamline data management, potentially reducing gas fees and boosting overall system performance.
Create a Smart Vector
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
}
Module Declaration:
module movement::smart_vector_module {
    // Module contents
}
This declares a new module named "smart_vector_module" within the "movement" package.
Importing the Smart Vector:
use aptos_std::smart_vector::{Self, SmartVector};
This line imports the SmartVector type and its associated functions from the Aptos standard library.
Defining a Custom Struct:
struct MovementObject has key {
    value: SmartVector<u64>;
}
This defines a new struct called MovementObject with a SmartVector of unsigned 64-bit integers (u64) as its value.
Initializing the Module:
fun init_module(caller: &signer) {
    // Function body
}
This function is called when the module is first published. It takes a reference to the signer (account) publishing the module.
Creating a New Smart Vector:
let smartvec = smart_vector::new<u64>();
This creates a new SmartVector that will hold u64 values.
Adding Elements to the Smart Vector:
smart_vector::push_back(&mut smartvec, 1);
smart_vector::push_back(&mut smartvec, 2);
smart_vector::push_back(&mut smartvec, 3);
These lines add the values 1, 2, and 3 to the end of the SmartVector.
Creating and Storing the MovementObject:
move_to(caller, MovementObject {
    value: smartvec
});
This creates a new MovementObject with the SmartVector we just populated, and stores it in the account's storage.
Running Test
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}
Running test:
movement move test -f test_get_length
Result:
Running Move unit tests
[debug] 3
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::test_get_length
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
How Smart Vector works
If you deploy modules and create a smart vector object, you can check the account data and you'll see an object like this:
{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": []
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "1",
        "2",
        "3"
      ]
    }
  }
}
Here, the smart vector stores data in
bucket
s, allowing it to hold a large number of elements while optimizing gas costs for users. Each
bucket
is a standard vector that stores the elements of the smart vector.
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        let i = 0;
        while (i <= 1000) {
            smart_vector::push_back(&mut smartvec, i);
            i = i + 1;
        };
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}
In the example above, I input 1000 elements using a
while loop
. When checking the result with the command
movement account list
, you'll see the following output:
{
  "0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": [
          {
            "bucket_size": "128",
            "buckets": {
              "inner": {
                "handle": "0xfb918a6dc3e0db1a6bef0ebdf53554f0fc759c01018c5012071fe2c4a86e8b80"
              },
              "length": "8"
            },
            "end_index": "983"
          }
        ]
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17"
      ]
    }
  }
},
Here, the smart vector automatically divides elements into multiple buckets. For example, when you access elements from 0-100, it only accesses the bucket containing those specific elements. This approach optimizes both the reading and writing processes of the smart vector.
Additional Smart Vector Functions
| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
new
| None | Creates an empty SmartVector |
SmartVector<T>
|
|
empty
| None | Creates an empty SmartVector (deprecated) |
SmartVector<T>
|
|
empty_with_config
|
inline_capacity: u64
,
bucket_size: u64
| Creates an empty SmartVector with custom configuration |
SmartVector<T>
|
|
singleton
|
element: T
| Creates a SmartVector with a single element |
SmartVector<T>
|
|
destroy_empty
|
self: SmartVector<T>
| Destroys an empty SmartVector | None |
|
destroy
|
self: SmartVector<T>
| Destroys a SmartVector | None |
|
clear
|
self: &mut SmartVector<T>
| Clears all elements from a SmartVector | None |
|
borrow
|
self: &SmartVector<T>
,
i: u64
| Borrows the i-th element |
&T
|
|
borrow_mut
|
self: &mut SmartVector<T>
,
i: u64
| Mutably borrows the i-th element |
&mut T
|
|
append
|
self: &mut SmartVector<T>
,
other: SmartVector<T>
| Moves all elements from other to self | None |
|
add_all
|
self: &mut SmartVector<T>
,
vals: vector<T>
| Adds multiple values to the vector | None |
|
to_vector
|
self: &SmartVector<T>
| Converts SmartVector to a native vector |
vector<T>
|
|
push_back
|
self: &mut SmartVector<T>
,
val: T
| Adds an element to the end | None |
|
pop_back
|
self: &mut SmartVector<T>
| Removes and returns the last element |
T
|
|
remove
|
self: &mut SmartVector<T>
,
i: u64
| Removes and returns the i-th element |
T
|
|
swap_remove
|
self: &mut SmartVector<T>
,
i: u64
| Swaps the i-th element with the last and removes it |
T
|
|
swap
|
self: &mut SmartVector<T>
,
i: u64
,
j: u64
| Swaps the i-th and j-th elements | None |
|
reverse
|
self: &mut SmartVector<T>
| Reverses the order of elements | None |
|
index_of
|
self: &SmartVector<T>
,
val: &T
| Finds the index of an element |
(bool, u64)
|
|
contains
|
self: &SmartVector<T>
,
val: &T
| Checks if an element exists |
bool
|
|
length
|
self: &SmartVector<T>
| Returns the number of elements |
u64
|
|
is_empty
|
self: &SmartVector<T>
| Checks if the vector is empty |
bool
|
|
for_each
|
self: SmartVector<T>
,
f: \|T\|
| Applies a function to each element, consuming the vector | None |
|
for_each_reverse
|
self: SmartVector<T>
,
f: \|T\|
| Applies a function to each element in reverse order, consuming the vector | None |
|
for_each_ref
|
self: &SmartVector<T>
,
f: \|&T\|
| Applies a function to a reference of each element | None |
|
for_each_mut
|
self: &mut SmartVector<T>
,
f: \|&mut T\|
| Applies a function to a mutable reference of each element | None |
|
enumerate_ref
|
self: &SmartVector<T>
,
f: \|(u64, &T)\|
| Applies a function to each element with its index | None |
|
enumerate_mut
|
self: &mut SmartVector<T>
,
f: \|(u64, &mut T)\|
| Applies a function to each mutable element with its index | None |
|
fold
|
self: SmartVector<T>
,
init: Accumulator
,
f: \|(Accumulator, T)\|Accumulator
| Folds the vector into an accumulated value |
Accumulator
|
|
foldr
|
self: SmartVector<T>
,
init: Accumulator
,
f: \|(T, Accumulator)\|Accumulator
| Folds the vector in reverse order into an accumulated value |
Accumulator
|
|
map_ref
|
self: &SmartVector<T1>
,
f: \|&T1\|T2
| Maps a function over references of the elements |
SmartVector<T2>
|
|
map
|
self: SmartVector<T1>
,
f: \|T1\|T2
| Maps a function over the elements |
SmartVector<T2>
|
|
filter
|
self: SmartVector<T>
,
p: \|&T\|bool
| Filters elements based on a predicate |
SmartVector<T>
|
|
zip
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|
| Zips two SmartVectors and applies a function to each pair | None |
|
zip_reverse
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|
| Zips two SmartVectors in reverse and applies a function to each pair | None |
|
zip_ref
|
self: &SmartVector<T1>
,
v2: &SmartVector<T2>
,
f: \|(&T1, &T2)\|
| Zips references of two SmartVectors and applies a function to each pair | None |
|
zip_mut
|
self: &mut SmartVector<T1>
,
v2: &mut SmartVector<T2>
,
f: \|(&mut T1, &mut T2)\|
| Zips mutable references of two SmartVectors and applies a function to each pair | None |
|
zip_map
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|NewT
| Zips two SmartVectors and maps a function over the pairs |
SmartVector<NewT>
|
|
zip_map_ref
|
self: &SmartVector<T1>
,
v2: &SmartVector<T2>
,
f: \|(&T1, &T2)\|NewT
| Zips references of two SmartVectors and maps a function over the pairs |
SmartVector<NewT>
|
			Summary
Smart Vector is an advanced data structure in the Aptos Framework designed to optimize data management in large-scale applications.
It combines the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses.
Smart Vector uses a bucket system to efficiently store and access large amounts of data, potentially reducing gas fees and improving performance.
The structure automatically divides elements into multiple buckets, optimizing both reading and writing processes.
Smart Vector offers a solution to performance bottlenecks often encountered when scaling applications with conventional data structures.
Implementation involves creating a SmartVector, adding elements, and storing it within a custom struct in the account's storage.
Overview
As you progress beyond the foundational P0 course, you'll encounter more complex data management challenges. While vectors and simple maps serve well for small-scale projects, they often fall short when handling larger datasets. To effectively scale your applications, it's crucial to adopt more advanced data structures.
One common pitfall in software development is underestimating the performance impact of data growth. As your application expands, operations that were once swift on vectors and simple maps can become significant bottlenecks, leading to increased processing time and resource consumption.
Conventional tables present an alternative strategy, offering pinpoint access to specific data elements. While this granular control can be beneficial, it's essential to weigh the storage costs associated with expanding these tables.
This is where smart tables and smart vector, a cutting-edge feature of the Aptos Framework, come into play. These sophisticated data structures are engineered to harness the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses. By leveraging smart tables & smart vector, developers can streamline data management, potentially reducing gas fees and boosting overall system performance.
Create a Smart Vector
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
}
Module Declaration:
module movement::smart_vector_module {
    // Module contents
}
This declares a new module named "smart_vector_module" within the "movement" package.
Importing the Smart Vector:
use aptos_std::smart_vector::{Self, SmartVector};
This line imports the SmartVector type and its associated functions from the Aptos standard library.
Defining a Custom Struct:
struct MovementObject has key {
    value: SmartVector<u64>;
}
This defines a new struct called MovementObject with a SmartVector of unsigned 64-bit integers (u64) as its value.
Initializing the Module:
fun init_module(caller: &signer) {
    // Function body
}
This function is called when the module is first published. It takes a reference to the signer (account) publishing the module.
Creating a New Smart Vector:
let smartvec = smart_vector::new<u64>();
This creates a new SmartVector that will hold u64 values.
Adding Elements to the Smart Vector:
smart_vector::push_back(&mut smartvec, 1);
smart_vector::push_back(&mut smartvec, 2);
smart_vector::push_back(&mut smartvec, 3);
These lines add the values 1, 2, and 3 to the end of the SmartVector.
Creating and Storing the MovementObject:
move_to(caller, MovementObject {
    value: smartvec
});
This creates a new MovementObject with the SmartVector we just populated, and stores it in the account's storage.
Running Test
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}
Running test:
movement move test -f test_get_length
Result:
Running Move unit tests
[debug] 3
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::test_get_length
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
How Smart Vector works
If you deploy modules and create a smart vector object, you can check the account data and you'll see an object like this:
{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": []
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "1",
        "2",
        "3"
      ]
    }
  }
}
Here, the smart vector stores data in
bucket
s, allowing it to hold a large number of elements while optimizing gas costs for users. Each
bucket
is a standard vector that stores the elements of the smart vector.
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        let i = 0;
        while (i <= 1000) {
            smart_vector::push_back(&mut smartvec, i);
            i = i + 1;
        };
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}
In the example above, I input 1000 elements using a
while loop
. When checking the result with the command
movement account list
, you'll see the following output:
{
  "0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": [
          {
            "bucket_size": "128",
            "buckets": {
              "inner": {
                "handle": "0xfb918a6dc3e0db1a6bef0ebdf53554f0fc759c01018c5012071fe2c4a86e8b80"
              },
              "length": "8"
            },
            "end_index": "983"
          }
        ]
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17"
      ]
    }
  }
},
Here, the smart vector automatically divides elements into multiple buckets. For example, when you access elements from 0-100, it only accesses the bucket containing those specific elements. This approach optimizes both the reading and writing processes of the smart vector.
Additional Smart Vector Functions
| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
new
| None | Creates an empty SmartVector |
SmartVector<T>
|
|
empty
| None | Creates an empty SmartVector (deprecated) |
SmartVector<T>
|
|
empty_with_config
|
inline_capacity: u64
,
bucket_size: u64
| Creates an empty SmartVector with custom configuration |
SmartVector<T>
|
|
singleton
|
element: T
| Creates a SmartVector with a single element |
SmartVector<T>
|
|
destroy_empty
|
self: SmartVector<T>
| Destroys an empty SmartVector | None |
|
destroy
|
self: SmartVector<T>
| Destroys a SmartVector | None |
|
clear
|
self: &mut SmartVector<T>
| Clears all elements from a SmartVector | None |
|
borrow
|
self: &SmartVector<T>
,
i: u64
| Borrows the i-th element |
&T
|
|
borrow_mut
|
self: &mut SmartVector<T>
,
i: u64
| Mutably borrows the i-th element |
&mut T
|
|
append
|
self: &mut SmartVector<T>
,
other: SmartVector<T>
| Moves all elements from other to self | None |
|
add_all
|
self: &mut SmartVector<T>
,
vals: vector<T>
| Adds multiple values to the vector | None |
|
to_vector
|
self: &SmartVector<T>
| Converts SmartVector to a native vector |
vector<T>
|
|
push_back
|
self: &mut SmartVector<T>
,
val: T
| Adds an element to the end | None |
|
pop_back
|
self: &mut SmartVector<T>
| Removes and returns the last element |
T
|
|
remove
|
self: &mut SmartVector<T>
,
i: u64
| Removes and returns the i-th element |
T
|
|
swap_remove
|
self: &mut SmartVector<T>
,
i: u64
| Swaps the i-th element with the last and removes it |
T
|
|
swap
|
self: &mut SmartVector<T>
,
i: u64
,
j: u64
| Swaps the i-th and j-th elements | None |
|
reverse
|
self: &mut SmartVector<T>
| Reverses the order of elements | None |
|
index_of
|
self: &SmartVector<T>
,
val: &T
| Finds the index of an element |
(bool, u64)
|
|
contains
|
self: &SmartVector<T>
,
val: &T
| Checks if an element exists |
bool
|
|
length
|
self: &SmartVector<T>
| Returns the number of elements |
u64
|
|
is_empty
|
self: &SmartVector<T>
| Checks if the vector is empty |
bool
|
|
for_each
|
self: SmartVector<T>
,
f: \|T\|
| Applies a function to each element, consuming the vector | None |
|
for_each_reverse
|
self: SmartVector<T>
,
f: \|T\|
| Applies a function to each element in reverse order, consuming the vector | None |
|
for_each_ref
|
self: &SmartVector<T>
,
f: \|&T\|
| Applies a function to a reference of each element | None |
|
for_each_mut
|
self: &mut SmartVector<T>
,
f: \|&mut T\|
| Applies a function to a mutable reference of each element | None |
|
enumerate_ref
|
self: &SmartVector<T>
,
f: \|(u64, &T)\|
| Applies a function to each element with its index | None |
|
enumerate_mut
|
self: &mut SmartVector<T>
,
f: \|(u64, &mut T)\|
| Applies a function to each mutable element with its index | None |
|
fold
|
self: SmartVector<T>
,
init: Accumulator
,
f: \|(Accumulator, T)\|Accumulator
| Folds the vector into an accumulated value |
Accumulator
|
|
foldr
|
self: SmartVector<T>
,
init: Accumulator
,
f: \|(T, Accumulator)\|Accumulator
| Folds the vector in reverse order into an accumulated value |
Accumulator
|
|
map_ref
|
self: &SmartVector<T1>
,
f: \|&T1\|T2
| Maps a function over references of the elements |
SmartVector<T2>
|
|
map
|
self: SmartVector<T1>
,
f: \|T1\|T2
| Maps a function over the elements |
SmartVector<T2>
|
|
filter
|
self: SmartVector<T>
,
p: \|&T\|bool
| Filters elements based on a predicate |
SmartVector<T>
|
|
zip
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|
| Zips two SmartVectors and applies a function to each pair | None |
|
zip_reverse
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|
| Zips two SmartVectors in reverse and applies a function to each pair | None |
|
zip_ref
|
self: &SmartVector<T1>
,
v2: &SmartVector<T2>
,
f: \|(&T1, &T2)\|
| Zips references of two SmartVectors and applies a function to each pair | None |
|
zip_mut
|
self: &mut SmartVector<T1>
,
v2: &mut SmartVector<T2>
,
f: \|(&mut T1, &mut T2)\|
| Zips mutable references of two SmartVectors and applies a function to each pair | None |
|
zip_map
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|NewT
| Zips two SmartVectors and maps a function over the pairs |
SmartVector<NewT>
|
|
zip_map_ref
|
self: &SmartVector<T1>
,
v2: &SmartVector<T2>
,
f: \|(&T1, &T2)\|NewT
| Zips references of two SmartVectors and maps a function over the pairs |
SmartVector<NewT>
|
			Summary
Smart Vector is an advanced data structure in the Aptos Framework designed to optimize data management in large-scale applications.
It combines the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses.
Smart Vector uses a bucket system to efficiently store and access large amounts of data, potentially reducing gas fees and improving performance.
The structure automatically divides elements into multiple buckets, optimizing both reading and writing processes.
Smart Vector offers a solution to performance bottlenecks often encountered when scaling applications with conventional data structures.
Implementation involves creating a SmartVector, adding elements, and storing it within a custom struct in the account's storage.
Overview
As you progress beyond the foundational P0 course, you'll encounter more complex data management challenges. While vectors and simple maps serve well for small-scale projects, they often fall short when handling larger datasets. To effectively scale your applications, it's crucial to adopt more advanced data structures.
One common pitfall in software development is underestimating the performance impact of data growth. As your application expands, operations that were once swift on vectors and simple maps can become significant bottlenecks, leading to increased processing time and resource consumption.
Conventional tables present an alternative strategy, offering pinpoint access to specific data elements. While this granular control can be beneficial, it's essential to weigh the storage costs associated with expanding these tables.
This is where smart tables and smart vector, a cutting-edge feature of the Aptos Framework, come into play. These sophisticated data structures are engineered to harness the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses. By leveraging smart tables & smart vector, developers can streamline data management, potentially reducing gas fees and boosting overall system performance.
Create a Smart Vector
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
}
Module Declaration:
module movement::smart_vector_module {
    // Module contents
}
This declares a new module named "smart_vector_module" within the "movement" package.
Importing the Smart Vector:
use aptos_std::smart_vector::{Self, SmartVector};
This line imports the SmartVector type and its associated functions from the Aptos standard library.
Defining a Custom Struct:
struct MovementObject has key {
    value: SmartVector<u64>;
}
This defines a new struct called MovementObject with a SmartVector of unsigned 64-bit integers (u64) as its value.
Initializing the Module:
fun init_module(caller: &signer) {
    // Function body
}
This function is called when the module is first published. It takes a reference to the signer (account) publishing the module.
Creating a New Smart Vector:
let smartvec = smart_vector::new<u64>();
This creates a new SmartVector that will hold u64 values.
Adding Elements to the Smart Vector:
smart_vector::push_back(&mut smartvec, 1);
smart_vector::push_back(&mut smartvec, 2);
smart_vector::push_back(&mut smartvec, 3);
These lines add the values 1, 2, and 3 to the end of the SmartVector.
Creating and Storing the MovementObject:
move_to(caller, MovementObject {
    value: smartvec
});
This creates a new MovementObject with the SmartVector we just populated, and stores it in the account's storage.
Running Test
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}
Running test:
movement move test -f test_get_length
Result:
Running Move unit tests
[debug] 3
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::test_get_length
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
How Smart Vector works
If you deploy modules and create a smart vector object, you can check the account data and you'll see an object like this:
{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": []
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "1",
        "2",
        "3"
      ]
    }
  }
}
Here, the smart vector stores data in
bucket
s, allowing it to hold a large number of elements while optimizing gas costs for users. Each
bucket
is a standard vector that stores the elements of the smart vector.
module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        let i = 0;
        while (i <= 1000) {
            smart_vector::push_back(&mut smartvec, i);
            i = i + 1;
        };
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}
In the example above, I input 1000 elements using a
while loop
. When checking the result with the command
movement account list
, you'll see the following output:
{
  "0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": [
          {
            "bucket_size": "128",
            "buckets": {
              "inner": {
                "handle": "0xfb918a6dc3e0db1a6bef0ebdf53554f0fc759c01018c5012071fe2c4a86e8b80"
              },
              "length": "8"
            },
            "end_index": "983"
          }
        ]
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17"
      ]
    }
  }
},
Here, the smart vector automatically divides elements into multiple buckets. For example, when you access elements from 0-100, it only accesses the bucket containing those specific elements. This approach optimizes both the reading and writing processes of the smart vector.
Additional Smart Vector Functions
| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
new
| None | Creates an empty SmartVector |
SmartVector<T>
|
|
empty
| None | Creates an empty SmartVector (deprecated) |
SmartVector<T>
|
|
empty_with_config
|
inline_capacity: u64
,
bucket_size: u64
| Creates an empty SmartVector with custom configuration |
SmartVector<T>
|
|
singleton
|
element: T
| Creates a SmartVector with a single element |
SmartVector<T>
|
|
destroy_empty
|
self: SmartVector<T>
| Destroys an empty SmartVector | None |
|
destroy
|
self: SmartVector<T>
| Destroys a SmartVector | None |
|
clear
|
self: &mut SmartVector<T>
| Clears all elements from a SmartVector | None |
|
borrow
|
self: &SmartVector<T>
,
i: u64
| Borrows the i-th element |
&T
|
|
borrow_mut
|
self: &mut SmartVector<T>
,
i: u64
| Mutably borrows the i-th element |
&mut T
|
|
append
|
self: &mut SmartVector<T>
,
other: SmartVector<T>
| Moves all elements from other to self | None |
|
add_all
|
self: &mut SmartVector<T>
,
vals: vector<T>
| Adds multiple values to the vector | None |
|
to_vector
|
self: &SmartVector<T>
| Converts SmartVector to a native vector |
vector<T>
|
|
push_back
|
self: &mut SmartVector<T>
,
val: T
| Adds an element to the end | None |
|
pop_back
|
self: &mut SmartVector<T>
| Removes and returns the last element |
T
|
|
remove
|
self: &mut SmartVector<T>
,
i: u64
| Removes and returns the i-th element |
T
|
|
swap_remove
|
self: &mut SmartVector<T>
,
i: u64
| Swaps the i-th element with the last and removes it |
T
|
|
swap
|
self: &mut SmartVector<T>
,
i: u64
,
j: u64
| Swaps the i-th and j-th elements | None |
|
reverse
|
self: &mut SmartVector<T>
| Reverses the order of elements | None |
|
index_of
|
self: &SmartVector<T>
,
val: &T
| Finds the index of an element |
(bool, u64)
|
|
contains
|
self: &SmartVector<T>
,
val: &T
| Checks if an element exists |
bool
|
|
length
|
self: &SmartVector<T>
| Returns the number of elements |
u64
|
|
is_empty
|
self: &SmartVector<T>
| Checks if the vector is empty |
bool
|
|
for_each
|
self: SmartVector<T>
,
f: \|T\|
| Applies a function to each element, consuming the vector | None |
|
for_each_reverse
|
self: SmartVector<T>
,
f: \|T\|
| Applies a function to each element in reverse order, consuming the vector | None |
|
for_each_ref
|
self: &SmartVector<T>
,
f: \|&T\|
| Applies a function to a reference of each element | None |
|
for_each_mut
|
self: &mut SmartVector<T>
,
f: \|&mut T\|
| Applies a function to a mutable reference of each element | None |
|
enumerate_ref
|
self: &SmartVector<T>
,
f: \|(u64, &T)\|
| Applies a function to each element with its index | None |
|
enumerate_mut
|
self: &mut SmartVector<T>
,
f: \|(u64, &mut T)\|
| Applies a function to each mutable element with its index | None |
|
fold
|
self: SmartVector<T>
,
init: Accumulator
,
f: \|(Accumulator, T)\|Accumulator
| Folds the vector into an accumulated value |
Accumulator
|
|
foldr
|
self: SmartVector<T>
,
init: Accumulator
,
f: \|(T, Accumulator)\|Accumulator
| Folds the vector in reverse order into an accumulated value |
Accumulator
|
|
map_ref
|
self: &SmartVector<T1>
,
f: \|&T1\|T2
| Maps a function over references of the elements |
SmartVector<T2>
|
|
map
|
self: SmartVector<T1>
,
f: \|T1\|T2
| Maps a function over the elements |
SmartVector<T2>
|
|
filter
|
self: SmartVector<T>
,
p: \|&T\|bool
| Filters elements based on a predicate |
SmartVector<T>
|
|
zip
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|
| Zips two SmartVectors and applies a function to each pair | None |
|
zip_reverse
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|
| Zips two SmartVectors in reverse and applies a function to each pair | None |
|
zip_ref
|
self: &SmartVector<T1>
,
v2: &SmartVector<T2>
,
f: \|(&T1, &T2)\|
| Zips references of two SmartVectors and applies a function to each pair | None |
|
zip_mut
|
self: &mut SmartVector<T1>
,
v2: &mut SmartVector<T2>
,
f: \|(&mut T1, &mut T2)\|
| Zips mutable references of two SmartVectors and applies a function to each pair | None |
|
zip_map
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|NewT
| Zips two SmartVectors and maps a function over the pairs |
SmartVector<NewT>
|
|
zip_map_ref
|
self: &SmartVector<T1>
,
v2: &SmartVector<T2>
,
f: \|(&T1, &T2)\|NewT
| Zips references of two SmartVectors and maps a function over the pairs |
SmartVector<NewT>
|
	Summary
	Summary
	Smart Vector is an advanced data structure in the Aptos Framework designed to optimize data management in large-scale applications.
It combines the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses.
Smart Vector uses a bucket system to efficiently store and access large amounts of data, potentially reducing gas fees and improving performance.
The structure automatically divides elements into multiple buckets, optimizing both reading and writing processes.
Smart Vector offers a solution to performance bottlenecks often encountered when scaling applications with conventional data structures.
Implementation involves creating a SmartVector, adding elements, and storing it within a custom struct in the account's storage.
	Smart Vector is an advanced data structure in the Aptos Framework designed to optimize data management in large-scale applications.
	Smart Vector is an advanced data structure in the Aptos Framework designed to optimize data management in large-scale applications.
	It combines the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses.
	It combines the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses.
	Smart Vector uses a bucket system to efficiently store and access large amounts of data, potentially reducing gas fees and improving performance.
	Smart Vector uses a bucket system to efficiently store and access large amounts of data, potentially reducing gas fees and improving performance.
	The structure automatically divides elements into multiple buckets, optimizing both reading and writing processes.
	The structure automatically divides elements into multiple buckets, optimizing both reading and writing processes.
	Smart Vector offers a solution to performance bottlenecks often encountered when scaling applications with conventional data structures.
	Smart Vector offers a solution to performance bottlenecks often encountered when scaling applications with conventional data structures.
	Implementation involves creating a SmartVector, adding elements, and storing it within a custom struct in the account's storage.
	Implementation involves creating a SmartVector, adding elements, and storing it within a custom struct in the account's storage.
	Overview
	Overview
	As you progress beyond the foundational P0 course, you'll encounter more complex data management challenges. While vectors and simple maps serve well for small-scale projects, they often fall short when handling larger datasets. To effectively scale your applications, it's crucial to adopt more advanced data structures.
	As you progress beyond the foundational P0 course, you'll encounter more complex data management challenges. While vectors and simple maps serve well for small-scale projects, they often fall short when handling larger datasets. To effectively scale your applications, it's crucial to adopt more advanced data structures.
	One common pitfall in software development is underestimating the performance impact of data growth. As your application expands, operations that were once swift on vectors and simple maps can become significant bottlenecks, leading to increased processing time and resource consumption.
	One common pitfall in software development is underestimating the performance impact of data growth. As your application expands, operations that were once swift on vectors and simple maps can become significant bottlenecks, leading to increased processing time and resource consumption.
	Conventional tables present an alternative strategy, offering pinpoint access to specific data elements. While this granular control can be beneficial, it's essential to weigh the storage costs associated with expanding these tables.
	Conventional tables present an alternative strategy, offering pinpoint access to specific data elements. While this granular control can be beneficial, it's essential to weigh the storage costs associated with expanding these tables.
	This is where smart tables and smart vector, a cutting-edge feature of the Aptos Framework, come into play. These sophisticated data structures are engineered to harness the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses. By leveraging smart tables & smart vector, developers can streamline data management, potentially reducing gas fees and boosting overall system performance.
	This is where smart tables and smart vector, a cutting-edge feature of the Aptos Framework, come into play. These sophisticated data structures are engineered to harness the strengths of vectors, simple maps, and traditional tables while mitigating their weaknesses. By leveraging smart tables & smart vector, developers can streamline data management, potentially reducing gas fees and boosting overall system performance.
	Create a Smart Vector
	Create a Smart Vector
	<code>module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
}</code>
	<code>module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
}</code>
	module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
}
	Module Declaration:
	Module Declaration:
	Module Declaration:
	<code>module movement::smart_vector_module {
    // Module contents
}</code>
	<code>module movement::smart_vector_module {
    // Module contents
}</code>
	module movement::smart_vector_module {
    // Module contents
}
	This declares a new module named "smart_vector_module" within the "movement" package.
	This declares a new module named "smart_vector_module" within the "movement" package.
	Importing the Smart Vector:
	Importing the Smart Vector:
	Importing the Smart Vector:
	<code>use aptos_std::smart_vector::{Self, SmartVector};</code>
	<code>use aptos_std::smart_vector::{Self, SmartVector};</code>
	use aptos_std::smart_vector::{Self, SmartVector};
	This line imports the SmartVector type and its associated functions from the Aptos standard library.
	This line imports the SmartVector type and its associated functions from the Aptos standard library.
	Defining a Custom Struct:
	Defining a Custom Struct:
	Defining a Custom Struct:
	<code>struct MovementObject has key {
    value: SmartVector<u64>;
}</code>
	<code>struct MovementObject has key {
    value: SmartVector<u64>;
}</code>
	struct MovementObject has key {
    value: SmartVector<u64>;
}
	This defines a new struct called MovementObject with a SmartVector of unsigned 64-bit integers (u64) as its value.
	This defines a new struct called MovementObject with a SmartVector of unsigned 64-bit integers (u64) as its value.
	Initializing the Module:
	Initializing the Module:
	Initializing the Module:
	<code>fun init_module(caller: &signer) {
    // Function body
}</code>
	<code>fun init_module(caller: &signer) {
    // Function body
}</code>
	fun init_module(caller: &signer) {
    // Function body
}
	This function is called when the module is first published. It takes a reference to the signer (account) publishing the module.
	This function is called when the module is first published. It takes a reference to the signer (account) publishing the module.
	Creating a New Smart Vector:
	Creating a New Smart Vector:
	Creating a New Smart Vector:
	<code>let smartvec = smart_vector::new<u64>();</code>
	<code>let smartvec = smart_vector::new<u64>();</code>
	let smartvec = smart_vector::new<u64>();
	This creates a new SmartVector that will hold u64 values.
	This creates a new SmartVector that will hold u64 values.
	Adding Elements to the Smart Vector:
	Adding Elements to the Smart Vector:
	Adding Elements to the Smart Vector:
	<code>smart_vector::push_back(&mut smartvec, 1);
smart_vector::push_back(&mut smartvec, 2);
smart_vector::push_back(&mut smartvec, 3);</code>
	<code>smart_vector::push_back(&mut smartvec, 1);
smart_vector::push_back(&mut smartvec, 2);
smart_vector::push_back(&mut smartvec, 3);</code>
	smart_vector::push_back(&mut smartvec, 1);
smart_vector::push_back(&mut smartvec, 2);
smart_vector::push_back(&mut smartvec, 3);
	These lines add the values 1, 2, and 3 to the end of the SmartVector.
	These lines add the values 1, 2, and 3 to the end of the SmartVector.
	Creating and Storing the MovementObject:
	Creating and Storing the MovementObject:
	Creating and Storing the MovementObject:
	<code>move_to(caller, MovementObject {
    value: smartvec
});</code>
	<code>move_to(caller, MovementObject {
    value: smartvec
});</code>
	move_to(caller, MovementObject {
    value: smartvec
});
	This creates a new MovementObject with the SmartVector we just populated, and stores it in the account's storage.
	This creates a new MovementObject with the SmartVector we just populated, and stores it in the account's storage.
	Running Test
	Running Test
	<code>module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}</code>
	<code>module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}</code>
	module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        smart_vector::push_back(&mut smartvec, 1);
        smart_vector::push_back(&mut smartvec, 2);
        smart_vector::push_back(&mut smartvec, 3);
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}
	Running test:
	Running test:
	Running test:
	<code>movement move test -f test_get_length</code>
	<code>movement move test -f test_get_length</code>
	movement move test -f test_get_length
	Result:
	Result:
	Result:
	<code>Running Move unit tests
[debug] 3
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::test_get_length
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	<code>Running Move unit tests
[debug] 3
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::test_get_length
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}</code>
	Running Move unit tests
[debug] 3
[ PASS ] 0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::test_get_length
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
  "Result": "Success"
}
	How Smart Vector works
	How Smart Vector works
	If you deploy modules and create a smart vector object, you can check the account data and you'll see an object like this:
	If you deploy modules and create a smart vector object, you can check the account data and you'll see an object like this:
	<code>{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": []
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "1",
        "2",
        "3"
      ]
    }
  }
}</code>
	<code>{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": []
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "1",
        "2",
        "3"
      ]
    }
  }
}</code>
	{
  "0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": []
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "1",
        "2",
        "3"
      ]
    }
  }
}
	Here, the smart vector stores data in
bucket
s, allowing it to hold a large number of elements while optimizing gas costs for users. Each
bucket
is a standard vector that stores the elements of the smart vector.
	Here, the smart vector stores data in
	<code>bucket</code>
	bucket
	s, allowing it to hold a large number of elements while optimizing gas costs for users. Each
	<code>bucket</code>
	bucket
	is a standard vector that stores the elements of the smart vector.
	<code>module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        let i = 0;
        while (i <= 1000) {
            smart_vector::push_back(&mut smartvec, i);
            i = i + 1;
        };
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}</code>
	<code>module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        let i = 0;
        while (i <= 1000) {
            smart_vector::push_back(&mut smartvec, i);
            i = i + 1;
        };
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}</code>
	module movement::smart_vector_module {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementObject has key {
        value: SmartVector<u64>
    }
    fun init_module(caller: &signer) {
        let smartvec = smart_vector::new<u64>();
        let i = 0;
        while (i <= 1000) {
            smart_vector::push_back(&mut smartvec, i);
            i = i + 1;
        };
        move_to(caller, MovementObject {
            value: smartvec
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    public fun get_length(addr: address): u64 acquires MovementObject {
        let vec = &borrow_global<MovementObject>(addr).value;
        smart_vector::length(vec)
    }
    #[test(caller = @0x1)]
    fun test_get_length(caller: &signer) acquires MovementObject {
        test_init_module(caller);
        let len = get_length(address_of(caller));
        print(&len);
    }
}
	In the example above, I input 1000 elements using a
while loop
. When checking the result with the command
movement account list
, you'll see the following output:
	In the example above, I input 1000 elements using a
	<code>while loop</code>
	while loop
	. When checking the result with the command
	<code>movement account list</code>
	movement account list
	, you'll see the following output:
	<code>{
  "0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": [
          {
            "bucket_size": "128",
            "buckets": {
              "inner": {
                "handle": "0xfb918a6dc3e0db1a6bef0ebdf53554f0fc759c01018c5012071fe2c4a86e8b80"
              },
              "length": "8"
            },
            "end_index": "983"
          }
        ]
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17"
      ]
    }
  }
},</code>
	<code>{
  "0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": [
          {
            "bucket_size": "128",
            "buckets": {
              "inner": {
                "handle": "0xfb918a6dc3e0db1a6bef0ebdf53554f0fc759c01018c5012071fe2c4a86e8b80"
              },
              "length": "8"
            },
            "end_index": "983"
          }
        ]
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17"
      ]
    }
  }
},</code>
	{
  "0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_vector_module::MovementObject": {
    "value": {
      "big_vec": {
        "vec": [
          {
            "bucket_size": "128",
            "buckets": {
              "inner": {
                "handle": "0xfb918a6dc3e0db1a6bef0ebdf53554f0fc759c01018c5012071fe2c4a86e8b80"
              },
              "length": "8"
            },
            "end_index": "983"
          }
        ]
      },
      "bucket_size": {
        "vec": []
      },
      "inline_capacity": {
        "vec": []
      },
      "inline_vec": [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17"
      ]
    }
  }
},
	Here, the smart vector automatically divides elements into multiple buckets. For example, when you access elements from 0-100, it only accesses the bucket containing those specific elements. This approach optimizes both the reading and writing processes of the smart vector.
	Here, the smart vector automatically divides elements into multiple buckets. For example, when you access elements from 0-100, it only accesses the bucket containing those specific elements. This approach optimizes both the reading and writing processes of the smart vector.
	Additional Smart Vector Functions
	Additional Smart Vector Functions
	| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
new
| None | Creates an empty SmartVector |
SmartVector<T>
|
|
empty
| None | Creates an empty SmartVector (deprecated) |
SmartVector<T>
|
|
empty_with_config
|
inline_capacity: u64
,
bucket_size: u64
| Creates an empty SmartVector with custom configuration |
SmartVector<T>
|
|
singleton
|
element: T
| Creates a SmartVector with a single element |
SmartVector<T>
|
|
destroy_empty
|
self: SmartVector<T>
| Destroys an empty SmartVector | None |
|
destroy
|
self: SmartVector<T>
| Destroys a SmartVector | None |
|
clear
|
self: &mut SmartVector<T>
| Clears all elements from a SmartVector | None |
|
borrow
|
self: &SmartVector<T>
,
i: u64
| Borrows the i-th element |
&T
|
|
borrow_mut
|
self: &mut SmartVector<T>
,
i: u64
| Mutably borrows the i-th element |
&mut T
|
|
append
|
self: &mut SmartVector<T>
,
other: SmartVector<T>
| Moves all elements from other to self | None |
|
add_all
|
self: &mut SmartVector<T>
,
vals: vector<T>
| Adds multiple values to the vector | None |
|
to_vector
|
self: &SmartVector<T>
| Converts SmartVector to a native vector |
vector<T>
|
|
push_back
|
self: &mut SmartVector<T>
,
val: T
| Adds an element to the end | None |
|
pop_back
|
self: &mut SmartVector<T>
| Removes and returns the last element |
T
|
|
remove
|
self: &mut SmartVector<T>
,
i: u64
| Removes and returns the i-th element |
T
|
|
swap_remove
|
self: &mut SmartVector<T>
,
i: u64
| Swaps the i-th element with the last and removes it |
T
|
|
swap
|
self: &mut SmartVector<T>
,
i: u64
,
j: u64
| Swaps the i-th and j-th elements | None |
|
reverse
|
self: &mut SmartVector<T>
| Reverses the order of elements | None |
|
index_of
|
self: &SmartVector<T>
,
val: &T
| Finds the index of an element |
(bool, u64)
|
|
contains
|
self: &SmartVector<T>
,
val: &T
| Checks if an element exists |
bool
|
|
length
|
self: &SmartVector<T>
| Returns the number of elements |
u64
|
|
is_empty
|
self: &SmartVector<T>
| Checks if the vector is empty |
bool
|
|
for_each
|
self: SmartVector<T>
,
f: \|T\|
| Applies a function to each element, consuming the vector | None |
|
for_each_reverse
|
self: SmartVector<T>
,
f: \|T\|
| Applies a function to each element in reverse order, consuming the vector | None |
|
for_each_ref
|
self: &SmartVector<T>
,
f: \|&T\|
| Applies a function to a reference of each element | None |
|
for_each_mut
|
self: &mut SmartVector<T>
,
f: \|&mut T\|
| Applies a function to a mutable reference of each element | None |
|
enumerate_ref
|
self: &SmartVector<T>
,
f: \|(u64, &T)\|
| Applies a function to each element with its index | None |
|
enumerate_mut
|
self: &mut SmartVector<T>
,
f: \|(u64, &mut T)\|
| Applies a function to each mutable element with its index | None |
|
fold
|
self: SmartVector<T>
,
init: Accumulator
,
f: \|(Accumulator, T)\|Accumulator
| Folds the vector into an accumulated value |
Accumulator
|
|
foldr
|
self: SmartVector<T>
,
init: Accumulator
,
f: \|(T, Accumulator)\|Accumulator
| Folds the vector in reverse order into an accumulated value |
Accumulator
|
|
map_ref
|
self: &SmartVector<T1>
,
f: \|&T1\|T2
| Maps a function over references of the elements |
SmartVector<T2>
|
|
map
|
self: SmartVector<T1>
,
f: \|T1\|T2
| Maps a function over the elements |
SmartVector<T2>
|
|
filter
|
self: SmartVector<T>
,
p: \|&T\|bool
| Filters elements based on a predicate |
SmartVector<T>
|
|
zip
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|
| Zips two SmartVectors and applies a function to each pair | None |
|
zip_reverse
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|
| Zips two SmartVectors in reverse and applies a function to each pair | None |
|
zip_ref
|
self: &SmartVector<T1>
,
v2: &SmartVector<T2>
,
f: \|(&T1, &T2)\|
| Zips references of two SmartVectors and applies a function to each pair | None |
|
zip_mut
|
self: &mut SmartVector<T1>
,
v2: &mut SmartVector<T2>
,
f: \|(&mut T1, &mut T2)\|
| Zips mutable references of two SmartVectors and applies a function to each pair | None |
|
zip_map
|
self: SmartVector<T1>
,
v2: SmartVector<T2>
,
f: \|(T1, T2)\|NewT
| Zips two SmartVectors and maps a function over the pairs |
SmartVector<NewT>
|
|
zip_map_ref
|
self: &SmartVector<T1>
,
v2: &SmartVector<T2>
,
f: \|(&T1, &T2)\|NewT
| Zips references of two SmartVectors and maps a function over the pairs |
SmartVector<NewT>
|
	| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
	<code>new</code>
	new
	| None | Creates an empty SmartVector |
	<code>SmartVector<T></code>
	SmartVector<T>
	|
|
	<code>empty</code>
	empty
	| None | Creates an empty SmartVector (deprecated) |
	<code>SmartVector<T></code>
	SmartVector<T>
	|
|
	<code>empty_with_config</code>
	empty_with_config
	|
	<code>inline_capacity: u64</code>
	inline_capacity: u64
	,
	<code>bucket_size: u64</code>
	bucket_size: u64
	| Creates an empty SmartVector with custom configuration |
	<code>SmartVector<T></code>
	SmartVector<T>
	|
|
	<code>singleton</code>
	singleton
	|
	<code>element: T</code>
	element: T
	| Creates a SmartVector with a single element |
	<code>SmartVector<T></code>
	SmartVector<T>
	|
|
	<code>destroy_empty</code>
	destroy_empty
	|
	<code>self: SmartVector<T></code>
	self: SmartVector<T>
	| Destroys an empty SmartVector | None |
|
	<code>destroy</code>
	destroy
	|
	<code>self: SmartVector<T></code>
	self: SmartVector<T>
	| Destroys a SmartVector | None |
|
	<code>clear</code>
	clear
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	| Clears all elements from a SmartVector | None |
|
	<code>borrow</code>
	borrow
	|
	<code>self: &SmartVector<T></code>
	self: &SmartVector<T>
	,
	<code>i: u64</code>
	i: u64
	| Borrows the i-th element |
	<code>&T</code>
	&T
	|
|
	<code>borrow_mut</code>
	borrow_mut
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	,
	<code>i: u64</code>
	i: u64
	| Mutably borrows the i-th element |
	<code>&mut T</code>
	&mut T
	|
|
	<code>append</code>
	append
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	,
	<code>other: SmartVector<T></code>
	other: SmartVector<T>
	| Moves all elements from other to self | None |
|
	<code>add_all</code>
	add_all
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	,
	<code>vals: vector<T></code>
	vals: vector<T>
	| Adds multiple values to the vector | None |
|
	<code>to_vector</code>
	to_vector
	|
	<code>self: &SmartVector<T></code>
	self: &SmartVector<T>
	| Converts SmartVector to a native vector |
	<code>vector<T></code>
	vector<T>
	|
|
	<code>push_back</code>
	push_back
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	,
	<code>val: T</code>
	val: T
	| Adds an element to the end | None |
|
	<code>pop_back</code>
	pop_back
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	| Removes and returns the last element |
	<code>T</code>
	T
	|
|
	<code>remove</code>
	remove
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	,
	<code>i: u64</code>
	i: u64
	| Removes and returns the i-th element |
	<code>T</code>
	T
	|
|
	<code>swap_remove</code>
	swap_remove
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	,
	<code>i: u64</code>
	i: u64
	| Swaps the i-th element with the last and removes it |
	<code>T</code>
	T
	|
|
	<code>swap</code>
	swap
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	,
	<code>i: u64</code>
	i: u64
	,
	<code>j: u64</code>
	j: u64
	| Swaps the i-th and j-th elements | None |
|
	<code>reverse</code>
	reverse
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	| Reverses the order of elements | None |
|
	<code>index_of</code>
	index_of
	|
	<code>self: &SmartVector<T></code>
	self: &SmartVector<T>
	,
	<code>val: &T</code>
	val: &T
	| Finds the index of an element |
	<code>(bool, u64)</code>
	(bool, u64)
	|
|
	<code>contains</code>
	contains
	|
	<code>self: &SmartVector<T></code>
	self: &SmartVector<T>
	,
	<code>val: &T</code>
	val: &T
	| Checks if an element exists |
	<code>bool</code>
	bool
	|
|
	<code>length</code>
	length
	|
	<code>self: &SmartVector<T></code>
	self: &SmartVector<T>
	| Returns the number of elements |
	<code>u64</code>
	u64
	|
|
	<code>is_empty</code>
	is_empty
	|
	<code>self: &SmartVector<T></code>
	self: &SmartVector<T>
	| Checks if the vector is empty |
	<code>bool</code>
	bool
	|
|
	<code>for_each</code>
	for_each
	|
	<code>self: SmartVector<T></code>
	self: SmartVector<T>
	,
	<code>f: \|T\|</code>
	f: \|T\|
	| Applies a function to each element, consuming the vector | None |
|
	<code>for_each_reverse</code>
	for_each_reverse
	|
	<code>self: SmartVector<T></code>
	self: SmartVector<T>
	,
	<code>f: \|T\|</code>
	f: \|T\|
	| Applies a function to each element in reverse order, consuming the vector | None |
|
	<code>for_each_ref</code>
	for_each_ref
	|
	<code>self: &SmartVector<T></code>
	self: &SmartVector<T>
	,
	<code>f: \|&T\|</code>
	f: \|&T\|
	| Applies a function to a reference of each element | None |
|
	<code>for_each_mut</code>
	for_each_mut
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	,
	<code>f: \|&mut T\|</code>
	f: \|&mut T\|
	| Applies a function to a mutable reference of each element | None |
|
	<code>enumerate_ref</code>
	enumerate_ref
	|
	<code>self: &SmartVector<T></code>
	self: &SmartVector<T>
	,
	<code>f: \|(u64, &T)\|</code>
	f: \|(u64, &T)\|
	| Applies a function to each element with its index | None |
|
	<code>enumerate_mut</code>
	enumerate_mut
	|
	<code>self: &mut SmartVector<T></code>
	self: &mut SmartVector<T>
	,
	<code>f: \|(u64, &mut T)\|</code>
	f: \|(u64, &mut T)\|
	| Applies a function to each mutable element with its index | None |
|
	<code>fold</code>
	fold
	|
	<code>self: SmartVector<T></code>
	self: SmartVector<T>
	,
	<code>init: Accumulator</code>
	init: Accumulator
	,
	<code>f: \|(Accumulator, T)\|Accumulator</code>
	f: \|(Accumulator, T)\|Accumulator
	| Folds the vector into an accumulated value |
	<code>Accumulator</code>
	Accumulator
	|
|
	<code>foldr</code>
	foldr
	|
	<code>self: SmartVector<T></code>
	self: SmartVector<T>
	,
	<code>init: Accumulator</code>
	init: Accumulator
	,
	<code>f: \|(T, Accumulator)\|Accumulator</code>
	f: \|(T, Accumulator)\|Accumulator
	| Folds the vector in reverse order into an accumulated value |
	<code>Accumulator</code>
	Accumulator
	|
|
	<code>map_ref</code>
	map_ref
	|
	<code>self: &SmartVector<T1></code>
	self: &SmartVector<T1>
	,
	<code>f: \|&T1\|T2</code>
	f: \|&T1\|T2
	| Maps a function over references of the elements |
	<code>SmartVector<T2></code>
	SmartVector<T2>
	|
|
	<code>map</code>
	map
	|
	<code>self: SmartVector<T1></code>
	self: SmartVector<T1>
	,
	<code>f: \|T1\|T2</code>
	f: \|T1\|T2
	| Maps a function over the elements |
	<code>SmartVector<T2></code>
	SmartVector<T2>
	|
|
	<code>filter</code>
	filter
	|
	<code>self: SmartVector<T></code>
	self: SmartVector<T>
	,
	<code>p: \|&T\|bool</code>
	p: \|&T\|bool
	| Filters elements based on a predicate |
	<code>SmartVector<T></code>
	SmartVector<T>
	|
|
	<code>zip</code>
	zip
	|
	<code>self: SmartVector<T1></code>
	self: SmartVector<T1>
	,
	<code>v2: SmartVector<T2></code>
	v2: SmartVector<T2>
	,
	<code>f: \|(T1, T2)\|</code>
	f: \|(T1, T2)\|
	| Zips two SmartVectors and applies a function to each pair | None |
|
	<code>zip_reverse</code>
	zip_reverse
	|
	<code>self: SmartVector<T1></code>
	self: SmartVector<T1>
	,
	<code>v2: SmartVector<T2></code>
	v2: SmartVector<T2>
	,
	<code>f: \|(T1, T2)\|</code>
	f: \|(T1, T2)\|
	| Zips two SmartVectors in reverse and applies a function to each pair | None |
|
	<code>zip_ref</code>
	zip_ref
	|
	<code>self: &SmartVector<T1></code>
	self: &SmartVector<T1>
	,
	<code>v2: &SmartVector<T2></code>
	v2: &SmartVector<T2>
	,
	<code>f: \|(&T1, &T2)\|</code>
	f: \|(&T1, &T2)\|
	| Zips references of two SmartVectors and applies a function to each pair | None |
|
	<code>zip_mut</code>
	zip_mut
	|
	<code>self: &mut SmartVector<T1></code>
	self: &mut SmartVector<T1>
	,
	<code>v2: &mut SmartVector<T2></code>
	v2: &mut SmartVector<T2>
	,
	<code>f: \|(&mut T1, &mut T2)\|</code>
	f: \|(&mut T1, &mut T2)\|
	| Zips mutable references of two SmartVectors and applies a function to each pair | None |
|
	<code>zip_map</code>
	zip_map
	|
	<code>self: SmartVector<T1></code>
	self: SmartVector<T1>
	,
	<code>v2: SmartVector<T2></code>
	v2: SmartVector<T2>
	,
	<code>f: \|(T1, T2)\|NewT</code>
	f: \|(T1, T2)\|NewT
	| Zips two SmartVectors and maps a function over the pairs |
	<code>SmartVector<NewT></code>
	SmartVector<NewT>
	|
|
	<code>zip_map_ref</code>
	zip_map_ref
	|
	<code>self: &SmartVector<T1></code>
	self: &SmartVector<T1>
	,
	<code>v2: &SmartVector<T2></code>
	v2: &SmartVector<T2>
	,
	<code>f: \|(&T1, &T2)\|NewT</code>
	f: \|(&T1, &T2)\|NewT
	| Zips references of two SmartVectors and maps a function over the pairs |
	<code>SmartVector<NewT></code>
	SmartVector<NewT>
	|

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/09-smart-tables
Smart Tables
Smart Tables
On This Page
Summary
Overview
Example
1. Module Declaration
2. Importing Required Modules
3. Defining a Custom Struct
4. Initialization Function
5. Creating a New SmartTable
6. Adding an Initial Entry
7. Moving the SmartTable to Storage
Full Example
1. init_module(caller: &signer)
2. test_init_module(caller: &signer)
3. get_amount_point(addr: address): u64
4. plus_point(addr: address, value: u64)
5. test_get_amount_point(caller: &signer)
6. test_plus_amount_point(caller: &signer)
Running Test
Additional SimpleMap Functions
Summary
Smart Table is a data structure in Move that stores data in multiple buckets for efficient access and gas optimization.
It operates similarly to Smart Vector, improving speed and cost-efficiency in data management.
The module demonstrates how to initialize, update, and retrieve data from a SmartTable.
The code includes test functions to verify the correct operation of SmartTable operations.
SmartTable uses address as keys and u64 as values in this example, suitable for tracking user points or balances.
Overview
Similar to
Smart Vector
, which we explored in the previous article,
Smart Table
operates on the same principle. Smart Table's data is divided into multiple
bucket
s for storage. Accessing, writing, and reading data in
Smart Table
occurs independently within each
bucket
containing that data. This organization improves speed and cost-efficiency while optimizing gas usage for users.
Example
module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
}
Let's break down the code and explain each function step-by-step:
1. Module Declaration
module movement::smart_table_module {
    // Module contents
}
This declares a new module named "smart_table_module" under the "movement" address.
2. Importing Required Modules
use aptos_std::smart_table::{Self, SmartTable};
This imports the SmartTable type and its associated functions from the aptos_std library.
3. Defining a Custom Struct
struct MovementTableObject has key {
    value: SmartTable<address, u64>
}
This defines a new struct called MovementTableObject that contains a SmartTable. The SmartTable uses address as keys and u64 as values.
4. Initialization Function
fun init_module(caller: &signer) {
    // Function body
}
This function is called when the module is published. It takes a reference to the signer (the account publishing the module) as an argument.
5. Creating a New SmartTable
let val = smart_table::new<address, u64>();
This creates a new SmartTable that uses address as keys and u64 as values.
6. Adding an Initial Entry
smart_table::add(&mut val, address_of(caller), 0);
This adds an initial entry to the SmartTable. The key is the address of the caller, and the value is 0.
7. Moving the SmartTable to Storage
move_to(caller, MovementTableObject {
    value: val
});
This creates a new MovementTableObject with the SmartTable we just created and moves it to the storage of the caller's account.
This initialization sets up a SmartTable in the caller's account, ready to be used for storing and managing data efficiently.
Full Example
module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    fun get_amount_point(addr: address): u64 acquires MovementTableObject {
        let table = &borrow_global<MovementTableObject>(addr).value;
        *smart_table::borrow(table, addr)
    }
    fun plus_point(addr: address, value: u64) acquires MovementTableObject {
        let table = &mut borrow_global_mut<MovementTableObject>(addr).value;
        let point = *smart_table::borrow_mut(table, addr);
        point = point + value;
        smart_table::upsert(table, addr, point);
    }
    #[test(caller = @0x1)]
    fun test_get_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
    #[test(caller = @0x1)]
    fun test_plus_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        plus_point(address_of(caller), 10);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
}
1. init_module(caller: &signer)
This function initializes the module when it's published:
Create a new SmartTable using
smart_table::new&lt;address, u64&gt;()
Add an initial entry to the table with the caller's address as the key and 0 as the value
Create a new MovementTableObject with the SmartTable and move it to the caller's storage
2. test_init_module(caller: &signer)
This is a test-only function that calls init_module:
It's annotated with
#[test_only]
, meaning it's only used for testing
It simply calls the init_module function with the provided caller
3. get_amount_point(addr: address): u64
This function retrieves the point amount for a given address:
It's annotated with
#[view]
, indicating it's a read-only function
Borrow the SmartTable from the MovementTableObject stored at the given address
Use
smart_table::borrow
to get the value associated with the address
Return the borrowed value (point amount)
4. plus_point(addr: address, value: u64)
This function adds points to a given address:
Borrow the SmartTable mutably from the MovementTableObject
Get the current point value for the address using
smart_table::borrow_mut
Add the new value to the current point
Update the SmartTable with the new point value using
smart_table::upsert
5. test_get_amount_point(caller: &signer)
This is a test function for get_amount_point:
It's annotated with
#[test(caller = @0x1)]
, setting up a test environment
Call test_init_module to set up the initial state
Call get_amount_point with the caller's address
Print the retrieved amount
6. test_plus_amount_point(caller: &signer)
This is a test function for plus_point:
It's also annotated with
#[test(caller = @0x1)]
Call test_init_module to set up the initial state
Call plus_point to add 10 points to the caller's address
Call get_amount_point to retrieve the updated point amount
Print the new amount
These functions demonstrate how to initialize, update, and retrieve data from a SmartTable, as well as how to set up tests for these operations.
Running Test
Running test:
movement move test -f smart_table_module
Result:
Running Move unit tests
[debug] 0
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_get_amount_point
[debug] 10
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_plus_amount_point
Test result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Additional SimpleMap Functions
| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
new
| None | Creates an empty SmartTable with default configurations |
SmartTable<K, V>
|
|
new_with_config
|
num_initial_buckets: u64
,
split_load_threshold: u8
,
target_bucket_size: u64
| Creates an empty SmartTable with customized configurations |
SmartTable<K, V>
|
|
destroy_empty
|
self: SmartTable<K, V>
| Destroys an empty table | None |
|
destroy
|
self: SmartTable<K, V>
| Destroys a table completely when V has
drop
| None |
|
clear
|
self: &mut SmartTable<K, V>
| Clears a table completely when T has
drop
| None |
|
add
|
self: &mut SmartTable<K, V>
,
key: K
,
value: V
| Adds a key-value pair to the table | None |
|
add_all
|
self: &mut SmartTable<K, V>
,
keys: vector<K>
,
values: vector<V>
| Adds multiple key-value pairs to the table | None |
|
unzip_entries
|
entries: &vector<Entry<K, V>>
| Unzips entries into separate key and value vectors |
(vector<K>, vector<V>)
|
|
to_simple_map
|
self: &SmartTable<K, V>
| Converts a smart table to a simple_map |
SimpleMap<K, V>
|
|
keys
|
self: &SmartTable<K, V>
| Gets all keys in a smart table |
vector<K>
|
|
keys_paginated
|
self: &SmartTable<K, V>
,
starting_bucket_index: u64
,
starting_vector_index: u64
,
num_keys_to_get: u64
| Gets keys from a smart table, paginated |
(vector<K>, Option<u64>, Option<u64>)
|
|
split_one_bucket
|
self: &mut SmartTable<K, V>
| Splits one bucket into two | None |
|
bucket_index
|
level: u8
,
num_buckets: u64
,
hash: u64
| Returns the expected bucket index for a hash |
u64
|
|
borrow
|
self: &SmartTable<K, V>
,
key: K
| Borrows an immutable reference to the value associated with the key |
&V
|
|
borrow_with_default
|
self: &SmartTable<K, V>
,
key: K
,
default: &V
| Borrows an immutable reference to the value, or returns the default if key not found |
&V
|
|
borrow_mut
|
self: &mut SmartTable<K, V>
,
key: K
| Borrows a mutable reference to the value associated with the key |
&mut V
|
|
borrow_mut_with_default
|
self: &mut SmartTable<K, V>
,
key: K
,
default: V
| Borrows a mutable reference to the value, or inserts and returns default if key not found |
&mut V
|
|
contains
|
self: &SmartTable<K, V>
,
key: K
| Checks if the table contains a key |
bool
|
|
remove
|
self: &mut SmartTable<K, V>
,
key: K
| Removes and returns the value associated with the key |
V
|
|
upsert
|
self: &mut SmartTable<K, V>
,
key: K
,
value: V
| Inserts a key-value pair or updates an existing one | None |
|
length
|
self: &SmartTable<K, V>
| Returns the number of entries in the table |
u64
|
|
load_factor
|
self: &SmartTable<K, V>
| Returns the load factor of the hashtable |
u64
|
|
update_split_load_threshold
|
self: &mut SmartTable<K, V>
,
split_load_threshold: u8
| Updates the split load threshold | None |
|
update_target_bucket_size
|
self: &mut SmartTable<K, V>
,
target_bucket_size: u64
| Updates the target bucket size | None |
|
for_each_ref
|
self: &SmartTable<K, V>
,
f: \|&K, &V\|
| Applies a function to a reference of each key-value pair | None |
|
for_each_mut
|
self: &mut SmartTable<K, V>
,
f: \|&K, &mut V\|
| Applies a function to a mutable reference of each key-value pair | None |
|
map_ref
|
self: &SmartTable<K, V1>
,
f: \|&V1\|V2
| Maps a function over the values, producing a new SmartTable |
SmartTable<K, V2>
|
|
any
|
self: &SmartTable<K, V>
,
p: \|&K, &V\|bool
| Checks if any key-value pair satisfies the predicate |
bool
|
|
borrow_kv
|
self: &Entry<K, V>
| Borrows references to the key and value of an entry |
(&K, &V)
|
|
borrow_kv_mut
|
self: &mut Entry<K, V>
| Borrows mutable references to the key and value of an entry |
(&mut K, &mut V)
|
|
num_buckets
|
self: &SmartTable<K, V>
| Returns the number of buckets in the table |
u64
|
|
borrow_buckets
|
self: &SmartTable<K, V>
| Borrows a reference to the buckets of the table |
&TableWithLength<u64, vector<Entry<K, V>>>
|
|
borrow_buckets_mut
|
self: &mut SmartTable<K, V>
| Borrows a mutable reference to the buckets of the table |
&mut TableWithLength<u64, vector<Entry<K, V>>>
|
On This Page
Summary
Overview
Example
1. Module Declaration
2. Importing Required Modules
3. Defining a Custom Struct
4. Initialization Function
5. Creating a New SmartTable
6. Adding an Initial Entry
7. Moving the SmartTable to Storage
Full Example
1. init_module(caller: &signer)
2. test_init_module(caller: &signer)
3. get_amount_point(addr: address): u64
4. plus_point(addr: address, value: u64)
5. test_get_amount_point(caller: &signer)
6. test_plus_amount_point(caller: &signer)
Running Test
Additional SimpleMap Functions
On This Page
Summary
Overview
Example
1. Module Declaration
2. Importing Required Modules
3. Defining a Custom Struct
4. Initialization Function
5. Creating a New SmartTable
6. Adding an Initial Entry
7. Moving the SmartTable to Storage
Full Example
1. init_module(caller: &signer)
2. test_init_module(caller: &signer)
3. get_amount_point(addr: address): u64
4. plus_point(addr: address, value: u64)
5. test_get_amount_point(caller: &signer)
6. test_plus_amount_point(caller: &signer)
Running Test
Additional SimpleMap Functions
			On This Page
			On This Page
			Summary
Overview
Example
1. Module Declaration
2. Importing Required Modules
3. Defining a Custom Struct
4. Initialization Function
5. Creating a New SmartTable
6. Adding an Initial Entry
7. Moving the SmartTable to Storage
Full Example
1. init_module(caller: &signer)
2. test_init_module(caller: &signer)
3. get_amount_point(addr: address): u64
4. plus_point(addr: address, value: u64)
5. test_get_amount_point(caller: &signer)
6. test_plus_amount_point(caller: &signer)
Running Test
Additional SimpleMap Functions
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			Example
1. Module Declaration
2. Importing Required Modules
3. Defining a Custom Struct
4. Initialization Function
5. Creating a New SmartTable
6. Adding an Initial Entry
7. Moving the SmartTable to Storage
			Example
			Example
			Example
			1. Module Declaration
2. Importing Required Modules
3. Defining a Custom Struct
4. Initialization Function
5. Creating a New SmartTable
6. Adding an Initial Entry
7. Moving the SmartTable to Storage
			1. Module Declaration
			1. Module Declaration
			1. Module Declaration
			1. Module Declaration
			2. Importing Required Modules
			2. Importing Required Modules
			2. Importing Required Modules
			2. Importing Required Modules
			3. Defining a Custom Struct
			3. Defining a Custom Struct
			3. Defining a Custom Struct
			3. Defining a Custom Struct
			4. Initialization Function
			4. Initialization Function
			4. Initialization Function
			4. Initialization Function
			5. Creating a New SmartTable
			5. Creating a New SmartTable
			5. Creating a New SmartTable
			5. Creating a New SmartTable
			6. Adding an Initial Entry
			6. Adding an Initial Entry
			6. Adding an Initial Entry
			6. Adding an Initial Entry
			7. Moving the SmartTable to Storage
			7. Moving the SmartTable to Storage
			7. Moving the SmartTable to Storage
			7. Moving the SmartTable to Storage
			Full Example
1. init_module(caller: &signer)
2. test_init_module(caller: &signer)
3. get_amount_point(addr: address): u64
4. plus_point(addr: address, value: u64)
5. test_get_amount_point(caller: &signer)
6. test_plus_amount_point(caller: &signer)
			Full Example
			Full Example
			Full Example
			1. init_module(caller: &signer)
2. test_init_module(caller: &signer)
3. get_amount_point(addr: address): u64
4. plus_point(addr: address, value: u64)
5. test_get_amount_point(caller: &signer)
6. test_plus_amount_point(caller: &signer)
			1. init_module(caller: &signer)
			1. init_module(caller: &signer)
			1. init_module(caller: &signer)
			1. init_module(caller: &signer)
			2. test_init_module(caller: &signer)
			2. test_init_module(caller: &signer)
			2. test_init_module(caller: &signer)
			2. test_init_module(caller: &signer)
			3. get_amount_point(addr: address): u64
			3. get_amount_point(addr: address): u64
			3. get_amount_point(addr: address): u64
			3. get_amount_point(addr: address): u64
			4. plus_point(addr: address, value: u64)
			4. plus_point(addr: address, value: u64)
			4. plus_point(addr: address, value: u64)
			4. plus_point(addr: address, value: u64)
			5. test_get_amount_point(caller: &signer)
			5. test_get_amount_point(caller: &signer)
			5. test_get_amount_point(caller: &signer)
			5. test_get_amount_point(caller: &signer)
			6. test_plus_amount_point(caller: &signer)
			6. test_plus_amount_point(caller: &signer)
			6. test_plus_amount_point(caller: &signer)
			6. test_plus_amount_point(caller: &signer)
			Running Test
			Running Test
			Running Test
			Running Test
			Additional SimpleMap Functions
			Additional SimpleMap Functions
			Additional SimpleMap Functions
			Additional SimpleMap Functions
			Summary
Smart Table is a data structure in Move that stores data in multiple buckets for efficient access and gas optimization.
It operates similarly to Smart Vector, improving speed and cost-efficiency in data management.
The module demonstrates how to initialize, update, and retrieve data from a SmartTable.
The code includes test functions to verify the correct operation of SmartTable operations.
SmartTable uses address as keys and u64 as values in this example, suitable for tracking user points or balances.
Overview
Similar to
Smart Vector
, which we explored in the previous article,
Smart Table
operates on the same principle. Smart Table's data is divided into multiple
bucket
s for storage. Accessing, writing, and reading data in
Smart Table
occurs independently within each
bucket
containing that data. This organization improves speed and cost-efficiency while optimizing gas usage for users.
Example
module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
}
Let's break down the code and explain each function step-by-step:
1. Module Declaration
module movement::smart_table_module {
    // Module contents
}
This declares a new module named "smart_table_module" under the "movement" address.
2. Importing Required Modules
use aptos_std::smart_table::{Self, SmartTable};
This imports the SmartTable type and its associated functions from the aptos_std library.
3. Defining a Custom Struct
struct MovementTableObject has key {
    value: SmartTable<address, u64>
}
This defines a new struct called MovementTableObject that contains a SmartTable. The SmartTable uses address as keys and u64 as values.
4. Initialization Function
fun init_module(caller: &signer) {
    // Function body
}
This function is called when the module is published. It takes a reference to the signer (the account publishing the module) as an argument.
5. Creating a New SmartTable
let val = smart_table::new<address, u64>();
This creates a new SmartTable that uses address as keys and u64 as values.
6. Adding an Initial Entry
smart_table::add(&mut val, address_of(caller), 0);
This adds an initial entry to the SmartTable. The key is the address of the caller, and the value is 0.
7. Moving the SmartTable to Storage
move_to(caller, MovementTableObject {
    value: val
});
This creates a new MovementTableObject with the SmartTable we just created and moves it to the storage of the caller's account.
This initialization sets up a SmartTable in the caller's account, ready to be used for storing and managing data efficiently.
Full Example
module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    fun get_amount_point(addr: address): u64 acquires MovementTableObject {
        let table = &borrow_global<MovementTableObject>(addr).value;
        *smart_table::borrow(table, addr)
    }
    fun plus_point(addr: address, value: u64) acquires MovementTableObject {
        let table = &mut borrow_global_mut<MovementTableObject>(addr).value;
        let point = *smart_table::borrow_mut(table, addr);
        point = point + value;
        smart_table::upsert(table, addr, point);
    }
    #[test(caller = @0x1)]
    fun test_get_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
    #[test(caller = @0x1)]
    fun test_plus_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        plus_point(address_of(caller), 10);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
}
1. init_module(caller: &signer)
This function initializes the module when it's published:
Create a new SmartTable using
smart_table::new&lt;address, u64&gt;()
Add an initial entry to the table with the caller's address as the key and 0 as the value
Create a new MovementTableObject with the SmartTable and move it to the caller's storage
2. test_init_module(caller: &signer)
This is a test-only function that calls init_module:
It's annotated with
#[test_only]
, meaning it's only used for testing
It simply calls the init_module function with the provided caller
3. get_amount_point(addr: address): u64
This function retrieves the point amount for a given address:
It's annotated with
#[view]
, indicating it's a read-only function
Borrow the SmartTable from the MovementTableObject stored at the given address
Use
smart_table::borrow
to get the value associated with the address
Return the borrowed value (point amount)
4. plus_point(addr: address, value: u64)
This function adds points to a given address:
Borrow the SmartTable mutably from the MovementTableObject
Get the current point value for the address using
smart_table::borrow_mut
Add the new value to the current point
Update the SmartTable with the new point value using
smart_table::upsert
5. test_get_amount_point(caller: &signer)
This is a test function for get_amount_point:
It's annotated with
#[test(caller = @0x1)]
, setting up a test environment
Call test_init_module to set up the initial state
Call get_amount_point with the caller's address
Print the retrieved amount
6. test_plus_amount_point(caller: &signer)
This is a test function for plus_point:
It's also annotated with
#[test(caller = @0x1)]
Call test_init_module to set up the initial state
Call plus_point to add 10 points to the caller's address
Call get_amount_point to retrieve the updated point amount
Print the new amount
These functions demonstrate how to initialize, update, and retrieve data from a SmartTable, as well as how to set up tests for these operations.
Running Test
Running test:
movement move test -f smart_table_module
Result:
Running Move unit tests
[debug] 0
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_get_amount_point
[debug] 10
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_plus_amount_point
Test result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Additional SimpleMap Functions
| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
new
| None | Creates an empty SmartTable with default configurations |
SmartTable<K, V>
|
|
new_with_config
|
num_initial_buckets: u64
,
split_load_threshold: u8
,
target_bucket_size: u64
| Creates an empty SmartTable with customized configurations |
SmartTable<K, V>
|
|
destroy_empty
|
self: SmartTable<K, V>
| Destroys an empty table | None |
|
destroy
|
self: SmartTable<K, V>
| Destroys a table completely when V has
drop
| None |
|
clear
|
self: &mut SmartTable<K, V>
| Clears a table completely when T has
drop
| None |
|
add
|
self: &mut SmartTable<K, V>
,
key: K
,
value: V
| Adds a key-value pair to the table | None |
|
add_all
|
self: &mut SmartTable<K, V>
,
keys: vector<K>
,
values: vector<V>
| Adds multiple key-value pairs to the table | None |
|
unzip_entries
|
entries: &vector<Entry<K, V>>
| Unzips entries into separate key and value vectors |
(vector<K>, vector<V>)
|
|
to_simple_map
|
self: &SmartTable<K, V>
| Converts a smart table to a simple_map |
SimpleMap<K, V>
|
|
keys
|
self: &SmartTable<K, V>
| Gets all keys in a smart table |
vector<K>
|
|
keys_paginated
|
self: &SmartTable<K, V>
,
starting_bucket_index: u64
,
starting_vector_index: u64
,
num_keys_to_get: u64
| Gets keys from a smart table, paginated |
(vector<K>, Option<u64>, Option<u64>)
|
|
split_one_bucket
|
self: &mut SmartTable<K, V>
| Splits one bucket into two | None |
|
bucket_index
|
level: u8
,
num_buckets: u64
,
hash: u64
| Returns the expected bucket index for a hash |
u64
|
|
borrow
|
self: &SmartTable<K, V>
,
key: K
| Borrows an immutable reference to the value associated with the key |
&V
|
|
borrow_with_default
|
self: &SmartTable<K, V>
,
key: K
,
default: &V
| Borrows an immutable reference to the value, or returns the default if key not found |
&V
|
|
borrow_mut
|
self: &mut SmartTable<K, V>
,
key: K
| Borrows a mutable reference to the value associated with the key |
&mut V
|
|
borrow_mut_with_default
|
self: &mut SmartTable<K, V>
,
key: K
,
default: V
| Borrows a mutable reference to the value, or inserts and returns default if key not found |
&mut V
|
|
contains
|
self: &SmartTable<K, V>
,
key: K
| Checks if the table contains a key |
bool
|
|
remove
|
self: &mut SmartTable<K, V>
,
key: K
| Removes and returns the value associated with the key |
V
|
|
upsert
|
self: &mut SmartTable<K, V>
,
key: K
,
value: V
| Inserts a key-value pair or updates an existing one | None |
|
length
|
self: &SmartTable<K, V>
| Returns the number of entries in the table |
u64
|
|
load_factor
|
self: &SmartTable<K, V>
| Returns the load factor of the hashtable |
u64
|
|
update_split_load_threshold
|
self: &mut SmartTable<K, V>
,
split_load_threshold: u8
| Updates the split load threshold | None |
|
update_target_bucket_size
|
self: &mut SmartTable<K, V>
,
target_bucket_size: u64
| Updates the target bucket size | None |
|
for_each_ref
|
self: &SmartTable<K, V>
,
f: \|&K, &V\|
| Applies a function to a reference of each key-value pair | None |
|
for_each_mut
|
self: &mut SmartTable<K, V>
,
f: \|&K, &mut V\|
| Applies a function to a mutable reference of each key-value pair | None |
|
map_ref
|
self: &SmartTable<K, V1>
,
f: \|&V1\|V2
| Maps a function over the values, producing a new SmartTable |
SmartTable<K, V2>
|
|
any
|
self: &SmartTable<K, V>
,
p: \|&K, &V\|bool
| Checks if any key-value pair satisfies the predicate |
bool
|
|
borrow_kv
|
self: &Entry<K, V>
| Borrows references to the key and value of an entry |
(&K, &V)
|
|
borrow_kv_mut
|
self: &mut Entry<K, V>
| Borrows mutable references to the key and value of an entry |
(&mut K, &mut V)
|
|
num_buckets
|
self: &SmartTable<K, V>
| Returns the number of buckets in the table |
u64
|
|
borrow_buckets
|
self: &SmartTable<K, V>
| Borrows a reference to the buckets of the table |
&TableWithLength<u64, vector<Entry<K, V>>>
|
|
borrow_buckets_mut
|
self: &mut SmartTable<K, V>
| Borrows a mutable reference to the buckets of the table |
&mut TableWithLength<u64, vector<Entry<K, V>>>
|
			Summary
Smart Table is a data structure in Move that stores data in multiple buckets for efficient access and gas optimization.
It operates similarly to Smart Vector, improving speed and cost-efficiency in data management.
The module demonstrates how to initialize, update, and retrieve data from a SmartTable.
The code includes test functions to verify the correct operation of SmartTable operations.
SmartTable uses address as keys and u64 as values in this example, suitable for tracking user points or balances.
Overview
Similar to
Smart Vector
, which we explored in the previous article,
Smart Table
operates on the same principle. Smart Table's data is divided into multiple
bucket
s for storage. Accessing, writing, and reading data in
Smart Table
occurs independently within each
bucket
containing that data. This organization improves speed and cost-efficiency while optimizing gas usage for users.
Example
module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
}
Let's break down the code and explain each function step-by-step:
1. Module Declaration
module movement::smart_table_module {
    // Module contents
}
This declares a new module named "smart_table_module" under the "movement" address.
2. Importing Required Modules
use aptos_std::smart_table::{Self, SmartTable};
This imports the SmartTable type and its associated functions from the aptos_std library.
3. Defining a Custom Struct
struct MovementTableObject has key {
    value: SmartTable<address, u64>
}
This defines a new struct called MovementTableObject that contains a SmartTable. The SmartTable uses address as keys and u64 as values.
4. Initialization Function
fun init_module(caller: &signer) {
    // Function body
}
This function is called when the module is published. It takes a reference to the signer (the account publishing the module) as an argument.
5. Creating a New SmartTable
let val = smart_table::new<address, u64>();
This creates a new SmartTable that uses address as keys and u64 as values.
6. Adding an Initial Entry
smart_table::add(&mut val, address_of(caller), 0);
This adds an initial entry to the SmartTable. The key is the address of the caller, and the value is 0.
7. Moving the SmartTable to Storage
move_to(caller, MovementTableObject {
    value: val
});
This creates a new MovementTableObject with the SmartTable we just created and moves it to the storage of the caller's account.
This initialization sets up a SmartTable in the caller's account, ready to be used for storing and managing data efficiently.
Full Example
module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    fun get_amount_point(addr: address): u64 acquires MovementTableObject {
        let table = &borrow_global<MovementTableObject>(addr).value;
        *smart_table::borrow(table, addr)
    }
    fun plus_point(addr: address, value: u64) acquires MovementTableObject {
        let table = &mut borrow_global_mut<MovementTableObject>(addr).value;
        let point = *smart_table::borrow_mut(table, addr);
        point = point + value;
        smart_table::upsert(table, addr, point);
    }
    #[test(caller = @0x1)]
    fun test_get_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
    #[test(caller = @0x1)]
    fun test_plus_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        plus_point(address_of(caller), 10);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
}
1. init_module(caller: &signer)
This function initializes the module when it's published:
Create a new SmartTable using
smart_table::new&lt;address, u64&gt;()
Add an initial entry to the table with the caller's address as the key and 0 as the value
Create a new MovementTableObject with the SmartTable and move it to the caller's storage
2. test_init_module(caller: &signer)
This is a test-only function that calls init_module:
It's annotated with
#[test_only]
, meaning it's only used for testing
It simply calls the init_module function with the provided caller
3. get_amount_point(addr: address): u64
This function retrieves the point amount for a given address:
It's annotated with
#[view]
, indicating it's a read-only function
Borrow the SmartTable from the MovementTableObject stored at the given address
Use
smart_table::borrow
to get the value associated with the address
Return the borrowed value (point amount)
4. plus_point(addr: address, value: u64)
This function adds points to a given address:
Borrow the SmartTable mutably from the MovementTableObject
Get the current point value for the address using
smart_table::borrow_mut
Add the new value to the current point
Update the SmartTable with the new point value using
smart_table::upsert
5. test_get_amount_point(caller: &signer)
This is a test function for get_amount_point:
It's annotated with
#[test(caller = @0x1)]
, setting up a test environment
Call test_init_module to set up the initial state
Call get_amount_point with the caller's address
Print the retrieved amount
6. test_plus_amount_point(caller: &signer)
This is a test function for plus_point:
It's also annotated with
#[test(caller = @0x1)]
Call test_init_module to set up the initial state
Call plus_point to add 10 points to the caller's address
Call get_amount_point to retrieve the updated point amount
Print the new amount
These functions demonstrate how to initialize, update, and retrieve data from a SmartTable, as well as how to set up tests for these operations.
Running Test
Running test:
movement move test -f smart_table_module
Result:
Running Move unit tests
[debug] 0
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_get_amount_point
[debug] 10
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_plus_amount_point
Test result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Additional SimpleMap Functions
| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
new
| None | Creates an empty SmartTable with default configurations |
SmartTable<K, V>
|
|
new_with_config
|
num_initial_buckets: u64
,
split_load_threshold: u8
,
target_bucket_size: u64
| Creates an empty SmartTable with customized configurations |
SmartTable<K, V>
|
|
destroy_empty
|
self: SmartTable<K, V>
| Destroys an empty table | None |
|
destroy
|
self: SmartTable<K, V>
| Destroys a table completely when V has
drop
| None |
|
clear
|
self: &mut SmartTable<K, V>
| Clears a table completely when T has
drop
| None |
|
add
|
self: &mut SmartTable<K, V>
,
key: K
,
value: V
| Adds a key-value pair to the table | None |
|
add_all
|
self: &mut SmartTable<K, V>
,
keys: vector<K>
,
values: vector<V>
| Adds multiple key-value pairs to the table | None |
|
unzip_entries
|
entries: &vector<Entry<K, V>>
| Unzips entries into separate key and value vectors |
(vector<K>, vector<V>)
|
|
to_simple_map
|
self: &SmartTable<K, V>
| Converts a smart table to a simple_map |
SimpleMap<K, V>
|
|
keys
|
self: &SmartTable<K, V>
| Gets all keys in a smart table |
vector<K>
|
|
keys_paginated
|
self: &SmartTable<K, V>
,
starting_bucket_index: u64
,
starting_vector_index: u64
,
num_keys_to_get: u64
| Gets keys from a smart table, paginated |
(vector<K>, Option<u64>, Option<u64>)
|
|
split_one_bucket
|
self: &mut SmartTable<K, V>
| Splits one bucket into two | None |
|
bucket_index
|
level: u8
,
num_buckets: u64
,
hash: u64
| Returns the expected bucket index for a hash |
u64
|
|
borrow
|
self: &SmartTable<K, V>
,
key: K
| Borrows an immutable reference to the value associated with the key |
&V
|
|
borrow_with_default
|
self: &SmartTable<K, V>
,
key: K
,
default: &V
| Borrows an immutable reference to the value, or returns the default if key not found |
&V
|
|
borrow_mut
|
self: &mut SmartTable<K, V>
,
key: K
| Borrows a mutable reference to the value associated with the key |
&mut V
|
|
borrow_mut_with_default
|
self: &mut SmartTable<K, V>
,
key: K
,
default: V
| Borrows a mutable reference to the value, or inserts and returns default if key not found |
&mut V
|
|
contains
|
self: &SmartTable<K, V>
,
key: K
| Checks if the table contains a key |
bool
|
|
remove
|
self: &mut SmartTable<K, V>
,
key: K
| Removes and returns the value associated with the key |
V
|
|
upsert
|
self: &mut SmartTable<K, V>
,
key: K
,
value: V
| Inserts a key-value pair or updates an existing one | None |
|
length
|
self: &SmartTable<K, V>
| Returns the number of entries in the table |
u64
|
|
load_factor
|
self: &SmartTable<K, V>
| Returns the load factor of the hashtable |
u64
|
|
update_split_load_threshold
|
self: &mut SmartTable<K, V>
,
split_load_threshold: u8
| Updates the split load threshold | None |
|
update_target_bucket_size
|
self: &mut SmartTable<K, V>
,
target_bucket_size: u64
| Updates the target bucket size | None |
|
for_each_ref
|
self: &SmartTable<K, V>
,
f: \|&K, &V\|
| Applies a function to a reference of each key-value pair | None |
|
for_each_mut
|
self: &mut SmartTable<K, V>
,
f: \|&K, &mut V\|
| Applies a function to a mutable reference of each key-value pair | None |
|
map_ref
|
self: &SmartTable<K, V1>
,
f: \|&V1\|V2
| Maps a function over the values, producing a new SmartTable |
SmartTable<K, V2>
|
|
any
|
self: &SmartTable<K, V>
,
p: \|&K, &V\|bool
| Checks if any key-value pair satisfies the predicate |
bool
|
|
borrow_kv
|
self: &Entry<K, V>
| Borrows references to the key and value of an entry |
(&K, &V)
|
|
borrow_kv_mut
|
self: &mut Entry<K, V>
| Borrows mutable references to the key and value of an entry |
(&mut K, &mut V)
|
|
num_buckets
|
self: &SmartTable<K, V>
| Returns the number of buckets in the table |
u64
|
|
borrow_buckets
|
self: &SmartTable<K, V>
| Borrows a reference to the buckets of the table |
&TableWithLength<u64, vector<Entry<K, V>>>
|
|
borrow_buckets_mut
|
self: &mut SmartTable<K, V>
| Borrows a mutable reference to the buckets of the table |
&mut TableWithLength<u64, vector<Entry<K, V>>>
|
			Summary
Smart Table is a data structure in Move that stores data in multiple buckets for efficient access and gas optimization.
It operates similarly to Smart Vector, improving speed and cost-efficiency in data management.
The module demonstrates how to initialize, update, and retrieve data from a SmartTable.
The code includes test functions to verify the correct operation of SmartTable operations.
SmartTable uses address as keys and u64 as values in this example, suitable for tracking user points or balances.
Overview
Similar to
Smart Vector
, which we explored in the previous article,
Smart Table
operates on the same principle. Smart Table's data is divided into multiple
bucket
s for storage. Accessing, writing, and reading data in
Smart Table
occurs independently within each
bucket
containing that data. This organization improves speed and cost-efficiency while optimizing gas usage for users.
Example
module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
}
Let's break down the code and explain each function step-by-step:
1. Module Declaration
module movement::smart_table_module {
    // Module contents
}
This declares a new module named "smart_table_module" under the "movement" address.
2. Importing Required Modules
use aptos_std::smart_table::{Self, SmartTable};
This imports the SmartTable type and its associated functions from the aptos_std library.
3. Defining a Custom Struct
struct MovementTableObject has key {
    value: SmartTable<address, u64>
}
This defines a new struct called MovementTableObject that contains a SmartTable. The SmartTable uses address as keys and u64 as values.
4. Initialization Function
fun init_module(caller: &signer) {
    // Function body
}
This function is called when the module is published. It takes a reference to the signer (the account publishing the module) as an argument.
5. Creating a New SmartTable
let val = smart_table::new<address, u64>();
This creates a new SmartTable that uses address as keys and u64 as values.
6. Adding an Initial Entry
smart_table::add(&mut val, address_of(caller), 0);
This adds an initial entry to the SmartTable. The key is the address of the caller, and the value is 0.
7. Moving the SmartTable to Storage
move_to(caller, MovementTableObject {
    value: val
});
This creates a new MovementTableObject with the SmartTable we just created and moves it to the storage of the caller's account.
This initialization sets up a SmartTable in the caller's account, ready to be used for storing and managing data efficiently.
Full Example
module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    fun get_amount_point(addr: address): u64 acquires MovementTableObject {
        let table = &borrow_global<MovementTableObject>(addr).value;
        *smart_table::borrow(table, addr)
    }
    fun plus_point(addr: address, value: u64) acquires MovementTableObject {
        let table = &mut borrow_global_mut<MovementTableObject>(addr).value;
        let point = *smart_table::borrow_mut(table, addr);
        point = point + value;
        smart_table::upsert(table, addr, point);
    }
    #[test(caller = @0x1)]
    fun test_get_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
    #[test(caller = @0x1)]
    fun test_plus_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        plus_point(address_of(caller), 10);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
}
1. init_module(caller: &signer)
This function initializes the module when it's published:
Create a new SmartTable using
smart_table::new&lt;address, u64&gt;()
Add an initial entry to the table with the caller's address as the key and 0 as the value
Create a new MovementTableObject with the SmartTable and move it to the caller's storage
2. test_init_module(caller: &signer)
This is a test-only function that calls init_module:
It's annotated with
#[test_only]
, meaning it's only used for testing
It simply calls the init_module function with the provided caller
3. get_amount_point(addr: address): u64
This function retrieves the point amount for a given address:
It's annotated with
#[view]
, indicating it's a read-only function
Borrow the SmartTable from the MovementTableObject stored at the given address
Use
smart_table::borrow
to get the value associated with the address
Return the borrowed value (point amount)
4. plus_point(addr: address, value: u64)
This function adds points to a given address:
Borrow the SmartTable mutably from the MovementTableObject
Get the current point value for the address using
smart_table::borrow_mut
Add the new value to the current point
Update the SmartTable with the new point value using
smart_table::upsert
5. test_get_amount_point(caller: &signer)
This is a test function for get_amount_point:
It's annotated with
#[test(caller = @0x1)]
, setting up a test environment
Call test_init_module to set up the initial state
Call get_amount_point with the caller's address
Print the retrieved amount
6. test_plus_amount_point(caller: &signer)
This is a test function for plus_point:
It's also annotated with
#[test(caller = @0x1)]
Call test_init_module to set up the initial state
Call plus_point to add 10 points to the caller's address
Call get_amount_point to retrieve the updated point amount
Print the new amount
These functions demonstrate how to initialize, update, and retrieve data from a SmartTable, as well as how to set up tests for these operations.
Running Test
Running test:
movement move test -f smart_table_module
Result:
Running Move unit tests
[debug] 0
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_get_amount_point
[debug] 10
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_plus_amount_point
Test result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
Additional SimpleMap Functions
| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
new
| None | Creates an empty SmartTable with default configurations |
SmartTable<K, V>
|
|
new_with_config
|
num_initial_buckets: u64
,
split_load_threshold: u8
,
target_bucket_size: u64
| Creates an empty SmartTable with customized configurations |
SmartTable<K, V>
|
|
destroy_empty
|
self: SmartTable<K, V>
| Destroys an empty table | None |
|
destroy
|
self: SmartTable<K, V>
| Destroys a table completely when V has
drop
| None |
|
clear
|
self: &mut SmartTable<K, V>
| Clears a table completely when T has
drop
| None |
|
add
|
self: &mut SmartTable<K, V>
,
key: K
,
value: V
| Adds a key-value pair to the table | None |
|
add_all
|
self: &mut SmartTable<K, V>
,
keys: vector<K>
,
values: vector<V>
| Adds multiple key-value pairs to the table | None |
|
unzip_entries
|
entries: &vector<Entry<K, V>>
| Unzips entries into separate key and value vectors |
(vector<K>, vector<V>)
|
|
to_simple_map
|
self: &SmartTable<K, V>
| Converts a smart table to a simple_map |
SimpleMap<K, V>
|
|
keys
|
self: &SmartTable<K, V>
| Gets all keys in a smart table |
vector<K>
|
|
keys_paginated
|
self: &SmartTable<K, V>
,
starting_bucket_index: u64
,
starting_vector_index: u64
,
num_keys_to_get: u64
| Gets keys from a smart table, paginated |
(vector<K>, Option<u64>, Option<u64>)
|
|
split_one_bucket
|
self: &mut SmartTable<K, V>
| Splits one bucket into two | None |
|
bucket_index
|
level: u8
,
num_buckets: u64
,
hash: u64
| Returns the expected bucket index for a hash |
u64
|
|
borrow
|
self: &SmartTable<K, V>
,
key: K
| Borrows an immutable reference to the value associated with the key |
&V
|
|
borrow_with_default
|
self: &SmartTable<K, V>
,
key: K
,
default: &V
| Borrows an immutable reference to the value, or returns the default if key not found |
&V
|
|
borrow_mut
|
self: &mut SmartTable<K, V>
,
key: K
| Borrows a mutable reference to the value associated with the key |
&mut V
|
|
borrow_mut_with_default
|
self: &mut SmartTable<K, V>
,
key: K
,
default: V
| Borrows a mutable reference to the value, or inserts and returns default if key not found |
&mut V
|
|
contains
|
self: &SmartTable<K, V>
,
key: K
| Checks if the table contains a key |
bool
|
|
remove
|
self: &mut SmartTable<K, V>
,
key: K
| Removes and returns the value associated with the key |
V
|
|
upsert
|
self: &mut SmartTable<K, V>
,
key: K
,
value: V
| Inserts a key-value pair or updates an existing one | None |
|
length
|
self: &SmartTable<K, V>
| Returns the number of entries in the table |
u64
|
|
load_factor
|
self: &SmartTable<K, V>
| Returns the load factor of the hashtable |
u64
|
|
update_split_load_threshold
|
self: &mut SmartTable<K, V>
,
split_load_threshold: u8
| Updates the split load threshold | None |
|
update_target_bucket_size
|
self: &mut SmartTable<K, V>
,
target_bucket_size: u64
| Updates the target bucket size | None |
|
for_each_ref
|
self: &SmartTable<K, V>
,
f: \|&K, &V\|
| Applies a function to a reference of each key-value pair | None |
|
for_each_mut
|
self: &mut SmartTable<K, V>
,
f: \|&K, &mut V\|
| Applies a function to a mutable reference of each key-value pair | None |
|
map_ref
|
self: &SmartTable<K, V1>
,
f: \|&V1\|V2
| Maps a function over the values, producing a new SmartTable |
SmartTable<K, V2>
|
|
any
|
self: &SmartTable<K, V>
,
p: \|&K, &V\|bool
| Checks if any key-value pair satisfies the predicate |
bool
|
|
borrow_kv
|
self: &Entry<K, V>
| Borrows references to the key and value of an entry |
(&K, &V)
|
|
borrow_kv_mut
|
self: &mut Entry<K, V>
| Borrows mutable references to the key and value of an entry |
(&mut K, &mut V)
|
|
num_buckets
|
self: &SmartTable<K, V>
| Returns the number of buckets in the table |
u64
|
|
borrow_buckets
|
self: &SmartTable<K, V>
| Borrows a reference to the buckets of the table |
&TableWithLength<u64, vector<Entry<K, V>>>
|
|
borrow_buckets_mut
|
self: &mut SmartTable<K, V>
| Borrows a mutable reference to the buckets of the table |
&mut TableWithLength<u64, vector<Entry<K, V>>>
|
	Summary
	Summary
	Smart Table is a data structure in Move that stores data in multiple buckets for efficient access and gas optimization.
It operates similarly to Smart Vector, improving speed and cost-efficiency in data management.
The module demonstrates how to initialize, update, and retrieve data from a SmartTable.
The code includes test functions to verify the correct operation of SmartTable operations.
SmartTable uses address as keys and u64 as values in this example, suitable for tracking user points or balances.
	Smart Table is a data structure in Move that stores data in multiple buckets for efficient access and gas optimization.
	Smart Table is a data structure in Move that stores data in multiple buckets for efficient access and gas optimization.
	It operates similarly to Smart Vector, improving speed and cost-efficiency in data management.
	It operates similarly to Smart Vector, improving speed and cost-efficiency in data management.
	The module demonstrates how to initialize, update, and retrieve data from a SmartTable.
	The module demonstrates how to initialize, update, and retrieve data from a SmartTable.
	The code includes test functions to verify the correct operation of SmartTable operations.
	The code includes test functions to verify the correct operation of SmartTable operations.
	SmartTable uses address as keys and u64 as values in this example, suitable for tracking user points or balances.
	SmartTable uses address as keys and u64 as values in this example, suitable for tracking user points or balances.
	Overview
	Overview
	Similar to
Smart Vector
, which we explored in the previous article,
Smart Table
operates on the same principle. Smart Table's data is divided into multiple
bucket
s for storage. Accessing, writing, and reading data in
Smart Table
occurs independently within each
bucket
containing that data. This organization improves speed and cost-efficiency while optimizing gas usage for users.
	Similar to
	<code>Smart Vector</code>
	Smart Vector
	, which we explored in the previous article,
	<code>Smart Table</code>
	Smart Table
	operates on the same principle. Smart Table's data is divided into multiple
	<code>bucket</code>
	bucket
	s for storage. Accessing, writing, and reading data in
	<code>Smart Table</code>
	Smart Table
	occurs independently within each
	<code>bucket</code>
	bucket
	containing that data. This organization improves speed and cost-efficiency while optimizing gas usage for users.
	Example
	Example
	<code>module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
}</code>
	<code>module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
}</code>
	module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
}
	Let's break down the code and explain each function step-by-step:
	Let's break down the code and explain each function step-by-step:
		1. Module Declaration
		1. Module Declaration
		<code>module movement::smart_table_module {
    // Module contents
}</code>
		<code>module movement::smart_table_module {
    // Module contents
}</code>
		module movement::smart_table_module {
    // Module contents
}
		This declares a new module named "smart_table_module" under the "movement" address.
		This declares a new module named "smart_table_module" under the "movement" address.
		2. Importing Required Modules
		2. Importing Required Modules
		<code>use aptos_std::smart_table::{Self, SmartTable};</code>
		<code>use aptos_std::smart_table::{Self, SmartTable};</code>
		use aptos_std::smart_table::{Self, SmartTable};
		This imports the SmartTable type and its associated functions from the aptos_std library.
		This imports the SmartTable type and its associated functions from the aptos_std library.
		3. Defining a Custom Struct
		3. Defining a Custom Struct
		<code>struct MovementTableObject has key {
    value: SmartTable<address, u64>
}</code>
		<code>struct MovementTableObject has key {
    value: SmartTable<address, u64>
}</code>
		struct MovementTableObject has key {
    value: SmartTable<address, u64>
}
		This defines a new struct called MovementTableObject that contains a SmartTable. The SmartTable uses address as keys and u64 as values.
		This defines a new struct called MovementTableObject that contains a SmartTable. The SmartTable uses address as keys and u64 as values.
		4. Initialization Function
		4. Initialization Function
		<code>fun init_module(caller: &signer) {
    // Function body
}</code>
		<code>fun init_module(caller: &signer) {
    // Function body
}</code>
		fun init_module(caller: &signer) {
    // Function body
}
		This function is called when the module is published. It takes a reference to the signer (the account publishing the module) as an argument.
		This function is called when the module is published. It takes a reference to the signer (the account publishing the module) as an argument.
		5. Creating a New SmartTable
		5. Creating a New SmartTable
		<code>let val = smart_table::new<address, u64>();</code>
		<code>let val = smart_table::new<address, u64>();</code>
		let val = smart_table::new<address, u64>();
		This creates a new SmartTable that uses address as keys and u64 as values.
		This creates a new SmartTable that uses address as keys and u64 as values.
		6. Adding an Initial Entry
		6. Adding an Initial Entry
		<code>smart_table::add(&mut val, address_of(caller), 0);</code>
		<code>smart_table::add(&mut val, address_of(caller), 0);</code>
		smart_table::add(&mut val, address_of(caller), 0);
		This adds an initial entry to the SmartTable. The key is the address of the caller, and the value is 0.
		This adds an initial entry to the SmartTable. The key is the address of the caller, and the value is 0.
		7. Moving the SmartTable to Storage
		7. Moving the SmartTable to Storage
		<code>move_to(caller, MovementTableObject {
    value: val
});</code>
		<code>move_to(caller, MovementTableObject {
    value: val
});</code>
		move_to(caller, MovementTableObject {
    value: val
});
		This creates a new MovementTableObject with the SmartTable we just created and moves it to the storage of the caller's account.
		This creates a new MovementTableObject with the SmartTable we just created and moves it to the storage of the caller's account.
		This initialization sets up a SmartTable in the caller's account, ready to be used for storing and managing data efficiently.
		This initialization sets up a SmartTable in the caller's account, ready to be used for storing and managing data efficiently.
	Full Example
	Full Example
	<code>module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    fun get_amount_point(addr: address): u64 acquires MovementTableObject {
        let table = &borrow_global<MovementTableObject>(addr).value;
        *smart_table::borrow(table, addr)
    }
    fun plus_point(addr: address, value: u64) acquires MovementTableObject {
        let table = &mut borrow_global_mut<MovementTableObject>(addr).value;
        let point = *smart_table::borrow_mut(table, addr);
        point = point + value;
        smart_table::upsert(table, addr, point);
    }
    #[test(caller = @0x1)]
    fun test_get_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
    #[test(caller = @0x1)]
    fun test_plus_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        plus_point(address_of(caller), 10);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
}</code>
	<code>module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    fun get_amount_point(addr: address): u64 acquires MovementTableObject {
        let table = &borrow_global<MovementTableObject>(addr).value;
        *smart_table::borrow(table, addr)
    }
    fun plus_point(addr: address, value: u64) acquires MovementTableObject {
        let table = &mut borrow_global_mut<MovementTableObject>(addr).value;
        let point = *smart_table::borrow_mut(table, addr);
        point = point + value;
        smart_table::upsert(table, addr, point);
    }
    #[test(caller = @0x1)]
    fun test_get_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
    #[test(caller = @0x1)]
    fun test_plus_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        plus_point(address_of(caller), 10);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
}</code>
	module movement::smart_table_module {
    use aptos_std::smart_table::{Self, SmartTable};
    use std::debug::print;
    use std::signer::address_of;
    struct MovementTableObject has key {
        value: SmartTable<address, u64>
    }
    fun init_module(caller: &signer) {
        let val = smart_table::new<address, u64>();
        smart_table::add(&mut val, address_of(caller), 0);
        move_to(caller, MovementTableObject {
            value: val
        });
    }
    #[test_only]
    fun test_init_module(caller: &signer) {
        init_module(caller);
    }
    #[view]
    fun get_amount_point(addr: address): u64 acquires MovementTableObject {
        let table = &borrow_global<MovementTableObject>(addr).value;
        *smart_table::borrow(table, addr)
    }
    fun plus_point(addr: address, value: u64) acquires MovementTableObject {
        let table = &mut borrow_global_mut<MovementTableObject>(addr).value;
        let point = *smart_table::borrow_mut(table, addr);
        point = point + value;
        smart_table::upsert(table, addr, point);
    }
    #[test(caller = @0x1)]
    fun test_get_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
    #[test(caller = @0x1)]
    fun test_plus_amount_point(caller: &signer) acquires MovementTableObject {
        test_init_module(caller);
        plus_point(address_of(caller), 10);
        let amount = get_amount_point(address_of(caller));
        print(&amount);
    }
}
		1. init_module(caller: &signer)
		1. init_module(caller: &signer)
		This function initializes the module when it's published:
		This function initializes the module when it's published:
		Create a new SmartTable using
smart_table::new&lt;address, u64&gt;()
Add an initial entry to the table with the caller's address as the key and 0 as the value
Create a new MovementTableObject with the SmartTable and move it to the caller's storage
		Create a new SmartTable using
smart_table::new&lt;address, u64&gt;()
		Create a new SmartTable using
		<code>smart_table::new&lt;address, u64&gt;()</code>
		smart_table::new&lt;address, u64&gt;()
		Add an initial entry to the table with the caller's address as the key and 0 as the value
		Add an initial entry to the table with the caller's address as the key and 0 as the value
		Create a new MovementTableObject with the SmartTable and move it to the caller's storage
		Create a new MovementTableObject with the SmartTable and move it to the caller's storage
		2. test_init_module(caller: &signer)
		2. test_init_module(caller: &signer)
		This is a test-only function that calls init_module:
		This is a test-only function that calls init_module:
		It's annotated with
#[test_only]
, meaning it's only used for testing
It simply calls the init_module function with the provided caller
		It's annotated with
#[test_only]
, meaning it's only used for testing
		It's annotated with
		<code>#[test_only]</code>
		#[test_only]
		, meaning it's only used for testing
		It simply calls the init_module function with the provided caller
		It simply calls the init_module function with the provided caller
		3. get_amount_point(addr: address): u64
		3. get_amount_point(addr: address): u64
		This function retrieves the point amount for a given address:
		This function retrieves the point amount for a given address:
		It's annotated with
#[view]
, indicating it's a read-only function
Borrow the SmartTable from the MovementTableObject stored at the given address
Use
smart_table::borrow
to get the value associated with the address
Return the borrowed value (point amount)
		It's annotated with
#[view]
, indicating it's a read-only function
		It's annotated with
		<code>#[view]</code>
		#[view]
		, indicating it's a read-only function
		Borrow the SmartTable from the MovementTableObject stored at the given address
		Borrow the SmartTable from the MovementTableObject stored at the given address
		Use
smart_table::borrow
to get the value associated with the address
		Use
		<code>smart_table::borrow</code>
		smart_table::borrow
		to get the value associated with the address
		Return the borrowed value (point amount)
		Return the borrowed value (point amount)
		4. plus_point(addr: address, value: u64)
		4. plus_point(addr: address, value: u64)
		This function adds points to a given address:
		This function adds points to a given address:
		Borrow the SmartTable mutably from the MovementTableObject
Get the current point value for the address using
smart_table::borrow_mut
Add the new value to the current point
Update the SmartTable with the new point value using
smart_table::upsert
		Borrow the SmartTable mutably from the MovementTableObject
		Borrow the SmartTable mutably from the MovementTableObject
		Get the current point value for the address using
smart_table::borrow_mut
		Get the current point value for the address using
		<code>smart_table::borrow_mut</code>
		smart_table::borrow_mut
		Add the new value to the current point
		Add the new value to the current point
		Update the SmartTable with the new point value using
smart_table::upsert
		Update the SmartTable with the new point value using
		<code>smart_table::upsert</code>
		smart_table::upsert
		5. test_get_amount_point(caller: &signer)
		5. test_get_amount_point(caller: &signer)
		This is a test function for get_amount_point:
		This is a test function for get_amount_point:
		It's annotated with
#[test(caller = @0x1)]
, setting up a test environment
Call test_init_module to set up the initial state
Call get_amount_point with the caller's address
Print the retrieved amount
		It's annotated with
#[test(caller = @0x1)]
, setting up a test environment
		It's annotated with
		<code>#[test(caller = @0x1)]</code>
		#[test(caller = @0x1)]
		, setting up a test environment
		Call test_init_module to set up the initial state
		Call test_init_module to set up the initial state
		Call get_amount_point with the caller's address
		Call get_amount_point with the caller's address
		Print the retrieved amount
		Print the retrieved amount
		6. test_plus_amount_point(caller: &signer)
		6. test_plus_amount_point(caller: &signer)
		This is a test function for plus_point:
		This is a test function for plus_point:
		It's also annotated with
#[test(caller = @0x1)]
Call test_init_module to set up the initial state
Call plus_point to add 10 points to the caller's address
Call get_amount_point to retrieve the updated point amount
Print the new amount
		It's also annotated with
#[test(caller = @0x1)]
		It's also annotated with
		<code>#[test(caller = @0x1)]</code>
		#[test(caller = @0x1)]
		Call test_init_module to set up the initial state
		Call test_init_module to set up the initial state
		Call plus_point to add 10 points to the caller's address
		Call plus_point to add 10 points to the caller's address
		Call get_amount_point to retrieve the updated point amount
		Call get_amount_point to retrieve the updated point amount
		Print the new amount
		Print the new amount
		These functions demonstrate how to initialize, update, and retrieve data from a SmartTable, as well as how to set up tests for these operations.
		These functions demonstrate how to initialize, update, and retrieve data from a SmartTable, as well as how to set up tests for these operations.
	Running Test
	Running Test
	Running test:
	Running test:
	Running test:
	<code>movement move test -f smart_table_module</code>
	<code>movement move test -f smart_table_module</code>
	movement move test -f smart_table_module
	Result:
	Result:
	Result:
	<code>Running Move unit tests
[debug] 0
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_get_amount_point
[debug] 10
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_plus_amount_point
Test result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}</code>
	<code>Running Move unit tests
[debug] 0
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_get_amount_point
[debug] 10
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_plus_amount_point
Test result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}</code>
	Running Move unit tests
[debug] 0
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_get_amount_point
[debug] 10
[ PASS    ] 0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_module::test_plus_amount_point
Test result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}
	Additional SimpleMap Functions
	Additional SimpleMap Functions
	| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
new
| None | Creates an empty SmartTable with default configurations |
SmartTable<K, V>
|
|
new_with_config
|
num_initial_buckets: u64
,
split_load_threshold: u8
,
target_bucket_size: u64
| Creates an empty SmartTable with customized configurations |
SmartTable<K, V>
|
|
destroy_empty
|
self: SmartTable<K, V>
| Destroys an empty table | None |
|
destroy
|
self: SmartTable<K, V>
| Destroys a table completely when V has
drop
| None |
|
clear
|
self: &mut SmartTable<K, V>
| Clears a table completely when T has
drop
| None |
|
add
|
self: &mut SmartTable<K, V>
,
key: K
,
value: V
| Adds a key-value pair to the table | None |
|
add_all
|
self: &mut SmartTable<K, V>
,
keys: vector<K>
,
values: vector<V>
| Adds multiple key-value pairs to the table | None |
|
unzip_entries
|
entries: &vector<Entry<K, V>>
| Unzips entries into separate key and value vectors |
(vector<K>, vector<V>)
|
|
to_simple_map
|
self: &SmartTable<K, V>
| Converts a smart table to a simple_map |
SimpleMap<K, V>
|
|
keys
|
self: &SmartTable<K, V>
| Gets all keys in a smart table |
vector<K>
|
|
keys_paginated
|
self: &SmartTable<K, V>
,
starting_bucket_index: u64
,
starting_vector_index: u64
,
num_keys_to_get: u64
| Gets keys from a smart table, paginated |
(vector<K>, Option<u64>, Option<u64>)
|
|
split_one_bucket
|
self: &mut SmartTable<K, V>
| Splits one bucket into two | None |
|
bucket_index
|
level: u8
,
num_buckets: u64
,
hash: u64
| Returns the expected bucket index for a hash |
u64
|
|
borrow
|
self: &SmartTable<K, V>
,
key: K
| Borrows an immutable reference to the value associated with the key |
&V
|
|
borrow_with_default
|
self: &SmartTable<K, V>
,
key: K
,
default: &V
| Borrows an immutable reference to the value, or returns the default if key not found |
&V
|
|
borrow_mut
|
self: &mut SmartTable<K, V>
,
key: K
| Borrows a mutable reference to the value associated with the key |
&mut V
|
|
borrow_mut_with_default
|
self: &mut SmartTable<K, V>
,
key: K
,
default: V
| Borrows a mutable reference to the value, or inserts and returns default if key not found |
&mut V
|
|
contains
|
self: &SmartTable<K, V>
,
key: K
| Checks if the table contains a key |
bool
|
|
remove
|
self: &mut SmartTable<K, V>
,
key: K
| Removes and returns the value associated with the key |
V
|
|
upsert
|
self: &mut SmartTable<K, V>
,
key: K
,
value: V
| Inserts a key-value pair or updates an existing one | None |
|
length
|
self: &SmartTable<K, V>
| Returns the number of entries in the table |
u64
|
|
load_factor
|
self: &SmartTable<K, V>
| Returns the load factor of the hashtable |
u64
|
|
update_split_load_threshold
|
self: &mut SmartTable<K, V>
,
split_load_threshold: u8
| Updates the split load threshold | None |
|
update_target_bucket_size
|
self: &mut SmartTable<K, V>
,
target_bucket_size: u64
| Updates the target bucket size | None |
|
for_each_ref
|
self: &SmartTable<K, V>
,
f: \|&K, &V\|
| Applies a function to a reference of each key-value pair | None |
|
for_each_mut
|
self: &mut SmartTable<K, V>
,
f: \|&K, &mut V\|
| Applies a function to a mutable reference of each key-value pair | None |
|
map_ref
|
self: &SmartTable<K, V1>
,
f: \|&V1\|V2
| Maps a function over the values, producing a new SmartTable |
SmartTable<K, V2>
|
|
any
|
self: &SmartTable<K, V>
,
p: \|&K, &V\|bool
| Checks if any key-value pair satisfies the predicate |
bool
|
|
borrow_kv
|
self: &Entry<K, V>
| Borrows references to the key and value of an entry |
(&K, &V)
|
|
borrow_kv_mut
|
self: &mut Entry<K, V>
| Borrows mutable references to the key and value of an entry |
(&mut K, &mut V)
|
|
num_buckets
|
self: &SmartTable<K, V>
| Returns the number of buckets in the table |
u64
|
|
borrow_buckets
|
self: &SmartTable<K, V>
| Borrows a reference to the buckets of the table |
&TableWithLength<u64, vector<Entry<K, V>>>
|
|
borrow_buckets_mut
|
self: &mut SmartTable<K, V>
| Borrows a mutable reference to the buckets of the table |
&mut TableWithLength<u64, vector<Entry<K, V>>>
|
	| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
|
	<code>new</code>
	new
	| None | Creates an empty SmartTable with default configurations |
	<code>SmartTable<K, V></code>
	SmartTable<K, V>
	|
|
	<code>new_with_config</code>
	new_with_config
	|
	<code>num_initial_buckets: u64</code>
	num_initial_buckets: u64
	,
	<code>split_load_threshold: u8</code>
	split_load_threshold: u8
	,
	<code>target_bucket_size: u64</code>
	target_bucket_size: u64
	| Creates an empty SmartTable with customized configurations |
	<code>SmartTable<K, V></code>
	SmartTable<K, V>
	|
|
	<code>destroy_empty</code>
	destroy_empty
	|
	<code>self: SmartTable<K, V></code>
	self: SmartTable<K, V>
	| Destroys an empty table | None |
|
	<code>destroy</code>
	destroy
	|
	<code>self: SmartTable<K, V></code>
	self: SmartTable<K, V>
	| Destroys a table completely when V has
	<code>drop</code>
	drop
	| None |
|
	<code>clear</code>
	clear
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	| Clears a table completely when T has
	<code>drop</code>
	drop
	| None |
|
	<code>add</code>
	add
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	,
	<code>key: K</code>
	key: K
	,
	<code>value: V</code>
	value: V
	| Adds a key-value pair to the table | None |
|
	<code>add_all</code>
	add_all
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	,
	<code>keys: vector<K></code>
	keys: vector<K>
	,
	<code>values: vector<V></code>
	values: vector<V>
	| Adds multiple key-value pairs to the table | None |
|
	<code>unzip_entries</code>
	unzip_entries
	|
	<code>entries: &vector<Entry<K, V>></code>
	entries: &vector<Entry<K, V>>
	| Unzips entries into separate key and value vectors |
	<code>(vector<K>, vector<V>)</code>
	(vector<K>, vector<V>)
	|
|
	<code>to_simple_map</code>
	to_simple_map
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	| Converts a smart table to a simple_map |
	<code>SimpleMap<K, V></code>
	SimpleMap<K, V>
	|
|
	<code>keys</code>
	keys
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	| Gets all keys in a smart table |
	<code>vector<K></code>
	vector<K>
	|
|
	<code>keys_paginated</code>
	keys_paginated
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	,
	<code>starting_bucket_index: u64</code>
	starting_bucket_index: u64
	,
	<code>starting_vector_index: u64</code>
	starting_vector_index: u64
	,
	<code>num_keys_to_get: u64</code>
	num_keys_to_get: u64
	| Gets keys from a smart table, paginated |
	<code>(vector<K>, Option<u64>, Option<u64>)</code>
	(vector<K>, Option<u64>, Option<u64>)
	|
|
	<code>split_one_bucket</code>
	split_one_bucket
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	| Splits one bucket into two | None |
|
	<code>bucket_index</code>
	bucket_index
	|
	<code>level: u8</code>
	level: u8
	,
	<code>num_buckets: u64</code>
	num_buckets: u64
	,
	<code>hash: u64</code>
	hash: u64
	| Returns the expected bucket index for a hash |
	<code>u64</code>
	u64
	|
|
	<code>borrow</code>
	borrow
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	,
	<code>key: K</code>
	key: K
	| Borrows an immutable reference to the value associated with the key |
	<code>&V</code>
	&V
	|
|
	<code>borrow_with_default</code>
	borrow_with_default
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	,
	<code>key: K</code>
	key: K
	,
	<code>default: &V</code>
	default: &V
	| Borrows an immutable reference to the value, or returns the default if key not found |
	<code>&V</code>
	&V
	|
|
	<code>borrow_mut</code>
	borrow_mut
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	,
	<code>key: K</code>
	key: K
	| Borrows a mutable reference to the value associated with the key |
	<code>&mut V</code>
	&mut V
	|
|
	<code>borrow_mut_with_default</code>
	borrow_mut_with_default
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	,
	<code>key: K</code>
	key: K
	,
	<code>default: V</code>
	default: V
	| Borrows a mutable reference to the value, or inserts and returns default if key not found |
	<code>&mut V</code>
	&mut V
	|
|
	<code>contains</code>
	contains
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	,
	<code>key: K</code>
	key: K
	| Checks if the table contains a key |
	<code>bool</code>
	bool
	|
|
	<code>remove</code>
	remove
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	,
	<code>key: K</code>
	key: K
	| Removes and returns the value associated with the key |
	<code>V</code>
	V
	|
|
	<code>upsert</code>
	upsert
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	,
	<code>key: K</code>
	key: K
	,
	<code>value: V</code>
	value: V
	| Inserts a key-value pair or updates an existing one | None |
|
	<code>length</code>
	length
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	| Returns the number of entries in the table |
	<code>u64</code>
	u64
	|
|
	<code>load_factor</code>
	load_factor
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	| Returns the load factor of the hashtable |
	<code>u64</code>
	u64
	|
|
	<code>update_split_load_threshold</code>
	update_split_load_threshold
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	,
	<code>split_load_threshold: u8</code>
	split_load_threshold: u8
	| Updates the split load threshold | None |
|
	<code>update_target_bucket_size</code>
	update_target_bucket_size
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	,
	<code>target_bucket_size: u64</code>
	target_bucket_size: u64
	| Updates the target bucket size | None |
|
	<code>for_each_ref</code>
	for_each_ref
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	,
	<code>f: \|&K, &V\|</code>
	f: \|&K, &V\|
	| Applies a function to a reference of each key-value pair | None |
|
	<code>for_each_mut</code>
	for_each_mut
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	,
	<code>f: \|&K, &mut V\|</code>
	f: \|&K, &mut V\|
	| Applies a function to a mutable reference of each key-value pair | None |
|
	<code>map_ref</code>
	map_ref
	|
	<code>self: &SmartTable<K, V1></code>
	self: &SmartTable<K, V1>
	,
	<code>f: \|&V1\|V2</code>
	f: \|&V1\|V2
	| Maps a function over the values, producing a new SmartTable |
	<code>SmartTable<K, V2></code>
	SmartTable<K, V2>
	|
|
	<code>any</code>
	any
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	,
	<code>p: \|&K, &V\|bool</code>
	p: \|&K, &V\|bool
	| Checks if any key-value pair satisfies the predicate |
	<code>bool</code>
	bool
	|
|
	<code>borrow_kv</code>
	borrow_kv
	|
	<code>self: &Entry<K, V></code>
	self: &Entry<K, V>
	| Borrows references to the key and value of an entry |
	<code>(&K, &V)</code>
	(&K, &V)
	|
|
	<code>borrow_kv_mut</code>
	borrow_kv_mut
	|
	<code>self: &mut Entry<K, V></code>
	self: &mut Entry<K, V>
	| Borrows mutable references to the key and value of an entry |
	<code>(&mut K, &mut V)</code>
	(&mut K, &mut V)
	|
|
	<code>num_buckets</code>
	num_buckets
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	| Returns the number of buckets in the table |
	<code>u64</code>
	u64
	|
|
	<code>borrow_buckets</code>
	borrow_buckets
	|
	<code>self: &SmartTable<K, V></code>
	self: &SmartTable<K, V>
	| Borrows a reference to the buckets of the table |
	<code>&TableWithLength<u64, vector<Entry<K, V>>></code>
	&TableWithLength<u64, vector<Entry<K, V>>>
	|
|
	<code>borrow_buckets_mut</code>
	borrow_buckets_mut
	|
	<code>self: &mut SmartTable<K, V></code>
	self: &mut SmartTable<K, V>
	| Borrows a mutable reference to the buckets of the table |
	<code>&mut TableWithLength<u64, vector<Entry<K, V>>></code>
	&mut TableWithLength<u64, vector<Entry<K, V>>>
	|

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/advanced-move/10-resource-account
Resource Account
Resource Account
On This Page
Movement Command Line Interface (CLI)
Smart Contract Integration
Resource accounts in Move offer a revolutionary approach to smart contract deployment and resource management. Unlike traditional object code deployment, these accounts provide enhanced control and flexibility for on-chain operations.
At its core, a resource account in Move functions as an autonomous entity, separate from user-controlled accounts. This separation allows for more robust module publishing and sophisticated access control mechanisms.
Resource accounts serve two primary functions:
Asset Isolation: They create a dedicated environment for hosting and managing specific resources within a module, ensuring better organization and security.
Autonomous Module Deployment: By establishing independent accounts for module deployment, resource accounts enhance the decentralization of smart contracts. This approach eliminates the need for private key management, with governance potentially handled through separate modules.
Setup Process
Developers can establish resource accounts through two main methods:
Movement Command Line Interface (CLI)
Streamlined commands like
movement account create-resource-account
and
movement move create-resource-account-and-publish-package
simplify the creation of resource accounts and associated package publishing.
Here are the CLI commands to run for each method:
# For create_resource_account
movement account create-resource-account --seed hello
Result
Transaction submitted: https://explorer.aptoslabs.com/txn/0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34?network=devnet
{
  "Result": {
    "resource_account": "a7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e",
    "transaction_hash": "0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34",
    "gas_used": 973,
    "gas_unit_price": 100,
    "sender": "3ebfa1047b74a82ee98b272abd6c83461007d4bc50ffe2ea363c61abe0ee89c9",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1728287140564035,
    "version": 41288052,
    "vm_status": "Executed successfully"
  }
}
Here, you will initialize a
resource_account
with the address:
0xa7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e
. It functions similarly to a regular account but lacks a
private key
. To interact with this account, you must go through its owner—the default account that created it.
Smart Contract Integration
Aptos Move provides functions such as
create_resource_account
,
create_resource_account_and_fund
, and
create_resource_account_and_publish_package
for programmatic management of resource accounts.
Each method provides distinct capabilities:
create_resource_account
: Generates an unfunded account, retaining signer access until explicitly released.
create_resource_account_and_fund
: Establishes and funds the account, maintaining signer access until voluntarily relinquished.
create_resource_account_and_publish_package
: Creates the account and immediately withdraws access, ideal for deploying self-governing and immutable contracts.
Critical Aspects
The creation of resource accounts in Aptos follows a unique protocol. It utilizes a SHA3-256 hash derived from the source address and additional seed data. This method guarantees the uniqueness of each resource account and prevents duplicate creation for a given source and seed pair.
Aptos implements protective measures for cases where an entity attempts to claim an address matching a potential resource account. If such an account is identified, ownership transfers to the resource account, provided the claimed account is transaction-free and lacks specific capabilities.
On This Page
Movement Command Line Interface (CLI)
Smart Contract Integration
On This Page
Movement Command Line Interface (CLI)
Smart Contract Integration
			On This Page
			On This Page
			Movement Command Line Interface (CLI)
Smart Contract Integration
			Movement Command Line Interface (CLI)
Smart Contract Integration
			Movement Command Line Interface (CLI)
Smart Contract Integration
			Movement Command Line Interface (CLI)
			Movement Command Line Interface (CLI)
			Movement Command Line Interface (CLI)
			Movement Command Line Interface (CLI)
			Smart Contract Integration
			Smart Contract Integration
			Smart Contract Integration
			Smart Contract Integration
			Resource accounts in Move offer a revolutionary approach to smart contract deployment and resource management. Unlike traditional object code deployment, these accounts provide enhanced control and flexibility for on-chain operations.
At its core, a resource account in Move functions as an autonomous entity, separate from user-controlled accounts. This separation allows for more robust module publishing and sophisticated access control mechanisms.
Resource accounts serve two primary functions:
Asset Isolation: They create a dedicated environment for hosting and managing specific resources within a module, ensuring better organization and security.
Autonomous Module Deployment: By establishing independent accounts for module deployment, resource accounts enhance the decentralization of smart contracts. This approach eliminates the need for private key management, with governance potentially handled through separate modules.
Setup Process
Developers can establish resource accounts through two main methods:
Movement Command Line Interface (CLI)
Streamlined commands like
movement account create-resource-account
and
movement move create-resource-account-and-publish-package
simplify the creation of resource accounts and associated package publishing.
Here are the CLI commands to run for each method:
# For create_resource_account
movement account create-resource-account --seed hello
Result
Transaction submitted: https://explorer.aptoslabs.com/txn/0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34?network=devnet
{
  "Result": {
    "resource_account": "a7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e",
    "transaction_hash": "0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34",
    "gas_used": 973,
    "gas_unit_price": 100,
    "sender": "3ebfa1047b74a82ee98b272abd6c83461007d4bc50ffe2ea363c61abe0ee89c9",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1728287140564035,
    "version": 41288052,
    "vm_status": "Executed successfully"
  }
}
Here, you will initialize a
resource_account
with the address:
0xa7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e
. It functions similarly to a regular account but lacks a
private key
. To interact with this account, you must go through its owner—the default account that created it.
Smart Contract Integration
Aptos Move provides functions such as
create_resource_account
,
create_resource_account_and_fund
, and
create_resource_account_and_publish_package
for programmatic management of resource accounts.
Each method provides distinct capabilities:
create_resource_account
: Generates an unfunded account, retaining signer access until explicitly released.
create_resource_account_and_fund
: Establishes and funds the account, maintaining signer access until voluntarily relinquished.
create_resource_account_and_publish_package
: Creates the account and immediately withdraws access, ideal for deploying self-governing and immutable contracts.
Critical Aspects
The creation of resource accounts in Aptos follows a unique protocol. It utilizes a SHA3-256 hash derived from the source address and additional seed data. This method guarantees the uniqueness of each resource account and prevents duplicate creation for a given source and seed pair.
Aptos implements protective measures for cases where an entity attempts to claim an address matching a potential resource account. If such an account is identified, ownership transfers to the resource account, provided the claimed account is transaction-free and lacks specific capabilities.
			Resource accounts in Move offer a revolutionary approach to smart contract deployment and resource management. Unlike traditional object code deployment, these accounts provide enhanced control and flexibility for on-chain operations.
At its core, a resource account in Move functions as an autonomous entity, separate from user-controlled accounts. This separation allows for more robust module publishing and sophisticated access control mechanisms.
Resource accounts serve two primary functions:
Asset Isolation: They create a dedicated environment for hosting and managing specific resources within a module, ensuring better organization and security.
Autonomous Module Deployment: By establishing independent accounts for module deployment, resource accounts enhance the decentralization of smart contracts. This approach eliminates the need for private key management, with governance potentially handled through separate modules.
Setup Process
Developers can establish resource accounts through two main methods:
Movement Command Line Interface (CLI)
Streamlined commands like
movement account create-resource-account
and
movement move create-resource-account-and-publish-package
simplify the creation of resource accounts and associated package publishing.
Here are the CLI commands to run for each method:
# For create_resource_account
movement account create-resource-account --seed hello
Result
Transaction submitted: https://explorer.aptoslabs.com/txn/0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34?network=devnet
{
  "Result": {
    "resource_account": "a7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e",
    "transaction_hash": "0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34",
    "gas_used": 973,
    "gas_unit_price": 100,
    "sender": "3ebfa1047b74a82ee98b272abd6c83461007d4bc50ffe2ea363c61abe0ee89c9",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1728287140564035,
    "version": 41288052,
    "vm_status": "Executed successfully"
  }
}
Here, you will initialize a
resource_account
with the address:
0xa7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e
. It functions similarly to a regular account but lacks a
private key
. To interact with this account, you must go through its owner—the default account that created it.
Smart Contract Integration
Aptos Move provides functions such as
create_resource_account
,
create_resource_account_and_fund
, and
create_resource_account_and_publish_package
for programmatic management of resource accounts.
Each method provides distinct capabilities:
create_resource_account
: Generates an unfunded account, retaining signer access until explicitly released.
create_resource_account_and_fund
: Establishes and funds the account, maintaining signer access until voluntarily relinquished.
create_resource_account_and_publish_package
: Creates the account and immediately withdraws access, ideal for deploying self-governing and immutable contracts.
Critical Aspects
The creation of resource accounts in Aptos follows a unique protocol. It utilizes a SHA3-256 hash derived from the source address and additional seed data. This method guarantees the uniqueness of each resource account and prevents duplicate creation for a given source and seed pair.
Aptos implements protective measures for cases where an entity attempts to claim an address matching a potential resource account. If such an account is identified, ownership transfers to the resource account, provided the claimed account is transaction-free and lacks specific capabilities.
			Resource accounts in Move offer a revolutionary approach to smart contract deployment and resource management. Unlike traditional object code deployment, these accounts provide enhanced control and flexibility for on-chain operations.
At its core, a resource account in Move functions as an autonomous entity, separate from user-controlled accounts. This separation allows for more robust module publishing and sophisticated access control mechanisms.
Resource accounts serve two primary functions:
Asset Isolation: They create a dedicated environment for hosting and managing specific resources within a module, ensuring better organization and security.
Autonomous Module Deployment: By establishing independent accounts for module deployment, resource accounts enhance the decentralization of smart contracts. This approach eliminates the need for private key management, with governance potentially handled through separate modules.
Setup Process
Developers can establish resource accounts through two main methods:
Movement Command Line Interface (CLI)
Streamlined commands like
movement account create-resource-account
and
movement move create-resource-account-and-publish-package
simplify the creation of resource accounts and associated package publishing.
Here are the CLI commands to run for each method:
# For create_resource_account
movement account create-resource-account --seed hello
Result
Transaction submitted: https://explorer.aptoslabs.com/txn/0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34?network=devnet
{
  "Result": {
    "resource_account": "a7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e",
    "transaction_hash": "0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34",
    "gas_used": 973,
    "gas_unit_price": 100,
    "sender": "3ebfa1047b74a82ee98b272abd6c83461007d4bc50ffe2ea363c61abe0ee89c9",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1728287140564035,
    "version": 41288052,
    "vm_status": "Executed successfully"
  }
}
Here, you will initialize a
resource_account
with the address:
0xa7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e
. It functions similarly to a regular account but lacks a
private key
. To interact with this account, you must go through its owner—the default account that created it.
Smart Contract Integration
Aptos Move provides functions such as
create_resource_account
,
create_resource_account_and_fund
, and
create_resource_account_and_publish_package
for programmatic management of resource accounts.
Each method provides distinct capabilities:
create_resource_account
: Generates an unfunded account, retaining signer access until explicitly released.
create_resource_account_and_fund
: Establishes and funds the account, maintaining signer access until voluntarily relinquished.
create_resource_account_and_publish_package
: Creates the account and immediately withdraws access, ideal for deploying self-governing and immutable contracts.
Critical Aspects
The creation of resource accounts in Aptos follows a unique protocol. It utilizes a SHA3-256 hash derived from the source address and additional seed data. This method guarantees the uniqueness of each resource account and prevents duplicate creation for a given source and seed pair.
Aptos implements protective measures for cases where an entity attempts to claim an address matching a potential resource account. If such an account is identified, ownership transfers to the resource account, provided the claimed account is transaction-free and lacks specific capabilities.
			Resource accounts in Move offer a revolutionary approach to smart contract deployment and resource management. Unlike traditional object code deployment, these accounts provide enhanced control and flexibility for on-chain operations.
			Resource accounts in Move offer a revolutionary approach to smart contract deployment and resource management. Unlike traditional object code deployment, these accounts provide enhanced control and flexibility for on-chain operations.
			At its core, a resource account in Move functions as an autonomous entity, separate from user-controlled accounts. This separation allows for more robust module publishing and sophisticated access control mechanisms.
			At its core, a resource account in Move functions as an autonomous entity, separate from user-controlled accounts. This separation allows for more robust module publishing and sophisticated access control mechanisms.
			Resource accounts serve two primary functions:
			Resource accounts serve two primary functions:
			Asset Isolation: They create a dedicated environment for hosting and managing specific resources within a module, ensuring better organization and security.
Autonomous Module Deployment: By establishing independent accounts for module deployment, resource accounts enhance the decentralization of smart contracts. This approach eliminates the need for private key management, with governance potentially handled through separate modules.
			Asset Isolation: They create a dedicated environment for hosting and managing specific resources within a module, ensuring better organization and security.
			Asset Isolation: They create a dedicated environment for hosting and managing specific resources within a module, ensuring better organization and security.
			Autonomous Module Deployment: By establishing independent accounts for module deployment, resource accounts enhance the decentralization of smart contracts. This approach eliminates the need for private key management, with governance potentially handled through separate modules.
			Autonomous Module Deployment: By establishing independent accounts for module deployment, resource accounts enhance the decentralization of smart contracts. This approach eliminates the need for private key management, with governance potentially handled through separate modules.
	Setup Process
	Setup Process
	Setup Process
	Developers can establish resource accounts through two main methods:
	Developers can establish resource accounts through two main methods:
		Movement Command Line Interface (CLI)
		Movement Command Line Interface (CLI)
		Streamlined commands like
movement account create-resource-account
and
movement move create-resource-account-and-publish-package
simplify the creation of resource accounts and associated package publishing.
		Streamlined commands like
		<code>movement account create-resource-account</code>
		movement account create-resource-account
		and
		<code>movement move create-resource-account-and-publish-package</code>
		movement move create-resource-account-and-publish-package
		simplify the creation of resource accounts and associated package publishing.
		Here are the CLI commands to run for each method:
		Here are the CLI commands to run for each method:
		<code># For create_resource_account
movement account create-resource-account --seed hello</code>
		<code># For create_resource_account
movement account create-resource-account --seed hello</code>
		# For create_resource_account
movement account create-resource-account --seed hello
		Result
		Result
		Result
		<code>Transaction submitted: https://explorer.aptoslabs.com/txn/0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34?network=devnet
{
  "Result": {
    "resource_account": "a7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e",
    "transaction_hash": "0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34",
    "gas_used": 973,
    "gas_unit_price": 100,
    "sender": "3ebfa1047b74a82ee98b272abd6c83461007d4bc50ffe2ea363c61abe0ee89c9",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1728287140564035,
    "version": 41288052,
    "vm_status": "Executed successfully"
  }
}</code>
		<code>Transaction submitted: https://explorer.aptoslabs.com/txn/0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34?network=devnet
{
  "Result": {
    "resource_account": "a7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e",
    "transaction_hash": "0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34",
    "gas_used": 973,
    "gas_unit_price": 100,
    "sender": "3ebfa1047b74a82ee98b272abd6c83461007d4bc50ffe2ea363c61abe0ee89c9",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1728287140564035,
    "version": 41288052,
    "vm_status": "Executed successfully"
  }
}</code>
		Transaction submitted: https://explorer.aptoslabs.com/txn/0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34?network=devnet
{
  "Result": {
    "resource_account": "a7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e",
    "transaction_hash": "0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34",
    "gas_used": 973,
    "gas_unit_price": 100,
    "sender": "3ebfa1047b74a82ee98b272abd6c83461007d4bc50ffe2ea363c61abe0ee89c9",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1728287140564035,
    "version": 41288052,
    "vm_status": "Executed successfully"
  }
}
		Here, you will initialize a
resource_account
with the address:
0xa7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e
. It functions similarly to a regular account but lacks a
private key
. To interact with this account, you must go through its owner—the default account that created it.
		Here, you will initialize a
		<code>resource_account</code>
		resource_account
		with the address:
		<code>0xa7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e</code>
		0xa7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e
		. It functions similarly to a regular account but lacks a
		<code>private key</code>
		private key
		. To interact with this account, you must go through its owner—the default account that created it.
		Smart Contract Integration
		Smart Contract Integration
		Aptos Move provides functions such as
create_resource_account
,
create_resource_account_and_fund
, and
create_resource_account_and_publish_package
for programmatic management of resource accounts.
		Aptos Move provides functions such as
		<code>create_resource_account</code>
		create_resource_account
		,
		<code>create_resource_account_and_fund</code>
		create_resource_account_and_fund
		, and
		<code>create_resource_account_and_publish_package</code>
		create_resource_account_and_publish_package
		for programmatic management of resource accounts.
		Each method provides distinct capabilities:
		Each method provides distinct capabilities:
		create_resource_account
: Generates an unfunded account, retaining signer access until explicitly released.
create_resource_account_and_fund
: Establishes and funds the account, maintaining signer access until voluntarily relinquished.
create_resource_account_and_publish_package
: Creates the account and immediately withdraws access, ideal for deploying self-governing and immutable contracts.
		create_resource_account
: Generates an unfunded account, retaining signer access until explicitly released.
		<code>create_resource_account</code>
		create_resource_account
		: Generates an unfunded account, retaining signer access until explicitly released.
		create_resource_account_and_fund
: Establishes and funds the account, maintaining signer access until voluntarily relinquished.
		<code>create_resource_account_and_fund</code>
		create_resource_account_and_fund
		: Establishes and funds the account, maintaining signer access until voluntarily relinquished.
		create_resource_account_and_publish_package
: Creates the account and immediately withdraws access, ideal for deploying self-governing and immutable contracts.
		<code>create_resource_account_and_publish_package</code>
		create_resource_account_and_publish_package
		: Creates the account and immediately withdraws access, ideal for deploying self-governing and immutable contracts.
	Critical Aspects
	Critical Aspects
	Critical Aspects
	The creation of resource accounts in Aptos follows a unique protocol. It utilizes a SHA3-256 hash derived from the source address and additional seed data. This method guarantees the uniqueness of each resource account and prevents duplicate creation for a given source and seed pair.
	The creation of resource accounts in Aptos follows a unique protocol. It utilizes a SHA3-256 hash derived from the source address and additional seed data. This method guarantees the uniqueness of each resource account and prevents duplicate creation for a given source and seed pair.
	Aptos implements protective measures for cases where an entity attempts to claim an address matching a potential resource account. If such an account is identified, ownership transfers to the resource account, provided the claimed account is transaction-free and lacks specific capabilities.
	Aptos implements protective measures for cases where an entity attempts to claim an address matching a potential resource account. If such an account is identified, ownership transfers to the resource account, provided the claimed account is transaction-free and lacks specific capabilities.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/nft
NFT
NFT
Explore the world of digital assets by creating and managing NFTs. Learn how to mint NFTs, modify token metadata, manage collections, and enforce royalty rules using the Move language.
Explore the world of digital assets by creating and managing NFTs. Learn how to mint NFTs, modify token metadata, manage collections, and enforce royalty rules using the Move language.
Start
Start
Insight into Non Fungible Tokens
Start
Collection
Start
Token Standard & Mint your NFT
Start
Token Metadata & Modifying Data
Start
Creating NFTs using Resource Account
Start
Managed Collection
Start
Royalty & Property Map
Start
Permission to mint NFTs
Start
Aptos Collection & Token V2
Start
Insight into Non Fungible Tokens
Start
Insight into Non Fungible Tokens
Start
Insight into Non Fungible Tokens
Insight into Non Fungible Tokens
Start
Start
Collection
Start
Collection
Start
Collection
Collection
Start
Start
Token Standard & Mint your NFT
Start
Token Standard & Mint your NFT
Start
Token Standard & Mint your NFT
Token Standard & Mint your NFT
Start
Start
Token Metadata & Modifying Data
Start
Token Metadata & Modifying Data
Start
Token Metadata & Modifying Data
Token Metadata & Modifying Data
Start
Start
Creating NFTs using Resource Account
Start
Creating NFTs using Resource Account
Start
Creating NFTs using Resource Account
Creating NFTs using Resource Account
Start
Start
Managed Collection
Start
Managed Collection
Start
Managed Collection
Managed Collection
Start
Start
Royalty & Property Map
Start
Royalty & Property Map
Start
Royalty & Property Map
Royalty & Property Map
Start
Start
Permission to mint NFTs
Start
Permission to mint NFTs
Start
Permission to mint NFTs
Permission to mint NFTs
Start
Start
Aptos Collection & Token V2
Start
Aptos Collection & Token V2
Start
Aptos Collection & Token V2
Aptos Collection & Token V2
Start
Start

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/nft/01-insight-into-non-fungible-tokens
Insight into Non
Insight into Non
On This Page
Understanding NFTs: Digital Assets on the Blockchain
Key Features of NFTs
The NFT Creation Process
The Value Proposition of NFTs
Challenges and Considerations
The Future of NFTs
Understanding NFTs: Digital Assets on the Blockchain
NFTs, or Non-Fungible Tokens, represent a revolutionary concept in the digital world. These unique digital assets exist on blockchain technology, offering a new way to own and trade digital content.
Key Features of NFTs
Uniqueness: Each NFT is one-of-a-kind, distinguishable from all others.
Digital Ownership: NFTs provide verifiable ownership of digital assets.
Blockchain-based: They leverage blockchain technology for security and transparency.
Diverse Applications: NFTs can represent art, collectibles, virtual real estate, and more.
The NFT Creation Process
NFT creation, often called "minting," involves several steps:
Asset Creation: Artists or creators develop unique digital content.
Blockchain Integration: The digital asset is linked to a blockchain, typically Movement.
Smart Contract Development: Creators establish rules for the NFT's behavior and attributes.
Minting: The NFT is officially created on the blockchain, ready for sale or transfer.
The Value Proposition of NFTs
NFTs offer several advantages in the digital economy:
Authenticity: Blockchain verification ensures the genuineness of each asset.
Scarcity: Limited editions or unique pieces can drive value.
Royalties: Smart contracts can ensure creators receive ongoing royalties from secondary sales.
Community Building: NFT projects often foster engaged communities around shared interests.
Challenges and Considerations
While NFTs present exciting opportunities, they also face challenges:
Environmental Concerns: Some blockchain networks consume significant energy.
Market Volatility: NFT valuations can be highly speculative and unstable.
Intellectual Property Issues: Questions around copyright and ownership rights persist.
Technological Barriers: Understanding and using NFTs can be complex for newcomers.
The Future of NFTs
As the technology evolves, NFTs are expanding beyond digital art into areas like gaming, virtual real estate, and identity verification. Their potential to revolutionize digital ownership and creative economies continues to grow, making them a fascinating area to watch in the coming years.
On This Page
Understanding NFTs: Digital Assets on the Blockchain
Key Features of NFTs
The NFT Creation Process
The Value Proposition of NFTs
Challenges and Considerations
The Future of NFTs
On This Page
Understanding NFTs: Digital Assets on the Blockchain
Key Features of NFTs
The NFT Creation Process
The Value Proposition of NFTs
Challenges and Considerations
The Future of NFTs
			On This Page
			On This Page
			Understanding NFTs: Digital Assets on the Blockchain
Key Features of NFTs
The NFT Creation Process
The Value Proposition of NFTs
Challenges and Considerations
The Future of NFTs
			Understanding NFTs: Digital Assets on the Blockchain
Key Features of NFTs
The NFT Creation Process
The Value Proposition of NFTs
Challenges and Considerations
The Future of NFTs
			Understanding NFTs: Digital Assets on the Blockchain
			Understanding NFTs: Digital Assets on the Blockchain
			Understanding NFTs: Digital Assets on the Blockchain
			Key Features of NFTs
The NFT Creation Process
The Value Proposition of NFTs
Challenges and Considerations
The Future of NFTs
			Key Features of NFTs
			Key Features of NFTs
			Key Features of NFTs
			Key Features of NFTs
			The NFT Creation Process
			The NFT Creation Process
			The NFT Creation Process
			The NFT Creation Process
			The Value Proposition of NFTs
			The Value Proposition of NFTs
			The Value Proposition of NFTs
			The Value Proposition of NFTs
			Challenges and Considerations
			Challenges and Considerations
			Challenges and Considerations
			Challenges and Considerations
			The Future of NFTs
			The Future of NFTs
			The Future of NFTs
			The Future of NFTs
			Understanding NFTs: Digital Assets on the Blockchain
NFTs, or Non-Fungible Tokens, represent a revolutionary concept in the digital world. These unique digital assets exist on blockchain technology, offering a new way to own and trade digital content.
Key Features of NFTs
Uniqueness: Each NFT is one-of-a-kind, distinguishable from all others.
Digital Ownership: NFTs provide verifiable ownership of digital assets.
Blockchain-based: They leverage blockchain technology for security and transparency.
Diverse Applications: NFTs can represent art, collectibles, virtual real estate, and more.
The NFT Creation Process
NFT creation, often called "minting," involves several steps:
Asset Creation: Artists or creators develop unique digital content.
Blockchain Integration: The digital asset is linked to a blockchain, typically Movement.
Smart Contract Development: Creators establish rules for the NFT's behavior and attributes.
Minting: The NFT is officially created on the blockchain, ready for sale or transfer.
The Value Proposition of NFTs
NFTs offer several advantages in the digital economy:
Authenticity: Blockchain verification ensures the genuineness of each asset.
Scarcity: Limited editions or unique pieces can drive value.
Royalties: Smart contracts can ensure creators receive ongoing royalties from secondary sales.
Community Building: NFT projects often foster engaged communities around shared interests.
Challenges and Considerations
While NFTs present exciting opportunities, they also face challenges:
Environmental Concerns: Some blockchain networks consume significant energy.
Market Volatility: NFT valuations can be highly speculative and unstable.
Intellectual Property Issues: Questions around copyright and ownership rights persist.
Technological Barriers: Understanding and using NFTs can be complex for newcomers.
The Future of NFTs
As the technology evolves, NFTs are expanding beyond digital art into areas like gaming, virtual real estate, and identity verification. Their potential to revolutionize digital ownership and creative economies continues to grow, making them a fascinating area to watch in the coming years.
			Understanding NFTs: Digital Assets on the Blockchain
NFTs, or Non-Fungible Tokens, represent a revolutionary concept in the digital world. These unique digital assets exist on blockchain technology, offering a new way to own and trade digital content.
Key Features of NFTs
Uniqueness: Each NFT is one-of-a-kind, distinguishable from all others.
Digital Ownership: NFTs provide verifiable ownership of digital assets.
Blockchain-based: They leverage blockchain technology for security and transparency.
Diverse Applications: NFTs can represent art, collectibles, virtual real estate, and more.
The NFT Creation Process
NFT creation, often called "minting," involves several steps:
Asset Creation: Artists or creators develop unique digital content.
Blockchain Integration: The digital asset is linked to a blockchain, typically Movement.
Smart Contract Development: Creators establish rules for the NFT's behavior and attributes.
Minting: The NFT is officially created on the blockchain, ready for sale or transfer.
The Value Proposition of NFTs
NFTs offer several advantages in the digital economy:
Authenticity: Blockchain verification ensures the genuineness of each asset.
Scarcity: Limited editions or unique pieces can drive value.
Royalties: Smart contracts can ensure creators receive ongoing royalties from secondary sales.
Community Building: NFT projects often foster engaged communities around shared interests.
Challenges and Considerations
While NFTs present exciting opportunities, they also face challenges:
Environmental Concerns: Some blockchain networks consume significant energy.
Market Volatility: NFT valuations can be highly speculative and unstable.
Intellectual Property Issues: Questions around copyright and ownership rights persist.
Technological Barriers: Understanding and using NFTs can be complex for newcomers.
The Future of NFTs
As the technology evolves, NFTs are expanding beyond digital art into areas like gaming, virtual real estate, and identity verification. Their potential to revolutionize digital ownership and creative economies continues to grow, making them a fascinating area to watch in the coming years.
			Understanding NFTs: Digital Assets on the Blockchain
NFTs, or Non-Fungible Tokens, represent a revolutionary concept in the digital world. These unique digital assets exist on blockchain technology, offering a new way to own and trade digital content.
Key Features of NFTs
Uniqueness: Each NFT is one-of-a-kind, distinguishable from all others.
Digital Ownership: NFTs provide verifiable ownership of digital assets.
Blockchain-based: They leverage blockchain technology for security and transparency.
Diverse Applications: NFTs can represent art, collectibles, virtual real estate, and more.
The NFT Creation Process
NFT creation, often called "minting," involves several steps:
Asset Creation: Artists or creators develop unique digital content.
Blockchain Integration: The digital asset is linked to a blockchain, typically Movement.
Smart Contract Development: Creators establish rules for the NFT's behavior and attributes.
Minting: The NFT is officially created on the blockchain, ready for sale or transfer.
The Value Proposition of NFTs
NFTs offer several advantages in the digital economy:
Authenticity: Blockchain verification ensures the genuineness of each asset.
Scarcity: Limited editions or unique pieces can drive value.
Royalties: Smart contracts can ensure creators receive ongoing royalties from secondary sales.
Community Building: NFT projects often foster engaged communities around shared interests.
Challenges and Considerations
While NFTs present exciting opportunities, they also face challenges:
Environmental Concerns: Some blockchain networks consume significant energy.
Market Volatility: NFT valuations can be highly speculative and unstable.
Intellectual Property Issues: Questions around copyright and ownership rights persist.
Technological Barriers: Understanding and using NFTs can be complex for newcomers.
The Future of NFTs
As the technology evolves, NFTs are expanding beyond digital art into areas like gaming, virtual real estate, and identity verification. Their potential to revolutionize digital ownership and creative economies continues to grow, making them a fascinating area to watch in the coming years.
Understanding NFTs: Digital Assets on the Blockchain
Understanding NFTs: Digital Assets on the Blockchain
NFTs, or Non-Fungible Tokens, represent a revolutionary concept in the digital world. These unique digital assets exist on blockchain technology, offering a new way to own and trade digital content.
NFTs, or Non-Fungible Tokens, represent a revolutionary concept in the digital world. These unique digital assets exist on blockchain technology, offering a new way to own and trade digital content.
NFTs, or Non-Fungible Tokens, represent a revolutionary concept in the digital world. These unique digital assets exist on blockchain technology, offering a new way to own and trade digital content.
	Key Features of NFTs
	Key Features of NFTs
	Uniqueness: Each NFT is one-of-a-kind, distinguishable from all others.
Digital Ownership: NFTs provide verifiable ownership of digital assets.
Blockchain-based: They leverage blockchain technology for security and transparency.
Diverse Applications: NFTs can represent art, collectibles, virtual real estate, and more.
	Uniqueness: Each NFT is one-of-a-kind, distinguishable from all others.
	Uniqueness: Each NFT is one-of-a-kind, distinguishable from all others.
	Digital Ownership: NFTs provide verifiable ownership of digital assets.
	Digital Ownership: NFTs provide verifiable ownership of digital assets.
	Blockchain-based: They leverage blockchain technology for security and transparency.
	Blockchain-based: They leverage blockchain technology for security and transparency.
	Diverse Applications: NFTs can represent art, collectibles, virtual real estate, and more.
	Diverse Applications: NFTs can represent art, collectibles, virtual real estate, and more.
	The NFT Creation Process
	The NFT Creation Process
	NFT creation, often called "minting," involves several steps:
	NFT creation, often called "minting," involves several steps:
	Asset Creation: Artists or creators develop unique digital content.
Blockchain Integration: The digital asset is linked to a blockchain, typically Movement.
Smart Contract Development: Creators establish rules for the NFT's behavior and attributes.
Minting: The NFT is officially created on the blockchain, ready for sale or transfer.
	Asset Creation: Artists or creators develop unique digital content.
	Asset Creation: Artists or creators develop unique digital content.
	Blockchain Integration: The digital asset is linked to a blockchain, typically Movement.
	Blockchain Integration: The digital asset is linked to a blockchain, typically Movement.
	Smart Contract Development: Creators establish rules for the NFT's behavior and attributes.
	Smart Contract Development: Creators establish rules for the NFT's behavior and attributes.
	Minting: The NFT is officially created on the blockchain, ready for sale or transfer.
	Minting: The NFT is officially created on the blockchain, ready for sale or transfer.
	The Value Proposition of NFTs
	The Value Proposition of NFTs
	NFTs offer several advantages in the digital economy:
	NFTs offer several advantages in the digital economy:
	Authenticity: Blockchain verification ensures the genuineness of each asset.
Scarcity: Limited editions or unique pieces can drive value.
Royalties: Smart contracts can ensure creators receive ongoing royalties from secondary sales.
Community Building: NFT projects often foster engaged communities around shared interests.
	Authenticity: Blockchain verification ensures the genuineness of each asset.
	Authenticity: Blockchain verification ensures the genuineness of each asset.
	Scarcity: Limited editions or unique pieces can drive value.
	Scarcity: Limited editions or unique pieces can drive value.
	Royalties: Smart contracts can ensure creators receive ongoing royalties from secondary sales.
	Royalties: Smart contracts can ensure creators receive ongoing royalties from secondary sales.
	Community Building: NFT projects often foster engaged communities around shared interests.
	Community Building: NFT projects often foster engaged communities around shared interests.
	Challenges and Considerations
	Challenges and Considerations
	While NFTs present exciting opportunities, they also face challenges:
	While NFTs present exciting opportunities, they also face challenges:
	Environmental Concerns: Some blockchain networks consume significant energy.
Market Volatility: NFT valuations can be highly speculative and unstable.
Intellectual Property Issues: Questions around copyright and ownership rights persist.
Technological Barriers: Understanding and using NFTs can be complex for newcomers.
	Environmental Concerns: Some blockchain networks consume significant energy.
	Environmental Concerns: Some blockchain networks consume significant energy.
	Market Volatility: NFT valuations can be highly speculative and unstable.
	Market Volatility: NFT valuations can be highly speculative and unstable.
	Intellectual Property Issues: Questions around copyright and ownership rights persist.
	Intellectual Property Issues: Questions around copyright and ownership rights persist.
	Technological Barriers: Understanding and using NFTs can be complex for newcomers.
	Technological Barriers: Understanding and using NFTs can be complex for newcomers.
	The Future of NFTs
	The Future of NFTs
	As the technology evolves, NFTs are expanding beyond digital art into areas like gaming, virtual real estate, and identity verification. Their potential to revolutionize digital ownership and creative economies continues to grow, making them a fascinating area to watch in the coming years.
	As the technology evolves, NFTs are expanding beyond digital art into areas like gaming, virtual real estate, and identity verification. Their potential to revolutionize digital ownership and creative economies continues to grow, making them a fascinating area to watch in the coming years.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/nft/02-collection
Collection
Collection
On This Page
Digital Assets Demystified: Revolutionary Approach to NFTs
Why Objects Are Useful
Initializing an object through the collection library
Digital Assets Demystified: Revolutionary Approach to NFTs
The Aptos framework provides a new approach to Digital Assets, revolutionizing the creation and management of collections and Non-Fungible Tokens.
By leveraging the power of Objects that we've explored in the previous section (Here), we can create objects containing distinct components of an NFT collection. This change compared to traditional models enhances the system's flexibility and allows for more adaptable control of components.
The object-oriented framework in Aptos brings several advantages:
High flexibility: Developers can easily customize NFTs for specific use cases.
Improved discoverability: The unique address of each object simplifies asset tracking and interaction.
Scalability: The system efficiently handles complex NFT structures.
For those unfamiliar with Aptos' object model, our detailed Object modules provide an excellent introduction to this groundbreaking approach in blockchain technology.
Collection
- A set of NFTs with a name and a bit of context for the group.
#[resource_group_member(#[group = 0x1::object::ObjectGroup])]
struct Collection has key {
    creator: address,
    description: String,
    name: String,
    uri: String,
		mutation_events: event::EventHandle<collection::MutationEvent>
}
To create a Collection with the Aptos framework, we have several different methods. Here are some predefined functions to initialize a collection through
aptos_token_objects
.
To use this library, you need to
import
it into the
Move.toml
file.
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
Complete
Move.toml
file contents.
[package]
name = "developer_portal"
version = "1.0.0"
authors = ["Movement Foundation"]
license = "MIT"
[addresses]
movement = "0x1"
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
[dev-dependencies]
Why Objects Are Useful
In reality, a user (account) can own one or multiple different collections. Using Objects to store Collections separately will help manage them more effectively and efficiently.
Furthermore, after creating Tokens, we know that these tokens may not necessarily belong to the collection owner but can be owned by anyone. With the use of objects, transferring, buying, selling, and managing these tokens will be easier and more flexible than ever before.
Initializing an object through the collection library
module movement::nft_factory {
    use aptos_token_objects::collection;
    use std::string::utf8;
    use std::option;
    fun init_module(creator: &signer, max_supply: u64) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(b"My Collection Description"),
            max_supply,
            utf8(b"My Collection"),
            royalty,
            utf8(b"https://mycollection.com"),
        );
    }
}
After initializing the module, we'll attempt to create a collection by
publish
ing this module through the CLI:
aptos move publish
After completing this process, check the transaction details on the explorer:
Through the
create_fixed_collection
function, we've initialized an
object
owned by the creator who initiated and possesses the object. We've also generated an
addr
of
0xa71c541d8f6022e60423d84a6cd5c0c76f898586933204f3521ab5f8f89bae86
. This address represents both the object's location and the
address owner
of the Collection.
The second resource initialized is a Collection that we defined in the Function.
On This Page
Digital Assets Demystified: Revolutionary Approach to NFTs
Why Objects Are Useful
Initializing an object through the collection library
On This Page
Digital Assets Demystified: Revolutionary Approach to NFTs
Why Objects Are Useful
Initializing an object through the collection library
			On This Page
			On This Page
			Digital Assets Demystified: Revolutionary Approach to NFTs
Why Objects Are Useful
Initializing an object through the collection library
			Digital Assets Demystified: Revolutionary Approach to NFTs
			Digital Assets Demystified: Revolutionary Approach to NFTs
			Digital Assets Demystified: Revolutionary Approach to NFTs
			Digital Assets Demystified: Revolutionary Approach to NFTs
			Why Objects Are Useful
Initializing an object through the collection library
			Why Objects Are Useful
			Why Objects Are Useful
			Why Objects Are Useful
			Initializing an object through the collection library
			Initializing an object through the collection library
			Initializing an object through the collection library
			Initializing an object through the collection library
			Initializing an object through the collection library
			Digital Assets Demystified: Revolutionary Approach to NFTs
The Aptos framework provides a new approach to Digital Assets, revolutionizing the creation and management of collections and Non-Fungible Tokens.
By leveraging the power of Objects that we've explored in the previous section (Here), we can create objects containing distinct components of an NFT collection. This change compared to traditional models enhances the system's flexibility and allows for more adaptable control of components.
The object-oriented framework in Aptos brings several advantages:
High flexibility: Developers can easily customize NFTs for specific use cases.
Improved discoverability: The unique address of each object simplifies asset tracking and interaction.
Scalability: The system efficiently handles complex NFT structures.
For those unfamiliar with Aptos' object model, our detailed Object modules provide an excellent introduction to this groundbreaking approach in blockchain technology.
Collection
- A set of NFTs with a name and a bit of context for the group.
#[resource_group_member(#[group = 0x1::object::ObjectGroup])]
struct Collection has key {
    creator: address,
    description: String,
    name: String,
    uri: String,
		mutation_events: event::EventHandle<collection::MutationEvent>
}
To create a Collection with the Aptos framework, we have several different methods. Here are some predefined functions to initialize a collection through
aptos_token_objects
.
To use this library, you need to
import
it into the
Move.toml
file.
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
Complete
Move.toml
file contents.
[package]
name = "developer_portal"
version = "1.0.0"
authors = ["Movement Foundation"]
license = "MIT"
[addresses]
movement = "0x1"
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
[dev-dependencies]
Why Objects Are Useful
In reality, a user (account) can own one or multiple different collections. Using Objects to store Collections separately will help manage them more effectively and efficiently.
Furthermore, after creating Tokens, we know that these tokens may not necessarily belong to the collection owner but can be owned by anyone. With the use of objects, transferring, buying, selling, and managing these tokens will be easier and more flexible than ever before.
Initializing an object through the collection library
module movement::nft_factory {
    use aptos_token_objects::collection;
    use std::string::utf8;
    use std::option;
    fun init_module(creator: &signer, max_supply: u64) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(b"My Collection Description"),
            max_supply,
            utf8(b"My Collection"),
            royalty,
            utf8(b"https://mycollection.com"),
        );
    }
}
After initializing the module, we'll attempt to create a collection by
publish
ing this module through the CLI:
aptos move publish
After completing this process, check the transaction details on the explorer:
Through the
create_fixed_collection
function, we've initialized an
object
owned by the creator who initiated and possesses the object. We've also generated an
addr
of
0xa71c541d8f6022e60423d84a6cd5c0c76f898586933204f3521ab5f8f89bae86
. This address represents both the object's location and the
address owner
of the Collection.
The second resource initialized is a Collection that we defined in the Function.
			Digital Assets Demystified: Revolutionary Approach to NFTs
The Aptos framework provides a new approach to Digital Assets, revolutionizing the creation and management of collections and Non-Fungible Tokens.
By leveraging the power of Objects that we've explored in the previous section (Here), we can create objects containing distinct components of an NFT collection. This change compared to traditional models enhances the system's flexibility and allows for more adaptable control of components.
The object-oriented framework in Aptos brings several advantages:
High flexibility: Developers can easily customize NFTs for specific use cases.
Improved discoverability: The unique address of each object simplifies asset tracking and interaction.
Scalability: The system efficiently handles complex NFT structures.
For those unfamiliar with Aptos' object model, our detailed Object modules provide an excellent introduction to this groundbreaking approach in blockchain technology.
Collection
- A set of NFTs with a name and a bit of context for the group.
#[resource_group_member(#[group = 0x1::object::ObjectGroup])]
struct Collection has key {
    creator: address,
    description: String,
    name: String,
    uri: String,
		mutation_events: event::EventHandle<collection::MutationEvent>
}
To create a Collection with the Aptos framework, we have several different methods. Here are some predefined functions to initialize a collection through
aptos_token_objects
.
To use this library, you need to
import
it into the
Move.toml
file.
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
Complete
Move.toml
file contents.
[package]
name = "developer_portal"
version = "1.0.0"
authors = ["Movement Foundation"]
license = "MIT"
[addresses]
movement = "0x1"
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
[dev-dependencies]
Why Objects Are Useful
In reality, a user (account) can own one or multiple different collections. Using Objects to store Collections separately will help manage them more effectively and efficiently.
Furthermore, after creating Tokens, we know that these tokens may not necessarily belong to the collection owner but can be owned by anyone. With the use of objects, transferring, buying, selling, and managing these tokens will be easier and more flexible than ever before.
Initializing an object through the collection library
module movement::nft_factory {
    use aptos_token_objects::collection;
    use std::string::utf8;
    use std::option;
    fun init_module(creator: &signer, max_supply: u64) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(b"My Collection Description"),
            max_supply,
            utf8(b"My Collection"),
            royalty,
            utf8(b"https://mycollection.com"),
        );
    }
}
After initializing the module, we'll attempt to create a collection by
publish
ing this module through the CLI:
aptos move publish
After completing this process, check the transaction details on the explorer:
Through the
create_fixed_collection
function, we've initialized an
object
owned by the creator who initiated and possesses the object. We've also generated an
addr
of
0xa71c541d8f6022e60423d84a6cd5c0c76f898586933204f3521ab5f8f89bae86
. This address represents both the object's location and the
address owner
of the Collection.
The second resource initialized is a Collection that we defined in the Function.
			Digital Assets Demystified: Revolutionary Approach to NFTs
The Aptos framework provides a new approach to Digital Assets, revolutionizing the creation and management of collections and Non-Fungible Tokens.
By leveraging the power of Objects that we've explored in the previous section (Here), we can create objects containing distinct components of an NFT collection. This change compared to traditional models enhances the system's flexibility and allows for more adaptable control of components.
The object-oriented framework in Aptos brings several advantages:
High flexibility: Developers can easily customize NFTs for specific use cases.
Improved discoverability: The unique address of each object simplifies asset tracking and interaction.
Scalability: The system efficiently handles complex NFT structures.
For those unfamiliar with Aptos' object model, our detailed Object modules provide an excellent introduction to this groundbreaking approach in blockchain technology.
Collection
- A set of NFTs with a name and a bit of context for the group.
#[resource_group_member(#[group = 0x1::object::ObjectGroup])]
struct Collection has key {
    creator: address,
    description: String,
    name: String,
    uri: String,
		mutation_events: event::EventHandle<collection::MutationEvent>
}
To create a Collection with the Aptos framework, we have several different methods. Here are some predefined functions to initialize a collection through
aptos_token_objects
.
To use this library, you need to
import
it into the
Move.toml
file.
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
Complete
Move.toml
file contents.
[package]
name = "developer_portal"
version = "1.0.0"
authors = ["Movement Foundation"]
license = "MIT"
[addresses]
movement = "0x1"
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
[dev-dependencies]
Why Objects Are Useful
In reality, a user (account) can own one or multiple different collections. Using Objects to store Collections separately will help manage them more effectively and efficiently.
Furthermore, after creating Tokens, we know that these tokens may not necessarily belong to the collection owner but can be owned by anyone. With the use of objects, transferring, buying, selling, and managing these tokens will be easier and more flexible than ever before.
Initializing an object through the collection library
module movement::nft_factory {
    use aptos_token_objects::collection;
    use std::string::utf8;
    use std::option;
    fun init_module(creator: &signer, max_supply: u64) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(b"My Collection Description"),
            max_supply,
            utf8(b"My Collection"),
            royalty,
            utf8(b"https://mycollection.com"),
        );
    }
}
After initializing the module, we'll attempt to create a collection by
publish
ing this module through the CLI:
aptos move publish
After completing this process, check the transaction details on the explorer:
Through the
create_fixed_collection
function, we've initialized an
object
owned by the creator who initiated and possesses the object. We've also generated an
addr
of
0xa71c541d8f6022e60423d84a6cd5c0c76f898586933204f3521ab5f8f89bae86
. This address represents both the object's location and the
address owner
of the Collection.
The second resource initialized is a Collection that we defined in the Function.
	Digital Assets Demystified: Revolutionary Approach to NFTs
	Digital Assets Demystified: Revolutionary Approach to NFTs
	The Aptos framework provides a new approach to Digital Assets, revolutionizing the creation and management of collections and Non-Fungible Tokens.
	The Aptos framework provides a new approach to Digital Assets, revolutionizing the creation and management of collections and Non-Fungible Tokens.
	By leveraging the power of Objects that we've explored in the previous section (Here), we can create objects containing distinct components of an NFT collection. This change compared to traditional models enhances the system's flexibility and allows for more adaptable control of components.
	By leveraging the power of Objects that we've explored in the previous section (Here), we can create objects containing distinct components of an NFT collection. This change compared to traditional models enhances the system's flexibility and allows for more adaptable control of components.
	The object-oriented framework in Aptos brings several advantages:
	The object-oriented framework in Aptos brings several advantages:
	High flexibility: Developers can easily customize NFTs for specific use cases.
Improved discoverability: The unique address of each object simplifies asset tracking and interaction.
Scalability: The system efficiently handles complex NFT structures.
	High flexibility: Developers can easily customize NFTs for specific use cases.
	High flexibility: Developers can easily customize NFTs for specific use cases.
	Improved discoverability: The unique address of each object simplifies asset tracking and interaction.
	Improved discoverability: The unique address of each object simplifies asset tracking and interaction.
	Scalability: The system efficiently handles complex NFT structures.
	Scalability: The system efficiently handles complex NFT structures.
	For those unfamiliar with Aptos' object model, our detailed Object modules provide an excellent introduction to this groundbreaking approach in blockchain technology.
	For those unfamiliar with Aptos' object model, our detailed Object modules provide an excellent introduction to this groundbreaking approach in blockchain technology.
	Collection
- A set of NFTs with a name and a bit of context for the group.
	<code>Collection</code>
	Collection
	- A set of NFTs with a name and a bit of context for the group.
	<code>#[resource_group_member(#[group = 0x1::object::ObjectGroup])]
struct Collection has key {
    creator: address,
    description: String,
    name: String,
    uri: String,
		mutation_events: event::EventHandle<collection::MutationEvent>
}</code>
	<code>#[resource_group_member(#[group = 0x1::object::ObjectGroup])]
struct Collection has key {
    creator: address,
    description: String,
    name: String,
    uri: String,
		mutation_events: event::EventHandle<collection::MutationEvent>
}</code>
	#[resource_group_member(#[group = 0x1::object::ObjectGroup])]
struct Collection has key {
    creator: address,
    description: String,
    name: String,
    uri: String,
		mutation_events: event::EventHandle<collection::MutationEvent>
}
	To create a Collection with the Aptos framework, we have several different methods. Here are some predefined functions to initialize a collection through
aptos_token_objects
.
	To create a Collection with the Aptos framework, we have several different methods. Here are some predefined functions to initialize a collection through
	<code>aptos_token_objects</code>
	aptos_token_objects
	.
	To use this library, you need to
import
it into the
Move.toml
file.
	To use this library, you need to
	<code>import</code>
	import
	it into the
	<code>Move.toml</code>
	Move.toml
	file.
	<code>[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"</code>
	<code>[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"</code>
	[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
	Complete
Move.toml
file contents.
	Complete
Move.toml
file contents.
	Complete
	<code>Move.toml</code>
	Move.toml
	file contents.
	<code>[package]
name = "developer_portal"
version = "1.0.0"
authors = ["Movement Foundation"]
license = "MIT"
[addresses]
movement = "0x1"
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
[dev-dependencies]</code>
	<code>[package]
name = "developer_portal"
version = "1.0.0"
authors = ["Movement Foundation"]
license = "MIT"
[addresses]
movement = "0x1"
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
[dev-dependencies]</code>
	[package]
name = "developer_portal"
version = "1.0.0"
authors = ["Movement Foundation"]
license = "MIT"
[addresses]
movement = "0x1"
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
[dev-dependencies]
	Why Objects Are Useful
	Why Objects Are Useful
	In reality, a user (account) can own one or multiple different collections. Using Objects to store Collections separately will help manage them more effectively and efficiently.
	In reality, a user (account) can own one or multiple different collections. Using Objects to store Collections separately will help manage them more effectively and efficiently.
	Furthermore, after creating Tokens, we know that these tokens may not necessarily belong to the collection owner but can be owned by anyone. With the use of objects, transferring, buying, selling, and managing these tokens will be easier and more flexible than ever before.
	Furthermore, after creating Tokens, we know that these tokens may not necessarily belong to the collection owner but can be owned by anyone. With the use of objects, transferring, buying, selling, and managing these tokens will be easier and more flexible than ever before.
		Initializing an object through the collection library
		Initializing an object through the collection library
		<code>module movement::nft_factory {
    use aptos_token_objects::collection;
    use std::string::utf8;
    use std::option;
    fun init_module(creator: &signer, max_supply: u64) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(b"My Collection Description"),
            max_supply,
            utf8(b"My Collection"),
            royalty,
            utf8(b"https://mycollection.com"),
        );
    }
}</code>
		<code>module movement::nft_factory {
    use aptos_token_objects::collection;
    use std::string::utf8;
    use std::option;
    fun init_module(creator: &signer, max_supply: u64) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(b"My Collection Description"),
            max_supply,
            utf8(b"My Collection"),
            royalty,
            utf8(b"https://mycollection.com"),
        );
    }
}</code>
		module movement::nft_factory {
    use aptos_token_objects::collection;
    use std::string::utf8;
    use std::option;
    fun init_module(creator: &signer, max_supply: u64) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(b"My Collection Description"),
            max_supply,
            utf8(b"My Collection"),
            royalty,
            utf8(b"https://mycollection.com"),
        );
    }
}
		After initializing the module, we'll attempt to create a collection by
publish
ing this module through the CLI:
		After initializing the module, we'll attempt to create a collection by
		<code>publish</code>
		publish
		ing this module through the CLI:
		<code>aptos move publish</code>
		<code>aptos move publish</code>
		aptos move publish
		After completing this process, check the transaction details on the explorer:
		After completing this process, check the transaction details on the explorer:
		Through the
create_fixed_collection
function, we've initialized an
object
owned by the creator who initiated and possesses the object. We've also generated an
addr
of
0xa71c541d8f6022e60423d84a6cd5c0c76f898586933204f3521ab5f8f89bae86
. This address represents both the object's location and the
address owner
of the Collection.
		Through the
		<code>create_fixed_collection</code>
		create_fixed_collection
		function, we've initialized an
		<code>object</code>
		object
		owned by the creator who initiated and possesses the object. We've also generated an
		<code>addr</code>
		addr
		of
		<code>0xa71c541d8f6022e60423d84a6cd5c0c76f898586933204f3521ab5f8f89bae86</code>
		0xa71c541d8f6022e60423d84a6cd5c0c76f898586933204f3521ab5f8f89bae86
		. This address represents both the object's location and the
		<code>address owner</code>
		address owner
		of the Collection.
		The second resource initialized is a Collection that we defined in the Function.
		The second resource initialized is a Collection that we defined in the Function.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/nft/03-token-standard-and-mint-your-nft
Token Standard & Mint your NFT
Token Standard & Mint your NFT
On This Page
Create a Non-Function Token
ConcurrentSupply
TokenIdentifiers
Token
Create a Non-Function Token
After creating a collection, which is a set of NFTs, the next step we need to take is undoubtedly to create the NFTs belonging to the Collection that we initiated in the previous topic.
Similar to Collections, NFTs are also objects stored separately, and actions performed on NFTs will not affect the Collection.
let token_constructor_ref = token::create_named_token(
   creator,
   string::utf8(COLLECTION_NAME),
   string::utf8(COLLECTION_DESCRIPTION),
   token_name,
   option::none(),
   string::utf8(TOKEN_URI),
);
There are multiple ways to initialize an NFT with different types, but in this tutorial, we'll simplify the process by using the
create_named_token
function to create an NFT through the Collection name.
Since we'll reuse
Collection Name
,
Collection Description
, and other data in this function, we'll convert these pieces of information into
constant
values for reusability:
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
		fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}
Similar to the previous topic, we will publish the package. After publishing, we already have the Object Collection in the account. Now, let's try to create an NFT using the
mint_nft
function.
movement move run --function-id 'default::nft_factory::mint_nft' --args string:Hello
After successful execution, let's examine our account on the Movement explorer:
In addition to Core Objects and Collection Objects, we'll find several new objects, including
TokenIdentifiers
,
Token
, and another Object we should pay attention to:
ConcurrentSupply
.
ConcurrentSupply
This provides information about the total supply of the collection and the number of tokens currently circulating in the market.
TokenIdentifiers
This will contain the name of the NFT that we initialized through the CLI.
Token
This is the Object Token containing the information of the
Token
On This Page
Create a Non-Function Token
ConcurrentSupply
TokenIdentifiers
Token
On This Page
Create a Non-Function Token
ConcurrentSupply
TokenIdentifiers
Token
			On This Page
			On This Page
			Create a Non-Function Token
ConcurrentSupply
TokenIdentifiers
Token
			Create a Non-Function Token
ConcurrentSupply
TokenIdentifiers
Token
			Create a Non-Function Token
			Create a Non-Function Token
			Create a Non-Function Token
			ConcurrentSupply
TokenIdentifiers
Token
			ConcurrentSupply
			ConcurrentSupply
			ConcurrentSupply
			ConcurrentSupply
			TokenIdentifiers
			TokenIdentifiers
			TokenIdentifiers
			TokenIdentifiers
			Token
			Token
			Token
			Token
			Create a Non-Function Token
After creating a collection, which is a set of NFTs, the next step we need to take is undoubtedly to create the NFTs belonging to the Collection that we initiated in the previous topic.
Similar to Collections, NFTs are also objects stored separately, and actions performed on NFTs will not affect the Collection.
let token_constructor_ref = token::create_named_token(
   creator,
   string::utf8(COLLECTION_NAME),
   string::utf8(COLLECTION_DESCRIPTION),
   token_name,
   option::none(),
   string::utf8(TOKEN_URI),
);
There are multiple ways to initialize an NFT with different types, but in this tutorial, we'll simplify the process by using the
create_named_token
function to create an NFT through the Collection name.
Since we'll reuse
Collection Name
,
Collection Description
, and other data in this function, we'll convert these pieces of information into
constant
values for reusability:
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
		fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}
Similar to the previous topic, we will publish the package. After publishing, we already have the Object Collection in the account. Now, let's try to create an NFT using the
mint_nft
function.
movement move run --function-id 'default::nft_factory::mint_nft' --args string:Hello
After successful execution, let's examine our account on the Movement explorer:
In addition to Core Objects and Collection Objects, we'll find several new objects, including
TokenIdentifiers
,
Token
, and another Object we should pay attention to:
ConcurrentSupply
.
ConcurrentSupply
This provides information about the total supply of the collection and the number of tokens currently circulating in the market.
TokenIdentifiers
This will contain the name of the NFT that we initialized through the CLI.
Token
This is the Object Token containing the information of the
Token
			Create a Non-Function Token
After creating a collection, which is a set of NFTs, the next step we need to take is undoubtedly to create the NFTs belonging to the Collection that we initiated in the previous topic.
Similar to Collections, NFTs are also objects stored separately, and actions performed on NFTs will not affect the Collection.
let token_constructor_ref = token::create_named_token(
   creator,
   string::utf8(COLLECTION_NAME),
   string::utf8(COLLECTION_DESCRIPTION),
   token_name,
   option::none(),
   string::utf8(TOKEN_URI),
);
There are multiple ways to initialize an NFT with different types, but in this tutorial, we'll simplify the process by using the
create_named_token
function to create an NFT through the Collection name.
Since we'll reuse
Collection Name
,
Collection Description
, and other data in this function, we'll convert these pieces of information into
constant
values for reusability:
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
		fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}
Similar to the previous topic, we will publish the package. After publishing, we already have the Object Collection in the account. Now, let's try to create an NFT using the
mint_nft
function.
movement move run --function-id 'default::nft_factory::mint_nft' --args string:Hello
After successful execution, let's examine our account on the Movement explorer:
In addition to Core Objects and Collection Objects, we'll find several new objects, including
TokenIdentifiers
,
Token
, and another Object we should pay attention to:
ConcurrentSupply
.
ConcurrentSupply
This provides information about the total supply of the collection and the number of tokens currently circulating in the market.
TokenIdentifiers
This will contain the name of the NFT that we initialized through the CLI.
Token
This is the Object Token containing the information of the
Token
			Create a Non-Function Token
After creating a collection, which is a set of NFTs, the next step we need to take is undoubtedly to create the NFTs belonging to the Collection that we initiated in the previous topic.
Similar to Collections, NFTs are also objects stored separately, and actions performed on NFTs will not affect the Collection.
let token_constructor_ref = token::create_named_token(
   creator,
   string::utf8(COLLECTION_NAME),
   string::utf8(COLLECTION_DESCRIPTION),
   token_name,
   option::none(),
   string::utf8(TOKEN_URI),
);
There are multiple ways to initialize an NFT with different types, but in this tutorial, we'll simplify the process by using the
create_named_token
function to create an NFT through the Collection name.
Since we'll reuse
Collection Name
,
Collection Description
, and other data in this function, we'll convert these pieces of information into
constant
values for reusability:
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
		fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}
Similar to the previous topic, we will publish the package. After publishing, we already have the Object Collection in the account. Now, let's try to create an NFT using the
mint_nft
function.
movement move run --function-id 'default::nft_factory::mint_nft' --args string:Hello
After successful execution, let's examine our account on the Movement explorer:
In addition to Core Objects and Collection Objects, we'll find several new objects, including
TokenIdentifiers
,
Token
, and another Object we should pay attention to:
ConcurrentSupply
.
ConcurrentSupply
This provides information about the total supply of the collection and the number of tokens currently circulating in the market.
TokenIdentifiers
This will contain the name of the NFT that we initialized through the CLI.
Token
This is the Object Token containing the information of the
Token
	Create a Non-Function Token
	Create a Non-Function Token
	After creating a collection, which is a set of NFTs, the next step we need to take is undoubtedly to create the NFTs belonging to the Collection that we initiated in the previous topic.
	After creating a collection, which is a set of NFTs, the next step we need to take is undoubtedly to create the NFTs belonging to the Collection that we initiated in the previous topic.
	Similar to Collections, NFTs are also objects stored separately, and actions performed on NFTs will not affect the Collection.
	Similar to Collections, NFTs are also objects stored separately, and actions performed on NFTs will not affect the Collection.
	<code>let token_constructor_ref = token::create_named_token(
   creator,
   string::utf8(COLLECTION_NAME),
   string::utf8(COLLECTION_DESCRIPTION),
   token_name,
   option::none(),
   string::utf8(TOKEN_URI),
);</code>
	<code>let token_constructor_ref = token::create_named_token(
   creator,
   string::utf8(COLLECTION_NAME),
   string::utf8(COLLECTION_DESCRIPTION),
   token_name,
   option::none(),
   string::utf8(TOKEN_URI),
);</code>
	let token_constructor_ref = token::create_named_token(
   creator,
   string::utf8(COLLECTION_NAME),
   string::utf8(COLLECTION_DESCRIPTION),
   token_name,
   option::none(),
   string::utf8(TOKEN_URI),
);
	There are multiple ways to initialize an NFT with different types, but in this tutorial, we'll simplify the process by using the
create_named_token
function to create an NFT through the Collection name.
	There are multiple ways to initialize an NFT with different types, but in this tutorial, we'll simplify the process by using the
	<code>create_named_token</code>
	create_named_token
	function to create an NFT through the Collection name.
	Since we'll reuse
Collection Name
,
Collection Description
, and other data in this function, we'll convert these pieces of information into
constant
values for reusability:
	Since we'll reuse
	<code>Collection Name</code>
	Collection Name
	,
	<code>Collection Description</code>
	Collection Description
	, and other data in this function, we'll convert these pieces of information into
	<code>constant</code>
	constant
	values for reusability:
	<code>module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
		fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}</code>
	<code>module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
		fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}</code>
	module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
		fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}
	Similar to the previous topic, we will publish the package. After publishing, we already have the Object Collection in the account. Now, let's try to create an NFT using the
mint_nft
function.
	Similar to the previous topic, we will publish the package. After publishing, we already have the Object Collection in the account. Now, let's try to create an NFT using the
	<code>mint_nft</code>
	mint_nft
	function.
	<code>movement move run --function-id 'default::nft_factory::mint_nft' --args string:Hello</code>
	<code>movement move run --function-id 'default::nft_factory::mint_nft' --args string:Hello</code>
	movement move run --function-id 'default::nft_factory::mint_nft' --args string:Hello
	After successful execution, let's examine our account on the Movement explorer:
	After successful execution, let's examine our account on the Movement explorer:
	In addition to Core Objects and Collection Objects, we'll find several new objects, including
TokenIdentifiers
,
Token
, and another Object we should pay attention to:
ConcurrentSupply
.
	In addition to Core Objects and Collection Objects, we'll find several new objects, including
	<code>TokenIdentifiers</code>
	TokenIdentifiers
	,
	<code>Token</code>
	Token
	, and another Object we should pay attention to:
	<code>ConcurrentSupply</code>
	ConcurrentSupply
	.
		ConcurrentSupply
		ConcurrentSupply
		This provides information about the total supply of the collection and the number of tokens currently circulating in the market.
		This provides information about the total supply of the collection and the number of tokens currently circulating in the market.
		TokenIdentifiers
		TokenIdentifiers
		This will contain the name of the NFT that we initialized through the CLI.
		This will contain the name of the NFT that we initialized through the CLI.
		Token
		Token
		This is the Object Token containing the information of the
Token
		This is the Object Token containing the information of the
		<code>Token</code>
		Token

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/nft/04-token-metadata-and-modifying-data
Token Metadata & Modifying Data
Token Metadata & Modifying Data
On This Page
Summary
Overview
Create a Token Metadata
Modify Token Metadata
Full Code
Summary
Token Metadata creation and modification for NFTs on Aptos blockchain
Use of
create_named_token
function to initialize TokenObjects
Creation of custom NFT using
Object Group Member
with user-defined fields
Process of initializing and transferring tokens to object's signer
Implementation of
mint_nft
function for token creation
Storage and usage of
mutator_ref
for updating token metadata
Example of updating token description using
update_token_description
function
Overview
In the previous lesson, we successfully initialized a collection and token, but here you can see that we use
create_named_token
to initialize a TokenObjects, and the fields here are predefined and we can only pass in the Token Name.
So in order to customize an NFT according to our wishes, we need to initialize another Resource and store it in the token Object that was initialized from the
create_named_token
function
Create a Token Metadata
Here, we'll create a custom NFT using an
Object Group Member
with fields that you can define according to your needs.
struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
}
Here's an example of an NFT meme token with three simple fields. In practice, you can customize it according to your needs.
Next, we'll initialize a token:
let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
The
name
,
uri
, and
description
are parameters passed from outside.
Since
create_named_object
returns a ConstructorRef, we need to create a
signer
from the object to store this NFT, transfer it to the signer, or use it for future transfers:
let token_signer = object::generate_signer(&constructor_ref);
Then we simply transfer it to the object's
signer
, similar to what we learned in the objects topic.
let token_signer = object::generate_signer(&constructor_ref);
let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
move_to(&token_signer, movement_meme);
After completing the code, your implementation should look like this:
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
    }
    fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let movement_meme = MovementPepeMeme {
            name: token_name,
            uri,
            description
        };
        move_to(&token_signer, movement_meme);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}
Next, we'll initialize the NFT through publishing the package and then call the
mint_nft
function via the CLI as follows:
movement run --function-id '0x8e4ad880c961f094f149993b3f83ac9eace3dd7ab8cedca7d0a4266b8de6aff7::nft_factory::mint_nft' --args string:Hello string:link string:desc --profile default
After the successful execution, we can verify the results on the explorer. We'll find a new Resource added:
Modify Token Metadata
We've successfully created an NFT with custom metadata. Now, how can we modify or update this metadata?
This process is similar to working with Objects, as NFTs are essentially objects we've studied in previous topics.
To modify metadata, we need to create a
mutator_ref
from the Token's
constructor
and store it somewhere. In this example, we'll store it directly on the Resource:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
    mutator_ref: token::MutatorRef
}
Next, initialize the
mutator_ref
and store it in the resource:
public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
    let constructor_ref = token::create_named_token(
        creator,
        utf8(COLLECTION_NAME),
        utf8(COLLECTION_DESCRIPTION),
        token_name,
        option::none(),
        utf8(COLLECTION_URI)
    );
    let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
    let token_signer = object::generate_signer(&constructor_ref);
    let mutator_ref = token::generate_mutator_ref(&constructor_ref);
    let movement_meme = MovementPepeMeme {
        name: token_name,
        uri,
        description,
        mutator_ref
    };
    move_to(&token_signer, movement_meme);
    object::transfer(creator, token_object, signer::address_of(creator));
}
Then we can use the mutator_ref to update the Token and Metadata:
public entry fun update_token_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
    let (meme_obj, meme) = get_meme(
        &signer::address_of(creator),
        &collection,
        &name,
    );
    let creator_addr = token::creator(meme_obj);
    assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
    token::set_description(&meme.mutator_ref, description);
}
inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
    let token_address = token::create_token_address(
        creator,
        collection,
        name,
    );
    (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
}
Full Code
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object::{Self, Object};
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    const ENOT_CREATOR: u64 = 0;
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
        mutator_ref: token::MutatorRef
    }
    public entry fun create_collection(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let mutator_ref = token::generate_mutator_ref(&constructor_ref);
        move_to(&token_signer, MovementPepeMeme {
            name: token_name,
            uri,
            description,
            mutator_ref
        });
        object::transfer(creator, token_object, signer::address_of(creator));
    }
    public entry fun update_meme_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
        let (meme_obj, meme) = get_meme(
            &signer::address_of(creator),
            &collection,
            &name,
        );
        let creator_addr = token::creator(meme_obj);
        assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
        token::set_description(&meme.mutator_ref, description);
    }
    inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
        let token_address = token::create_token_address(
            creator,
            collection,
            name,
        );
        (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
    }
}
On This Page
Summary
Overview
Create a Token Metadata
Modify Token Metadata
Full Code
On This Page
Summary
Overview
Create a Token Metadata
Modify Token Metadata
Full Code
			On This Page
			On This Page
			Summary
Overview
Create a Token Metadata
Modify Token Metadata
Full Code
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			Create a Token Metadata
			Create a Token Metadata
			Create a Token Metadata
			Create a Token Metadata
			Modify Token Metadata
Full Code
			Modify Token Metadata
			Modify Token Metadata
			Modify Token Metadata
			Full Code
			Full Code
			Full Code
			Full Code
			Full Code
			Summary
Token Metadata creation and modification for NFTs on Aptos blockchain
Use of
create_named_token
function to initialize TokenObjects
Creation of custom NFT using
Object Group Member
with user-defined fields
Process of initializing and transferring tokens to object's signer
Implementation of
mint_nft
function for token creation
Storage and usage of
mutator_ref
for updating token metadata
Example of updating token description using
update_token_description
function
Overview
In the previous lesson, we successfully initialized a collection and token, but here you can see that we use
create_named_token
to initialize a TokenObjects, and the fields here are predefined and we can only pass in the Token Name.
So in order to customize an NFT according to our wishes, we need to initialize another Resource and store it in the token Object that was initialized from the
create_named_token
function
Create a Token Metadata
Here, we'll create a custom NFT using an
Object Group Member
with fields that you can define according to your needs.
struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
}
Here's an example of an NFT meme token with three simple fields. In practice, you can customize it according to your needs.
Next, we'll initialize a token:
let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
The
name
,
uri
, and
description
are parameters passed from outside.
Since
create_named_object
returns a ConstructorRef, we need to create a
signer
from the object to store this NFT, transfer it to the signer, or use it for future transfers:
let token_signer = object::generate_signer(&constructor_ref);
Then we simply transfer it to the object's
signer
, similar to what we learned in the objects topic.
let token_signer = object::generate_signer(&constructor_ref);
let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
move_to(&token_signer, movement_meme);
After completing the code, your implementation should look like this:
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
    }
    fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let movement_meme = MovementPepeMeme {
            name: token_name,
            uri,
            description
        };
        move_to(&token_signer, movement_meme);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}
Next, we'll initialize the NFT through publishing the package and then call the
mint_nft
function via the CLI as follows:
movement run --function-id '0x8e4ad880c961f094f149993b3f83ac9eace3dd7ab8cedca7d0a4266b8de6aff7::nft_factory::mint_nft' --args string:Hello string:link string:desc --profile default
After the successful execution, we can verify the results on the explorer. We'll find a new Resource added:
Modify Token Metadata
We've successfully created an NFT with custom metadata. Now, how can we modify or update this metadata?
This process is similar to working with Objects, as NFTs are essentially objects we've studied in previous topics.
To modify metadata, we need to create a
mutator_ref
from the Token's
constructor
and store it somewhere. In this example, we'll store it directly on the Resource:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
    mutator_ref: token::MutatorRef
}
Next, initialize the
mutator_ref
and store it in the resource:
public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
    let constructor_ref = token::create_named_token(
        creator,
        utf8(COLLECTION_NAME),
        utf8(COLLECTION_DESCRIPTION),
        token_name,
        option::none(),
        utf8(COLLECTION_URI)
    );
    let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
    let token_signer = object::generate_signer(&constructor_ref);
    let mutator_ref = token::generate_mutator_ref(&constructor_ref);
    let movement_meme = MovementPepeMeme {
        name: token_name,
        uri,
        description,
        mutator_ref
    };
    move_to(&token_signer, movement_meme);
    object::transfer(creator, token_object, signer::address_of(creator));
}
Then we can use the mutator_ref to update the Token and Metadata:
public entry fun update_token_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
    let (meme_obj, meme) = get_meme(
        &signer::address_of(creator),
        &collection,
        &name,
    );
    let creator_addr = token::creator(meme_obj);
    assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
    token::set_description(&meme.mutator_ref, description);
}
inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
    let token_address = token::create_token_address(
        creator,
        collection,
        name,
    );
    (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
}
Full Code
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object::{Self, Object};
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    const ENOT_CREATOR: u64 = 0;
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
        mutator_ref: token::MutatorRef
    }
    public entry fun create_collection(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let mutator_ref = token::generate_mutator_ref(&constructor_ref);
        move_to(&token_signer, MovementPepeMeme {
            name: token_name,
            uri,
            description,
            mutator_ref
        });
        object::transfer(creator, token_object, signer::address_of(creator));
    }
    public entry fun update_meme_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
        let (meme_obj, meme) = get_meme(
            &signer::address_of(creator),
            &collection,
            &name,
        );
        let creator_addr = token::creator(meme_obj);
        assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
        token::set_description(&meme.mutator_ref, description);
    }
    inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
        let token_address = token::create_token_address(
            creator,
            collection,
            name,
        );
        (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
    }
}
			Summary
Token Metadata creation and modification for NFTs on Aptos blockchain
Use of
create_named_token
function to initialize TokenObjects
Creation of custom NFT using
Object Group Member
with user-defined fields
Process of initializing and transferring tokens to object's signer
Implementation of
mint_nft
function for token creation
Storage and usage of
mutator_ref
for updating token metadata
Example of updating token description using
update_token_description
function
Overview
In the previous lesson, we successfully initialized a collection and token, but here you can see that we use
create_named_token
to initialize a TokenObjects, and the fields here are predefined and we can only pass in the Token Name.
So in order to customize an NFT according to our wishes, we need to initialize another Resource and store it in the token Object that was initialized from the
create_named_token
function
Create a Token Metadata
Here, we'll create a custom NFT using an
Object Group Member
with fields that you can define according to your needs.
struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
}
Here's an example of an NFT meme token with three simple fields. In practice, you can customize it according to your needs.
Next, we'll initialize a token:
let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
The
name
,
uri
, and
description
are parameters passed from outside.
Since
create_named_object
returns a ConstructorRef, we need to create a
signer
from the object to store this NFT, transfer it to the signer, or use it for future transfers:
let token_signer = object::generate_signer(&constructor_ref);
Then we simply transfer it to the object's
signer
, similar to what we learned in the objects topic.
let token_signer = object::generate_signer(&constructor_ref);
let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
move_to(&token_signer, movement_meme);
After completing the code, your implementation should look like this:
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
    }
    fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let movement_meme = MovementPepeMeme {
            name: token_name,
            uri,
            description
        };
        move_to(&token_signer, movement_meme);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}
Next, we'll initialize the NFT through publishing the package and then call the
mint_nft
function via the CLI as follows:
movement run --function-id '0x8e4ad880c961f094f149993b3f83ac9eace3dd7ab8cedca7d0a4266b8de6aff7::nft_factory::mint_nft' --args string:Hello string:link string:desc --profile default
After the successful execution, we can verify the results on the explorer. We'll find a new Resource added:
Modify Token Metadata
We've successfully created an NFT with custom metadata. Now, how can we modify or update this metadata?
This process is similar to working with Objects, as NFTs are essentially objects we've studied in previous topics.
To modify metadata, we need to create a
mutator_ref
from the Token's
constructor
and store it somewhere. In this example, we'll store it directly on the Resource:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
    mutator_ref: token::MutatorRef
}
Next, initialize the
mutator_ref
and store it in the resource:
public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
    let constructor_ref = token::create_named_token(
        creator,
        utf8(COLLECTION_NAME),
        utf8(COLLECTION_DESCRIPTION),
        token_name,
        option::none(),
        utf8(COLLECTION_URI)
    );
    let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
    let token_signer = object::generate_signer(&constructor_ref);
    let mutator_ref = token::generate_mutator_ref(&constructor_ref);
    let movement_meme = MovementPepeMeme {
        name: token_name,
        uri,
        description,
        mutator_ref
    };
    move_to(&token_signer, movement_meme);
    object::transfer(creator, token_object, signer::address_of(creator));
}
Then we can use the mutator_ref to update the Token and Metadata:
public entry fun update_token_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
    let (meme_obj, meme) = get_meme(
        &signer::address_of(creator),
        &collection,
        &name,
    );
    let creator_addr = token::creator(meme_obj);
    assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
    token::set_description(&meme.mutator_ref, description);
}
inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
    let token_address = token::create_token_address(
        creator,
        collection,
        name,
    );
    (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
}
Full Code
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object::{Self, Object};
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    const ENOT_CREATOR: u64 = 0;
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
        mutator_ref: token::MutatorRef
    }
    public entry fun create_collection(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let mutator_ref = token::generate_mutator_ref(&constructor_ref);
        move_to(&token_signer, MovementPepeMeme {
            name: token_name,
            uri,
            description,
            mutator_ref
        });
        object::transfer(creator, token_object, signer::address_of(creator));
    }
    public entry fun update_meme_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
        let (meme_obj, meme) = get_meme(
            &signer::address_of(creator),
            &collection,
            &name,
        );
        let creator_addr = token::creator(meme_obj);
        assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
        token::set_description(&meme.mutator_ref, description);
    }
    inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
        let token_address = token::create_token_address(
            creator,
            collection,
            name,
        );
        (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
    }
}
			Summary
Token Metadata creation and modification for NFTs on Aptos blockchain
Use of
create_named_token
function to initialize TokenObjects
Creation of custom NFT using
Object Group Member
with user-defined fields
Process of initializing and transferring tokens to object's signer
Implementation of
mint_nft
function for token creation
Storage and usage of
mutator_ref
for updating token metadata
Example of updating token description using
update_token_description
function
Overview
In the previous lesson, we successfully initialized a collection and token, but here you can see that we use
create_named_token
to initialize a TokenObjects, and the fields here are predefined and we can only pass in the Token Name.
So in order to customize an NFT according to our wishes, we need to initialize another Resource and store it in the token Object that was initialized from the
create_named_token
function
Create a Token Metadata
Here, we'll create a custom NFT using an
Object Group Member
with fields that you can define according to your needs.
struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
}
Here's an example of an NFT meme token with three simple fields. In practice, you can customize it according to your needs.
Next, we'll initialize a token:
let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
The
name
,
uri
, and
description
are parameters passed from outside.
Since
create_named_object
returns a ConstructorRef, we need to create a
signer
from the object to store this NFT, transfer it to the signer, or use it for future transfers:
let token_signer = object::generate_signer(&constructor_ref);
Then we simply transfer it to the object's
signer
, similar to what we learned in the objects topic.
let token_signer = object::generate_signer(&constructor_ref);
let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
move_to(&token_signer, movement_meme);
After completing the code, your implementation should look like this:
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
    }
    fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let movement_meme = MovementPepeMeme {
            name: token_name,
            uri,
            description
        };
        move_to(&token_signer, movement_meme);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}
Next, we'll initialize the NFT through publishing the package and then call the
mint_nft
function via the CLI as follows:
movement run --function-id '0x8e4ad880c961f094f149993b3f83ac9eace3dd7ab8cedca7d0a4266b8de6aff7::nft_factory::mint_nft' --args string:Hello string:link string:desc --profile default
After the successful execution, we can verify the results on the explorer. We'll find a new Resource added:
Modify Token Metadata
We've successfully created an NFT with custom metadata. Now, how can we modify or update this metadata?
This process is similar to working with Objects, as NFTs are essentially objects we've studied in previous topics.
To modify metadata, we need to create a
mutator_ref
from the Token's
constructor
and store it somewhere. In this example, we'll store it directly on the Resource:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
    mutator_ref: token::MutatorRef
}
Next, initialize the
mutator_ref
and store it in the resource:
public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
    let constructor_ref = token::create_named_token(
        creator,
        utf8(COLLECTION_NAME),
        utf8(COLLECTION_DESCRIPTION),
        token_name,
        option::none(),
        utf8(COLLECTION_URI)
    );
    let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
    let token_signer = object::generate_signer(&constructor_ref);
    let mutator_ref = token::generate_mutator_ref(&constructor_ref);
    let movement_meme = MovementPepeMeme {
        name: token_name,
        uri,
        description,
        mutator_ref
    };
    move_to(&token_signer, movement_meme);
    object::transfer(creator, token_object, signer::address_of(creator));
}
Then we can use the mutator_ref to update the Token and Metadata:
public entry fun update_token_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
    let (meme_obj, meme) = get_meme(
        &signer::address_of(creator),
        &collection,
        &name,
    );
    let creator_addr = token::creator(meme_obj);
    assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
    token::set_description(&meme.mutator_ref, description);
}
inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
    let token_address = token::create_token_address(
        creator,
        collection,
        name,
    );
    (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
}
Full Code
module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object::{Self, Object};
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    const ENOT_CREATOR: u64 = 0;
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
        mutator_ref: token::MutatorRef
    }
    public entry fun create_collection(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let mutator_ref = token::generate_mutator_ref(&constructor_ref);
        move_to(&token_signer, MovementPepeMeme {
            name: token_name,
            uri,
            description,
            mutator_ref
        });
        object::transfer(creator, token_object, signer::address_of(creator));
    }
    public entry fun update_meme_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
        let (meme_obj, meme) = get_meme(
            &signer::address_of(creator),
            &collection,
            &name,
        );
        let creator_addr = token::creator(meme_obj);
        assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
        token::set_description(&meme.mutator_ref, description);
    }
    inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
        let token_address = token::create_token_address(
            creator,
            collection,
            name,
        );
        (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
    }
}
	Summary
	Summary
	Token Metadata creation and modification for NFTs on Aptos blockchain
Use of
create_named_token
function to initialize TokenObjects
Creation of custom NFT using
Object Group Member
with user-defined fields
Process of initializing and transferring tokens to object's signer
Implementation of
mint_nft
function for token creation
Storage and usage of
mutator_ref
for updating token metadata
Example of updating token description using
update_token_description
function
	Token Metadata creation and modification for NFTs on Aptos blockchain
	Token Metadata creation and modification for NFTs on Aptos blockchain
	Use of
create_named_token
function to initialize TokenObjects
	Use of
	<code>create_named_token</code>
	create_named_token
	function to initialize TokenObjects
	Creation of custom NFT using
Object Group Member
with user-defined fields
	Creation of custom NFT using
	<code>Object Group Member</code>
	Object Group Member
	with user-defined fields
	Process of initializing and transferring tokens to object's signer
	Process of initializing and transferring tokens to object's signer
	Implementation of
mint_nft
function for token creation
	Implementation of
	<code>mint_nft</code>
	mint_nft
	function for token creation
	Storage and usage of
mutator_ref
for updating token metadata
	Storage and usage of
	<code>mutator_ref</code>
	mutator_ref
	for updating token metadata
	Example of updating token description using
update_token_description
function
	Example of updating token description using
	<code>update_token_description</code>
	update_token_description
	function
	Overview
	Overview
	In the previous lesson, we successfully initialized a collection and token, but here you can see that we use
create_named_token
to initialize a TokenObjects, and the fields here are predefined and we can only pass in the Token Name.
	In the previous lesson, we successfully initialized a collection and token, but here you can see that we use
	<code>create_named_token</code>
	create_named_token
	to initialize a TokenObjects, and the fields here are predefined and we can only pass in the Token Name.
	So in order to customize an NFT according to our wishes, we need to initialize another Resource and store it in the token Object that was initialized from the
create_named_token
function
	So in order to customize an NFT according to our wishes, we need to initialize another Resource and store it in the token Object that was initialized from the
	<code>create_named_token</code>
	create_named_token
	function
	Create a Token Metadata
	Create a Token Metadata
	Here, we'll create a custom NFT using an
Object Group Member
with fields that you can define according to your needs.
	Here, we'll create a custom NFT using an
	<code>Object Group Member</code>
	Object Group Member
	with fields that you can define according to your needs.
	<code>struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
}</code>
	<code>struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
}</code>
	struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
}
	Here's an example of an NFT meme token with three simple fields. In practice, you can customize it according to your needs.
	Here's an example of an NFT meme token with three simple fields. In practice, you can customize it according to your needs.
	Next, we'll initialize a token:
	Next, we'll initialize a token:
	<code>let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};</code>
	<code>let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};</code>
	let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
	The
name
,
uri
, and
description
are parameters passed from outside.
	The
	<code>name</code>
	name
	,
	<code>uri</code>
	uri
	, and
	<code>description</code>
	description
	are parameters passed from outside.
	Since
create_named_object
returns a ConstructorRef, we need to create a
signer
from the object to store this NFT, transfer it to the signer, or use it for future transfers:
	Since
	<code>create_named_object</code>
	create_named_object
	returns a ConstructorRef, we need to create a
	<code>signer</code>
	signer
	from the object to store this NFT, transfer it to the signer, or use it for future transfers:
	<code>let token_signer = object::generate_signer(&constructor_ref);</code>
	<code>let token_signer = object::generate_signer(&constructor_ref);</code>
	let token_signer = object::generate_signer(&constructor_ref);
	Then we simply transfer it to the object's
signer
, similar to what we learned in the objects topic.
	Then we simply transfer it to the object's
	<code>signer</code>
	signer
	, similar to what we learned in the objects topic.
	<code>let token_signer = object::generate_signer(&constructor_ref);
let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
move_to(&token_signer, movement_meme);</code>
	<code>let token_signer = object::generate_signer(&constructor_ref);
let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
move_to(&token_signer, movement_meme);</code>
	let token_signer = object::generate_signer(&constructor_ref);
let movement_meme = MovementPepeMeme {
    name: token_name,
    uri,
    description
};
move_to(&token_signer, movement_meme);
	After completing the code, your implementation should look like this:
	After completing the code, your implementation should look like this:
	<code>module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
    }
    fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let movement_meme = MovementPepeMeme {
            name: token_name,
            uri,
            description
        };
        move_to(&token_signer, movement_meme);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}</code>
	<code>module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
    }
    fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let movement_meme = MovementPepeMeme {
            name: token_name,
            uri,
            description
        };
        move_to(&token_signer, movement_meme);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}</code>
	module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
    }
    fun init_module(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let movement_meme = MovementPepeMeme {
            name: token_name,
            uri,
            description
        };
        move_to(&token_signer, movement_meme);
        object::transfer(creator, token_object, signer::address_of(creator));
    }
}
	Next, we'll initialize the NFT through publishing the package and then call the
mint_nft
function via the CLI as follows:
	Next, we'll initialize the NFT through publishing the package and then call the
	<code>mint_nft</code>
	mint_nft
	function via the CLI as follows:
	<code>movement run --function-id '0x8e4ad880c961f094f149993b3f83ac9eace3dd7ab8cedca7d0a4266b8de6aff7::nft_factory::mint_nft' --args string:Hello string:link string:desc --profile default</code>
	<code>movement run --function-id '0x8e4ad880c961f094f149993b3f83ac9eace3dd7ab8cedca7d0a4266b8de6aff7::nft_factory::mint_nft' --args string:Hello string:link string:desc --profile default</code>
	movement run --function-id '0x8e4ad880c961f094f149993b3f83ac9eace3dd7ab8cedca7d0a4266b8de6aff7::nft_factory::mint_nft' --args string:Hello string:link string:desc --profile default
	After the successful execution, we can verify the results on the explorer. We'll find a new Resource added:
	After the successful execution, we can verify the results on the explorer. We'll find a new Resource added:
	Modify Token Metadata
	Modify Token Metadata
	We've successfully created an NFT with custom metadata. Now, how can we modify or update this metadata?
	We've successfully created an NFT with custom metadata. Now, how can we modify or update this metadata?
	This process is similar to working with Objects, as NFTs are essentially objects we've studied in previous topics.
	This process is similar to working with Objects, as NFTs are essentially objects we've studied in previous topics.
	To modify metadata, we need to create a
mutator_ref
from the Token's
constructor
and store it somewhere. In this example, we'll store it directly on the Resource:
	To modify metadata, we need to create a
	<code>mutator_ref</code>
	mutator_ref
	from the Token's
	<code>constructor</code>
	constructor
	and store it somewhere. In this example, we'll store it directly on the Resource:
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
    mutator_ref: token::MutatorRef
}</code>
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
    mutator_ref: token::MutatorRef
}</code>
	#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementPepeMeme has key {
    name: String,
    uri: String,
    description: String,
    mutator_ref: token::MutatorRef
}
	Next, initialize the
mutator_ref
and store it in the resource:
	Next, initialize the
	<code>mutator_ref</code>
	mutator_ref
	and store it in the resource:
	<code>public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
    let constructor_ref = token::create_named_token(
        creator,
        utf8(COLLECTION_NAME),
        utf8(COLLECTION_DESCRIPTION),
        token_name,
        option::none(),
        utf8(COLLECTION_URI)
    );
    let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
    let token_signer = object::generate_signer(&constructor_ref);
    let mutator_ref = token::generate_mutator_ref(&constructor_ref);
    let movement_meme = MovementPepeMeme {
        name: token_name,
        uri,
        description,
        mutator_ref
    };
    move_to(&token_signer, movement_meme);
    object::transfer(creator, token_object, signer::address_of(creator));
}</code>
	<code>public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
    let constructor_ref = token::create_named_token(
        creator,
        utf8(COLLECTION_NAME),
        utf8(COLLECTION_DESCRIPTION),
        token_name,
        option::none(),
        utf8(COLLECTION_URI)
    );
    let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
    let token_signer = object::generate_signer(&constructor_ref);
    let mutator_ref = token::generate_mutator_ref(&constructor_ref);
    let movement_meme = MovementPepeMeme {
        name: token_name,
        uri,
        description,
        mutator_ref
    };
    move_to(&token_signer, movement_meme);
    object::transfer(creator, token_object, signer::address_of(creator));
}</code>
	public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
    let constructor_ref = token::create_named_token(
        creator,
        utf8(COLLECTION_NAME),
        utf8(COLLECTION_DESCRIPTION),
        token_name,
        option::none(),
        utf8(COLLECTION_URI)
    );
    let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
    let token_signer = object::generate_signer(&constructor_ref);
    let mutator_ref = token::generate_mutator_ref(&constructor_ref);
    let movement_meme = MovementPepeMeme {
        name: token_name,
        uri,
        description,
        mutator_ref
    };
    move_to(&token_signer, movement_meme);
    object::transfer(creator, token_object, signer::address_of(creator));
}
	Then we can use the mutator_ref to update the Token and Metadata:
	Then we can use the mutator_ref to update the Token and Metadata:
	<code>public entry fun update_token_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
    let (meme_obj, meme) = get_meme(
        &signer::address_of(creator),
        &collection,
        &name,
    );
    let creator_addr = token::creator(meme_obj);
    assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
    token::set_description(&meme.mutator_ref, description);
}
inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
    let token_address = token::create_token_address(
        creator,
        collection,
        name,
    );
    (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
}</code>
	<code>public entry fun update_token_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
    let (meme_obj, meme) = get_meme(
        &signer::address_of(creator),
        &collection,
        &name,
    );
    let creator_addr = token::creator(meme_obj);
    assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
    token::set_description(&meme.mutator_ref, description);
}
inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
    let token_address = token::create_token_address(
        creator,
        collection,
        name,
    );
    (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
}</code>
	public entry fun update_token_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
    let (meme_obj, meme) = get_meme(
        &signer::address_of(creator),
        &collection,
        &name,
    );
    let creator_addr = token::creator(meme_obj);
    assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
    token::set_description(&meme.mutator_ref, description);
}
inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
    let token_address = token::create_token_address(
        creator,
        collection,
        name,
    );
    (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
}
		Full Code
		Full Code
		<code>module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object::{Self, Object};
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    const ENOT_CREATOR: u64 = 0;
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
        mutator_ref: token::MutatorRef
    }
    public entry fun create_collection(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let mutator_ref = token::generate_mutator_ref(&constructor_ref);
        move_to(&token_signer, MovementPepeMeme {
            name: token_name,
            uri,
            description,
            mutator_ref
        });
        object::transfer(creator, token_object, signer::address_of(creator));
    }
    public entry fun update_meme_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
        let (meme_obj, meme) = get_meme(
            &signer::address_of(creator),
            &collection,
            &name,
        );
        let creator_addr = token::creator(meme_obj);
        assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
        token::set_description(&meme.mutator_ref, description);
    }
    inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
        let token_address = token::create_token_address(
            creator,
            collection,
            name,
        );
        (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
    }
}</code>
		<code>module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object::{Self, Object};
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    const ENOT_CREATOR: u64 = 0;
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
        mutator_ref: token::MutatorRef
    }
    public entry fun create_collection(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let mutator_ref = token::generate_mutator_ref(&constructor_ref);
        move_to(&token_signer, MovementPepeMeme {
            name: token_name,
            uri,
            description,
            mutator_ref
        });
        object::transfer(creator, token_object, signer::address_of(creator));
    }
    public entry fun update_meme_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
        let (meme_obj, meme) = get_meme(
            &signer::address_of(creator),
            &collection,
            &name,
        );
        let creator_addr = token::creator(meme_obj);
        assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
        token::set_description(&meme.mutator_ref, description);
    }
    inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
        let token_address = token::create_token_address(
            creator,
            collection,
            name,
        );
        (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
    }
}</code>
		module movement::nft_factory {
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object::{Self, Object};
    use std::string::{utf8, String};
    use std::option;
    use std::signer;
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens Collection";
    const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
    const MAX_SUPPLY: u64 = 10_000;
    const ENOT_CREATOR: u64 = 0;
    struct MovementPepeMeme has key {
        name: String,
        uri: String,
        description: String,
        mutator_ref: token::MutatorRef
    }
    public entry fun create_collection(creator: &signer) {
        let royalty = option::none();
        collection::create_fixed_collection(
            creator,
            utf8(COLLECTION_DESCRIPTION),
            MAX_SUPPLY,
            utf8(COLLECTION_NAME),
            royalty,
            utf8(COLLECTION_URI),
        );
    }
    public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
        let constructor_ref = token::create_named_token(
            creator,
            utf8(COLLECTION_NAME),
            utf8(COLLECTION_DESCRIPTION),
            token_name,
            option::none(),
            utf8(COLLECTION_URI)
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);
        let mutator_ref = token::generate_mutator_ref(&constructor_ref);
        move_to(&token_signer, MovementPepeMeme {
            name: token_name,
            uri,
            description,
            mutator_ref
        });
        object::transfer(creator, token_object, signer::address_of(creator));
    }
    public entry fun update_meme_description(creator: &signer, collection: String, name: String, description: String) acquires MovementPepeMeme {
        let (meme_obj, meme) = get_meme(
            &signer::address_of(creator),
            &collection,
            &name,
        );
        let creator_addr = token::creator(meme_obj);
        assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
        token::set_description(&meme.mutator_ref, description);
    }
    inline fun get_meme(creator: &address, collection: &String, name: &String): (Object<MovementPepeMeme>, &MovementPepeMeme) {
        let token_address = token::create_token_address(
            creator,
            collection,
            name,
        );
        (object::address_to_object<MovementPepeMeme>(token_address), borrow_global<MovementPepeMeme>(token_address))
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/nft/05-creating-nfts-using-resource-account
Creating NFTs using Resource Account
Creating NFTs using Resource Account
On This Page
Summary
Option 1: Create a new Resource account
Step 1: Understanding Resource Accounts
Step 2: Setting Up the Resource Account
Step 3: Storing the Resource Account Information
Step 4: Creating the NFT Collection
Step 5: Defining the Collection Configuration
Step 6: Implementing the Collection Creation Function
Step 7: Minting NFTs
Fullcode
Option 2: Publish/Mint to an Existing Resource Account
Fullcode
Summary
Resource accounts in Aptos enable programmatic control of assets and actions.
The process involves setting up a resource account, storing account information, and creating an NFT collection.
A CollectionConfig struct is used to manage collection details.
The create_collection function combines all steps to set up the NFT collection.
A mint function allows for creating and transferring NFTs within the collection.
This approach allows for autonomous management of NFTs in decentralized applications.
Option 1: Create a new Resource account
Step 1: Understanding Resource Accounts
Resource accounts in Aptos are a powerful feature that allows for the creation of accounts that can be programmatically controlled. They're particularly useful for creating decentralized applications (dApps) that need to manage assets or perform actions autonomously.
Step 2: Setting Up the Resource Account
To create an NFT collection using a resource account, we first need to set up the account and generate a signer. Here's how we do it:
use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
// Create the resource account
let (resource, resource_cap) = create_resource_account(account, seeds);
// Generate a signer from the resource account
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
In this code:
create_resource_account
creates a new resource account and returns the account address and a capability to generate signers for it.
create_signer_with_capability
uses the capability to create a signer for the resource account.
Step 3: Storing the Resource Account Information
Next, we'll store the resource account information in a custom struct:
struct ResourceInfo has key {
    source: address,
    resource_cap: SignerCapability
}
move_to&lt;ResourceInfo&gt;(&resource_signer_from_cap, ResourceInfo {
    source: account_addr,
    resource_cap: resource_cap
});
This step is crucial because it allows us to retrieve the signer capability later when we need to perform actions on behalf of the resource account.
Step 4: Creating the NFT Collection
Now that we have our resource account set up, we can create the NFT collection:
collection::create_fixed_collection(
    &resource_signer_from_cap,
    collection_description,
    collection_maximum,
    collection_name,
    option::none(),
    collection_uri,
);
This function creates a new collection with a fixed number of tokens. The resource account is the owner of this collection.
Step 5: Defining the Collection Configuration
To keep track of our collection's details, we'll create a
CollectionConfig
struct:
struct CollectionConfig has key {
    collection_name: String,
    collection_description: String,
    collection_maximum: u64,
    collection_uri: String,
    token_counter: u64,
    token_base_name: String,
    token_description: String,
}
This struct will store all the necessary information about our collection, including details for individual tokens.
Step 6: Implementing the Collection Creation Function
Now, let's put it all together in a function that creates the collection:
public entry fun create_collection(
    account: &signer,
    collection_name: String,
    collection_description: String,
    collection_uri: String,
    collection_maximum: u64,
    token_base_name: String,
    token_description: String,
    seeds: vector&lt;u8&gt;
) {
    let (resource, resource_cap) = create_resource_account(account, seeds);
    let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
    let account_addr = signer::address_of(account);
    move_to(&resource_signer_from_cap, ResourceInfo {
        source: account_addr,
        resource_cap: resource_cap
    });
    move_to(&resource_signer_from_cap, CollectionConfig {
        collection_name,
        collection_description,
        collection_maximum,
        collection_uri,
        token_counter: 0,
        token_base_name,
        token_description,
    });
    collection::create_fixed_collection(
        &resource_signer_from_cap,
        collection_description,
        collection_maximum,
        collection_name,
        option::none(),
        collection_uri,
    );
}
This function combines all the previous steps to create a resource account, set up the collection configuration, and create the actual NFT collection.
Step 7: Minting NFTs
Finally, let's implement a function to mint NFTs within our collection:
public entry fun mint(
    nft_claimer: &signer,
    collection_address: address,
    token_name: String,
    token_uri: String
) acquires ResourceInfo, CollectionConfig {
    let nft_claimer_addr = signer::address_of(nft_claimer);
    let collection_config = borrow_global_mut&lt;CollectionConfig&gt;(collection_address);
    let resource_info = borrow_global_mut&lt;ResourceInfo&gt;(collection_address);
    let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
    let constructor_ref = token::create_named_token(
        &resource_signer_from_cap,
        collection_config.collection_name,
        collection_config.collection_description,
        token_name,
        option::none(),
        token_uri
    );
    let token_object = object::object_from_constructor_ref&lt;Token&gt;(&constructor_ref);
    object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
}
This function does the following:
Retrieves the collection configuration and resource info.
Creates a new token within the collection.
Transfers the newly created token to the claimer's address.
Fullcode
module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let (resource, resource_cap) = create_resource_account(account, seeds);
        let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}
Option 2: Publish/Mint to an Existing Resource Account
let (resource, resource_cap) = create_resource_account(account, seeds);
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
The function
account::create_resource_account
simply creates a new resource account, which you can use to deploy or store data, NFTs, etc.
However, in some cases, you may need to deploy or publish a module, or mint NFTs in an existing resource of another account. For this, we'll use the
resource_account::retrieve_resource_account_cap
function from the aptos_framework:
const DEV: address = @dev;
let signer_cap = resource_account::retrieve_resource_account_cap(caller, DEV);
let resource_signer = account::create_signer_with_capability(&signer_cap);
Here, DEV is the address of the pre-existing resource account. In this example, let's create a new resource account using the CLI:
movement account create-resource-account --seed "any-thing"
The result will be a resource account created from the CLI caller's account. In this case:
Transaction submitted: https://explorer.aptoslabs.com/txn/0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb?network=devnet
{
  "Result": {
    "resource_account": "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31",
    "transaction_hash": "0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb",
    "gas_used": 511,
    "gas_unit_price": 100,
    "sender": "1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1729570392468682,
    "version": 95355030,
    "vm_status": "Executed successfully"
  }
}
resource address:
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
source address:
0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
To publish a module to the resource address, create a profile for it in the
./aptos/config.yaml
file:
---
profiles:
  default:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: 1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
  resource:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
Note that the PrivateKey and PublicKey of these two profiles are identical; only the account differs.
Next, modify the
Move.toml
file, changing the module's address to the resource account address:
[package]
name = "movement"
version = "1.0.0"
authors = []
[addresses]
source_addr = "0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97" // owner addr
movement = "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31" // resource addr
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosToken]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token"
[dev-dependencies]
You can now run the command to publish the module to the resource account
movement = f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. If you encounter a GAS error, run this CLI command to fund the
resource profile
:
movement account fund-with-faucet --account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31 --amount 100000000
After funding, you can publish using this CLI command:
movement move publish --profile resource
or using sender account is
resource_address
movement move publish --sender-account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
If successful, check the modules of the
resource addr
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. You should see your module, its functions, and other data and resources.
Fullcode
module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::resource_account;
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    const SOURCE_ADDR: address = @source_addr;
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let resource_cap_cap = resource_account::retrieve_resource_account_cap(caller, SOURCE_ADDR);
        let resource_signer = account::create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}
On This Page
Summary
Option 1: Create a new Resource account
Step 1: Understanding Resource Accounts
Step 2: Setting Up the Resource Account
Step 3: Storing the Resource Account Information
Step 4: Creating the NFT Collection
Step 5: Defining the Collection Configuration
Step 6: Implementing the Collection Creation Function
Step 7: Minting NFTs
Fullcode
Option 2: Publish/Mint to an Existing Resource Account
Fullcode
On This Page
Summary
Option 1: Create a new Resource account
Step 1: Understanding Resource Accounts
Step 2: Setting Up the Resource Account
Step 3: Storing the Resource Account Information
Step 4: Creating the NFT Collection
Step 5: Defining the Collection Configuration
Step 6: Implementing the Collection Creation Function
Step 7: Minting NFTs
Fullcode
Option 2: Publish/Mint to an Existing Resource Account
Fullcode
			On This Page
			On This Page
			Summary
Option 1: Create a new Resource account
Step 1: Understanding Resource Accounts
Step 2: Setting Up the Resource Account
Step 3: Storing the Resource Account Information
Step 4: Creating the NFT Collection
Step 5: Defining the Collection Configuration
Step 6: Implementing the Collection Creation Function
Step 7: Minting NFTs
Fullcode
Option 2: Publish/Mint to an Existing Resource Account
Fullcode
			Summary
			Summary
			Summary
			Summary
			Option 1: Create a new Resource account
Step 1: Understanding Resource Accounts
Step 2: Setting Up the Resource Account
Step 3: Storing the Resource Account Information
Step 4: Creating the NFT Collection
Step 5: Defining the Collection Configuration
Step 6: Implementing the Collection Creation Function
Step 7: Minting NFTs
Fullcode
			Option 1: Create a new Resource account
			Option 1: Create a new Resource account
			Option 1: Create a new Resource account
			Step 1: Understanding Resource Accounts
Step 2: Setting Up the Resource Account
Step 3: Storing the Resource Account Information
Step 4: Creating the NFT Collection
Step 5: Defining the Collection Configuration
Step 6: Implementing the Collection Creation Function
Step 7: Minting NFTs
Fullcode
			Step 1: Understanding Resource Accounts
			Step 1: Understanding Resource Accounts
			Step 1: Understanding Resource Accounts
			Step 1: Understanding Resource Accounts
			Step 2: Setting Up the Resource Account
			Step 2: Setting Up the Resource Account
			Step 2: Setting Up the Resource Account
			Step 2: Setting Up the Resource Account
			Step 3: Storing the Resource Account Information
			Step 3: Storing the Resource Account Information
			Step 3: Storing the Resource Account Information
			Step 3: Storing the Resource Account Information
			Step 4: Creating the NFT Collection
			Step 4: Creating the NFT Collection
			Step 4: Creating the NFT Collection
			Step 4: Creating the NFT Collection
			Step 5: Defining the Collection Configuration
			Step 5: Defining the Collection Configuration
			Step 5: Defining the Collection Configuration
			Step 5: Defining the Collection Configuration
			Step 6: Implementing the Collection Creation Function
			Step 6: Implementing the Collection Creation Function
			Step 6: Implementing the Collection Creation Function
			Step 6: Implementing the Collection Creation Function
			Step 7: Minting NFTs
			Step 7: Minting NFTs
			Step 7: Minting NFTs
			Step 7: Minting NFTs
			Fullcode
			Fullcode
			Fullcode
			Fullcode
			Option 2: Publish/Mint to an Existing Resource Account
Fullcode
			Option 2: Publish/Mint to an Existing Resource Account
			Option 2: Publish/Mint to an Existing Resource Account
			Option 2: Publish/Mint to an Existing Resource Account
			Fullcode
			Fullcode
			Fullcode
			Fullcode
			Fullcode
			Summary
Resource accounts in Aptos enable programmatic control of assets and actions.
The process involves setting up a resource account, storing account information, and creating an NFT collection.
A CollectionConfig struct is used to manage collection details.
The create_collection function combines all steps to set up the NFT collection.
A mint function allows for creating and transferring NFTs within the collection.
This approach allows for autonomous management of NFTs in decentralized applications.
Option 1: Create a new Resource account
Step 1: Understanding Resource Accounts
Resource accounts in Aptos are a powerful feature that allows for the creation of accounts that can be programmatically controlled. They're particularly useful for creating decentralized applications (dApps) that need to manage assets or perform actions autonomously.
Step 2: Setting Up the Resource Account
To create an NFT collection using a resource account, we first need to set up the account and generate a signer. Here's how we do it:
use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
// Create the resource account
let (resource, resource_cap) = create_resource_account(account, seeds);
// Generate a signer from the resource account
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
In this code:
create_resource_account
creates a new resource account and returns the account address and a capability to generate signers for it.
create_signer_with_capability
uses the capability to create a signer for the resource account.
Step 3: Storing the Resource Account Information
Next, we'll store the resource account information in a custom struct:
struct ResourceInfo has key {
    source: address,
    resource_cap: SignerCapability
}
move_to&lt;ResourceInfo&gt;(&resource_signer_from_cap, ResourceInfo {
    source: account_addr,
    resource_cap: resource_cap
});
This step is crucial because it allows us to retrieve the signer capability later when we need to perform actions on behalf of the resource account.
Step 4: Creating the NFT Collection
Now that we have our resource account set up, we can create the NFT collection:
collection::create_fixed_collection(
    &resource_signer_from_cap,
    collection_description,
    collection_maximum,
    collection_name,
    option::none(),
    collection_uri,
);
This function creates a new collection with a fixed number of tokens. The resource account is the owner of this collection.
Step 5: Defining the Collection Configuration
To keep track of our collection's details, we'll create a
CollectionConfig
struct:
struct CollectionConfig has key {
    collection_name: String,
    collection_description: String,
    collection_maximum: u64,
    collection_uri: String,
    token_counter: u64,
    token_base_name: String,
    token_description: String,
}
This struct will store all the necessary information about our collection, including details for individual tokens.
Step 6: Implementing the Collection Creation Function
Now, let's put it all together in a function that creates the collection:
public entry fun create_collection(
    account: &signer,
    collection_name: String,
    collection_description: String,
    collection_uri: String,
    collection_maximum: u64,
    token_base_name: String,
    token_description: String,
    seeds: vector&lt;u8&gt;
) {
    let (resource, resource_cap) = create_resource_account(account, seeds);
    let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
    let account_addr = signer::address_of(account);
    move_to(&resource_signer_from_cap, ResourceInfo {
        source: account_addr,
        resource_cap: resource_cap
    });
    move_to(&resource_signer_from_cap, CollectionConfig {
        collection_name,
        collection_description,
        collection_maximum,
        collection_uri,
        token_counter: 0,
        token_base_name,
        token_description,
    });
    collection::create_fixed_collection(
        &resource_signer_from_cap,
        collection_description,
        collection_maximum,
        collection_name,
        option::none(),
        collection_uri,
    );
}
This function combines all the previous steps to create a resource account, set up the collection configuration, and create the actual NFT collection.
Step 7: Minting NFTs
Finally, let's implement a function to mint NFTs within our collection:
public entry fun mint(
    nft_claimer: &signer,
    collection_address: address,
    token_name: String,
    token_uri: String
) acquires ResourceInfo, CollectionConfig {
    let nft_claimer_addr = signer::address_of(nft_claimer);
    let collection_config = borrow_global_mut&lt;CollectionConfig&gt;(collection_address);
    let resource_info = borrow_global_mut&lt;ResourceInfo&gt;(collection_address);
    let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
    let constructor_ref = token::create_named_token(
        &resource_signer_from_cap,
        collection_config.collection_name,
        collection_config.collection_description,
        token_name,
        option::none(),
        token_uri
    );
    let token_object = object::object_from_constructor_ref&lt;Token&gt;(&constructor_ref);
    object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
}
This function does the following:
Retrieves the collection configuration and resource info.
Creates a new token within the collection.
Transfers the newly created token to the claimer's address.
Fullcode
module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let (resource, resource_cap) = create_resource_account(account, seeds);
        let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}
Option 2: Publish/Mint to an Existing Resource Account
let (resource, resource_cap) = create_resource_account(account, seeds);
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
The function
account::create_resource_account
simply creates a new resource account, which you can use to deploy or store data, NFTs, etc.
However, in some cases, you may need to deploy or publish a module, or mint NFTs in an existing resource of another account. For this, we'll use the
resource_account::retrieve_resource_account_cap
function from the aptos_framework:
const DEV: address = @dev;
let signer_cap = resource_account::retrieve_resource_account_cap(caller, DEV);
let resource_signer = account::create_signer_with_capability(&signer_cap);
Here, DEV is the address of the pre-existing resource account. In this example, let's create a new resource account using the CLI:
movement account create-resource-account --seed "any-thing"
The result will be a resource account created from the CLI caller's account. In this case:
Transaction submitted: https://explorer.aptoslabs.com/txn/0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb?network=devnet
{
  "Result": {
    "resource_account": "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31",
    "transaction_hash": "0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb",
    "gas_used": 511,
    "gas_unit_price": 100,
    "sender": "1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1729570392468682,
    "version": 95355030,
    "vm_status": "Executed successfully"
  }
}
resource address:
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
source address:
0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
To publish a module to the resource address, create a profile for it in the
./aptos/config.yaml
file:
---
profiles:
  default:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: 1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
  resource:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
Note that the PrivateKey and PublicKey of these two profiles are identical; only the account differs.
Next, modify the
Move.toml
file, changing the module's address to the resource account address:
[package]
name = "movement"
version = "1.0.0"
authors = []
[addresses]
source_addr = "0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97" // owner addr
movement = "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31" // resource addr
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosToken]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token"
[dev-dependencies]
You can now run the command to publish the module to the resource account
movement = f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. If you encounter a GAS error, run this CLI command to fund the
resource profile
:
movement account fund-with-faucet --account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31 --amount 100000000
After funding, you can publish using this CLI command:
movement move publish --profile resource
or using sender account is
resource_address
movement move publish --sender-account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
If successful, check the modules of the
resource addr
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. You should see your module, its functions, and other data and resources.
Fullcode
module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::resource_account;
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    const SOURCE_ADDR: address = @source_addr;
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let resource_cap_cap = resource_account::retrieve_resource_account_cap(caller, SOURCE_ADDR);
        let resource_signer = account::create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}
			Summary
Resource accounts in Aptos enable programmatic control of assets and actions.
The process involves setting up a resource account, storing account information, and creating an NFT collection.
A CollectionConfig struct is used to manage collection details.
The create_collection function combines all steps to set up the NFT collection.
A mint function allows for creating and transferring NFTs within the collection.
This approach allows for autonomous management of NFTs in decentralized applications.
Option 1: Create a new Resource account
Step 1: Understanding Resource Accounts
Resource accounts in Aptos are a powerful feature that allows for the creation of accounts that can be programmatically controlled. They're particularly useful for creating decentralized applications (dApps) that need to manage assets or perform actions autonomously.
Step 2: Setting Up the Resource Account
To create an NFT collection using a resource account, we first need to set up the account and generate a signer. Here's how we do it:
use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
// Create the resource account
let (resource, resource_cap) = create_resource_account(account, seeds);
// Generate a signer from the resource account
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
In this code:
create_resource_account
creates a new resource account and returns the account address and a capability to generate signers for it.
create_signer_with_capability
uses the capability to create a signer for the resource account.
Step 3: Storing the Resource Account Information
Next, we'll store the resource account information in a custom struct:
struct ResourceInfo has key {
    source: address,
    resource_cap: SignerCapability
}
move_to&lt;ResourceInfo&gt;(&resource_signer_from_cap, ResourceInfo {
    source: account_addr,
    resource_cap: resource_cap
});
This step is crucial because it allows us to retrieve the signer capability later when we need to perform actions on behalf of the resource account.
Step 4: Creating the NFT Collection
Now that we have our resource account set up, we can create the NFT collection:
collection::create_fixed_collection(
    &resource_signer_from_cap,
    collection_description,
    collection_maximum,
    collection_name,
    option::none(),
    collection_uri,
);
This function creates a new collection with a fixed number of tokens. The resource account is the owner of this collection.
Step 5: Defining the Collection Configuration
To keep track of our collection's details, we'll create a
CollectionConfig
struct:
struct CollectionConfig has key {
    collection_name: String,
    collection_description: String,
    collection_maximum: u64,
    collection_uri: String,
    token_counter: u64,
    token_base_name: String,
    token_description: String,
}
This struct will store all the necessary information about our collection, including details for individual tokens.
Step 6: Implementing the Collection Creation Function
Now, let's put it all together in a function that creates the collection:
public entry fun create_collection(
    account: &signer,
    collection_name: String,
    collection_description: String,
    collection_uri: String,
    collection_maximum: u64,
    token_base_name: String,
    token_description: String,
    seeds: vector&lt;u8&gt;
) {
    let (resource, resource_cap) = create_resource_account(account, seeds);
    let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
    let account_addr = signer::address_of(account);
    move_to(&resource_signer_from_cap, ResourceInfo {
        source: account_addr,
        resource_cap: resource_cap
    });
    move_to(&resource_signer_from_cap, CollectionConfig {
        collection_name,
        collection_description,
        collection_maximum,
        collection_uri,
        token_counter: 0,
        token_base_name,
        token_description,
    });
    collection::create_fixed_collection(
        &resource_signer_from_cap,
        collection_description,
        collection_maximum,
        collection_name,
        option::none(),
        collection_uri,
    );
}
This function combines all the previous steps to create a resource account, set up the collection configuration, and create the actual NFT collection.
Step 7: Minting NFTs
Finally, let's implement a function to mint NFTs within our collection:
public entry fun mint(
    nft_claimer: &signer,
    collection_address: address,
    token_name: String,
    token_uri: String
) acquires ResourceInfo, CollectionConfig {
    let nft_claimer_addr = signer::address_of(nft_claimer);
    let collection_config = borrow_global_mut&lt;CollectionConfig&gt;(collection_address);
    let resource_info = borrow_global_mut&lt;ResourceInfo&gt;(collection_address);
    let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
    let constructor_ref = token::create_named_token(
        &resource_signer_from_cap,
        collection_config.collection_name,
        collection_config.collection_description,
        token_name,
        option::none(),
        token_uri
    );
    let token_object = object::object_from_constructor_ref&lt;Token&gt;(&constructor_ref);
    object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
}
This function does the following:
Retrieves the collection configuration and resource info.
Creates a new token within the collection.
Transfers the newly created token to the claimer's address.
Fullcode
module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let (resource, resource_cap) = create_resource_account(account, seeds);
        let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}
Option 2: Publish/Mint to an Existing Resource Account
let (resource, resource_cap) = create_resource_account(account, seeds);
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
The function
account::create_resource_account
simply creates a new resource account, which you can use to deploy or store data, NFTs, etc.
However, in some cases, you may need to deploy or publish a module, or mint NFTs in an existing resource of another account. For this, we'll use the
resource_account::retrieve_resource_account_cap
function from the aptos_framework:
const DEV: address = @dev;
let signer_cap = resource_account::retrieve_resource_account_cap(caller, DEV);
let resource_signer = account::create_signer_with_capability(&signer_cap);
Here, DEV is the address of the pre-existing resource account. In this example, let's create a new resource account using the CLI:
movement account create-resource-account --seed "any-thing"
The result will be a resource account created from the CLI caller's account. In this case:
Transaction submitted: https://explorer.aptoslabs.com/txn/0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb?network=devnet
{
  "Result": {
    "resource_account": "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31",
    "transaction_hash": "0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb",
    "gas_used": 511,
    "gas_unit_price": 100,
    "sender": "1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1729570392468682,
    "version": 95355030,
    "vm_status": "Executed successfully"
  }
}
resource address:
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
source address:
0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
To publish a module to the resource address, create a profile for it in the
./aptos/config.yaml
file:
---
profiles:
  default:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: 1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
  resource:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
Note that the PrivateKey and PublicKey of these two profiles are identical; only the account differs.
Next, modify the
Move.toml
file, changing the module's address to the resource account address:
[package]
name = "movement"
version = "1.0.0"
authors = []
[addresses]
source_addr = "0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97" // owner addr
movement = "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31" // resource addr
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosToken]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token"
[dev-dependencies]
You can now run the command to publish the module to the resource account
movement = f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. If you encounter a GAS error, run this CLI command to fund the
resource profile
:
movement account fund-with-faucet --account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31 --amount 100000000
After funding, you can publish using this CLI command:
movement move publish --profile resource
or using sender account is
resource_address
movement move publish --sender-account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
If successful, check the modules of the
resource addr
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. You should see your module, its functions, and other data and resources.
Fullcode
module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::resource_account;
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    const SOURCE_ADDR: address = @source_addr;
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let resource_cap_cap = resource_account::retrieve_resource_account_cap(caller, SOURCE_ADDR);
        let resource_signer = account::create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}
			Summary
Resource accounts in Aptos enable programmatic control of assets and actions.
The process involves setting up a resource account, storing account information, and creating an NFT collection.
A CollectionConfig struct is used to manage collection details.
The create_collection function combines all steps to set up the NFT collection.
A mint function allows for creating and transferring NFTs within the collection.
This approach allows for autonomous management of NFTs in decentralized applications.
Option 1: Create a new Resource account
Step 1: Understanding Resource Accounts
Resource accounts in Aptos are a powerful feature that allows for the creation of accounts that can be programmatically controlled. They're particularly useful for creating decentralized applications (dApps) that need to manage assets or perform actions autonomously.
Step 2: Setting Up the Resource Account
To create an NFT collection using a resource account, we first need to set up the account and generate a signer. Here's how we do it:
use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
// Create the resource account
let (resource, resource_cap) = create_resource_account(account, seeds);
// Generate a signer from the resource account
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
In this code:
create_resource_account
creates a new resource account and returns the account address and a capability to generate signers for it.
create_signer_with_capability
uses the capability to create a signer for the resource account.
Step 3: Storing the Resource Account Information
Next, we'll store the resource account information in a custom struct:
struct ResourceInfo has key {
    source: address,
    resource_cap: SignerCapability
}
move_to&lt;ResourceInfo&gt;(&resource_signer_from_cap, ResourceInfo {
    source: account_addr,
    resource_cap: resource_cap
});
This step is crucial because it allows us to retrieve the signer capability later when we need to perform actions on behalf of the resource account.
Step 4: Creating the NFT Collection
Now that we have our resource account set up, we can create the NFT collection:
collection::create_fixed_collection(
    &resource_signer_from_cap,
    collection_description,
    collection_maximum,
    collection_name,
    option::none(),
    collection_uri,
);
This function creates a new collection with a fixed number of tokens. The resource account is the owner of this collection.
Step 5: Defining the Collection Configuration
To keep track of our collection's details, we'll create a
CollectionConfig
struct:
struct CollectionConfig has key {
    collection_name: String,
    collection_description: String,
    collection_maximum: u64,
    collection_uri: String,
    token_counter: u64,
    token_base_name: String,
    token_description: String,
}
This struct will store all the necessary information about our collection, including details for individual tokens.
Step 6: Implementing the Collection Creation Function
Now, let's put it all together in a function that creates the collection:
public entry fun create_collection(
    account: &signer,
    collection_name: String,
    collection_description: String,
    collection_uri: String,
    collection_maximum: u64,
    token_base_name: String,
    token_description: String,
    seeds: vector&lt;u8&gt;
) {
    let (resource, resource_cap) = create_resource_account(account, seeds);
    let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
    let account_addr = signer::address_of(account);
    move_to(&resource_signer_from_cap, ResourceInfo {
        source: account_addr,
        resource_cap: resource_cap
    });
    move_to(&resource_signer_from_cap, CollectionConfig {
        collection_name,
        collection_description,
        collection_maximum,
        collection_uri,
        token_counter: 0,
        token_base_name,
        token_description,
    });
    collection::create_fixed_collection(
        &resource_signer_from_cap,
        collection_description,
        collection_maximum,
        collection_name,
        option::none(),
        collection_uri,
    );
}
This function combines all the previous steps to create a resource account, set up the collection configuration, and create the actual NFT collection.
Step 7: Minting NFTs
Finally, let's implement a function to mint NFTs within our collection:
public entry fun mint(
    nft_claimer: &signer,
    collection_address: address,
    token_name: String,
    token_uri: String
) acquires ResourceInfo, CollectionConfig {
    let nft_claimer_addr = signer::address_of(nft_claimer);
    let collection_config = borrow_global_mut&lt;CollectionConfig&gt;(collection_address);
    let resource_info = borrow_global_mut&lt;ResourceInfo&gt;(collection_address);
    let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
    let constructor_ref = token::create_named_token(
        &resource_signer_from_cap,
        collection_config.collection_name,
        collection_config.collection_description,
        token_name,
        option::none(),
        token_uri
    );
    let token_object = object::object_from_constructor_ref&lt;Token&gt;(&constructor_ref);
    object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
}
This function does the following:
Retrieves the collection configuration and resource info.
Creates a new token within the collection.
Transfers the newly created token to the claimer's address.
Fullcode
module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let (resource, resource_cap) = create_resource_account(account, seeds);
        let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}
Option 2: Publish/Mint to an Existing Resource Account
let (resource, resource_cap) = create_resource_account(account, seeds);
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
The function
account::create_resource_account
simply creates a new resource account, which you can use to deploy or store data, NFTs, etc.
However, in some cases, you may need to deploy or publish a module, or mint NFTs in an existing resource of another account. For this, we'll use the
resource_account::retrieve_resource_account_cap
function from the aptos_framework:
const DEV: address = @dev;
let signer_cap = resource_account::retrieve_resource_account_cap(caller, DEV);
let resource_signer = account::create_signer_with_capability(&signer_cap);
Here, DEV is the address of the pre-existing resource account. In this example, let's create a new resource account using the CLI:
movement account create-resource-account --seed "any-thing"
The result will be a resource account created from the CLI caller's account. In this case:
Transaction submitted: https://explorer.aptoslabs.com/txn/0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb?network=devnet
{
  "Result": {
    "resource_account": "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31",
    "transaction_hash": "0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb",
    "gas_used": 511,
    "gas_unit_price": 100,
    "sender": "1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1729570392468682,
    "version": 95355030,
    "vm_status": "Executed successfully"
  }
}
resource address:
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
source address:
0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
To publish a module to the resource address, create a profile for it in the
./aptos/config.yaml
file:
---
profiles:
  default:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: 1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
  resource:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
Note that the PrivateKey and PublicKey of these two profiles are identical; only the account differs.
Next, modify the
Move.toml
file, changing the module's address to the resource account address:
[package]
name = "movement"
version = "1.0.0"
authors = []
[addresses]
source_addr = "0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97" // owner addr
movement = "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31" // resource addr
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosToken]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token"
[dev-dependencies]
You can now run the command to publish the module to the resource account
movement = f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. If you encounter a GAS error, run this CLI command to fund the
resource profile
:
movement account fund-with-faucet --account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31 --amount 100000000
After funding, you can publish using this CLI command:
movement move publish --profile resource
or using sender account is
resource_address
movement move publish --sender-account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
If successful, check the modules of the
resource addr
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. You should see your module, its functions, and other data and resources.
Fullcode
module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::resource_account;
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    const SOURCE_ADDR: address = @source_addr;
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let resource_cap_cap = resource_account::retrieve_resource_account_cap(caller, SOURCE_ADDR);
        let resource_signer = account::create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}
	Summary
	Summary
	Resource accounts in Aptos enable programmatic control of assets and actions.
The process involves setting up a resource account, storing account information, and creating an NFT collection.
A CollectionConfig struct is used to manage collection details.
The create_collection function combines all steps to set up the NFT collection.
A mint function allows for creating and transferring NFTs within the collection.
This approach allows for autonomous management of NFTs in decentralized applications.
	Resource accounts in Aptos enable programmatic control of assets and actions.
	Resource accounts in Aptos enable programmatic control of assets and actions.
	The process involves setting up a resource account, storing account information, and creating an NFT collection.
	The process involves setting up a resource account, storing account information, and creating an NFT collection.
	A CollectionConfig struct is used to manage collection details.
	A CollectionConfig struct is used to manage collection details.
	The create_collection function combines all steps to set up the NFT collection.
	The create_collection function combines all steps to set up the NFT collection.
	A mint function allows for creating and transferring NFTs within the collection.
	A mint function allows for creating and transferring NFTs within the collection.
	This approach allows for autonomous management of NFTs in decentralized applications.
	This approach allows for autonomous management of NFTs in decentralized applications.
Option 1: Create a new Resource account
Option 1: Create a new Resource account
		Step 1: Understanding Resource Accounts
		Step 1: Understanding Resource Accounts
		Resource accounts in Aptos are a powerful feature that allows for the creation of accounts that can be programmatically controlled. They're particularly useful for creating decentralized applications (dApps) that need to manage assets or perform actions autonomously.
		Resource accounts in Aptos are a powerful feature that allows for the creation of accounts that can be programmatically controlled. They're particularly useful for creating decentralized applications (dApps) that need to manage assets or perform actions autonomously.
		Step 2: Setting Up the Resource Account
		Step 2: Setting Up the Resource Account
		To create an NFT collection using a resource account, we first need to set up the account and generate a signer. Here's how we do it:
		To create an NFT collection using a resource account, we first need to set up the account and generate a signer. Here's how we do it:
		<code>use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
// Create the resource account
let (resource, resource_cap) = create_resource_account(account, seeds);
// Generate a signer from the resource account
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);</code>
		<code>use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
// Create the resource account
let (resource, resource_cap) = create_resource_account(account, seeds);
// Generate a signer from the resource account
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);</code>
		use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
// Create the resource account
let (resource, resource_cap) = create_resource_account(account, seeds);
// Generate a signer from the resource account
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
		In this code:
		In this code:
		create_resource_account
creates a new resource account and returns the account address and a capability to generate signers for it.
create_signer_with_capability
uses the capability to create a signer for the resource account.
		create_resource_account
creates a new resource account and returns the account address and a capability to generate signers for it.
		<code>create_resource_account</code>
		create_resource_account
		creates a new resource account and returns the account address and a capability to generate signers for it.
		create_signer_with_capability
uses the capability to create a signer for the resource account.
		<code>create_signer_with_capability</code>
		create_signer_with_capability
		uses the capability to create a signer for the resource account.
		Step 3: Storing the Resource Account Information
		Step 3: Storing the Resource Account Information
		Next, we'll store the resource account information in a custom struct:
		Next, we'll store the resource account information in a custom struct:
		<code>struct ResourceInfo has key {
    source: address,
    resource_cap: SignerCapability
}
move_to&lt;ResourceInfo&gt;(&resource_signer_from_cap, ResourceInfo {
    source: account_addr,
    resource_cap: resource_cap
});</code>
		<code>struct ResourceInfo has key {
    source: address,
    resource_cap: SignerCapability
}
move_to&lt;ResourceInfo&gt;(&resource_signer_from_cap, ResourceInfo {
    source: account_addr,
    resource_cap: resource_cap
});</code>
		struct ResourceInfo has key {
    source: address,
    resource_cap: SignerCapability
}
move_to&lt;ResourceInfo&gt;(&resource_signer_from_cap, ResourceInfo {
    source: account_addr,
    resource_cap: resource_cap
});
		This step is crucial because it allows us to retrieve the signer capability later when we need to perform actions on behalf of the resource account.
		This step is crucial because it allows us to retrieve the signer capability later when we need to perform actions on behalf of the resource account.
		Step 4: Creating the NFT Collection
		Step 4: Creating the NFT Collection
		Now that we have our resource account set up, we can create the NFT collection:
		Now that we have our resource account set up, we can create the NFT collection:
		<code>collection::create_fixed_collection(
    &resource_signer_from_cap,
    collection_description,
    collection_maximum,
    collection_name,
    option::none(),
    collection_uri,
);</code>
		<code>collection::create_fixed_collection(
    &resource_signer_from_cap,
    collection_description,
    collection_maximum,
    collection_name,
    option::none(),
    collection_uri,
);</code>
		collection::create_fixed_collection(
    &resource_signer_from_cap,
    collection_description,
    collection_maximum,
    collection_name,
    option::none(),
    collection_uri,
);
		This function creates a new collection with a fixed number of tokens. The resource account is the owner of this collection.
		This function creates a new collection with a fixed number of tokens. The resource account is the owner of this collection.
		Step 5: Defining the Collection Configuration
		Step 5: Defining the Collection Configuration
		To keep track of our collection's details, we'll create a
CollectionConfig
struct:
		To keep track of our collection's details, we'll create a
		<code>CollectionConfig</code>
		CollectionConfig
		struct:
		<code>struct CollectionConfig has key {
    collection_name: String,
    collection_description: String,
    collection_maximum: u64,
    collection_uri: String,
    token_counter: u64,
    token_base_name: String,
    token_description: String,
}</code>
		<code>struct CollectionConfig has key {
    collection_name: String,
    collection_description: String,
    collection_maximum: u64,
    collection_uri: String,
    token_counter: u64,
    token_base_name: String,
    token_description: String,
}</code>
		struct CollectionConfig has key {
    collection_name: String,
    collection_description: String,
    collection_maximum: u64,
    collection_uri: String,
    token_counter: u64,
    token_base_name: String,
    token_description: String,
}
		This struct will store all the necessary information about our collection, including details for individual tokens.
		This struct will store all the necessary information about our collection, including details for individual tokens.
		Step 6: Implementing the Collection Creation Function
		Step 6: Implementing the Collection Creation Function
		Now, let's put it all together in a function that creates the collection:
		Now, let's put it all together in a function that creates the collection:
		<code>public entry fun create_collection(
    account: &signer,
    collection_name: String,
    collection_description: String,
    collection_uri: String,
    collection_maximum: u64,
    token_base_name: String,
    token_description: String,
    seeds: vector&lt;u8&gt;
) {
    let (resource, resource_cap) = create_resource_account(account, seeds);
    let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
    let account_addr = signer::address_of(account);
    move_to(&resource_signer_from_cap, ResourceInfo {
        source: account_addr,
        resource_cap: resource_cap
    });
    move_to(&resource_signer_from_cap, CollectionConfig {
        collection_name,
        collection_description,
        collection_maximum,
        collection_uri,
        token_counter: 0,
        token_base_name,
        token_description,
    });
    collection::create_fixed_collection(
        &resource_signer_from_cap,
        collection_description,
        collection_maximum,
        collection_name,
        option::none(),
        collection_uri,
    );
}</code>
		<code>public entry fun create_collection(
    account: &signer,
    collection_name: String,
    collection_description: String,
    collection_uri: String,
    collection_maximum: u64,
    token_base_name: String,
    token_description: String,
    seeds: vector&lt;u8&gt;
) {
    let (resource, resource_cap) = create_resource_account(account, seeds);
    let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
    let account_addr = signer::address_of(account);
    move_to(&resource_signer_from_cap, ResourceInfo {
        source: account_addr,
        resource_cap: resource_cap
    });
    move_to(&resource_signer_from_cap, CollectionConfig {
        collection_name,
        collection_description,
        collection_maximum,
        collection_uri,
        token_counter: 0,
        token_base_name,
        token_description,
    });
    collection::create_fixed_collection(
        &resource_signer_from_cap,
        collection_description,
        collection_maximum,
        collection_name,
        option::none(),
        collection_uri,
    );
}</code>
		public entry fun create_collection(
    account: &signer,
    collection_name: String,
    collection_description: String,
    collection_uri: String,
    collection_maximum: u64,
    token_base_name: String,
    token_description: String,
    seeds: vector&lt;u8&gt;
) {
    let (resource, resource_cap) = create_resource_account(account, seeds);
    let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
    let account_addr = signer::address_of(account);
    move_to(&resource_signer_from_cap, ResourceInfo {
        source: account_addr,
        resource_cap: resource_cap
    });
    move_to(&resource_signer_from_cap, CollectionConfig {
        collection_name,
        collection_description,
        collection_maximum,
        collection_uri,
        token_counter: 0,
        token_base_name,
        token_description,
    });
    collection::create_fixed_collection(
        &resource_signer_from_cap,
        collection_description,
        collection_maximum,
        collection_name,
        option::none(),
        collection_uri,
    );
}
		This function combines all the previous steps to create a resource account, set up the collection configuration, and create the actual NFT collection.
		This function combines all the previous steps to create a resource account, set up the collection configuration, and create the actual NFT collection.
		Step 7: Minting NFTs
		Step 7: Minting NFTs
		Finally, let's implement a function to mint NFTs within our collection:
		Finally, let's implement a function to mint NFTs within our collection:
		<code>public entry fun mint(
    nft_claimer: &signer,
    collection_address: address,
    token_name: String,
    token_uri: String
) acquires ResourceInfo, CollectionConfig {
    let nft_claimer_addr = signer::address_of(nft_claimer);
    let collection_config = borrow_global_mut&lt;CollectionConfig&gt;(collection_address);
    let resource_info = borrow_global_mut&lt;ResourceInfo&gt;(collection_address);
    let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
    let constructor_ref = token::create_named_token(
        &resource_signer_from_cap,
        collection_config.collection_name,
        collection_config.collection_description,
        token_name,
        option::none(),
        token_uri
    );
    let token_object = object::object_from_constructor_ref&lt;Token&gt;(&constructor_ref);
    object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
}</code>
		<code>public entry fun mint(
    nft_claimer: &signer,
    collection_address: address,
    token_name: String,
    token_uri: String
) acquires ResourceInfo, CollectionConfig {
    let nft_claimer_addr = signer::address_of(nft_claimer);
    let collection_config = borrow_global_mut&lt;CollectionConfig&gt;(collection_address);
    let resource_info = borrow_global_mut&lt;ResourceInfo&gt;(collection_address);
    let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
    let constructor_ref = token::create_named_token(
        &resource_signer_from_cap,
        collection_config.collection_name,
        collection_config.collection_description,
        token_name,
        option::none(),
        token_uri
    );
    let token_object = object::object_from_constructor_ref&lt;Token&gt;(&constructor_ref);
    object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
}</code>
		public entry fun mint(
    nft_claimer: &signer,
    collection_address: address,
    token_name: String,
    token_uri: String
) acquires ResourceInfo, CollectionConfig {
    let nft_claimer_addr = signer::address_of(nft_claimer);
    let collection_config = borrow_global_mut&lt;CollectionConfig&gt;(collection_address);
    let resource_info = borrow_global_mut&lt;ResourceInfo&gt;(collection_address);
    let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
    let constructor_ref = token::create_named_token(
        &resource_signer_from_cap,
        collection_config.collection_name,
        collection_config.collection_description,
        token_name,
        option::none(),
        token_uri
    );
    let token_object = object::object_from_constructor_ref&lt;Token&gt;(&constructor_ref);
    object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
}
		This function does the following:
		This function does the following:
		Retrieves the collection configuration and resource info.
Creates a new token within the collection.
Transfers the newly created token to the claimer's address.
		Retrieves the collection configuration and resource info.
		Retrieves the collection configuration and resource info.
		Creates a new token within the collection.
		Creates a new token within the collection.
		Transfers the newly created token to the claimer's address.
		Transfers the newly created token to the claimer's address.
		Fullcode
		Fullcode
		<code>module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let (resource, resource_cap) = create_resource_account(account, seeds);
        let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}</code>
		<code>module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let (resource, resource_cap) = create_resource_account(account, seeds);
        let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}</code>
		module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let (resource, resource_cap) = create_resource_account(account, seeds);
        let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}
Option 2: Publish/Mint to an Existing Resource Account
Option 2: Publish/Mint to an Existing Resource Account
<code>let (resource, resource_cap) = create_resource_account(account, seeds);
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);</code>
<code>let (resource, resource_cap) = create_resource_account(account, seeds);
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);</code>
let (resource, resource_cap) = create_resource_account(account, seeds);
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
The function
account::create_resource_account
simply creates a new resource account, which you can use to deploy or store data, NFTs, etc.
The function
<code>account::create_resource_account</code>
account::create_resource_account
simply creates a new resource account, which you can use to deploy or store data, NFTs, etc.
However, in some cases, you may need to deploy or publish a module, or mint NFTs in an existing resource of another account. For this, we'll use the
resource_account::retrieve_resource_account_cap
function from the aptos_framework:
However, in some cases, you may need to deploy or publish a module, or mint NFTs in an existing resource of another account. For this, we'll use the
<code>resource_account::retrieve_resource_account_cap</code>
resource_account::retrieve_resource_account_cap
function from the aptos_framework:
<code>const DEV: address = @dev;
let signer_cap = resource_account::retrieve_resource_account_cap(caller, DEV);
let resource_signer = account::create_signer_with_capability(&signer_cap);</code>
<code>const DEV: address = @dev;
let signer_cap = resource_account::retrieve_resource_account_cap(caller, DEV);
let resource_signer = account::create_signer_with_capability(&signer_cap);</code>
const DEV: address = @dev;
let signer_cap = resource_account::retrieve_resource_account_cap(caller, DEV);
let resource_signer = account::create_signer_with_capability(&signer_cap);
Here, DEV is the address of the pre-existing resource account. In this example, let's create a new resource account using the CLI:
Here, DEV is the address of the pre-existing resource account. In this example, let's create a new resource account using the CLI:
<code>movement account create-resource-account --seed "any-thing"</code>
<code>movement account create-resource-account --seed "any-thing"</code>
movement account create-resource-account --seed "any-thing"
The result will be a resource account created from the CLI caller's account. In this case:
The result will be a resource account created from the CLI caller's account. In this case:
<code>Transaction submitted: https://explorer.aptoslabs.com/txn/0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb?network=devnet
{
  "Result": {
    "resource_account": "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31",
    "transaction_hash": "0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb",
    "gas_used": 511,
    "gas_unit_price": 100,
    "sender": "1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1729570392468682,
    "version": 95355030,
    "vm_status": "Executed successfully"
  }
}</code>
<code>Transaction submitted: https://explorer.aptoslabs.com/txn/0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb?network=devnet
{
  "Result": {
    "resource_account": "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31",
    "transaction_hash": "0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb",
    "gas_used": 511,
    "gas_unit_price": 100,
    "sender": "1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1729570392468682,
    "version": 95355030,
    "vm_status": "Executed successfully"
  }
}</code>
Transaction submitted: https://explorer.aptoslabs.com/txn/0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb?network=devnet
{
  "Result": {
    "resource_account": "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31",
    "transaction_hash": "0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb",
    "gas_used": 511,
    "gas_unit_price": 100,
    "sender": "1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1729570392468682,
    "version": 95355030,
    "vm_status": "Executed successfully"
  }
}
resource address:
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
source address:
0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
resource address:
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
resource address:
<code>f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31</code>
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
source address:
0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
source address:
<code>0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97</code>
0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
To publish a module to the resource address, create a profile for it in the
./aptos/config.yaml
file:
To publish a module to the resource address, create a profile for it in the
<code>./aptos/config.yaml</code>
./aptos/config.yaml
file:
<code>---
profiles:
  default:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: 1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
  resource:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"</code>
<code>---
profiles:
  default:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: 1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
  resource:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"</code>
---
profiles:
  default:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: 1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
  resource:
    network: Devnet
    private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
    public_key: "0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
    account: f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
Note that the PrivateKey and PublicKey of these two profiles are identical; only the account differs.
Note that the PrivateKey and PublicKey of these two profiles are identical; only the account differs.
Next, modify the
Move.toml
file, changing the module's address to the resource account address:
Next, modify the
<code>Move.toml</code>
Move.toml
file, changing the module's address to the resource account address:
<code>[package]
name = "movement"
version = "1.0.0"
authors = []
[addresses]
source_addr = "0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97" // owner addr
movement = "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31" // resource addr
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosToken]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token"
[dev-dependencies]</code>
<code>[package]
name = "movement"
version = "1.0.0"
authors = []
[addresses]
source_addr = "0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97" // owner addr
movement = "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31" // resource addr
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosToken]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token"
[dev-dependencies]</code>
[package]
name = "movement"
version = "1.0.0"
authors = []
[addresses]
source_addr = "0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97" // owner addr
movement = "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31" // resource addr
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosToken]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token"
[dev-dependencies]
You can now run the command to publish the module to the resource account
movement = f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. If you encounter a GAS error, run this CLI command to fund the
resource profile
:
You can now run the command to publish the module to the resource account
<code>movement = f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31</code>
movement = f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. If you encounter a GAS error, run this CLI command to fund the
<code>resource profile</code>
resource profile
:
<code>movement account fund-with-faucet --account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31 --amount 100000000</code>
<code>movement account fund-with-faucet --account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31 --amount 100000000</code>
movement account fund-with-faucet --account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31 --amount 100000000
After funding, you can publish using this CLI command:
After funding, you can publish using this CLI command:
<code>movement move publish --profile resource</code>
<code>movement move publish --profile resource</code>
movement move publish --profile resource
or using sender account is
resource_address
or using sender account is
<code>resource_address</code>
resource_address
<code>movement move publish --sender-account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31</code>
<code>movement move publish --sender-account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31</code>
movement move publish --sender-account f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
If successful, check the modules of the
resource addr
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. You should see your module, its functions, and other data and resources.
If successful, check the modules of the
<code>resource addr</code>
resource addr
<code>f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31</code>
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
. You should see your module, its functions, and other data and resources.
	Fullcode
	Fullcode
	<code>module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::resource_account;
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    const SOURCE_ADDR: address = @source_addr;
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let resource_cap_cap = resource_account::retrieve_resource_account_cap(caller, SOURCE_ADDR);
        let resource_signer = account::create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}</code>
	<code>module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::resource_account;
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    const SOURCE_ADDR: address = @source_addr;
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let resource_cap_cap = resource_account::retrieve_resource_account_cap(caller, SOURCE_ADDR);
        let resource_signer = account::create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}</code>
	module movement::mint_nft_by_resource_account {
    use std::string::{Self, String};
    use aptos_token_objects::collection;
    use aptos_token_objects::token::{Self, Token};
    use aptos_framework::resource_account;
    use aptos_framework::object;
    use std::signer;
    use std::option;
    use aptos_framework::account::{Self, SignerCapability, create_resource_account, create_signer_with_capability};
    struct ResourceInfo has key {
        source: address,
        resource_cap: SignerCapability
    }
    struct CollectionConfig has key {
        collection_name: String,
        collection_description: String,
        collection_maximum: u64,
        collection_uri: String,
        token_counter: u64,
        token_base_name: String,
        token_description: String,
    }
    const SOURCE_ADDR: address = @source_addr;
    public entry fun create_collection(
        account: &signer,
        collection_name: String,
        collection_description: String,
        collection_uri: String,
        collection_maximum: u64,
        // Token
        token_base_name: String,
        token_description: String,
        seeds: vector<u8>
    ) {
        let resource_cap_cap = resource_account::retrieve_resource_account_cap(caller, SOURCE_ADDR);
        let resource_signer = account::create_signer_with_capability(&resource_cap);
        let account_addr = signer::address_of(account);
        // Token
        move_to(&resource_signer_from_cap, ResourceInfo {
            source: account_addr,
            resource_cap: resource_cap
        });
        move_to(&resource_signer_from_cap, CollectionConfig {
            collection_name,
            collection_description,
            collection_maximum: collection_maximum,
            collection_uri,
            token_counter: 1,
            // Token
            token_base_name,
            token_description,
        });
        collection::create_fixed_collection(
            &resource_signer_from_cap,
            collection_description,
            collection_maximum,
            collection_name,
            option::none(),
            collection_uri,
        );
    }
    public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String, token_uri: String) acquires ResourceInfo, CollectionConfig {
        let nft_claimer_addr = signer::address_of(nft_claimer);
        let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
        let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
        let resource_signer_from_cap = account::create_signer_with_capability(&resource_info.resource_cap);
        let constructor_ref = token::create_named_token(
            &resource_signer_from_cap,
            collection_config.collection_name,
            collection_config.collection_description,
            token_name,
            option::none(),
            token_uri
        );
        let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
        object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/nft/06-managed-collection
Managed Collection
Managed Collection
On This Page
Summary
Create NFT Collection & Manager
Create Movement AptosCollection
Create AptosToken
FullCode
Summary
Introduces the concept of managing NFT collections and tokens using Aptos blockchain
Explains the use of
Object
for storing token and collection data
Demonstrates creation of custom structures for collection management
Shows implementation of collection initialization and token minting functions
Highlights the importance of tracking object addresses for collections and tokens
Introduces a method to store and retrieve minted NFTs for each user
Provides code examples for creating collections, minting tokens, and viewing token information
Create NFT Collection & Manager
When using aptos_token and collection, all data and resources are stored as
Object
. This makes our
token
much more flexible, but at the same time also makes management more complex. In this section, we will use another resource together to manage these tokens and collections effectively.
struct CreateNFTCollection has key {
    collection_object: Object<collection::Collection>,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}
With this structure, we can store the initialization components and information of the Collection. We can also add details like
admin
or other functions. However, in this example, I'll separate the
admin
resource into a distinct resource to make changing the owner or admin of this collection more flexible.
struct DataManager has key {
    admin: address,
}
Next, we'll complete the initialization of a collection. But first, we need to set the
admin
to determine who has the authority to create collections.
fun init_module(resource_account: &signer) {
    move_to(resource_account, DataManager {
        admin: @movement
    })
}
Create Movement AptosCollection
Here, we'll use the account itself as the platform admin. Whenever someone initializes a collection, they'll automatically become the admin of that collection.
public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
    let admin_addr = signer::address_of(admin);
    // Check if the collection already exists for the admin
    // Abort if the MovementCollection already exists for the admin
    assert!(!exists&lt;MovementCollection&gt;(admin_addr), 0);
    
    // Set the admin address in the CollectionManager
    // Move the MovementCollection resource to the admin's account
    let module_data = borrow_global_mut&lt;CollectionManager&gt;(@movement);
    module_data.admin = admin_addr;
    
    // Create a new collection object with specified parameters
    let collection_object = aptos_token::create_collection_object(
        admin,                                     // Creator
        utf8(COLLECTION_DESCRIPTION),              // Description
        1000,                                      // Max Supply
        utf8(COLLECTION_NAME),                     // Collection Name
        utf8(COLLECTION_URI),                      // Collection URI
        true,                                      // mutable_description
        true,                                      // mutable_royalty
        true,                                      // mutable_uri
        true,                                      // mutable_token_description
        true,                                      // mutable_token_name
        true,                                      // mutable_token_properties
        true,                                      // mutable_token_uri
        true,                                      // tokens_burnable_by_creator
        true,                                      // tokens_freezable_by_creator
        0,                                         // royalty_numerator
        100,                                       // royalty_denominator
    );
    move_to(admin, MovementCollection {
        collection_object,
        collection_name: utf8(COLLECTION_NAME),
        minting_enabled: true,
        mint_fee: 0
    });
}
After initializing the Collection, we'll create tokens within the
collection
. Since we've stored the
collection_name
in the MovementCollection Resource, we can easily access the user's global data to retrieve this information through acquires.
public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global&lt;MovementCollection&gt;(@movement);
    aptos_token::mint_token_object(
        user,                                    // Creator
        movement_collection.collection_name,     // Collection Name
        utf8(b"Token Movement Description"),     // Token Description
        utf8(b"Token Movement Name"),            // Token Name
        utf8(b"Token URI"),                      // Token URI: `https://example.com/image.png`
        vector[],                                // Property Keys: vector<String>
        vector[],                                // Property Types: vector<String>
        vector[]                                 // Property Values: vector<u8>
    );
}
Here we have a
property
parameter, but we'll discuss it in later lessons. Returning to this section, we notice an issue: we're creating
objects
but we don't know their addresses or locations, similar to what we learned in the object lesson. We should store these object addresses for future use.
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}
We're adding a
collection_address
field to store the object_address of the created collection. We'll store it like this:
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0
});
This allows us to store the collection_address in the resources. We can also create a view function to retrieve this
object
address:
#[view]
public fun get_collection_object_address(owner: address): address acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    object::create_object_address(&owner, COLLECTION_NAME)
}
After checking the
object
information, you'll see that it creates four different resources when you call the
create_movement_collection
function:
Create AptosToken
Similarly, when initializing AptosToken:
We'll use
create_object_address
to generate an address for storing the token_object. I'll add another field to
MovementCollection
with the data type
table&lt;address, vector&lt;address&gt;&gt;
. This allows me to track how many tokens a person has minted and which tokens they are.
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
}
When initializing the collection, I'll create a new
table
:
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new()
});
I'll change the
aptos_token::mint
function to
aptos_token::mint_token_object
so it returns an object, which I'll use to create a named_address:
public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(@movement);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        user,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
}
#[view]
public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    *table::borrow(&movement_collection.minted_nfts, owner)
}
With this view function, I can easily determine how many
AptosTokens
have been created and which
tokens
they are.
FullCode
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        admin: address
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(resource_account: &signer) {
        move_to(resource_account, CollectionManager {
            admin: @movement
        })
    }
    public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let module_data = borrow_global_mut<CollectionManager>(@movement);
        module_data.admin = admin_addr;
        let collection_object = aptos_token::create_collection_object(
            admin,                                     // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new()
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(@movement);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            user,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
    }
    #[view]
    public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}
On This Page
Summary
Create NFT Collection & Manager
Create Movement AptosCollection
Create AptosToken
FullCode
On This Page
Summary
Create NFT Collection & Manager
Create Movement AptosCollection
Create AptosToken
FullCode
			On This Page
			On This Page
			Summary
Create NFT Collection & Manager
Create Movement AptosCollection
Create AptosToken
FullCode
			Summary
			Summary
			Summary
			Summary
			Create NFT Collection & Manager
			Create NFT Collection & Manager
			Create NFT Collection & Manager
			Create NFT Collection & Manager
			Create Movement AptosCollection
			Create Movement AptosCollection
			Create Movement AptosCollection
			Create Movement AptosCollection
			Create AptosToken
			Create AptosToken
			Create AptosToken
			Create AptosToken
			FullCode
			FullCode
			FullCode
			FullCode
			Summary
Introduces the concept of managing NFT collections and tokens using Aptos blockchain
Explains the use of
Object
for storing token and collection data
Demonstrates creation of custom structures for collection management
Shows implementation of collection initialization and token minting functions
Highlights the importance of tracking object addresses for collections and tokens
Introduces a method to store and retrieve minted NFTs for each user
Provides code examples for creating collections, minting tokens, and viewing token information
Create NFT Collection & Manager
When using aptos_token and collection, all data and resources are stored as
Object
. This makes our
token
much more flexible, but at the same time also makes management more complex. In this section, we will use another resource together to manage these tokens and collections effectively.
struct CreateNFTCollection has key {
    collection_object: Object<collection::Collection>,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}
With this structure, we can store the initialization components and information of the Collection. We can also add details like
admin
or other functions. However, in this example, I'll separate the
admin
resource into a distinct resource to make changing the owner or admin of this collection more flexible.
struct DataManager has key {
    admin: address,
}
Next, we'll complete the initialization of a collection. But first, we need to set the
admin
to determine who has the authority to create collections.
fun init_module(resource_account: &signer) {
    move_to(resource_account, DataManager {
        admin: @movement
    })
}
Create Movement AptosCollection
Here, we'll use the account itself as the platform admin. Whenever someone initializes a collection, they'll automatically become the admin of that collection.
public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
    let admin_addr = signer::address_of(admin);
    // Check if the collection already exists for the admin
    // Abort if the MovementCollection already exists for the admin
    assert!(!exists&lt;MovementCollection&gt;(admin_addr), 0);
    
    // Set the admin address in the CollectionManager
    // Move the MovementCollection resource to the admin's account
    let module_data = borrow_global_mut&lt;CollectionManager&gt;(@movement);
    module_data.admin = admin_addr;
    
    // Create a new collection object with specified parameters
    let collection_object = aptos_token::create_collection_object(
        admin,                                     // Creator
        utf8(COLLECTION_DESCRIPTION),              // Description
        1000,                                      // Max Supply
        utf8(COLLECTION_NAME),                     // Collection Name
        utf8(COLLECTION_URI),                      // Collection URI
        true,                                      // mutable_description
        true,                                      // mutable_royalty
        true,                                      // mutable_uri
        true,                                      // mutable_token_description
        true,                                      // mutable_token_name
        true,                                      // mutable_token_properties
        true,                                      // mutable_token_uri
        true,                                      // tokens_burnable_by_creator
        true,                                      // tokens_freezable_by_creator
        0,                                         // royalty_numerator
        100,                                       // royalty_denominator
    );
    move_to(admin, MovementCollection {
        collection_object,
        collection_name: utf8(COLLECTION_NAME),
        minting_enabled: true,
        mint_fee: 0
    });
}
After initializing the Collection, we'll create tokens within the
collection
. Since we've stored the
collection_name
in the MovementCollection Resource, we can easily access the user's global data to retrieve this information through acquires.
public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global&lt;MovementCollection&gt;(@movement);
    aptos_token::mint_token_object(
        user,                                    // Creator
        movement_collection.collection_name,     // Collection Name
        utf8(b"Token Movement Description"),     // Token Description
        utf8(b"Token Movement Name"),            // Token Name
        utf8(b"Token URI"),                      // Token URI: `https://example.com/image.png`
        vector[],                                // Property Keys: vector<String>
        vector[],                                // Property Types: vector<String>
        vector[]                                 // Property Values: vector<u8>
    );
}
Here we have a
property
parameter, but we'll discuss it in later lessons. Returning to this section, we notice an issue: we're creating
objects
but we don't know their addresses or locations, similar to what we learned in the object lesson. We should store these object addresses for future use.
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}
We're adding a
collection_address
field to store the object_address of the created collection. We'll store it like this:
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0
});
This allows us to store the collection_address in the resources. We can also create a view function to retrieve this
object
address:
#[view]
public fun get_collection_object_address(owner: address): address acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    object::create_object_address(&owner, COLLECTION_NAME)
}
After checking the
object
information, you'll see that it creates four different resources when you call the
create_movement_collection
function:
Create AptosToken
Similarly, when initializing AptosToken:
We'll use
create_object_address
to generate an address for storing the token_object. I'll add another field to
MovementCollection
with the data type
table&lt;address, vector&lt;address&gt;&gt;
. This allows me to track how many tokens a person has minted and which tokens they are.
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
}
When initializing the collection, I'll create a new
table
:
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new()
});
I'll change the
aptos_token::mint
function to
aptos_token::mint_token_object
so it returns an object, which I'll use to create a named_address:
public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(@movement);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        user,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
}
#[view]
public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    *table::borrow(&movement_collection.minted_nfts, owner)
}
With this view function, I can easily determine how many
AptosTokens
have been created and which
tokens
they are.
FullCode
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        admin: address
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(resource_account: &signer) {
        move_to(resource_account, CollectionManager {
            admin: @movement
        })
    }
    public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let module_data = borrow_global_mut<CollectionManager>(@movement);
        module_data.admin = admin_addr;
        let collection_object = aptos_token::create_collection_object(
            admin,                                     // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new()
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(@movement);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            user,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
    }
    #[view]
    public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}
			Summary
Introduces the concept of managing NFT collections and tokens using Aptos blockchain
Explains the use of
Object
for storing token and collection data
Demonstrates creation of custom structures for collection management
Shows implementation of collection initialization and token minting functions
Highlights the importance of tracking object addresses for collections and tokens
Introduces a method to store and retrieve minted NFTs for each user
Provides code examples for creating collections, minting tokens, and viewing token information
Create NFT Collection & Manager
When using aptos_token and collection, all data and resources are stored as
Object
. This makes our
token
much more flexible, but at the same time also makes management more complex. In this section, we will use another resource together to manage these tokens and collections effectively.
struct CreateNFTCollection has key {
    collection_object: Object<collection::Collection>,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}
With this structure, we can store the initialization components and information of the Collection. We can also add details like
admin
or other functions. However, in this example, I'll separate the
admin
resource into a distinct resource to make changing the owner or admin of this collection more flexible.
struct DataManager has key {
    admin: address,
}
Next, we'll complete the initialization of a collection. But first, we need to set the
admin
to determine who has the authority to create collections.
fun init_module(resource_account: &signer) {
    move_to(resource_account, DataManager {
        admin: @movement
    })
}
Create Movement AptosCollection
Here, we'll use the account itself as the platform admin. Whenever someone initializes a collection, they'll automatically become the admin of that collection.
public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
    let admin_addr = signer::address_of(admin);
    // Check if the collection already exists for the admin
    // Abort if the MovementCollection already exists for the admin
    assert!(!exists&lt;MovementCollection&gt;(admin_addr), 0);
    
    // Set the admin address in the CollectionManager
    // Move the MovementCollection resource to the admin's account
    let module_data = borrow_global_mut&lt;CollectionManager&gt;(@movement);
    module_data.admin = admin_addr;
    
    // Create a new collection object with specified parameters
    let collection_object = aptos_token::create_collection_object(
        admin,                                     // Creator
        utf8(COLLECTION_DESCRIPTION),              // Description
        1000,                                      // Max Supply
        utf8(COLLECTION_NAME),                     // Collection Name
        utf8(COLLECTION_URI),                      // Collection URI
        true,                                      // mutable_description
        true,                                      // mutable_royalty
        true,                                      // mutable_uri
        true,                                      // mutable_token_description
        true,                                      // mutable_token_name
        true,                                      // mutable_token_properties
        true,                                      // mutable_token_uri
        true,                                      // tokens_burnable_by_creator
        true,                                      // tokens_freezable_by_creator
        0,                                         // royalty_numerator
        100,                                       // royalty_denominator
    );
    move_to(admin, MovementCollection {
        collection_object,
        collection_name: utf8(COLLECTION_NAME),
        minting_enabled: true,
        mint_fee: 0
    });
}
After initializing the Collection, we'll create tokens within the
collection
. Since we've stored the
collection_name
in the MovementCollection Resource, we can easily access the user's global data to retrieve this information through acquires.
public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global&lt;MovementCollection&gt;(@movement);
    aptos_token::mint_token_object(
        user,                                    // Creator
        movement_collection.collection_name,     // Collection Name
        utf8(b"Token Movement Description"),     // Token Description
        utf8(b"Token Movement Name"),            // Token Name
        utf8(b"Token URI"),                      // Token URI: `https://example.com/image.png`
        vector[],                                // Property Keys: vector<String>
        vector[],                                // Property Types: vector<String>
        vector[]                                 // Property Values: vector<u8>
    );
}
Here we have a
property
parameter, but we'll discuss it in later lessons. Returning to this section, we notice an issue: we're creating
objects
but we don't know their addresses or locations, similar to what we learned in the object lesson. We should store these object addresses for future use.
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}
We're adding a
collection_address
field to store the object_address of the created collection. We'll store it like this:
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0
});
This allows us to store the collection_address in the resources. We can also create a view function to retrieve this
object
address:
#[view]
public fun get_collection_object_address(owner: address): address acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    object::create_object_address(&owner, COLLECTION_NAME)
}
After checking the
object
information, you'll see that it creates four different resources when you call the
create_movement_collection
function:
Create AptosToken
Similarly, when initializing AptosToken:
We'll use
create_object_address
to generate an address for storing the token_object. I'll add another field to
MovementCollection
with the data type
table&lt;address, vector&lt;address&gt;&gt;
. This allows me to track how many tokens a person has minted and which tokens they are.
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
}
When initializing the collection, I'll create a new
table
:
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new()
});
I'll change the
aptos_token::mint
function to
aptos_token::mint_token_object
so it returns an object, which I'll use to create a named_address:
public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(@movement);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        user,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
}
#[view]
public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    *table::borrow(&movement_collection.minted_nfts, owner)
}
With this view function, I can easily determine how many
AptosTokens
have been created and which
tokens
they are.
FullCode
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        admin: address
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(resource_account: &signer) {
        move_to(resource_account, CollectionManager {
            admin: @movement
        })
    }
    public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let module_data = borrow_global_mut<CollectionManager>(@movement);
        module_data.admin = admin_addr;
        let collection_object = aptos_token::create_collection_object(
            admin,                                     // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new()
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(@movement);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            user,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
    }
    #[view]
    public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}
			Summary
Introduces the concept of managing NFT collections and tokens using Aptos blockchain
Explains the use of
Object
for storing token and collection data
Demonstrates creation of custom structures for collection management
Shows implementation of collection initialization and token minting functions
Highlights the importance of tracking object addresses for collections and tokens
Introduces a method to store and retrieve minted NFTs for each user
Provides code examples for creating collections, minting tokens, and viewing token information
Create NFT Collection & Manager
When using aptos_token and collection, all data and resources are stored as
Object
. This makes our
token
much more flexible, but at the same time also makes management more complex. In this section, we will use another resource together to manage these tokens and collections effectively.
struct CreateNFTCollection has key {
    collection_object: Object<collection::Collection>,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}
With this structure, we can store the initialization components and information of the Collection. We can also add details like
admin
or other functions. However, in this example, I'll separate the
admin
resource into a distinct resource to make changing the owner or admin of this collection more flexible.
struct DataManager has key {
    admin: address,
}
Next, we'll complete the initialization of a collection. But first, we need to set the
admin
to determine who has the authority to create collections.
fun init_module(resource_account: &signer) {
    move_to(resource_account, DataManager {
        admin: @movement
    })
}
Create Movement AptosCollection
Here, we'll use the account itself as the platform admin. Whenever someone initializes a collection, they'll automatically become the admin of that collection.
public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
    let admin_addr = signer::address_of(admin);
    // Check if the collection already exists for the admin
    // Abort if the MovementCollection already exists for the admin
    assert!(!exists&lt;MovementCollection&gt;(admin_addr), 0);
    
    // Set the admin address in the CollectionManager
    // Move the MovementCollection resource to the admin's account
    let module_data = borrow_global_mut&lt;CollectionManager&gt;(@movement);
    module_data.admin = admin_addr;
    
    // Create a new collection object with specified parameters
    let collection_object = aptos_token::create_collection_object(
        admin,                                     // Creator
        utf8(COLLECTION_DESCRIPTION),              // Description
        1000,                                      // Max Supply
        utf8(COLLECTION_NAME),                     // Collection Name
        utf8(COLLECTION_URI),                      // Collection URI
        true,                                      // mutable_description
        true,                                      // mutable_royalty
        true,                                      // mutable_uri
        true,                                      // mutable_token_description
        true,                                      // mutable_token_name
        true,                                      // mutable_token_properties
        true,                                      // mutable_token_uri
        true,                                      // tokens_burnable_by_creator
        true,                                      // tokens_freezable_by_creator
        0,                                         // royalty_numerator
        100,                                       // royalty_denominator
    );
    move_to(admin, MovementCollection {
        collection_object,
        collection_name: utf8(COLLECTION_NAME),
        minting_enabled: true,
        mint_fee: 0
    });
}
After initializing the Collection, we'll create tokens within the
collection
. Since we've stored the
collection_name
in the MovementCollection Resource, we can easily access the user's global data to retrieve this information through acquires.
public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global&lt;MovementCollection&gt;(@movement);
    aptos_token::mint_token_object(
        user,                                    // Creator
        movement_collection.collection_name,     // Collection Name
        utf8(b"Token Movement Description"),     // Token Description
        utf8(b"Token Movement Name"),            // Token Name
        utf8(b"Token URI"),                      // Token URI: `https://example.com/image.png`
        vector[],                                // Property Keys: vector<String>
        vector[],                                // Property Types: vector<String>
        vector[]                                 // Property Values: vector<u8>
    );
}
Here we have a
property
parameter, but we'll discuss it in later lessons. Returning to this section, we notice an issue: we're creating
objects
but we don't know their addresses or locations, similar to what we learned in the object lesson. We should store these object addresses for future use.
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}
We're adding a
collection_address
field to store the object_address of the created collection. We'll store it like this:
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0
});
This allows us to store the collection_address in the resources. We can also create a view function to retrieve this
object
address:
#[view]
public fun get_collection_object_address(owner: address): address acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    object::create_object_address(&owner, COLLECTION_NAME)
}
After checking the
object
information, you'll see that it creates four different resources when you call the
create_movement_collection
function:
Create AptosToken
Similarly, when initializing AptosToken:
We'll use
create_object_address
to generate an address for storing the token_object. I'll add another field to
MovementCollection
with the data type
table&lt;address, vector&lt;address&gt;&gt;
. This allows me to track how many tokens a person has minted and which tokens they are.
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
}
When initializing the collection, I'll create a new
table
:
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new()
});
I'll change the
aptos_token::mint
function to
aptos_token::mint_token_object
so it returns an object, which I'll use to create a named_address:
public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(@movement);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        user,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
}
#[view]
public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    *table::borrow(&movement_collection.minted_nfts, owner)
}
With this view function, I can easily determine how many
AptosTokens
have been created and which
tokens
they are.
FullCode
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        admin: address
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(resource_account: &signer) {
        move_to(resource_account, CollectionManager {
            admin: @movement
        })
    }
    public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let module_data = borrow_global_mut<CollectionManager>(@movement);
        module_data.admin = admin_addr;
        let collection_object = aptos_token::create_collection_object(
            admin,                                     // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new()
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(@movement);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            user,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
    }
    #[view]
    public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}
	Summary
	Summary
	Introduces the concept of managing NFT collections and tokens using Aptos blockchain
Explains the use of
Object
for storing token and collection data
Demonstrates creation of custom structures for collection management
Shows implementation of collection initialization and token minting functions
Highlights the importance of tracking object addresses for collections and tokens
Introduces a method to store and retrieve minted NFTs for each user
Provides code examples for creating collections, minting tokens, and viewing token information
	Introduces the concept of managing NFT collections and tokens using Aptos blockchain
	Introduces the concept of managing NFT collections and tokens using Aptos blockchain
	Explains the use of
Object
for storing token and collection data
	Explains the use of
	<code>Object</code>
	Object
	for storing token and collection data
	Demonstrates creation of custom structures for collection management
	Demonstrates creation of custom structures for collection management
	Shows implementation of collection initialization and token minting functions
	Shows implementation of collection initialization and token minting functions
	Highlights the importance of tracking object addresses for collections and tokens
	Highlights the importance of tracking object addresses for collections and tokens
	Introduces a method to store and retrieve minted NFTs for each user
	Introduces a method to store and retrieve minted NFTs for each user
	Provides code examples for creating collections, minting tokens, and viewing token information
	Provides code examples for creating collections, minting tokens, and viewing token information
	Create NFT Collection & Manager
	Create NFT Collection & Manager
	When using aptos_token and collection, all data and resources are stored as
Object
. This makes our
token
much more flexible, but at the same time also makes management more complex. In this section, we will use another resource together to manage these tokens and collections effectively.
	When using aptos_token and collection, all data and resources are stored as
	<code>Object</code>
	Object
	. This makes our
	<code>token</code>
	token
	much more flexible, but at the same time also makes management more complex. In this section, we will use another resource together to manage these tokens and collections effectively.
	<code>struct CreateNFTCollection has key {
    collection_object: Object<collection::Collection>,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}</code>
	<code>struct CreateNFTCollection has key {
    collection_object: Object<collection::Collection>,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}</code>
	struct CreateNFTCollection has key {
    collection_object: Object<collection::Collection>,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}
	With this structure, we can store the initialization components and information of the Collection. We can also add details like
admin
or other functions. However, in this example, I'll separate the
admin
resource into a distinct resource to make changing the owner or admin of this collection more flexible.
	With this structure, we can store the initialization components and information of the Collection. We can also add details like
	<code>admin</code>
	admin
	or other functions. However, in this example, I'll separate the
	<code>admin</code>
	admin
	resource into a distinct resource to make changing the owner or admin of this collection more flexible.
	<code>struct DataManager has key {
    admin: address,
}</code>
	<code>struct DataManager has key {
    admin: address,
}</code>
	struct DataManager has key {
    admin: address,
}
	Next, we'll complete the initialization of a collection. But first, we need to set the
admin
to determine who has the authority to create collections.
	Next, we'll complete the initialization of a collection. But first, we need to set the
	<code>admin</code>
	admin
	to determine who has the authority to create collections.
	<code>fun init_module(resource_account: &signer) {
    move_to(resource_account, DataManager {
        admin: @movement
    })
}</code>
	<code>fun init_module(resource_account: &signer) {
    move_to(resource_account, DataManager {
        admin: @movement
    })
}</code>
	fun init_module(resource_account: &signer) {
    move_to(resource_account, DataManager {
        admin: @movement
    })
}
	Create Movement AptosCollection
	Create Movement AptosCollection
	Here, we'll use the account itself as the platform admin. Whenever someone initializes a collection, they'll automatically become the admin of that collection.
	Here, we'll use the account itself as the platform admin. Whenever someone initializes a collection, they'll automatically become the admin of that collection.
	<code>public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
    let admin_addr = signer::address_of(admin);
    // Check if the collection already exists for the admin
    // Abort if the MovementCollection already exists for the admin
    assert!(!exists&lt;MovementCollection&gt;(admin_addr), 0);
    
    // Set the admin address in the CollectionManager
    // Move the MovementCollection resource to the admin's account
    let module_data = borrow_global_mut&lt;CollectionManager&gt;(@movement);
    module_data.admin = admin_addr;
    
    // Create a new collection object with specified parameters
    let collection_object = aptos_token::create_collection_object(
        admin,                                     // Creator
        utf8(COLLECTION_DESCRIPTION),              // Description
        1000,                                      // Max Supply
        utf8(COLLECTION_NAME),                     // Collection Name
        utf8(COLLECTION_URI),                      // Collection URI
        true,                                      // mutable_description
        true,                                      // mutable_royalty
        true,                                      // mutable_uri
        true,                                      // mutable_token_description
        true,                                      // mutable_token_name
        true,                                      // mutable_token_properties
        true,                                      // mutable_token_uri
        true,                                      // tokens_burnable_by_creator
        true,                                      // tokens_freezable_by_creator
        0,                                         // royalty_numerator
        100,                                       // royalty_denominator
    );
    move_to(admin, MovementCollection {
        collection_object,
        collection_name: utf8(COLLECTION_NAME),
        minting_enabled: true,
        mint_fee: 0
    });
}</code>
	<code>public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
    let admin_addr = signer::address_of(admin);
    // Check if the collection already exists for the admin
    // Abort if the MovementCollection already exists for the admin
    assert!(!exists&lt;MovementCollection&gt;(admin_addr), 0);
    
    // Set the admin address in the CollectionManager
    // Move the MovementCollection resource to the admin's account
    let module_data = borrow_global_mut&lt;CollectionManager&gt;(@movement);
    module_data.admin = admin_addr;
    
    // Create a new collection object with specified parameters
    let collection_object = aptos_token::create_collection_object(
        admin,                                     // Creator
        utf8(COLLECTION_DESCRIPTION),              // Description
        1000,                                      // Max Supply
        utf8(COLLECTION_NAME),                     // Collection Name
        utf8(COLLECTION_URI),                      // Collection URI
        true,                                      // mutable_description
        true,                                      // mutable_royalty
        true,                                      // mutable_uri
        true,                                      // mutable_token_description
        true,                                      // mutable_token_name
        true,                                      // mutable_token_properties
        true,                                      // mutable_token_uri
        true,                                      // tokens_burnable_by_creator
        true,                                      // tokens_freezable_by_creator
        0,                                         // royalty_numerator
        100,                                       // royalty_denominator
    );
    move_to(admin, MovementCollection {
        collection_object,
        collection_name: utf8(COLLECTION_NAME),
        minting_enabled: true,
        mint_fee: 0
    });
}</code>
	public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
    let admin_addr = signer::address_of(admin);
    // Check if the collection already exists for the admin
    // Abort if the MovementCollection already exists for the admin
    assert!(!exists&lt;MovementCollection&gt;(admin_addr), 0);
    
    // Set the admin address in the CollectionManager
    // Move the MovementCollection resource to the admin's account
    let module_data = borrow_global_mut&lt;CollectionManager&gt;(@movement);
    module_data.admin = admin_addr;
    
    // Create a new collection object with specified parameters
    let collection_object = aptos_token::create_collection_object(
        admin,                                     // Creator
        utf8(COLLECTION_DESCRIPTION),              // Description
        1000,                                      // Max Supply
        utf8(COLLECTION_NAME),                     // Collection Name
        utf8(COLLECTION_URI),                      // Collection URI
        true,                                      // mutable_description
        true,                                      // mutable_royalty
        true,                                      // mutable_uri
        true,                                      // mutable_token_description
        true,                                      // mutable_token_name
        true,                                      // mutable_token_properties
        true,                                      // mutable_token_uri
        true,                                      // tokens_burnable_by_creator
        true,                                      // tokens_freezable_by_creator
        0,                                         // royalty_numerator
        100,                                       // royalty_denominator
    );
    move_to(admin, MovementCollection {
        collection_object,
        collection_name: utf8(COLLECTION_NAME),
        minting_enabled: true,
        mint_fee: 0
    });
}
	After initializing the Collection, we'll create tokens within the
collection
. Since we've stored the
collection_name
in the MovementCollection Resource, we can easily access the user's global data to retrieve this information through acquires.
	After initializing the Collection, we'll create tokens within the
	<code>collection</code>
	collection
	. Since we've stored the
	<code>collection_name</code>
	collection_name
	in the MovementCollection Resource, we can easily access the user's global data to retrieve this information through acquires.
	<code>public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global&lt;MovementCollection&gt;(@movement);
    aptos_token::mint_token_object(
        user,                                    // Creator
        movement_collection.collection_name,     // Collection Name
        utf8(b"Token Movement Description"),     // Token Description
        utf8(b"Token Movement Name"),            // Token Name
        utf8(b"Token URI"),                      // Token URI: `https://example.com/image.png`
        vector[],                                // Property Keys: vector<String>
        vector[],                                // Property Types: vector<String>
        vector[]                                 // Property Values: vector<u8>
    );
}</code>
	<code>public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global&lt;MovementCollection&gt;(@movement);
    aptos_token::mint_token_object(
        user,                                    // Creator
        movement_collection.collection_name,     // Collection Name
        utf8(b"Token Movement Description"),     // Token Description
        utf8(b"Token Movement Name"),            // Token Name
        utf8(b"Token URI"),                      // Token URI: `https://example.com/image.png`
        vector[],                                // Property Keys: vector<String>
        vector[],                                // Property Types: vector<String>
        vector[]                                 // Property Values: vector<u8>
    );
}</code>
	public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global&lt;MovementCollection&gt;(@movement);
    aptos_token::mint_token_object(
        user,                                    // Creator
        movement_collection.collection_name,     // Collection Name
        utf8(b"Token Movement Description"),     // Token Description
        utf8(b"Token Movement Name"),            // Token Name
        utf8(b"Token URI"),                      // Token URI: `https://example.com/image.png`
        vector[],                                // Property Keys: vector<String>
        vector[],                                // Property Types: vector<String>
        vector[]                                 // Property Values: vector<u8>
    );
}
	Here we have a
property
parameter, but we'll discuss it in later lessons. Returning to this section, we notice an issue: we're creating
objects
but we don't know their addresses or locations, similar to what we learned in the object lesson. We should store these object addresses for future use.
	Here we have a
	<code>property</code>
	property
	parameter, but we'll discuss it in later lessons. Returning to this section, we notice an issue: we're creating
	<code>objects</code>
	objects
	but we don't know their addresses or locations, similar to what we learned in the object lesson. We should store these object addresses for future use.
	<code>struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}</code>
	<code>struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}</code>
	struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64
}
	We're adding a
collection_address
field to store the object_address of the created collection. We'll store it like this:
	We're adding a
	<code>collection_address</code>
	collection_address
	field to store the object_address of the created collection. We'll store it like this:
	<code>let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0
});</code>
	<code>let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0
});</code>
	let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0
});
	This allows us to store the collection_address in the resources. We can also create a view function to retrieve this
object
address:
	This allows us to store the collection_address in the resources. We can also create a view function to retrieve this
	<code>object</code>
	object
	address:
	<code>#[view]
public fun get_collection_object_address(owner: address): address acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    object::create_object_address(&owner, COLLECTION_NAME)
}</code>
	<code>#[view]
public fun get_collection_object_address(owner: address): address acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    object::create_object_address(&owner, COLLECTION_NAME)
}</code>
	#[view]
public fun get_collection_object_address(owner: address): address acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    object::create_object_address(&owner, COLLECTION_NAME)
}
	After checking the
object
information, you'll see that it creates four different resources when you call the
create_movement_collection
function:
	After checking the
	<code>object</code>
	object
	information, you'll see that it creates four different resources when you call the
	<code>create_movement_collection</code>
	create_movement_collection
	function:
	Create AptosToken
	Create AptosToken
	Similarly, when initializing AptosToken:
	Similarly, when initializing AptosToken:
	We'll use
create_object_address
to generate an address for storing the token_object. I'll add another field to
MovementCollection
with the data type
table&lt;address, vector&lt;address&gt;&gt;
. This allows me to track how many tokens a person has minted and which tokens they are.
	We'll use
	<code>create_object_address</code>
	create_object_address
	to generate an address for storing the token_object. I'll add another field to
	<code>MovementCollection</code>
	MovementCollection
	with the data type
	<code>table&lt;address, vector&lt;address&gt;&gt;</code>
	table&lt;address, vector&lt;address&gt;&gt;
	. This allows me to track how many tokens a person has minted and which tokens they are.
	<code>struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
}</code>
	<code>struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
}</code>
	struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
}
	When initializing the collection, I'll create a new
table
:
	When initializing the collection, I'll create a new
	<code>table</code>
	table
	:
	<code>move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new()
});</code>
	<code>move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new()
});</code>
	move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new()
});
	I'll change the
aptos_token::mint
function to
aptos_token::mint_token_object
so it returns an object, which I'll use to create a named_address:
	I'll change the
	<code>aptos_token::mint</code>
	aptos_token::mint
	function to
	<code>aptos_token::mint_token_object</code>
	aptos_token::mint_token_object
	so it returns an object, which I'll use to create a named_address:
	<code>public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(@movement);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        user,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
}
#[view]
public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    *table::borrow(&movement_collection.minted_nfts, owner)
}</code>
	<code>public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(@movement);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        user,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
}
#[view]
public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    *table::borrow(&movement_collection.minted_nfts, owner)
}</code>
	public entry fun mint_nft(user: &signer) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(@movement);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        user,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
}
#[view]
public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
    let movement_collection = borrow_global<MovementCollection>(owner);
    *table::borrow(&movement_collection.minted_nfts, owner)
}
	With this view function, I can easily determine how many
AptosTokens
have been created and which
tokens
they are.
	With this view function, I can easily determine how many
	<code>AptosTokens</code>
	AptosTokens
	have been created and which
	<code>tokens</code>
	tokens
	they are.
	FullCode
	FullCode
	<code>module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        admin: address
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(resource_account: &signer) {
        move_to(resource_account, CollectionManager {
            admin: @movement
        })
    }
    public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let module_data = borrow_global_mut<CollectionManager>(@movement);
        module_data.admin = admin_addr;
        let collection_object = aptos_token::create_collection_object(
            admin,                                     // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new()
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(@movement);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            user,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
    }
    #[view]
    public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}</code>
	<code>module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        admin: address
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(resource_account: &signer) {
        move_to(resource_account, CollectionManager {
            admin: @movement
        })
    }
    public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let module_data = borrow_global_mut<CollectionManager>(@movement);
        module_data.admin = admin_addr;
        let collection_object = aptos_token::create_collection_object(
            admin,                                     // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new()
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(@movement);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            user,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
    }
    #[view]
    public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}</code>
	module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        admin: address
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(resource_account: &signer) {
        move_to(resource_account, CollectionManager {
            admin: @movement
        })
    }
    public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let module_data = borrow_global_mut<CollectionManager>(@movement);
        module_data.admin = admin_addr;
        let collection_object = aptos_token::create_collection_object(
            admin,                                     // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new()
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(@movement);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            user,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
    }
    #[view]
    public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/nft/07-royalty-and-property-map
Royalty & Property Map
Royalty & Property Map
On This Page
Summary
Royalty
Property
Additional Functions
Key Functions for PropertyMap Management
PropertyMap Query Functions
Type-Specific Read Functions
PropertyMap Modification Functions
Summary
Royalties for NFT collections are defined using numerator and denominator values
NFT properties are stored in a PropertyMap as key-value pairs
Various functions are available for managing and querying PropertyMap data
Specific functions exist for reading different data types from PropertyMap
PropertyMap can be modified using add, update, and remove functions
Royalty
In the previous topic, we used
aptos_token::create_collection
to initialize a collection, which includes two parameters called
royalty
.
let collection_object = aptos_token::create_collection_object(
    admin,                                     // Creator
    utf8(COLLECTION_DESCRIPTION),              // Description
    1000,                                      // Max Supply
    utf8(COLLECTION_NAME),                     // Collection Name
    utf8(COLLECTION_URI),                      // Collection Uri
    true,                                      // mutable_description
    true,                                      // mutable_royalty
    true,                                      // mutable_uri
    true,                                      // mutable_token_description
    true,                                      // mutable_token_name
    true,                                      // mutable_token_properties
    true,                                      // mutable_token_uri
    true,                                      // tokens_burnable_by_creator
    true,                                      // tokens_freezable_by_creator
    0,                                         // royalty_numerator
    100,                                       // royalty_denominator
);
royalty_numerator
and
royalty_denominator
define the royalty percentage for the NFT collection. Specifically:
royalty_numerator
: The royalty amount.
royalty_denominator
: The total transaction amount.
The royalty percentage is calculated by dividing
royalty_numerator
by
royalty_denominator
.
In this example:
royalty_numerator = 0
royalty_denominator = 100
This results in a royalty percentage of 0/100 = 0%, meaning no royalties are applied to this collection. To set a royalty percentage—for example, 2.5%—you could use:
royalty_numerator = 25
royalty_denominator = 1000
This creates a ratio of 25/1000 = 2.5%.
Using two separate values (instead of a simple decimal) allows for precise representation of fractions without encountering issues with decimal precision in computers.
Property
In the
mint_nft
function, we have three empty parameters:
let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
Typically, an NFT contains additional metadata such as parameters, attributes, or any other desired information.
Each NFT has a PropertyMap to store these properties, which are saved as key-value pairs:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
/// A Map for typed key to value mapping, the contract using it
/// should keep track of what keys are what types, and parse them accordingly.
struct PropertyMap has drop, key {
    inner: SimpleMap<String, PropertyValue>,
}
/// A typed value for the `PropertyMap` to ensure that typing is always consistent
struct PropertyValue has drop, store {
    type: u8,
    value: vector<u8>,
}
Based on this, we can create data pairs:
let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[utf8(b"keys")],
    vector[utf8(b"types")],
    vector[b"value"]
);
Additional Functions
Key Functions for PropertyMap Management
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| init | Initializes PropertyMap | ref: &ConstructorRef, container: PropertyMap | None |
| extend | Adds PropertyMap to object | ref: &ExtendRef, container: PropertyMap | None |
| burn | Removes entire property map | ref: MutatorRef | None |
| prepare_input | Prepares property container | keys: vector, types: vector, values: vector<vector> | PropertyMap |
| generate_mutator_ref | Creates MutatorRef | ref: &ConstructorRef | MutatorRef |
PropertyMap Query Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| contains_key | Checks for key | object: &Object, key: &String | bool |
| length | Counts entries | object: &Object | u64 |
| read | Retrieves BCS-encoded property | object: &Object, key: &String | (String, vector) |
Type-Specific Read Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| read_bool | Retrieves boolean | object: &Object, key: &String | bool |
| read_u8/u16/u32/u64/u128/u256 | Retrieves unsigned integer | object: &Object, key: &String | respective uint |
| read_address | Retrieves address | object: &Object, key: &String | address |
| read_bytes | Retrieves byte vector | object: &Object, key: &String | vector |
| read_string | Retrieves string | object: &Object, key: &String | String |
PropertyMap Modification Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| add | Adds BCS-encoded property | ref: &MutatorRef, key: String, type: String, value: vector | None |
| add_typed | Adds non-BCS-encoded property | ref: &MutatorRef, key: String, value: T | None |
| update | Updates BCS-encoded property | ref: &MutatorRef, key: &String, type: String, value: vector | None |
| update_typed | Updates non-BCS-encoded property | ref: &MutatorRef, key: &String, value: T | None |
| remove | Deletes property | ref: &MutatorRef, key: &String | None |
On This Page
Summary
Royalty
Property
Additional Functions
Key Functions for PropertyMap Management
PropertyMap Query Functions
Type-Specific Read Functions
PropertyMap Modification Functions
On This Page
Summary
Royalty
Property
Additional Functions
Key Functions for PropertyMap Management
PropertyMap Query Functions
Type-Specific Read Functions
PropertyMap Modification Functions
			On This Page
			On This Page
			Summary
Royalty
Property
Additional Functions
Key Functions for PropertyMap Management
PropertyMap Query Functions
Type-Specific Read Functions
PropertyMap Modification Functions
			Summary
			Summary
			Summary
			Summary
			Royalty
			Royalty
			Royalty
			Royalty
			Property
			Property
			Property
			Property
			Additional Functions
Key Functions for PropertyMap Management
PropertyMap Query Functions
Type-Specific Read Functions
PropertyMap Modification Functions
			Additional Functions
			Additional Functions
			Additional Functions
			Key Functions for PropertyMap Management
PropertyMap Query Functions
Type-Specific Read Functions
PropertyMap Modification Functions
			Key Functions for PropertyMap Management
			Key Functions for PropertyMap Management
			Key Functions for PropertyMap Management
			Key Functions for PropertyMap Management
			PropertyMap Query Functions
			PropertyMap Query Functions
			PropertyMap Query Functions
			PropertyMap Query Functions
			Type-Specific Read Functions
			Type-Specific Read Functions
			Type-Specific Read Functions
			Type-Specific Read Functions
			PropertyMap Modification Functions
			PropertyMap Modification Functions
			PropertyMap Modification Functions
			PropertyMap Modification Functions
			Summary
Royalties for NFT collections are defined using numerator and denominator values
NFT properties are stored in a PropertyMap as key-value pairs
Various functions are available for managing and querying PropertyMap data
Specific functions exist for reading different data types from PropertyMap
PropertyMap can be modified using add, update, and remove functions
Royalty
In the previous topic, we used
aptos_token::create_collection
to initialize a collection, which includes two parameters called
royalty
.
let collection_object = aptos_token::create_collection_object(
    admin,                                     // Creator
    utf8(COLLECTION_DESCRIPTION),              // Description
    1000,                                      // Max Supply
    utf8(COLLECTION_NAME),                     // Collection Name
    utf8(COLLECTION_URI),                      // Collection Uri
    true,                                      // mutable_description
    true,                                      // mutable_royalty
    true,                                      // mutable_uri
    true,                                      // mutable_token_description
    true,                                      // mutable_token_name
    true,                                      // mutable_token_properties
    true,                                      // mutable_token_uri
    true,                                      // tokens_burnable_by_creator
    true,                                      // tokens_freezable_by_creator
    0,                                         // royalty_numerator
    100,                                       // royalty_denominator
);
royalty_numerator
and
royalty_denominator
define the royalty percentage for the NFT collection. Specifically:
royalty_numerator
: The royalty amount.
royalty_denominator
: The total transaction amount.
The royalty percentage is calculated by dividing
royalty_numerator
by
royalty_denominator
.
In this example:
royalty_numerator = 0
royalty_denominator = 100
This results in a royalty percentage of 0/100 = 0%, meaning no royalties are applied to this collection. To set a royalty percentage—for example, 2.5%—you could use:
royalty_numerator = 25
royalty_denominator = 1000
This creates a ratio of 25/1000 = 2.5%.
Using two separate values (instead of a simple decimal) allows for precise representation of fractions without encountering issues with decimal precision in computers.
Property
In the
mint_nft
function, we have three empty parameters:
let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
Typically, an NFT contains additional metadata such as parameters, attributes, or any other desired information.
Each NFT has a PropertyMap to store these properties, which are saved as key-value pairs:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
/// A Map for typed key to value mapping, the contract using it
/// should keep track of what keys are what types, and parse them accordingly.
struct PropertyMap has drop, key {
    inner: SimpleMap<String, PropertyValue>,
}
/// A typed value for the `PropertyMap` to ensure that typing is always consistent
struct PropertyValue has drop, store {
    type: u8,
    value: vector<u8>,
}
Based on this, we can create data pairs:
let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[utf8(b"keys")],
    vector[utf8(b"types")],
    vector[b"value"]
);
Additional Functions
Key Functions for PropertyMap Management
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| init | Initializes PropertyMap | ref: &ConstructorRef, container: PropertyMap | None |
| extend | Adds PropertyMap to object | ref: &ExtendRef, container: PropertyMap | None |
| burn | Removes entire property map | ref: MutatorRef | None |
| prepare_input | Prepares property container | keys: vector, types: vector, values: vector<vector> | PropertyMap |
| generate_mutator_ref | Creates MutatorRef | ref: &ConstructorRef | MutatorRef |
PropertyMap Query Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| contains_key | Checks for key | object: &Object, key: &String | bool |
| length | Counts entries | object: &Object | u64 |
| read | Retrieves BCS-encoded property | object: &Object, key: &String | (String, vector) |
Type-Specific Read Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| read_bool | Retrieves boolean | object: &Object, key: &String | bool |
| read_u8/u16/u32/u64/u128/u256 | Retrieves unsigned integer | object: &Object, key: &String | respective uint |
| read_address | Retrieves address | object: &Object, key: &String | address |
| read_bytes | Retrieves byte vector | object: &Object, key: &String | vector |
| read_string | Retrieves string | object: &Object, key: &String | String |
PropertyMap Modification Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| add | Adds BCS-encoded property | ref: &MutatorRef, key: String, type: String, value: vector | None |
| add_typed | Adds non-BCS-encoded property | ref: &MutatorRef, key: String, value: T | None |
| update | Updates BCS-encoded property | ref: &MutatorRef, key: &String, type: String, value: vector | None |
| update_typed | Updates non-BCS-encoded property | ref: &MutatorRef, key: &String, value: T | None |
| remove | Deletes property | ref: &MutatorRef, key: &String | None |
			Summary
Royalties for NFT collections are defined using numerator and denominator values
NFT properties are stored in a PropertyMap as key-value pairs
Various functions are available for managing and querying PropertyMap data
Specific functions exist for reading different data types from PropertyMap
PropertyMap can be modified using add, update, and remove functions
Royalty
In the previous topic, we used
aptos_token::create_collection
to initialize a collection, which includes two parameters called
royalty
.
let collection_object = aptos_token::create_collection_object(
    admin,                                     // Creator
    utf8(COLLECTION_DESCRIPTION),              // Description
    1000,                                      // Max Supply
    utf8(COLLECTION_NAME),                     // Collection Name
    utf8(COLLECTION_URI),                      // Collection Uri
    true,                                      // mutable_description
    true,                                      // mutable_royalty
    true,                                      // mutable_uri
    true,                                      // mutable_token_description
    true,                                      // mutable_token_name
    true,                                      // mutable_token_properties
    true,                                      // mutable_token_uri
    true,                                      // tokens_burnable_by_creator
    true,                                      // tokens_freezable_by_creator
    0,                                         // royalty_numerator
    100,                                       // royalty_denominator
);
royalty_numerator
and
royalty_denominator
define the royalty percentage for the NFT collection. Specifically:
royalty_numerator
: The royalty amount.
royalty_denominator
: The total transaction amount.
The royalty percentage is calculated by dividing
royalty_numerator
by
royalty_denominator
.
In this example:
royalty_numerator = 0
royalty_denominator = 100
This results in a royalty percentage of 0/100 = 0%, meaning no royalties are applied to this collection. To set a royalty percentage—for example, 2.5%—you could use:
royalty_numerator = 25
royalty_denominator = 1000
This creates a ratio of 25/1000 = 2.5%.
Using two separate values (instead of a simple decimal) allows for precise representation of fractions without encountering issues with decimal precision in computers.
Property
In the
mint_nft
function, we have three empty parameters:
let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
Typically, an NFT contains additional metadata such as parameters, attributes, or any other desired information.
Each NFT has a PropertyMap to store these properties, which are saved as key-value pairs:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
/// A Map for typed key to value mapping, the contract using it
/// should keep track of what keys are what types, and parse them accordingly.
struct PropertyMap has drop, key {
    inner: SimpleMap<String, PropertyValue>,
}
/// A typed value for the `PropertyMap` to ensure that typing is always consistent
struct PropertyValue has drop, store {
    type: u8,
    value: vector<u8>,
}
Based on this, we can create data pairs:
let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[utf8(b"keys")],
    vector[utf8(b"types")],
    vector[b"value"]
);
Additional Functions
Key Functions for PropertyMap Management
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| init | Initializes PropertyMap | ref: &ConstructorRef, container: PropertyMap | None |
| extend | Adds PropertyMap to object | ref: &ExtendRef, container: PropertyMap | None |
| burn | Removes entire property map | ref: MutatorRef | None |
| prepare_input | Prepares property container | keys: vector, types: vector, values: vector<vector> | PropertyMap |
| generate_mutator_ref | Creates MutatorRef | ref: &ConstructorRef | MutatorRef |
PropertyMap Query Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| contains_key | Checks for key | object: &Object, key: &String | bool |
| length | Counts entries | object: &Object | u64 |
| read | Retrieves BCS-encoded property | object: &Object, key: &String | (String, vector) |
Type-Specific Read Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| read_bool | Retrieves boolean | object: &Object, key: &String | bool |
| read_u8/u16/u32/u64/u128/u256 | Retrieves unsigned integer | object: &Object, key: &String | respective uint |
| read_address | Retrieves address | object: &Object, key: &String | address |
| read_bytes | Retrieves byte vector | object: &Object, key: &String | vector |
| read_string | Retrieves string | object: &Object, key: &String | String |
PropertyMap Modification Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| add | Adds BCS-encoded property | ref: &MutatorRef, key: String, type: String, value: vector | None |
| add_typed | Adds non-BCS-encoded property | ref: &MutatorRef, key: String, value: T | None |
| update | Updates BCS-encoded property | ref: &MutatorRef, key: &String, type: String, value: vector | None |
| update_typed | Updates non-BCS-encoded property | ref: &MutatorRef, key: &String, value: T | None |
| remove | Deletes property | ref: &MutatorRef, key: &String | None |
			Summary
Royalties for NFT collections are defined using numerator and denominator values
NFT properties are stored in a PropertyMap as key-value pairs
Various functions are available for managing and querying PropertyMap data
Specific functions exist for reading different data types from PropertyMap
PropertyMap can be modified using add, update, and remove functions
Royalty
In the previous topic, we used
aptos_token::create_collection
to initialize a collection, which includes two parameters called
royalty
.
let collection_object = aptos_token::create_collection_object(
    admin,                                     // Creator
    utf8(COLLECTION_DESCRIPTION),              // Description
    1000,                                      // Max Supply
    utf8(COLLECTION_NAME),                     // Collection Name
    utf8(COLLECTION_URI),                      // Collection Uri
    true,                                      // mutable_description
    true,                                      // mutable_royalty
    true,                                      // mutable_uri
    true,                                      // mutable_token_description
    true,                                      // mutable_token_name
    true,                                      // mutable_token_properties
    true,                                      // mutable_token_uri
    true,                                      // tokens_burnable_by_creator
    true,                                      // tokens_freezable_by_creator
    0,                                         // royalty_numerator
    100,                                       // royalty_denominator
);
royalty_numerator
and
royalty_denominator
define the royalty percentage for the NFT collection. Specifically:
royalty_numerator
: The royalty amount.
royalty_denominator
: The total transaction amount.
The royalty percentage is calculated by dividing
royalty_numerator
by
royalty_denominator
.
In this example:
royalty_numerator = 0
royalty_denominator = 100
This results in a royalty percentage of 0/100 = 0%, meaning no royalties are applied to this collection. To set a royalty percentage—for example, 2.5%—you could use:
royalty_numerator = 25
royalty_denominator = 1000
This creates a ratio of 25/1000 = 2.5%.
Using two separate values (instead of a simple decimal) allows for precise representation of fractions without encountering issues with decimal precision in computers.
Property
In the
mint_nft
function, we have three empty parameters:
let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
Typically, an NFT contains additional metadata such as parameters, attributes, or any other desired information.
Each NFT has a PropertyMap to store these properties, which are saved as key-value pairs:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
/// A Map for typed key to value mapping, the contract using it
/// should keep track of what keys are what types, and parse them accordingly.
struct PropertyMap has drop, key {
    inner: SimpleMap<String, PropertyValue>,
}
/// A typed value for the `PropertyMap` to ensure that typing is always consistent
struct PropertyValue has drop, store {
    type: u8,
    value: vector<u8>,
}
Based on this, we can create data pairs:
let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[utf8(b"keys")],
    vector[utf8(b"types")],
    vector[b"value"]
);
Additional Functions
Key Functions for PropertyMap Management
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| init | Initializes PropertyMap | ref: &ConstructorRef, container: PropertyMap | None |
| extend | Adds PropertyMap to object | ref: &ExtendRef, container: PropertyMap | None |
| burn | Removes entire property map | ref: MutatorRef | None |
| prepare_input | Prepares property container | keys: vector, types: vector, values: vector<vector> | PropertyMap |
| generate_mutator_ref | Creates MutatorRef | ref: &ConstructorRef | MutatorRef |
PropertyMap Query Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| contains_key | Checks for key | object: &Object, key: &String | bool |
| length | Counts entries | object: &Object | u64 |
| read | Retrieves BCS-encoded property | object: &Object, key: &String | (String, vector) |
Type-Specific Read Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| read_bool | Retrieves boolean | object: &Object, key: &String | bool |
| read_u8/u16/u32/u64/u128/u256 | Retrieves unsigned integer | object: &Object, key: &String | respective uint |
| read_address | Retrieves address | object: &Object, key: &String | address |
| read_bytes | Retrieves byte vector | object: &Object, key: &String | vector |
| read_string | Retrieves string | object: &Object, key: &String | String |
PropertyMap Modification Functions
|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| add | Adds BCS-encoded property | ref: &MutatorRef, key: String, type: String, value: vector | None |
| add_typed | Adds non-BCS-encoded property | ref: &MutatorRef, key: String, value: T | None |
| update | Updates BCS-encoded property | ref: &MutatorRef, key: &String, type: String, value: vector | None |
| update_typed | Updates non-BCS-encoded property | ref: &MutatorRef, key: &String, value: T | None |
| remove | Deletes property | ref: &MutatorRef, key: &String | None |
	Summary
	Summary
	Royalties for NFT collections are defined using numerator and denominator values
NFT properties are stored in a PropertyMap as key-value pairs
Various functions are available for managing and querying PropertyMap data
Specific functions exist for reading different data types from PropertyMap
PropertyMap can be modified using add, update, and remove functions
	Royalties for NFT collections are defined using numerator and denominator values
	Royalties for NFT collections are defined using numerator and denominator values
	NFT properties are stored in a PropertyMap as key-value pairs
	NFT properties are stored in a PropertyMap as key-value pairs
	Various functions are available for managing and querying PropertyMap data
	Various functions are available for managing and querying PropertyMap data
	Specific functions exist for reading different data types from PropertyMap
	Specific functions exist for reading different data types from PropertyMap
	PropertyMap can be modified using add, update, and remove functions
	PropertyMap can be modified using add, update, and remove functions
	Royalty
	Royalty
	In the previous topic, we used
aptos_token::create_collection
to initialize a collection, which includes two parameters called
royalty
.
	In the previous topic, we used
	<code>aptos_token::create_collection</code>
	aptos_token::create_collection
	to initialize a collection, which includes two parameters called
	<code>royalty</code>
	royalty
	.
	<code>let collection_object = aptos_token::create_collection_object(
    admin,                                     // Creator
    utf8(COLLECTION_DESCRIPTION),              // Description
    1000,                                      // Max Supply
    utf8(COLLECTION_NAME),                     // Collection Name
    utf8(COLLECTION_URI),                      // Collection Uri
    true,                                      // mutable_description
    true,                                      // mutable_royalty
    true,                                      // mutable_uri
    true,                                      // mutable_token_description
    true,                                      // mutable_token_name
    true,                                      // mutable_token_properties
    true,                                      // mutable_token_uri
    true,                                      // tokens_burnable_by_creator
    true,                                      // tokens_freezable_by_creator
    0,                                         // royalty_numerator
    100,                                       // royalty_denominator
);</code>
	<code>let collection_object = aptos_token::create_collection_object(
    admin,                                     // Creator
    utf8(COLLECTION_DESCRIPTION),              // Description
    1000,                                      // Max Supply
    utf8(COLLECTION_NAME),                     // Collection Name
    utf8(COLLECTION_URI),                      // Collection Uri
    true,                                      // mutable_description
    true,                                      // mutable_royalty
    true,                                      // mutable_uri
    true,                                      // mutable_token_description
    true,                                      // mutable_token_name
    true,                                      // mutable_token_properties
    true,                                      // mutable_token_uri
    true,                                      // tokens_burnable_by_creator
    true,                                      // tokens_freezable_by_creator
    0,                                         // royalty_numerator
    100,                                       // royalty_denominator
);</code>
	let collection_object = aptos_token::create_collection_object(
    admin,                                     // Creator
    utf8(COLLECTION_DESCRIPTION),              // Description
    1000,                                      // Max Supply
    utf8(COLLECTION_NAME),                     // Collection Name
    utf8(COLLECTION_URI),                      // Collection Uri
    true,                                      // mutable_description
    true,                                      // mutable_royalty
    true,                                      // mutable_uri
    true,                                      // mutable_token_description
    true,                                      // mutable_token_name
    true,                                      // mutable_token_properties
    true,                                      // mutable_token_uri
    true,                                      // tokens_burnable_by_creator
    true,                                      // tokens_freezable_by_creator
    0,                                         // royalty_numerator
    100,                                       // royalty_denominator
);
	royalty_numerator
and
royalty_denominator
define the royalty percentage for the NFT collection. Specifically:
	<code>royalty_numerator</code>
	royalty_numerator
	and
	<code>royalty_denominator</code>
	royalty_denominator
	define the royalty percentage for the NFT collection. Specifically:
	royalty_numerator
: The royalty amount.
royalty_denominator
: The total transaction amount.
	royalty_numerator
: The royalty amount.
	<code>royalty_numerator</code>
	royalty_numerator
	: The royalty amount.
	royalty_denominator
: The total transaction amount.
	<code>royalty_denominator</code>
	royalty_denominator
	: The total transaction amount.
	The royalty percentage is calculated by dividing
royalty_numerator
by
royalty_denominator
.
	The royalty percentage is calculated by dividing
	<code>royalty_numerator</code>
	royalty_numerator
	by
	<code>royalty_denominator</code>
	royalty_denominator
	.
	In this example:
	In this example:
	<code>royalty_numerator = 0
royalty_denominator = 100</code>
	<code>royalty_numerator = 0
royalty_denominator = 100</code>
	royalty_numerator = 0
royalty_denominator = 100
	This results in a royalty percentage of 0/100 = 0%, meaning no royalties are applied to this collection. To set a royalty percentage—for example, 2.5%—you could use:
	This results in a royalty percentage of 0/100 = 0%, meaning no royalties are applied to this collection. To set a royalty percentage—for example, 2.5%—you could use:
	<code>royalty_numerator = 25
royalty_denominator = 1000</code>
	<code>royalty_numerator = 25
royalty_denominator = 1000</code>
	royalty_numerator = 25
royalty_denominator = 1000
	This creates a ratio of 25/1000 = 2.5%.
	This creates a ratio of 25/1000 = 2.5%.
	Using two separate values (instead of a simple decimal) allows for precise representation of fractions without encountering issues with decimal precision in computers.
	Using two separate values (instead of a simple decimal) allows for precise representation of fractions without encountering issues with decimal precision in computers.
	Property
	Property
	In the
mint_nft
function, we have three empty parameters:
	In the
	<code>mint_nft</code>
	mint_nft
	function, we have three empty parameters:
	<code>let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);</code>
	<code>let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);</code>
	let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
	Typically, an NFT contains additional metadata such as parameters, attributes, or any other desired information.
	Typically, an NFT contains additional metadata such as parameters, attributes, or any other desired information.
	Each NFT has a PropertyMap to store these properties, which are saved as key-value pairs:
	Each NFT has a PropertyMap to store these properties, which are saved as key-value pairs:
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
/// A Map for typed key to value mapping, the contract using it
/// should keep track of what keys are what types, and parse them accordingly.
struct PropertyMap has drop, key {
    inner: SimpleMap<String, PropertyValue>,
}
/// A typed value for the `PropertyMap` to ensure that typing is always consistent
struct PropertyValue has drop, store {
    type: u8,
    value: vector<u8>,
}</code>
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
/// A Map for typed key to value mapping, the contract using it
/// should keep track of what keys are what types, and parse them accordingly.
struct PropertyMap has drop, key {
    inner: SimpleMap<String, PropertyValue>,
}
/// A typed value for the `PropertyMap` to ensure that typing is always consistent
struct PropertyValue has drop, store {
    type: u8,
    value: vector<u8>,
}</code>
	#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
/// A Map for typed key to value mapping, the contract using it
/// should keep track of what keys are what types, and parse them accordingly.
struct PropertyMap has drop, key {
    inner: SimpleMap<String, PropertyValue>,
}
/// A typed value for the `PropertyMap` to ensure that typing is always consistent
struct PropertyValue has drop, store {
    type: u8,
    value: vector<u8>,
}
	Based on this, we can create data pairs:
	Based on this, we can create data pairs:
	<code>let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[utf8(b"keys")],
    vector[utf8(b"types")],
    vector[b"value"]
);</code>
	<code>let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[utf8(b"keys")],
    vector[utf8(b"types")],
    vector[b"value"]
);</code>
	let create_token_object = aptos_token::mint_token_object(
    user,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[utf8(b"keys")],
    vector[utf8(b"types")],
    vector[b"value"]
);
	Additional Functions
	Additional Functions
		Key Functions for PropertyMap Management
		Key Functions for PropertyMap Management
		|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| init | Initializes PropertyMap | ref: &ConstructorRef, container: PropertyMap | None |
| extend | Adds PropertyMap to object | ref: &ExtendRef, container: PropertyMap | None |
| burn | Removes entire property map | ref: MutatorRef | None |
| prepare_input | Prepares property container | keys: vector, types: vector, values: vector<vector> | PropertyMap |
| generate_mutator_ref | Creates MutatorRef | ref: &ConstructorRef | MutatorRef |
		|
		Function
		Function
		|
		Description
		Description
		|
		Parameters
		Parameters
		|
		Return
		Return
		|
| --- | --- | --- | --- |
| init | Initializes PropertyMap | ref: &ConstructorRef, container: PropertyMap | None |
| extend | Adds PropertyMap to object | ref: &ExtendRef, container: PropertyMap | None |
| burn | Removes entire property map | ref: MutatorRef | None |
| prepare_input | Prepares property container | keys: vector, types: vector, values: vector<vector> | PropertyMap |
| generate_mutator_ref | Creates MutatorRef | ref: &ConstructorRef | MutatorRef |
		PropertyMap Query Functions
		PropertyMap Query Functions
		|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| contains_key | Checks for key | object: &Object, key: &String | bool |
| length | Counts entries | object: &Object | u64 |
| read | Retrieves BCS-encoded property | object: &Object, key: &String | (String, vector) |
		|
		Function
		Function
		|
		Description
		Description
		|
		Parameters
		Parameters
		|
		Return
		Return
		|
| --- | --- | --- | --- |
| contains_key | Checks for key | object: &Object, key: &String | bool |
| length | Counts entries | object: &Object | u64 |
| read | Retrieves BCS-encoded property | object: &Object, key: &String | (String, vector) |
		Type-Specific Read Functions
		Type-Specific Read Functions
		|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| read_bool | Retrieves boolean | object: &Object, key: &String | bool |
| read_u8/u16/u32/u64/u128/u256 | Retrieves unsigned integer | object: &Object, key: &String | respective uint |
| read_address | Retrieves address | object: &Object, key: &String | address |
| read_bytes | Retrieves byte vector | object: &Object, key: &String | vector |
| read_string | Retrieves string | object: &Object, key: &String | String |
		|
		Function
		Function
		|
		Description
		Description
		|
		Parameters
		Parameters
		|
		Return
		Return
		|
| --- | --- | --- | --- |
| read_bool | Retrieves boolean | object: &Object, key: &String | bool |
| read_u8/u16/u32/u64/u128/u256 | Retrieves unsigned integer | object: &Object, key: &String | respective uint |
| read_address | Retrieves address | object: &Object, key: &String | address |
| read_bytes | Retrieves byte vector | object: &Object, key: &String | vector |
| read_string | Retrieves string | object: &Object, key: &String | String |
		PropertyMap Modification Functions
		PropertyMap Modification Functions
		|
Function
|
Description
|
Parameters
|
Return
|
| --- | --- | --- | --- |
| add | Adds BCS-encoded property | ref: &MutatorRef, key: String, type: String, value: vector | None |
| add_typed | Adds non-BCS-encoded property | ref: &MutatorRef, key: String, value: T | None |
| update | Updates BCS-encoded property | ref: &MutatorRef, key: &String, type: String, value: vector | None |
| update_typed | Updates non-BCS-encoded property | ref: &MutatorRef, key: &String, value: T | None |
| remove | Deletes property | ref: &MutatorRef, key: &String | None |
		|
		Function
		Function
		|
		Description
		Description
		|
		Parameters
		Parameters
		|
		Return
		Return
		|
| --- | --- | --- | --- |
| add | Adds BCS-encoded property | ref: &MutatorRef, key: String, type: String, value: vector | None |
| add_typed | Adds non-BCS-encoded property | ref: &MutatorRef, key: String, value: T | None |
| update | Updates BCS-encoded property | ref: &MutatorRef, key: &String, type: String, value: vector | None |
| update_typed | Updates non-BCS-encoded property | ref: &MutatorRef, key: &String, value: T | None |
| remove | Deletes property | ref: &MutatorRef, key: &String | None |

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/nft/08-permission-to-mint-nfts
Permission to mint NFTs
Permission to mint NFTs
On This Page
Summary
Create ExtendRef
Open Minting to Everyone
FullCode
Summary
Introduces the concept of ExtendRef to allow minting of NFTs by users
Demonstrates how to initialize ExtendRef and store it in MovementCollection struct
Shows implementation of a
mint_nft
function that allows anyone to mint NFTs
Utilizes
ExtendRef
to create and transfer token objects to users
Provides full code example of the NFT minting module in Rust
Includes functions for creating collections, minting NFTs, and retrieving collection and token addresses
Create ExtendRef
In the previous topic, we helped the collection admin create a token. So how do we allow everyone to mint these NFTs? Actually, we've learned this in the
object
section—it's about initializing object abilities, specifically
ExtendRef
in this case.
In this example, we'll initialize ExtendRef and store it in MovementCollection:
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
    extend_ref: ExtendRef
}
Next, we'll initialize extend_ref in the
create_movement_collection
function:
let creator_constructor_ref = &object::create_object(admin_addr);
let extend_ref = object::generate_extend_ref(creator_constructor_ref);
let creator = &object::generate_signer_for_extending(&extend_ref);
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new(),
    extend_ref
});
Open Minting to Everyone
After initializing
ExtendRef
, we can allow users to use it to create
NFT
s. In this example, we'll allow everyone to mint NFTs:
public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(owner);
    let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        creator,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
    object::transfer(creator, create_token_object, user_addr);
}
In the example above, we use data from
MovementCollection
via borrow_global at a specific owner address. This will be a parameter because we can have multiple collections, and users can choose to mint_nft from any Collection.
let movement_collection = borrow_global_mut<MovementCollection>(owner);
let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
Finally, we'll initialize the NFT and transfer it to the owner using
extend_ref
:
let create_token_object = aptos_token::mint_token_object(
    creator,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
object::transfer(creator, create_token_object, user_addr);
FullCode
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_token_objects::property_map;
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        extend_ref: ExtendRef
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
        extend_ref: ExtendRef
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(creator: &signer) {
        let creator_constructor_ref = &object::create_object(@movement);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        move_to(creator, CollectionManager {
            extend_ref
        })
    }
    public entry fun create_movement_collection(admin: &signer) {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let creator_constructor_ref = &object::create_object(admin_addr);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        let creator = &object::generate_signer_for_extending(&extend_ref);
        let collection_object = aptos_token::create_collection_object(
            creator,                                   // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new(),
            extend_ref
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(owner);
        let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            creator,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
        object::transfer(creator, create_token_object, user_addr);
    }
    #[view]
    public fun get_token_object_address(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}
On This Page
Summary
Create ExtendRef
Open Minting to Everyone
FullCode
On This Page
Summary
Create ExtendRef
Open Minting to Everyone
FullCode
			On This Page
			On This Page
			Summary
Create ExtendRef
Open Minting to Everyone
FullCode
			Summary
			Summary
			Summary
			Summary
			Create ExtendRef
			Create ExtendRef
			Create ExtendRef
			Create ExtendRef
			Open Minting to Everyone
FullCode
			Open Minting to Everyone
			Open Minting to Everyone
			Open Minting to Everyone
			FullCode
			FullCode
			FullCode
			FullCode
			FullCode
			Summary
Introduces the concept of ExtendRef to allow minting of NFTs by users
Demonstrates how to initialize ExtendRef and store it in MovementCollection struct
Shows implementation of a
mint_nft
function that allows anyone to mint NFTs
Utilizes
ExtendRef
to create and transfer token objects to users
Provides full code example of the NFT minting module in Rust
Includes functions for creating collections, minting NFTs, and retrieving collection and token addresses
Create ExtendRef
In the previous topic, we helped the collection admin create a token. So how do we allow everyone to mint these NFTs? Actually, we've learned this in the
object
section—it's about initializing object abilities, specifically
ExtendRef
in this case.
In this example, we'll initialize ExtendRef and store it in MovementCollection:
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
    extend_ref: ExtendRef
}
Next, we'll initialize extend_ref in the
create_movement_collection
function:
let creator_constructor_ref = &object::create_object(admin_addr);
let extend_ref = object::generate_extend_ref(creator_constructor_ref);
let creator = &object::generate_signer_for_extending(&extend_ref);
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new(),
    extend_ref
});
Open Minting to Everyone
After initializing
ExtendRef
, we can allow users to use it to create
NFT
s. In this example, we'll allow everyone to mint NFTs:
public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(owner);
    let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        creator,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
    object::transfer(creator, create_token_object, user_addr);
}
In the example above, we use data from
MovementCollection
via borrow_global at a specific owner address. This will be a parameter because we can have multiple collections, and users can choose to mint_nft from any Collection.
let movement_collection = borrow_global_mut<MovementCollection>(owner);
let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
Finally, we'll initialize the NFT and transfer it to the owner using
extend_ref
:
let create_token_object = aptos_token::mint_token_object(
    creator,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
object::transfer(creator, create_token_object, user_addr);
FullCode
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_token_objects::property_map;
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        extend_ref: ExtendRef
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
        extend_ref: ExtendRef
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(creator: &signer) {
        let creator_constructor_ref = &object::create_object(@movement);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        move_to(creator, CollectionManager {
            extend_ref
        })
    }
    public entry fun create_movement_collection(admin: &signer) {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let creator_constructor_ref = &object::create_object(admin_addr);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        let creator = &object::generate_signer_for_extending(&extend_ref);
        let collection_object = aptos_token::create_collection_object(
            creator,                                   // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new(),
            extend_ref
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(owner);
        let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            creator,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
        object::transfer(creator, create_token_object, user_addr);
    }
    #[view]
    public fun get_token_object_address(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}
			Summary
Introduces the concept of ExtendRef to allow minting of NFTs by users
Demonstrates how to initialize ExtendRef and store it in MovementCollection struct
Shows implementation of a
mint_nft
function that allows anyone to mint NFTs
Utilizes
ExtendRef
to create and transfer token objects to users
Provides full code example of the NFT minting module in Rust
Includes functions for creating collections, minting NFTs, and retrieving collection and token addresses
Create ExtendRef
In the previous topic, we helped the collection admin create a token. So how do we allow everyone to mint these NFTs? Actually, we've learned this in the
object
section—it's about initializing object abilities, specifically
ExtendRef
in this case.
In this example, we'll initialize ExtendRef and store it in MovementCollection:
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
    extend_ref: ExtendRef
}
Next, we'll initialize extend_ref in the
create_movement_collection
function:
let creator_constructor_ref = &object::create_object(admin_addr);
let extend_ref = object::generate_extend_ref(creator_constructor_ref);
let creator = &object::generate_signer_for_extending(&extend_ref);
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new(),
    extend_ref
});
Open Minting to Everyone
After initializing
ExtendRef
, we can allow users to use it to create
NFT
s. In this example, we'll allow everyone to mint NFTs:
public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(owner);
    let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        creator,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
    object::transfer(creator, create_token_object, user_addr);
}
In the example above, we use data from
MovementCollection
via borrow_global at a specific owner address. This will be a parameter because we can have multiple collections, and users can choose to mint_nft from any Collection.
let movement_collection = borrow_global_mut<MovementCollection>(owner);
let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
Finally, we'll initialize the NFT and transfer it to the owner using
extend_ref
:
let create_token_object = aptos_token::mint_token_object(
    creator,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
object::transfer(creator, create_token_object, user_addr);
FullCode
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_token_objects::property_map;
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        extend_ref: ExtendRef
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
        extend_ref: ExtendRef
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(creator: &signer) {
        let creator_constructor_ref = &object::create_object(@movement);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        move_to(creator, CollectionManager {
            extend_ref
        })
    }
    public entry fun create_movement_collection(admin: &signer) {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let creator_constructor_ref = &object::create_object(admin_addr);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        let creator = &object::generate_signer_for_extending(&extend_ref);
        let collection_object = aptos_token::create_collection_object(
            creator,                                   // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new(),
            extend_ref
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(owner);
        let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            creator,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
        object::transfer(creator, create_token_object, user_addr);
    }
    #[view]
    public fun get_token_object_address(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}
			Summary
Introduces the concept of ExtendRef to allow minting of NFTs by users
Demonstrates how to initialize ExtendRef and store it in MovementCollection struct
Shows implementation of a
mint_nft
function that allows anyone to mint NFTs
Utilizes
ExtendRef
to create and transfer token objects to users
Provides full code example of the NFT minting module in Rust
Includes functions for creating collections, minting NFTs, and retrieving collection and token addresses
Create ExtendRef
In the previous topic, we helped the collection admin create a token. So how do we allow everyone to mint these NFTs? Actually, we've learned this in the
object
section—it's about initializing object abilities, specifically
ExtendRef
in this case.
In this example, we'll initialize ExtendRef and store it in MovementCollection:
struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
    extend_ref: ExtendRef
}
Next, we'll initialize extend_ref in the
create_movement_collection
function:
let creator_constructor_ref = &object::create_object(admin_addr);
let extend_ref = object::generate_extend_ref(creator_constructor_ref);
let creator = &object::generate_signer_for_extending(&extend_ref);
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new(),
    extend_ref
});
Open Minting to Everyone
After initializing
ExtendRef
, we can allow users to use it to create
NFT
s. In this example, we'll allow everyone to mint NFTs:
public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(owner);
    let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        creator,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
    object::transfer(creator, create_token_object, user_addr);
}
In the example above, we use data from
MovementCollection
via borrow_global at a specific owner address. This will be a parameter because we can have multiple collections, and users can choose to mint_nft from any Collection.
let movement_collection = borrow_global_mut<MovementCollection>(owner);
let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
Finally, we'll initialize the NFT and transfer it to the owner using
extend_ref
:
let create_token_object = aptos_token::mint_token_object(
    creator,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
object::transfer(creator, create_token_object, user_addr);
FullCode
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_token_objects::property_map;
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        extend_ref: ExtendRef
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
        extend_ref: ExtendRef
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(creator: &signer) {
        let creator_constructor_ref = &object::create_object(@movement);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        move_to(creator, CollectionManager {
            extend_ref
        })
    }
    public entry fun create_movement_collection(admin: &signer) {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let creator_constructor_ref = &object::create_object(admin_addr);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        let creator = &object::generate_signer_for_extending(&extend_ref);
        let collection_object = aptos_token::create_collection_object(
            creator,                                   // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new(),
            extend_ref
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(owner);
        let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            creator,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
        object::transfer(creator, create_token_object, user_addr);
    }
    #[view]
    public fun get_token_object_address(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}
	Summary
	Summary
	Introduces the concept of ExtendRef to allow minting of NFTs by users
Demonstrates how to initialize ExtendRef and store it in MovementCollection struct
Shows implementation of a
mint_nft
function that allows anyone to mint NFTs
Utilizes
ExtendRef
to create and transfer token objects to users
Provides full code example of the NFT minting module in Rust
Includes functions for creating collections, minting NFTs, and retrieving collection and token addresses
	Introduces the concept of ExtendRef to allow minting of NFTs by users
	Introduces the concept of ExtendRef to allow minting of NFTs by users
	Demonstrates how to initialize ExtendRef and store it in MovementCollection struct
	Demonstrates how to initialize ExtendRef and store it in MovementCollection struct
	Shows implementation of a
mint_nft
function that allows anyone to mint NFTs
	Shows implementation of a
	<code>mint_nft</code>
	mint_nft
	function that allows anyone to mint NFTs
	Utilizes
ExtendRef
to create and transfer token objects to users
	Utilizes
	<code>ExtendRef</code>
	ExtendRef
	to create and transfer token objects to users
	Provides full code example of the NFT minting module in Rust
	Provides full code example of the NFT minting module in Rust
	Includes functions for creating collections, minting NFTs, and retrieving collection and token addresses
	Includes functions for creating collections, minting NFTs, and retrieving collection and token addresses
	Create ExtendRef
	Create ExtendRef
	In the previous topic, we helped the collection admin create a token. So how do we allow everyone to mint these NFTs? Actually, we've learned this in the
object
section—it's about initializing object abilities, specifically
ExtendRef
in this case.
	In the previous topic, we helped the collection admin create a token. So how do we allow everyone to mint these NFTs? Actually, we've learned this in the
	<code>object</code>
	object
	section—it's about initializing object abilities, specifically
	<code>ExtendRef</code>
	ExtendRef
	in this case.
	In this example, we'll initialize ExtendRef and store it in MovementCollection:
	In this example, we'll initialize ExtendRef and store it in MovementCollection:
	<code>struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
    extend_ref: ExtendRef
}</code>
	<code>struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
    extend_ref: ExtendRef
}</code>
	struct MovementCollection has key {
    collection_object: Object<AptosCollection>,
    collection_address: address,
    collection_name: String,
    minting_enabled: bool,
    mint_fee: u64,
    minted_nfts: table::Table<address, vector<address>>,
    extend_ref: ExtendRef
}
	Next, we'll initialize extend_ref in the
create_movement_collection
function:
	Next, we'll initialize extend_ref in the
	<code>create_movement_collection</code>
	create_movement_collection
	function:
	<code>let creator_constructor_ref = &object::create_object(admin_addr);
let extend_ref = object::generate_extend_ref(creator_constructor_ref);
let creator = &object::generate_signer_for_extending(&extend_ref);
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new(),
    extend_ref
});</code>
	<code>let creator_constructor_ref = &object::create_object(admin_addr);
let extend_ref = object::generate_extend_ref(creator_constructor_ref);
let creator = &object::generate_signer_for_extending(&extend_ref);
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new(),
    extend_ref
});</code>
	let creator_constructor_ref = &object::create_object(admin_addr);
let extend_ref = object::generate_extend_ref(creator_constructor_ref);
let creator = &object::generate_signer_for_extending(&extend_ref);
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
    collection_object,
    collection_address,
    collection_name: utf8(COLLECTION_NAME),
    minting_enabled: true,
    mint_fee: 0,
    minted_nfts: table::new(),
    extend_ref
});
	Open Minting to Everyone
	Open Minting to Everyone
	After initializing
ExtendRef
, we can allow users to use it to create
NFT
s. In this example, we'll allow everyone to mint NFTs:
	After initializing
	<code>ExtendRef</code>
	ExtendRef
	, we can allow users to use it to create
	<code>NFT</code>
	NFT
	s. In this example, we'll allow everyone to mint NFTs:
	<code>public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(owner);
    let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        creator,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
    object::transfer(creator, create_token_object, user_addr);
}</code>
	<code>public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(owner);
    let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        creator,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
    object::transfer(creator, create_token_object, user_addr);
}</code>
	public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
    let user_addr = signer::address_of(user);
    let movement_collection = borrow_global_mut<MovementCollection>(owner);
    let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
    if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
        table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
    };
    let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
    let create_token_object = aptos_token::mint_token_object(
        creator,
        movement_collection.collection_name,
        utf8(b"Token Movement Description"),
        utf8(b"Token Movement Name"),
        utf8(b"Token URI"),
        vector[],
        vector[],
        vector[]
    );
    let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
    vector::push_back(nft_minted, token_address);
    object::transfer(creator, create_token_object, user_addr);
}
	In the example above, we use data from
MovementCollection
via borrow_global at a specific owner address. This will be a parameter because we can have multiple collections, and users can choose to mint_nft from any Collection.
	In the example above, we use data from
	<code>MovementCollection</code>
	MovementCollection
	via borrow_global at a specific owner address. This will be a parameter because we can have multiple collections, and users can choose to mint_nft from any Collection.
	<code>let movement_collection = borrow_global_mut<MovementCollection>(owner);
let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);</code>
	<code>let movement_collection = borrow_global_mut<MovementCollection>(owner);
let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);</code>
	let movement_collection = borrow_global_mut<MovementCollection>(owner);
let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
	Finally, we'll initialize the NFT and transfer it to the owner using
extend_ref
:
	Finally, we'll initialize the NFT and transfer it to the owner using
	<code>extend_ref</code>
	extend_ref
	:
	<code>let create_token_object = aptos_token::mint_token_object(
    creator,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
object::transfer(creator, create_token_object, user_addr);</code>
	<code>let create_token_object = aptos_token::mint_token_object(
    creator,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
object::transfer(creator, create_token_object, user_addr);</code>
	let create_token_object = aptos_token::mint_token_object(
    creator,
    movement_collection.collection_name,
    utf8(b"Token Movement Description"),
    utf8(b"Token Movement Name"),
    utf8(b"Token URI"),
    vector[],
    vector[],
    vector[]
);
object::transfer(creator, create_token_object, user_addr);
		FullCode
		FullCode
		<code>module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_token_objects::property_map;
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        extend_ref: ExtendRef
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
        extend_ref: ExtendRef
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(creator: &signer) {
        let creator_constructor_ref = &object::create_object(@movement);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        move_to(creator, CollectionManager {
            extend_ref
        })
    }
    public entry fun create_movement_collection(admin: &signer) {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let creator_constructor_ref = &object::create_object(admin_addr);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        let creator = &object::generate_signer_for_extending(&extend_ref);
        let collection_object = aptos_token::create_collection_object(
            creator,                                   // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new(),
            extend_ref
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(owner);
        let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            creator,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
        object::transfer(creator, create_token_object, user_addr);
    }
    #[view]
    public fun get_token_object_address(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}</code>
		<code>module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_token_objects::property_map;
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        extend_ref: ExtendRef
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
        extend_ref: ExtendRef
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(creator: &signer) {
        let creator_constructor_ref = &object::create_object(@movement);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        move_to(creator, CollectionManager {
            extend_ref
        })
    }
    public entry fun create_movement_collection(admin: &signer) {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let creator_constructor_ref = &object::create_object(admin_addr);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        let creator = &object::generate_signer_for_extending(&extend_ref);
        let collection_object = aptos_token::create_collection_object(
            creator,                                   // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new(),
            extend_ref
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(owner);
        let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            creator,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
        object::transfer(creator, create_token_object, user_addr);
    }
    #[view]
    public fun get_token_object_address(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}</code>
		module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
    use aptos_token_objects::token;
    use aptos_token_objects::collection::{Self,Collection};
    use aptos_token_objects::property_map;
    use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
    use std::signer;
    use std::table;
    use std::option;
    use std::string::{utf8, String};
    use std::event;
    use std::vector;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
    struct CollectionManager has key {
        extend_ref: ExtendRef
    }
    struct MovementCollection has key {
        collection_object: Object<AptosCollection>,
        collection_address: address,
        collection_name: String,
        minting_enabled: bool,
        mint_fee: u64,
        minted_nfts: table::Table<address, vector<address>>,
        extend_ref: ExtendRef
    }
    #[event]
    struct CreateMovementCollectionEvents has drop, store {
        collection_address: address,
        collection_name: String,
        owner: address
    }
    fun init_module(creator: &signer) {
        let creator_constructor_ref = &object::create_object(@movement);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        move_to(creator, CollectionManager {
            extend_ref
        })
    }
    public entry fun create_movement_collection(admin: &signer) {
        let admin_addr = signer::address_of(admin);
        assert!(!exists<MovementCollection>(admin_addr), 0);
        let creator_constructor_ref = &object::create_object(admin_addr);
        let extend_ref = object::generate_extend_ref(creator_constructor_ref);
        let creator = &object::generate_signer_for_extending(&extend_ref);
        let collection_object = aptos_token::create_collection_object(
            creator,                                   // Creator
            utf8(COLLECTION_DESCRIPTION),              // Desciprtion
            1000,                                      // Max Supply
            utf8(COLLECTION_NAME),                     // Collection Name
            utf8(COLLECTION_URI),                      // Collection Uri
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
        let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
        move_to(admin, MovementCollection {
            collection_object,
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            minting_enabled: true,
            mint_fee: 0,
            minted_nfts: table::new(),
            extend_ref
        });
        event::emit(CreateMovementCollectionEvents {
            collection_address,
            collection_name: utf8(COLLECTION_NAME),
            owner: admin_addr
        });
    }
    #[view]
    public fun get_collection_object_address(owner: address): address acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        object::create_object_address(&owner, COLLECTION_NAME)
    }
    public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
        let user_addr = signer::address_of(user);
        let movement_collection = borrow_global_mut<MovementCollection>(owner);
        let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
        if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
            table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
        };
        let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
        let create_token_object = aptos_token::mint_token_object(
            creator,
            movement_collection.collection_name,
            utf8(b"Token Movement Description"),
            utf8(b"Token Movement Name"),
            utf8(b"Token URI"),
            vector[],
            vector[],
            vector[]
        );
        let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
        vector::push_back(nft_minted, token_address);
        object::transfer(creator, create_token_object, user_addr);
    }
    #[view]
    public fun get_token_object_address(owner: address): vector<address> acquires MovementCollection {
        let movement_collection = borrow_global<MovementCollection>(owner);
        *table::borrow(&movement_collection.minted_nfts, owner)
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/nft/09-aptos-collection-and-token-v2
Aptos Collection & Token V2
Aptos Collection & Token V2
On This Page
Summary
Overview
Aptos Tokens
Summary
Aptos Collection & Token V2 provides enhanced customization and standardization for NFTs on the Aptos blockchain.
The
aptos_token_objects::aptos_token
module offers a standardized approach for creating collections and tokens.
Aptos Collections are created with two resources:
Collection
and
AptosCollection
, allowing for various customizable attributes.
Aptos Tokens automatically generate ability options for mutator, burn, and transfer operations, simplifying the token creation process.
The
AptosToken
object provides built-in functionality for burning, transferring, and mutating tokens without manual setup.
This approach offers greater flexibility and ease of use compared to manual initialization with
aptos_token_objects::token
.
Overview
With the use of
use aptos_token_objects::token
to initialize tokens, or using
use aptos_token_objects::collection
and
collection::create_fixed_collection
to initialize collections, these are Tokens that you can customize according to your preferences. However, with
aptos_framework
, they also provide you with another standard to standardize
aptos_tokens
(token v2), making synchronization in common cases easier through
aptos_token_objects::aptos_token
When initializing with
collection::create_fixed_collection
, we will create an object called Collection, but when you initialize an Aptos Collection through the function
aptos_tokens::create_collection
, you will receive 2 resources including:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Collection has key {
   creator: address,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosCollection has key {
    mutator_ref: Option<collection::MutatorRef>,
    royalty_mutator_ref: Option<royalty::MutatorRef>,
    mutable_description: bool,
    mutable_uri: bool,
    mutable_token_description: bool,
    mutable_token_name: bool,
    mutable_token_properties: bool,
    mutable_token_uri: bool,
    tokens_burnable_by_creator: bool,
    tokens_freezable_by_creator: bool,
}
For example, when using the
aptos_token::create_collection
function:
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token;
    use std::string;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    fun init_module(caller: &signer) {
        aptos_token::create_collection(
            caller,                                    // Creator
            string::utf8(b"Move Spiders are awesome"), // Collection Description
            1000,                                      // Max Supply
            string::utf8(b"Move Spiders"),             // Collection Name
            string::utf8(b"https://movementlabs.xyz"), // Collection URI
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
    }
}
Here you can see that with
aptos_collection
, you can easily customize various
ability
settings. These include options to modify internal fields of the
token
, such as
description
,
royalty
,
uri
, and more.
Aptos Tokens
Similar to Aptos Collection, aptos_token also provides a Mint function based on the
AptosCollection
you've previously created. This function is akin to create_token in
aptos_token_objects::token
, but with a key difference: it automatically generates various
ability
options for
mutator
,
burn
, or
transfer
operations. This eliminates the need for manual setup as we did before.
When using
aptos_token::mint
, we not only create a
Token
object but also an additional object called
AptosToken
:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Token has key {
   collection: Object<Collection>,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosToken has key {
    burn_ref: Option<token::BurnRef>,
    transfer_ref: Option<object::TransferRef>,
    mutator_ref: Option<token::MutatorRef>,
    property_mutator_ref: property_map::MutatorRef,
}
With AptosToken already initialized and using the
ability
options you need without manual initialization as when using
aptos_token_objects::token
fun create_movement_token(caller: &signer) {
    aptos_token::mint(
        caller,                                        // creator
        string::utf8(COLLECTION_NAME),                 // collection name
        string::utf8(b"Movement Token description"),   // token description
        string::utf8(b"Movement Token"),               // token name
        string::utf8(b"https://movementlabs.xyz"),     // token uri
        vector[],                                      // property_keys
        vector[],                                      // property_types
        vector[],                                      // property_values
    )
}
On This Page
Summary
Overview
Aptos Tokens
On This Page
Summary
Overview
Aptos Tokens
			On This Page
			On This Page
			Summary
Overview
Aptos Tokens
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			Aptos Tokens
			Aptos Tokens
			Aptos Tokens
			Aptos Tokens
			Summary
Aptos Collection & Token V2 provides enhanced customization and standardization for NFTs on the Aptos blockchain.
The
aptos_token_objects::aptos_token
module offers a standardized approach for creating collections and tokens.
Aptos Collections are created with two resources:
Collection
and
AptosCollection
, allowing for various customizable attributes.
Aptos Tokens automatically generate ability options for mutator, burn, and transfer operations, simplifying the token creation process.
The
AptosToken
object provides built-in functionality for burning, transferring, and mutating tokens without manual setup.
This approach offers greater flexibility and ease of use compared to manual initialization with
aptos_token_objects::token
.
Overview
With the use of
use aptos_token_objects::token
to initialize tokens, or using
use aptos_token_objects::collection
and
collection::create_fixed_collection
to initialize collections, these are Tokens that you can customize according to your preferences. However, with
aptos_framework
, they also provide you with another standard to standardize
aptos_tokens
(token v2), making synchronization in common cases easier through
aptos_token_objects::aptos_token
When initializing with
collection::create_fixed_collection
, we will create an object called Collection, but when you initialize an Aptos Collection through the function
aptos_tokens::create_collection
, you will receive 2 resources including:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Collection has key {
   creator: address,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosCollection has key {
    mutator_ref: Option<collection::MutatorRef>,
    royalty_mutator_ref: Option<royalty::MutatorRef>,
    mutable_description: bool,
    mutable_uri: bool,
    mutable_token_description: bool,
    mutable_token_name: bool,
    mutable_token_properties: bool,
    mutable_token_uri: bool,
    tokens_burnable_by_creator: bool,
    tokens_freezable_by_creator: bool,
}
For example, when using the
aptos_token::create_collection
function:
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token;
    use std::string;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    fun init_module(caller: &signer) {
        aptos_token::create_collection(
            caller,                                    // Creator
            string::utf8(b"Move Spiders are awesome"), // Collection Description
            1000,                                      // Max Supply
            string::utf8(b"Move Spiders"),             // Collection Name
            string::utf8(b"https://movementlabs.xyz"), // Collection URI
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
    }
}
Here you can see that with
aptos_collection
, you can easily customize various
ability
settings. These include options to modify internal fields of the
token
, such as
description
,
royalty
,
uri
, and more.
Aptos Tokens
Similar to Aptos Collection, aptos_token also provides a Mint function based on the
AptosCollection
you've previously created. This function is akin to create_token in
aptos_token_objects::token
, but with a key difference: it automatically generates various
ability
options for
mutator
,
burn
, or
transfer
operations. This eliminates the need for manual setup as we did before.
When using
aptos_token::mint
, we not only create a
Token
object but also an additional object called
AptosToken
:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Token has key {
   collection: Object<Collection>,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosToken has key {
    burn_ref: Option<token::BurnRef>,
    transfer_ref: Option<object::TransferRef>,
    mutator_ref: Option<token::MutatorRef>,
    property_mutator_ref: property_map::MutatorRef,
}
With AptosToken already initialized and using the
ability
options you need without manual initialization as when using
aptos_token_objects::token
fun create_movement_token(caller: &signer) {
    aptos_token::mint(
        caller,                                        // creator
        string::utf8(COLLECTION_NAME),                 // collection name
        string::utf8(b"Movement Token description"),   // token description
        string::utf8(b"Movement Token"),               // token name
        string::utf8(b"https://movementlabs.xyz"),     // token uri
        vector[],                                      // property_keys
        vector[],                                      // property_types
        vector[],                                      // property_values
    )
}
			Summary
Aptos Collection & Token V2 provides enhanced customization and standardization for NFTs on the Aptos blockchain.
The
aptos_token_objects::aptos_token
module offers a standardized approach for creating collections and tokens.
Aptos Collections are created with two resources:
Collection
and
AptosCollection
, allowing for various customizable attributes.
Aptos Tokens automatically generate ability options for mutator, burn, and transfer operations, simplifying the token creation process.
The
AptosToken
object provides built-in functionality for burning, transferring, and mutating tokens without manual setup.
This approach offers greater flexibility and ease of use compared to manual initialization with
aptos_token_objects::token
.
Overview
With the use of
use aptos_token_objects::token
to initialize tokens, or using
use aptos_token_objects::collection
and
collection::create_fixed_collection
to initialize collections, these are Tokens that you can customize according to your preferences. However, with
aptos_framework
, they also provide you with another standard to standardize
aptos_tokens
(token v2), making synchronization in common cases easier through
aptos_token_objects::aptos_token
When initializing with
collection::create_fixed_collection
, we will create an object called Collection, but when you initialize an Aptos Collection through the function
aptos_tokens::create_collection
, you will receive 2 resources including:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Collection has key {
   creator: address,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosCollection has key {
    mutator_ref: Option<collection::MutatorRef>,
    royalty_mutator_ref: Option<royalty::MutatorRef>,
    mutable_description: bool,
    mutable_uri: bool,
    mutable_token_description: bool,
    mutable_token_name: bool,
    mutable_token_properties: bool,
    mutable_token_uri: bool,
    tokens_burnable_by_creator: bool,
    tokens_freezable_by_creator: bool,
}
For example, when using the
aptos_token::create_collection
function:
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token;
    use std::string;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    fun init_module(caller: &signer) {
        aptos_token::create_collection(
            caller,                                    // Creator
            string::utf8(b"Move Spiders are awesome"), // Collection Description
            1000,                                      // Max Supply
            string::utf8(b"Move Spiders"),             // Collection Name
            string::utf8(b"https://movementlabs.xyz"), // Collection URI
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
    }
}
Here you can see that with
aptos_collection
, you can easily customize various
ability
settings. These include options to modify internal fields of the
token
, such as
description
,
royalty
,
uri
, and more.
Aptos Tokens
Similar to Aptos Collection, aptos_token also provides a Mint function based on the
AptosCollection
you've previously created. This function is akin to create_token in
aptos_token_objects::token
, but with a key difference: it automatically generates various
ability
options for
mutator
,
burn
, or
transfer
operations. This eliminates the need for manual setup as we did before.
When using
aptos_token::mint
, we not only create a
Token
object but also an additional object called
AptosToken
:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Token has key {
   collection: Object<Collection>,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosToken has key {
    burn_ref: Option<token::BurnRef>,
    transfer_ref: Option<object::TransferRef>,
    mutator_ref: Option<token::MutatorRef>,
    property_mutator_ref: property_map::MutatorRef,
}
With AptosToken already initialized and using the
ability
options you need without manual initialization as when using
aptos_token_objects::token
fun create_movement_token(caller: &signer) {
    aptos_token::mint(
        caller,                                        // creator
        string::utf8(COLLECTION_NAME),                 // collection name
        string::utf8(b"Movement Token description"),   // token description
        string::utf8(b"Movement Token"),               // token name
        string::utf8(b"https://movementlabs.xyz"),     // token uri
        vector[],                                      // property_keys
        vector[],                                      // property_types
        vector[],                                      // property_values
    )
}
			Summary
Aptos Collection & Token V2 provides enhanced customization and standardization for NFTs on the Aptos blockchain.
The
aptos_token_objects::aptos_token
module offers a standardized approach for creating collections and tokens.
Aptos Collections are created with two resources:
Collection
and
AptosCollection
, allowing for various customizable attributes.
Aptos Tokens automatically generate ability options for mutator, burn, and transfer operations, simplifying the token creation process.
The
AptosToken
object provides built-in functionality for burning, transferring, and mutating tokens without manual setup.
This approach offers greater flexibility and ease of use compared to manual initialization with
aptos_token_objects::token
.
Overview
With the use of
use aptos_token_objects::token
to initialize tokens, or using
use aptos_token_objects::collection
and
collection::create_fixed_collection
to initialize collections, these are Tokens that you can customize according to your preferences. However, with
aptos_framework
, they also provide you with another standard to standardize
aptos_tokens
(token v2), making synchronization in common cases easier through
aptos_token_objects::aptos_token
When initializing with
collection::create_fixed_collection
, we will create an object called Collection, but when you initialize an Aptos Collection through the function
aptos_tokens::create_collection
, you will receive 2 resources including:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Collection has key {
   creator: address,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosCollection has key {
    mutator_ref: Option<collection::MutatorRef>,
    royalty_mutator_ref: Option<royalty::MutatorRef>,
    mutable_description: bool,
    mutable_uri: bool,
    mutable_token_description: bool,
    mutable_token_name: bool,
    mutable_token_properties: bool,
    mutable_token_uri: bool,
    tokens_burnable_by_creator: bool,
    tokens_freezable_by_creator: bool,
}
For example, when using the
aptos_token::create_collection
function:
module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token;
    use std::string;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    fun init_module(caller: &signer) {
        aptos_token::create_collection(
            caller,                                    // Creator
            string::utf8(b"Move Spiders are awesome"), // Collection Description
            1000,                                      // Max Supply
            string::utf8(b"Move Spiders"),             // Collection Name
            string::utf8(b"https://movementlabs.xyz"), // Collection URI
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
    }
}
Here you can see that with
aptos_collection
, you can easily customize various
ability
settings. These include options to modify internal fields of the
token
, such as
description
,
royalty
,
uri
, and more.
Aptos Tokens
Similar to Aptos Collection, aptos_token also provides a Mint function based on the
AptosCollection
you've previously created. This function is akin to create_token in
aptos_token_objects::token
, but with a key difference: it automatically generates various
ability
options for
mutator
,
burn
, or
transfer
operations. This eliminates the need for manual setup as we did before.
When using
aptos_token::mint
, we not only create a
Token
object but also an additional object called
AptosToken
:
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Token has key {
   collection: Object<Collection>,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosToken has key {
    burn_ref: Option<token::BurnRef>,
    transfer_ref: Option<object::TransferRef>,
    mutator_ref: Option<token::MutatorRef>,
    property_mutator_ref: property_map::MutatorRef,
}
With AptosToken already initialized and using the
ability
options you need without manual initialization as when using
aptos_token_objects::token
fun create_movement_token(caller: &signer) {
    aptos_token::mint(
        caller,                                        // creator
        string::utf8(COLLECTION_NAME),                 // collection name
        string::utf8(b"Movement Token description"),   // token description
        string::utf8(b"Movement Token"),               // token name
        string::utf8(b"https://movementlabs.xyz"),     // token uri
        vector[],                                      // property_keys
        vector[],                                      // property_types
        vector[],                                      // property_values
    )
}
	Summary
	Summary
	Aptos Collection & Token V2 provides enhanced customization and standardization for NFTs on the Aptos blockchain.
The
aptos_token_objects::aptos_token
module offers a standardized approach for creating collections and tokens.
Aptos Collections are created with two resources:
Collection
and
AptosCollection
, allowing for various customizable attributes.
Aptos Tokens automatically generate ability options for mutator, burn, and transfer operations, simplifying the token creation process.
The
AptosToken
object provides built-in functionality for burning, transferring, and mutating tokens without manual setup.
This approach offers greater flexibility and ease of use compared to manual initialization with
aptos_token_objects::token
.
	Aptos Collection & Token V2 provides enhanced customization and standardization for NFTs on the Aptos blockchain.
	Aptos Collection & Token V2 provides enhanced customization and standardization for NFTs on the Aptos blockchain.
	The
aptos_token_objects::aptos_token
module offers a standardized approach for creating collections and tokens.
	The
	<code>aptos_token_objects::aptos_token</code>
	aptos_token_objects::aptos_token
	module offers a standardized approach for creating collections and tokens.
	Aptos Collections are created with two resources:
Collection
and
AptosCollection
, allowing for various customizable attributes.
	Aptos Collections are created with two resources:
	<code>Collection</code>
	Collection
	and
	<code>AptosCollection</code>
	AptosCollection
	, allowing for various customizable attributes.
	Aptos Tokens automatically generate ability options for mutator, burn, and transfer operations, simplifying the token creation process.
	Aptos Tokens automatically generate ability options for mutator, burn, and transfer operations, simplifying the token creation process.
	The
AptosToken
object provides built-in functionality for burning, transferring, and mutating tokens without manual setup.
	The
	<code>AptosToken</code>
	AptosToken
	object provides built-in functionality for burning, transferring, and mutating tokens without manual setup.
	This approach offers greater flexibility and ease of use compared to manual initialization with
aptos_token_objects::token
.
	This approach offers greater flexibility and ease of use compared to manual initialization with
	<code>aptos_token_objects::token</code>
	aptos_token_objects::token
	.
	Overview
	Overview
	With the use of
use aptos_token_objects::token
to initialize tokens, or using
use aptos_token_objects::collection
and
collection::create_fixed_collection
to initialize collections, these are Tokens that you can customize according to your preferences. However, with
aptos_framework
, they also provide you with another standard to standardize
aptos_tokens
(token v2), making synchronization in common cases easier through
aptos_token_objects::aptos_token
	With the use of
	<code>use aptos_token_objects::token</code>
	use aptos_token_objects::token
	to initialize tokens, or using
	<code>use aptos_token_objects::collection</code>
	use aptos_token_objects::collection
	and
	<code>collection::create_fixed_collection</code>
	collection::create_fixed_collection
	to initialize collections, these are Tokens that you can customize according to your preferences. However, with
	<code>aptos_framework</code>
	aptos_framework
	, they also provide you with another standard to standardize
	<code>aptos_tokens</code>
	aptos_tokens
	(token v2), making synchronization in common cases easier through
	<code>aptos_token_objects::aptos_token</code>
	aptos_token_objects::aptos_token
	When initializing with
collection::create_fixed_collection
, we will create an object called Collection, but when you initialize an Aptos Collection through the function
aptos_tokens::create_collection
, you will receive 2 resources including:
	When initializing with
	<code>collection::create_fixed_collection</code>
	collection::create_fixed_collection
	, we will create an object called Collection, but when you initialize an Aptos Collection through the function
	<code>aptos_tokens::create_collection</code>
	aptos_tokens::create_collection
	, you will receive 2 resources including:
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Collection has key {
   creator: address,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosCollection has key {
    mutator_ref: Option<collection::MutatorRef>,
    royalty_mutator_ref: Option<royalty::MutatorRef>,
    mutable_description: bool,
    mutable_uri: bool,
    mutable_token_description: bool,
    mutable_token_name: bool,
    mutable_token_properties: bool,
    mutable_token_uri: bool,
    tokens_burnable_by_creator: bool,
    tokens_freezable_by_creator: bool,
}</code>
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Collection has key {
   creator: address,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosCollection has key {
    mutator_ref: Option<collection::MutatorRef>,
    royalty_mutator_ref: Option<royalty::MutatorRef>,
    mutable_description: bool,
    mutable_uri: bool,
    mutable_token_description: bool,
    mutable_token_name: bool,
    mutable_token_properties: bool,
    mutable_token_uri: bool,
    tokens_burnable_by_creator: bool,
    tokens_freezable_by_creator: bool,
}</code>
	#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Collection has key {
   creator: address,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosCollection has key {
    mutator_ref: Option<collection::MutatorRef>,
    royalty_mutator_ref: Option<royalty::MutatorRef>,
    mutable_description: bool,
    mutable_uri: bool,
    mutable_token_description: bool,
    mutable_token_name: bool,
    mutable_token_properties: bool,
    mutable_token_uri: bool,
    tokens_burnable_by_creator: bool,
    tokens_freezable_by_creator: bool,
}
	For example, when using the
aptos_token::create_collection
function:
	For example, when using the
	<code>aptos_token::create_collection</code>
	aptos_token::create_collection
	function:
	<code>module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token;
    use std::string;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    fun init_module(caller: &signer) {
        aptos_token::create_collection(
            caller,                                    // Creator
            string::utf8(b"Move Spiders are awesome"), // Collection Description
            1000,                                      // Max Supply
            string::utf8(b"Move Spiders"),             // Collection Name
            string::utf8(b"https://movementlabs.xyz"), // Collection URI
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
    }
}</code>
	<code>module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token;
    use std::string;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    fun init_module(caller: &signer) {
        aptos_token::create_collection(
            caller,                                    // Creator
            string::utf8(b"Move Spiders are awesome"), // Collection Description
            1000,                                      // Max Supply
            string::utf8(b"Move Spiders"),             // Collection Name
            string::utf8(b"https://movementlabs.xyz"), // Collection URI
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
    }
}</code>
	module movement::nft_aptos_collection {
    use aptos_token_objects::aptos_token;
    use std::string;
    const COLLECTION_NAME: vector<u8> = b"Movement NFT";
    const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
    fun init_module(caller: &signer) {
        aptos_token::create_collection(
            caller,                                    // Creator
            string::utf8(b"Move Spiders are awesome"), // Collection Description
            1000,                                      // Max Supply
            string::utf8(b"Move Spiders"),             // Collection Name
            string::utf8(b"https://movementlabs.xyz"), // Collection URI
            true,                                      // mutable_description
            true,                                      // mutable_royalty
            true,                                      // mutable_uri
            true,                                      // mutable_token_description
            true,                                      // mutable_token_name
            true,                                      // mutable_token_properties
            true,                                      // mutable_token_uri
            true,                                      // tokens_burnable_by_creator
            true,                                      // tokens_freezable_by_creator
            0,                                         // royalty_numerator
            100,                                       // royatly_denominator
        );
    }
}
	Here you can see that with
aptos_collection
, you can easily customize various
ability
settings. These include options to modify internal fields of the
token
, such as
description
,
royalty
,
uri
, and more.
	Here you can see that with
	<code>aptos_collection</code>
	aptos_collection
	, you can easily customize various
	<code>ability</code>
	ability
	settings. These include options to modify internal fields of the
	<code>token</code>
	token
	, such as
	<code>description</code>
	description
	,
	<code>royalty</code>
	royalty
	,
	<code>uri</code>
	uri
	, and more.
	Aptos Tokens
	Aptos Tokens
	Similar to Aptos Collection, aptos_token also provides a Mint function based on the
AptosCollection
you've previously created. This function is akin to create_token in
aptos_token_objects::token
, but with a key difference: it automatically generates various
ability
options for
mutator
,
burn
, or
transfer
operations. This eliminates the need for manual setup as we did before.
	Similar to Aptos Collection, aptos_token also provides a Mint function based on the
	<code>AptosCollection</code>
	AptosCollection
	you've previously created. This function is akin to create_token in
	<code>aptos_token_objects::token</code>
	aptos_token_objects::token
	, but with a key difference: it automatically generates various
	<code>ability</code>
	ability
	options for
	<code>mutator</code>
	mutator
	,
	<code>burn</code>
	burn
	, or
	<code>transfer</code>
	transfer
	operations. This eliminates the need for manual setup as we did before.
	When using
aptos_token::mint
, we not only create a
Token
object but also an additional object called
AptosToken
:
	When using
	<code>aptos_token::mint</code>
	aptos_token::mint
	, we not only create a
	<code>Token</code>
	Token
	object but also an additional object called
	<code>AptosToken</code>
	AptosToken
	:
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Token has key {
   collection: Object<Collection>,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosToken has key {
    burn_ref: Option<token::BurnRef>,
    transfer_ref: Option<object::TransferRef>,
    mutator_ref: Option<token::MutatorRef>,
    property_mutator_ref: property_map::MutatorRef,
}</code>
	<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Token has key {
   collection: Object<Collection>,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosToken has key {
    burn_ref: Option<token::BurnRef>,
    transfer_ref: Option<object::TransferRef>,
    mutator_ref: Option<token::MutatorRef>,
    property_mutator_ref: property_map::MutatorRef,
}</code>
	#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Token has key {
   collection: Object<Collection>,
   description: String,
   name: String,
   uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosToken has key {
    burn_ref: Option<token::BurnRef>,
    transfer_ref: Option<object::TransferRef>,
    mutator_ref: Option<token::MutatorRef>,
    property_mutator_ref: property_map::MutatorRef,
}
	With AptosToken already initialized and using the
ability
options you need without manual initialization as when using
aptos_token_objects::token
	With AptosToken already initialized and using the
	<code>ability</code>
	ability
	options you need without manual initialization as when using
	<code>aptos_token_objects::token</code>
	aptos_token_objects::token
	<code>fun create_movement_token(caller: &signer) {
    aptos_token::mint(
        caller,                                        // creator
        string::utf8(COLLECTION_NAME),                 // collection name
        string::utf8(b"Movement Token description"),   // token description
        string::utf8(b"Movement Token"),               // token name
        string::utf8(b"https://movementlabs.xyz"),     // token uri
        vector[],                                      // property_keys
        vector[],                                      // property_types
        vector[],                                      // property_values
    )
}</code>
	<code>fun create_movement_token(caller: &signer) {
    aptos_token::mint(
        caller,                                        // creator
        string::utf8(COLLECTION_NAME),                 // collection name
        string::utf8(b"Movement Token description"),   // token description
        string::utf8(b"Movement Token"),               // token name
        string::utf8(b"https://movementlabs.xyz"),     // token uri
        vector[],                                      // property_keys
        vector[],                                      // property_types
        vector[],                                      // property_values
    )
}</code>
	fun create_movement_token(caller: &signer) {
    aptos_token::mint(
        caller,                                        // creator
        string::utf8(COLLECTION_NAME),                 // collection name
        string::utf8(b"Movement Token description"),   // token description
        string::utf8(b"Movement Token"),               // token name
        string::utf8(b"https://movementlabs.xyz"),     // token uri
        vector[],                                      // property_keys
        vector[],                                      // property_types
        vector[],                                      // property_values
    )
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi
DeFi
DeFi
Learn how to create and manage coins, swap tokens, and provide liquidity. Explore lending protocols, pool types, and liquidation processes in the DeFi space.
Learn how to create and manage coins, swap tokens, and provide liquidity. Explore lending protocols, pool types, and liquidation processes in the DeFi space.
Start
Start
Fungible Asset
Start
Swap
Start
Pump4Fun
Start
Lending & Borrowing
Start
Fungible Asset
Start
Fungible Asset
Start
Fungible Asset
Fungible Asset
Start
Start
Swap
Start
Swap
Start
Swap
Swap
Start
Start
Pump4Fun
Start
Pump4Fun
Start
Pump4Fun
Pump4Fun
Start
Start
Lending & Borrowing
Start
Lending & Borrowing
Start
Lending & Borrowing
Lending & Borrowing
Start
Start

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/01-fungible-asset
Fungible Asset
Fungible Asset
Start
Start
What is Fungible Asset (FA)
Start
Fungible Asset Framework Functions
Start
Primary Fungible Store Framework Functions
Start
Fungible Asset vs Primary Fungible Store Details
Start
Initialize a Fungible Asset
Start
Management Functions Fungible Asset Framework
Start
Transfer a Fungible Asset
Start
What is Fungible Asset (FA)
Start
What is Fungible Asset (FA)
Start
What is Fungible Asset (FA)
What is Fungible Asset (FA)
Start
Start
Fungible Asset Framework Functions
Start
Fungible Asset Framework Functions
Start
Fungible Asset Framework Functions
Fungible Asset Framework Functions
Start
Start
Primary Fungible Store Framework Functions
Start
Primary Fungible Store Framework Functions
Start
Primary Fungible Store Framework Functions
Primary Fungible Store Framework Functions
Start
Start
Fungible Asset vs Primary Fungible Store Details
Start
Fungible Asset vs Primary Fungible Store Details
Start
Fungible Asset vs Primary Fungible Store Details
Fungible Asset vs Primary Fungible Store Details
Start
Start
Initialize a Fungible Asset
Start
Initialize a Fungible Asset
Start
Initialize a Fungible Asset
Initialize a Fungible Asset
Start
Start
Management Functions Fungible Asset Framework
Start
Management Functions Fungible Asset Framework
Start
Management Functions Fungible Asset Framework
Management Functions Fungible Asset Framework
Start
Start
Transfer a Fungible Asset
Start
Transfer a Fungible Asset
Start
Transfer a Fungible Asset
Transfer a Fungible Asset
Start
Start

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/01-fungible-asset/01-what-is-fungible-asset-fa
What is Fungible Asset (FA)
What is Fungible Asset (FA)
Fungible assets, or tokens, are digital representations of value on a blockchain platform. Here’s a breakdown:
| Token Standards | Like ERC-20 (Ethereum) or BEP-20 (Binance Smart Chain). These are the rules of the game, making sure tokens play nice with wallets and exchanges. |
| --- | --- |
| Smart Contracts/Modules | These are programs that manage tokens, specifying how they are created, transferred, and held. |
| Decentralization | Tokens operate on a blockchain, a transparent and secure system maintained by a network of computers. |
| Use Cases | Tokens can serve various purposes, like cryptocurrencies (e.g., Bitcoin), utility tokens (access to services), Stablecoins (cryptocurrencies that are pegged to fiat) or representing ownership of assets. |
| Transfers | Tokens can be sent to other blockchain addresses, with each transaction securely recorded using cryptographic signatures. |
| Ownership | Your tokens are yours thanks to private keys. |
| Interoperability | Tokens can interact with other tokens and applications on the same blockchain, enabling a wide range of functionalities. |
Movement offers two ways to create and manage tokens: Coin and Fungible Asset. Coin is considered the legacy standard, in this section we’ll focus on the new Fungible Asset standard.
The Fungible Asset standard allows you to:
Create and manage your own fungible asset.
Manage a user’s fungible store (like a digital wallet) for a specific asset.
Set a maximum supply, preventing unlimited minting (a feature Coin doesn’t have).
Customize permissions for actions like minting, burning, freezing, and forced transfers.
Use a fully functional freezing feature, unlike the limited one in the Coin standard.
In summary, the Fungible Asset standard provides more control and flexibility than the original Coin standard, offering enhanced capabilities for token management.
Fungible assets, or tokens, are digital representations of value on a blockchain platform. Here’s a breakdown:
| Token Standards | Like ERC-20 (Ethereum) or BEP-20 (Binance Smart Chain). These are the rules of the game, making sure tokens play nice with wallets and exchanges. |
| --- | --- |
| Smart Contracts/Modules | These are programs that manage tokens, specifying how they are created, transferred, and held. |
| Decentralization | Tokens operate on a blockchain, a transparent and secure system maintained by a network of computers. |
| Use Cases | Tokens can serve various purposes, like cryptocurrencies (e.g., Bitcoin), utility tokens (access to services), Stablecoins (cryptocurrencies that are pegged to fiat) or representing ownership of assets. |
| Transfers | Tokens can be sent to other blockchain addresses, with each transaction securely recorded using cryptographic signatures. |
| Ownership | Your tokens are yours thanks to private keys. |
| Interoperability | Tokens can interact with other tokens and applications on the same blockchain, enabling a wide range of functionalities. |
Movement offers two ways to create and manage tokens: Coin and Fungible Asset. Coin is considered the legacy standard, in this section we’ll focus on the new Fungible Asset standard.
The Fungible Asset standard allows you to:
Create and manage your own fungible asset.
Manage a user’s fungible store (like a digital wallet) for a specific asset.
Set a maximum supply, preventing unlimited minting (a feature Coin doesn’t have).
Customize permissions for actions like minting, burning, freezing, and forced transfers.
Use a fully functional freezing feature, unlike the limited one in the Coin standard.
In summary, the Fungible Asset standard provides more control and flexibility than the original Coin standard, offering enhanced capabilities for token management.
Fungible assets, or tokens, are digital representations of value on a blockchain platform. Here’s a breakdown:
| Token Standards | Like ERC-20 (Ethereum) or BEP-20 (Binance Smart Chain). These are the rules of the game, making sure tokens play nice with wallets and exchanges. |
| --- | --- |
| Smart Contracts/Modules | These are programs that manage tokens, specifying how they are created, transferred, and held. |
| Decentralization | Tokens operate on a blockchain, a transparent and secure system maintained by a network of computers. |
| Use Cases | Tokens can serve various purposes, like cryptocurrencies (e.g., Bitcoin), utility tokens (access to services), Stablecoins (cryptocurrencies that are pegged to fiat) or representing ownership of assets. |
| Transfers | Tokens can be sent to other blockchain addresses, with each transaction securely recorded using cryptographic signatures. |
| Ownership | Your tokens are yours thanks to private keys. |
| Interoperability | Tokens can interact with other tokens and applications on the same blockchain, enabling a wide range of functionalities. |
Movement offers two ways to create and manage tokens: Coin and Fungible Asset. Coin is considered the legacy standard, in this section we’ll focus on the new Fungible Asset standard.
The Fungible Asset standard allows you to:
Create and manage your own fungible asset.
Manage a user’s fungible store (like a digital wallet) for a specific asset.
Set a maximum supply, preventing unlimited minting (a feature Coin doesn’t have).
Customize permissions for actions like minting, burning, freezing, and forced transfers.
Use a fully functional freezing feature, unlike the limited one in the Coin standard.
In summary, the Fungible Asset standard provides more control and flexibility than the original Coin standard, offering enhanced capabilities for token management.
Fungible assets, or tokens, are digital representations of value on a blockchain platform. Here’s a breakdown:
| Token Standards | Like ERC-20 (Ethereum) or BEP-20 (Binance Smart Chain). These are the rules of the game, making sure tokens play nice with wallets and exchanges. |
| --- | --- |
| Smart Contracts/Modules | These are programs that manage tokens, specifying how they are created, transferred, and held. |
| Decentralization | Tokens operate on a blockchain, a transparent and secure system maintained by a network of computers. |
| Use Cases | Tokens can serve various purposes, like cryptocurrencies (e.g., Bitcoin), utility tokens (access to services), Stablecoins (cryptocurrencies that are pegged to fiat) or representing ownership of assets. |
| Transfers | Tokens can be sent to other blockchain addresses, with each transaction securely recorded using cryptographic signatures. |
| Ownership | Your tokens are yours thanks to private keys. |
| Interoperability | Tokens can interact with other tokens and applications on the same blockchain, enabling a wide range of functionalities. |
Movement offers two ways to create and manage tokens: Coin and Fungible Asset. Coin is considered the legacy standard, in this section we’ll focus on the new Fungible Asset standard.
The Fungible Asset standard allows you to:
Create and manage your own fungible asset.
Manage a user’s fungible store (like a digital wallet) for a specific asset.
Set a maximum supply, preventing unlimited minting (a feature Coin doesn’t have).
Customize permissions for actions like minting, burning, freezing, and forced transfers.
Use a fully functional freezing feature, unlike the limited one in the Coin standard.
In summary, the Fungible Asset standard provides more control and flexibility than the original Coin standard, offering enhanced capabilities for token management.
Fungible assets, or tokens, are digital representations of value on a blockchain platform. Here’s a breakdown:
Fungible assets, or tokens, are digital representations of value on a blockchain platform. Here’s a breakdown:
| Token Standards | Like ERC-20 (Ethereum) or BEP-20 (Binance Smart Chain). These are the rules of the game, making sure tokens play nice with wallets and exchanges. |
| --- | --- |
| Smart Contracts/Modules | These are programs that manage tokens, specifying how they are created, transferred, and held. |
| Decentralization | Tokens operate on a blockchain, a transparent and secure system maintained by a network of computers. |
| Use Cases | Tokens can serve various purposes, like cryptocurrencies (e.g., Bitcoin), utility tokens (access to services), Stablecoins (cryptocurrencies that are pegged to fiat) or representing ownership of assets. |
| Transfers | Tokens can be sent to other blockchain addresses, with each transaction securely recorded using cryptographic signatures. |
| Ownership | Your tokens are yours thanks to private keys. |
| Interoperability | Tokens can interact with other tokens and applications on the same blockchain, enabling a wide range of functionalities. |
| Token Standards | Like ERC-20 (Ethereum) or BEP-20 (Binance Smart Chain). These are the rules of the game, making sure tokens play nice with wallets and exchanges. |
| --- | --- |
| Smart Contracts/Modules | These are programs that manage tokens, specifying how they are created, transferred, and held. |
| Decentralization | Tokens operate on a blockchain, a transparent and secure system maintained by a network of computers. |
| Use Cases | Tokens can serve various purposes, like cryptocurrencies (e.g., Bitcoin), utility tokens (access to services), Stablecoins (cryptocurrencies that are pegged to fiat) or representing ownership of assets. |
| Transfers | Tokens can be sent to other blockchain addresses, with each transaction securely recorded using cryptographic signatures. |
| Ownership | Your tokens are yours thanks to private keys. |
| Interoperability | Tokens can interact with other tokens and applications on the same blockchain, enabling a wide range of functionalities. |
Movement offers two ways to create and manage tokens: Coin and Fungible Asset. Coin is considered the legacy standard, in this section we’ll focus on the new Fungible Asset standard.
Movement offers two ways to create and manage tokens: Coin and Fungible Asset. Coin is considered the legacy standard, in this section we’ll focus on the new Fungible Asset standard.
The Fungible Asset standard allows you to:
The Fungible Asset standard allows you to:
Create and manage your own fungible asset.
Manage a user’s fungible store (like a digital wallet) for a specific asset.
Set a maximum supply, preventing unlimited minting (a feature Coin doesn’t have).
Customize permissions for actions like minting, burning, freezing, and forced transfers.
Use a fully functional freezing feature, unlike the limited one in the Coin standard.
Create and manage your own fungible asset.
Create and manage your own fungible asset.
Manage a user’s fungible store (like a digital wallet) for a specific asset.
Manage a user’s fungible store (like a digital wallet) for a specific asset.
Set a maximum supply, preventing unlimited minting (a feature Coin doesn’t have).
Set a maximum supply, preventing unlimited minting (a feature Coin doesn’t have).
Customize permissions for actions like minting, burning, freezing, and forced transfers.
Customize permissions for actions like minting, burning, freezing, and forced transfers.
Use a fully functional freezing feature, unlike the limited one in the Coin standard.
Use a fully functional freezing feature, unlike the limited one in the Coin standard.
In summary, the Fungible Asset standard provides more control and flexibility than the original Coin standard, offering enhanced capabilities for token management.
In summary, the Fungible Asset standard provides more control and flexibility than the original Coin standard, offering enhanced capabilities for token management.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/01-fungible-asset/02-fungible-asset-framework-functions
Fungible Asset Framework Functions
Fungible Asset Framework Functions
On This Page
Summary
Core Functions
Minting & Burning
Asset Management
Store Management
Reference Generation
Metadata Management
Advanced Features
Dispatch Functions
Summary
Comprehensive framework for managing fungible assets in blockchain systems
Core functions for token initialization, storage, and basic transactions
Minting and burning capabilities for supply management
Asset management functions for splitting, merging, and optimizing tokens
Store management for lifecycle and state control of token stores
Reference generation for establishing permissions and authorities
Metadata management for retrieving and validating token information
Advanced features for enhanced security, performance, and customization
Core Functions
Overview:
Core functions represent the fundamental building blocks of the framework, essential for establishing and managing fungible assets. These functions are utilized when:
Initializing a new token type
Creating token storage facilities (stores)
Executing basic token transactions between stores
Managing deposit/withdraw operations
This function group serves as the foundation for all other operations within the framework and represents the most frequently used functionalities.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
add_fungibility
| constructor_ref:
&ConstructorRef
,
maximum_supply: Option<u128>
,
name: String
,
symbol: String
,
decimals: u8
,
icon_uri: String
,
project_uri: String
| Makes an existing object fungible by adding Metadata resource. Sets up maximum supply monitoring. | Object |
|
create_store
| constructor_ref:
&ConstructorRef
,
metadata: Object<T>
| Creates a new store for holding fungible assets with zero initial balance. | Object |
|
withdraw
| owner:
&signer
,
store: Object<T>
,
amount: u64
| Withdraws specified amount from store owned by signer. | FungibleAsset |
|
deposit
| store:
Object<T>
,
fa: FungibleAsset
| Deposits fungible asset into specified store. | void |
|
transfer
| sender:
&signer
,
from: Object<T>
,
to: Object<T>
,
amount: u64
| Transfers fungible assets between stores. | void |
Minting & Burning
Overview:
This group of functions handles token creation and destruction, commonly used in scenarios involving:
Issuing new tokens into circulation
Managing total token supply
Implementing tokenomics and emission schedules
Handling token burning events and supply reduction
These functions typically have restricted access, limited to addresses with token issuance authority (such as token owners).
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
mint
| ref: &MintRef, amount: u64 | Mints new fungible assets. | FungibleAsset |
|
mint_to
| ref: &MintRef, store: Object, amount: u64 | Mints directly to specified store. | void |
|
burn
| ref: &BurnRef, fa: FungibleAsset | Burns fungible assets. | void |
|
burn_from
| ref: &BurnRef, store: Object, amount: u64 | Burns amount from specified store. | void |
Asset Management
Overview:
Asset Management functions facilitate the manipulation and management of fungible assets. These are particularly useful when:
Splitting tokens into smaller denominations
Consolidating multiple token fragments
Managing zero-value tokens
Optimizing token handling in complex applications
These functions are essential for building sophisticated features like liquidity pools, vaults, or other DeFi mechanisms.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
extract
| fungible_asset: &mut FungibleAsset, amount: u64 | Extracts amount from existing asset. | FungibleAsset |
|
merge
| dst_fungible_asset: &mut FungibleAsset, src_fungible_asset: FungibleAsset | Merges two fungible assets. | void |
|
destroy_zero
| fungible_asset: FungibleAsset | Destroys zero-value asset. | void |
|
zero
| metadata: Object | Creates zero-value asset. | FungibleAsset |
Store Management
Overview:
Store Management functions handle the lifecycle and state of token stores. These functions are essential when:
Initializing and managing new wallets/stores
Checking store states and balances
Managing store freeze states
Cleaning up and removing unused stores
These functions are crucial for maintaining store lifecycle and ensuring secure token storage.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
remove_store
| delete_ref: &DeleteRef | Removes empty store. | void |
|
store_exists
| store: address | Checks if store exists. | bool |
|
balance
| store: Object | Gets store balance. | u64 |
|
is_frozen
| store: Object | Checks if store is frozen. | bool |
Reference Generation
Overview:
Reference Generation functions create capability references for fungible assets. These are utilized when:
Establishing mint/burn permissions
Setting up token transfer authorities
Implementing complex permission management
Creating permission-limited smart contracts
These functions are vital for implementing tokenomics and permission management within the system.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
generate_mint_ref
| constructor_ref: &ConstructorRef | Creates mint capability. | MintRef |
|
generate_burn_ref
| constructor_ref: &ConstructorRef | Creates burn capability. | BurnRef |
|
generate_transfer_ref
| constructor_ref: &ConstructorRef | Creates transfer capability. | TransferRef |
Metadata Management
Overview:
Metadata Management functions handle token descriptive information. These functions are essential when:
Retrieving token information
Verifying supply limits and current circulation
Displaying token information in UI/UX
Validating token properties
These functions are crucial for external system integration and providing user information.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
metadata
| metadata: Object | Gets metadata struct. | Metadata |
|
supply
| metadata: Object | Gets current supply. | Option |
|
maximum
| metadata: Object | Gets maximum supply. | Option |
|
name
| metadata: Object | Gets asset name. | String |
|
symbol
| metadata: Object | Gets asset symbol. | String |
|
decimals
| metadata: Object | Gets decimal places. | u8 |
Advanced Features
Overview:
Advanced Features provide enhanced functionality for fungible assets. These are implemented when:
Requiring specialized security mechanisms
Optimizing performance with concurrent operations
Establishing special transfer restrictions
Upgrading token functionality
These functions are typically employed in complex applications or when specific advanced features are needed.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
set_frozen_flag
| ref: &TransferRef, store: Object, frozen: bool | Sets store frozen status. | void |
|
upgrade_to_concurrent
| ref: &ExtendRef | Upgrades to concurrent supply. | void |
|
upgrade_store_to_concurrent
| owner: &signer, store: Object | Upgrades store to concurrent. | void |
|
set_untransferable
| constructor_ref: &ConstructorRef | Makes asset untransferable. | void |
Dispatch Functions
Overview:
Dispatch Functions enable customization of fungible asset behavior. These are used when:
Implementing custom transfer logic
Adding operation hooks
Creating derived calculations
Implementing complex business rules
These functions are designed for advanced users who need to customize their token's operational behavior.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
register_dispatch_functions
| constructor_ref: &ConstructorRef, withdraw_function: Option, deposit_function: Option, derived_balance_function: Option | Registers dispatch hooks. | void |
|
register_derive_supply_dispatch_function
| constructor_ref: &ConstructorRef, dispatch_function: Option | Registers supply derivation. | void |
On This Page
Summary
Core Functions
Minting & Burning
Asset Management
Store Management
Reference Generation
Metadata Management
Advanced Features
Dispatch Functions
On This Page
Summary
Core Functions
Minting & Burning
Asset Management
Store Management
Reference Generation
Metadata Management
Advanced Features
Dispatch Functions
			On This Page
			On This Page
			Summary
Core Functions
Minting & Burning
Asset Management
Store Management
Reference Generation
Metadata Management
Advanced Features
Dispatch Functions
			Summary
			Summary
			Summary
			Summary
			Core Functions
			Core Functions
			Core Functions
			Core Functions
			Minting & Burning
			Minting & Burning
			Minting & Burning
			Minting & Burning
			Asset Management
			Asset Management
			Asset Management
			Asset Management
			Store Management
			Store Management
			Store Management
			Store Management
			Reference Generation
			Reference Generation
			Reference Generation
			Reference Generation
			Metadata Management
			Metadata Management
			Metadata Management
			Metadata Management
			Advanced Features
			Advanced Features
			Advanced Features
			Advanced Features
			Dispatch Functions
			Dispatch Functions
			Dispatch Functions
			Dispatch Functions
			Summary
Comprehensive framework for managing fungible assets in blockchain systems
Core functions for token initialization, storage, and basic transactions
Minting and burning capabilities for supply management
Asset management functions for splitting, merging, and optimizing tokens
Store management for lifecycle and state control of token stores
Reference generation for establishing permissions and authorities
Metadata management for retrieving and validating token information
Advanced features for enhanced security, performance, and customization
Core Functions
Overview:
Core functions represent the fundamental building blocks of the framework, essential for establishing and managing fungible assets. These functions are utilized when:
Initializing a new token type
Creating token storage facilities (stores)
Executing basic token transactions between stores
Managing deposit/withdraw operations
This function group serves as the foundation for all other operations within the framework and represents the most frequently used functionalities.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
add_fungibility
| constructor_ref:
&ConstructorRef
,
maximum_supply: Option<u128>
,
name: String
,
symbol: String
,
decimals: u8
,
icon_uri: String
,
project_uri: String
| Makes an existing object fungible by adding Metadata resource. Sets up maximum supply monitoring. | Object |
|
create_store
| constructor_ref:
&ConstructorRef
,
metadata: Object<T>
| Creates a new store for holding fungible assets with zero initial balance. | Object |
|
withdraw
| owner:
&signer
,
store: Object<T>
,
amount: u64
| Withdraws specified amount from store owned by signer. | FungibleAsset |
|
deposit
| store:
Object<T>
,
fa: FungibleAsset
| Deposits fungible asset into specified store. | void |
|
transfer
| sender:
&signer
,
from: Object<T>
,
to: Object<T>
,
amount: u64
| Transfers fungible assets between stores. | void |
Minting & Burning
Overview:
This group of functions handles token creation and destruction, commonly used in scenarios involving:
Issuing new tokens into circulation
Managing total token supply
Implementing tokenomics and emission schedules
Handling token burning events and supply reduction
These functions typically have restricted access, limited to addresses with token issuance authority (such as token owners).
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
mint
| ref: &MintRef, amount: u64 | Mints new fungible assets. | FungibleAsset |
|
mint_to
| ref: &MintRef, store: Object, amount: u64 | Mints directly to specified store. | void |
|
burn
| ref: &BurnRef, fa: FungibleAsset | Burns fungible assets. | void |
|
burn_from
| ref: &BurnRef, store: Object, amount: u64 | Burns amount from specified store. | void |
Asset Management
Overview:
Asset Management functions facilitate the manipulation and management of fungible assets. These are particularly useful when:
Splitting tokens into smaller denominations
Consolidating multiple token fragments
Managing zero-value tokens
Optimizing token handling in complex applications
These functions are essential for building sophisticated features like liquidity pools, vaults, or other DeFi mechanisms.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
extract
| fungible_asset: &mut FungibleAsset, amount: u64 | Extracts amount from existing asset. | FungibleAsset |
|
merge
| dst_fungible_asset: &mut FungibleAsset, src_fungible_asset: FungibleAsset | Merges two fungible assets. | void |
|
destroy_zero
| fungible_asset: FungibleAsset | Destroys zero-value asset. | void |
|
zero
| metadata: Object | Creates zero-value asset. | FungibleAsset |
Store Management
Overview:
Store Management functions handle the lifecycle and state of token stores. These functions are essential when:
Initializing and managing new wallets/stores
Checking store states and balances
Managing store freeze states
Cleaning up and removing unused stores
These functions are crucial for maintaining store lifecycle and ensuring secure token storage.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
remove_store
| delete_ref: &DeleteRef | Removes empty store. | void |
|
store_exists
| store: address | Checks if store exists. | bool |
|
balance
| store: Object | Gets store balance. | u64 |
|
is_frozen
| store: Object | Checks if store is frozen. | bool |
Reference Generation
Overview:
Reference Generation functions create capability references for fungible assets. These are utilized when:
Establishing mint/burn permissions
Setting up token transfer authorities
Implementing complex permission management
Creating permission-limited smart contracts
These functions are vital for implementing tokenomics and permission management within the system.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
generate_mint_ref
| constructor_ref: &ConstructorRef | Creates mint capability. | MintRef |
|
generate_burn_ref
| constructor_ref: &ConstructorRef | Creates burn capability. | BurnRef |
|
generate_transfer_ref
| constructor_ref: &ConstructorRef | Creates transfer capability. | TransferRef |
Metadata Management
Overview:
Metadata Management functions handle token descriptive information. These functions are essential when:
Retrieving token information
Verifying supply limits and current circulation
Displaying token information in UI/UX
Validating token properties
These functions are crucial for external system integration and providing user information.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
metadata
| metadata: Object | Gets metadata struct. | Metadata |
|
supply
| metadata: Object | Gets current supply. | Option |
|
maximum
| metadata: Object | Gets maximum supply. | Option |
|
name
| metadata: Object | Gets asset name. | String |
|
symbol
| metadata: Object | Gets asset symbol. | String |
|
decimals
| metadata: Object | Gets decimal places. | u8 |
Advanced Features
Overview:
Advanced Features provide enhanced functionality for fungible assets. These are implemented when:
Requiring specialized security mechanisms
Optimizing performance with concurrent operations
Establishing special transfer restrictions
Upgrading token functionality
These functions are typically employed in complex applications or when specific advanced features are needed.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
set_frozen_flag
| ref: &TransferRef, store: Object, frozen: bool | Sets store frozen status. | void |
|
upgrade_to_concurrent
| ref: &ExtendRef | Upgrades to concurrent supply. | void |
|
upgrade_store_to_concurrent
| owner: &signer, store: Object | Upgrades store to concurrent. | void |
|
set_untransferable
| constructor_ref: &ConstructorRef | Makes asset untransferable. | void |
Dispatch Functions
Overview:
Dispatch Functions enable customization of fungible asset behavior. These are used when:
Implementing custom transfer logic
Adding operation hooks
Creating derived calculations
Implementing complex business rules
These functions are designed for advanced users who need to customize their token's operational behavior.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
register_dispatch_functions
| constructor_ref: &ConstructorRef, withdraw_function: Option, deposit_function: Option, derived_balance_function: Option | Registers dispatch hooks. | void |
|
register_derive_supply_dispatch_function
| constructor_ref: &ConstructorRef, dispatch_function: Option | Registers supply derivation. | void |
			Summary
Comprehensive framework for managing fungible assets in blockchain systems
Core functions for token initialization, storage, and basic transactions
Minting and burning capabilities for supply management
Asset management functions for splitting, merging, and optimizing tokens
Store management for lifecycle and state control of token stores
Reference generation for establishing permissions and authorities
Metadata management for retrieving and validating token information
Advanced features for enhanced security, performance, and customization
Core Functions
Overview:
Core functions represent the fundamental building blocks of the framework, essential for establishing and managing fungible assets. These functions are utilized when:
Initializing a new token type
Creating token storage facilities (stores)
Executing basic token transactions between stores
Managing deposit/withdraw operations
This function group serves as the foundation for all other operations within the framework and represents the most frequently used functionalities.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
add_fungibility
| constructor_ref:
&ConstructorRef
,
maximum_supply: Option<u128>
,
name: String
,
symbol: String
,
decimals: u8
,
icon_uri: String
,
project_uri: String
| Makes an existing object fungible by adding Metadata resource. Sets up maximum supply monitoring. | Object |
|
create_store
| constructor_ref:
&ConstructorRef
,
metadata: Object<T>
| Creates a new store for holding fungible assets with zero initial balance. | Object |
|
withdraw
| owner:
&signer
,
store: Object<T>
,
amount: u64
| Withdraws specified amount from store owned by signer. | FungibleAsset |
|
deposit
| store:
Object<T>
,
fa: FungibleAsset
| Deposits fungible asset into specified store. | void |
|
transfer
| sender:
&signer
,
from: Object<T>
,
to: Object<T>
,
amount: u64
| Transfers fungible assets between stores. | void |
Minting & Burning
Overview:
This group of functions handles token creation and destruction, commonly used in scenarios involving:
Issuing new tokens into circulation
Managing total token supply
Implementing tokenomics and emission schedules
Handling token burning events and supply reduction
These functions typically have restricted access, limited to addresses with token issuance authority (such as token owners).
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
mint
| ref: &MintRef, amount: u64 | Mints new fungible assets. | FungibleAsset |
|
mint_to
| ref: &MintRef, store: Object, amount: u64 | Mints directly to specified store. | void |
|
burn
| ref: &BurnRef, fa: FungibleAsset | Burns fungible assets. | void |
|
burn_from
| ref: &BurnRef, store: Object, amount: u64 | Burns amount from specified store. | void |
Asset Management
Overview:
Asset Management functions facilitate the manipulation and management of fungible assets. These are particularly useful when:
Splitting tokens into smaller denominations
Consolidating multiple token fragments
Managing zero-value tokens
Optimizing token handling in complex applications
These functions are essential for building sophisticated features like liquidity pools, vaults, or other DeFi mechanisms.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
extract
| fungible_asset: &mut FungibleAsset, amount: u64 | Extracts amount from existing asset. | FungibleAsset |
|
merge
| dst_fungible_asset: &mut FungibleAsset, src_fungible_asset: FungibleAsset | Merges two fungible assets. | void |
|
destroy_zero
| fungible_asset: FungibleAsset | Destroys zero-value asset. | void |
|
zero
| metadata: Object | Creates zero-value asset. | FungibleAsset |
Store Management
Overview:
Store Management functions handle the lifecycle and state of token stores. These functions are essential when:
Initializing and managing new wallets/stores
Checking store states and balances
Managing store freeze states
Cleaning up and removing unused stores
These functions are crucial for maintaining store lifecycle and ensuring secure token storage.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
remove_store
| delete_ref: &DeleteRef | Removes empty store. | void |
|
store_exists
| store: address | Checks if store exists. | bool |
|
balance
| store: Object | Gets store balance. | u64 |
|
is_frozen
| store: Object | Checks if store is frozen. | bool |
Reference Generation
Overview:
Reference Generation functions create capability references for fungible assets. These are utilized when:
Establishing mint/burn permissions
Setting up token transfer authorities
Implementing complex permission management
Creating permission-limited smart contracts
These functions are vital for implementing tokenomics and permission management within the system.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
generate_mint_ref
| constructor_ref: &ConstructorRef | Creates mint capability. | MintRef |
|
generate_burn_ref
| constructor_ref: &ConstructorRef | Creates burn capability. | BurnRef |
|
generate_transfer_ref
| constructor_ref: &ConstructorRef | Creates transfer capability. | TransferRef |
Metadata Management
Overview:
Metadata Management functions handle token descriptive information. These functions are essential when:
Retrieving token information
Verifying supply limits and current circulation
Displaying token information in UI/UX
Validating token properties
These functions are crucial for external system integration and providing user information.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
metadata
| metadata: Object | Gets metadata struct. | Metadata |
|
supply
| metadata: Object | Gets current supply. | Option |
|
maximum
| metadata: Object | Gets maximum supply. | Option |
|
name
| metadata: Object | Gets asset name. | String |
|
symbol
| metadata: Object | Gets asset symbol. | String |
|
decimals
| metadata: Object | Gets decimal places. | u8 |
Advanced Features
Overview:
Advanced Features provide enhanced functionality for fungible assets. These are implemented when:
Requiring specialized security mechanisms
Optimizing performance with concurrent operations
Establishing special transfer restrictions
Upgrading token functionality
These functions are typically employed in complex applications or when specific advanced features are needed.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
set_frozen_flag
| ref: &TransferRef, store: Object, frozen: bool | Sets store frozen status. | void |
|
upgrade_to_concurrent
| ref: &ExtendRef | Upgrades to concurrent supply. | void |
|
upgrade_store_to_concurrent
| owner: &signer, store: Object | Upgrades store to concurrent. | void |
|
set_untransferable
| constructor_ref: &ConstructorRef | Makes asset untransferable. | void |
Dispatch Functions
Overview:
Dispatch Functions enable customization of fungible asset behavior. These are used when:
Implementing custom transfer logic
Adding operation hooks
Creating derived calculations
Implementing complex business rules
These functions are designed for advanced users who need to customize their token's operational behavior.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
register_dispatch_functions
| constructor_ref: &ConstructorRef, withdraw_function: Option, deposit_function: Option, derived_balance_function: Option | Registers dispatch hooks. | void |
|
register_derive_supply_dispatch_function
| constructor_ref: &ConstructorRef, dispatch_function: Option | Registers supply derivation. | void |
			Summary
Comprehensive framework for managing fungible assets in blockchain systems
Core functions for token initialization, storage, and basic transactions
Minting and burning capabilities for supply management
Asset management functions for splitting, merging, and optimizing tokens
Store management for lifecycle and state control of token stores
Reference generation for establishing permissions and authorities
Metadata management for retrieving and validating token information
Advanced features for enhanced security, performance, and customization
Core Functions
Overview:
Core functions represent the fundamental building blocks of the framework, essential for establishing and managing fungible assets. These functions are utilized when:
Initializing a new token type
Creating token storage facilities (stores)
Executing basic token transactions between stores
Managing deposit/withdraw operations
This function group serves as the foundation for all other operations within the framework and represents the most frequently used functionalities.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
add_fungibility
| constructor_ref:
&ConstructorRef
,
maximum_supply: Option<u128>
,
name: String
,
symbol: String
,
decimals: u8
,
icon_uri: String
,
project_uri: String
| Makes an existing object fungible by adding Metadata resource. Sets up maximum supply monitoring. | Object |
|
create_store
| constructor_ref:
&ConstructorRef
,
metadata: Object<T>
| Creates a new store for holding fungible assets with zero initial balance. | Object |
|
withdraw
| owner:
&signer
,
store: Object<T>
,
amount: u64
| Withdraws specified amount from store owned by signer. | FungibleAsset |
|
deposit
| store:
Object<T>
,
fa: FungibleAsset
| Deposits fungible asset into specified store. | void |
|
transfer
| sender:
&signer
,
from: Object<T>
,
to: Object<T>
,
amount: u64
| Transfers fungible assets between stores. | void |
Minting & Burning
Overview:
This group of functions handles token creation and destruction, commonly used in scenarios involving:
Issuing new tokens into circulation
Managing total token supply
Implementing tokenomics and emission schedules
Handling token burning events and supply reduction
These functions typically have restricted access, limited to addresses with token issuance authority (such as token owners).
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
mint
| ref: &MintRef, amount: u64 | Mints new fungible assets. | FungibleAsset |
|
mint_to
| ref: &MintRef, store: Object, amount: u64 | Mints directly to specified store. | void |
|
burn
| ref: &BurnRef, fa: FungibleAsset | Burns fungible assets. | void |
|
burn_from
| ref: &BurnRef, store: Object, amount: u64 | Burns amount from specified store. | void |
Asset Management
Overview:
Asset Management functions facilitate the manipulation and management of fungible assets. These are particularly useful when:
Splitting tokens into smaller denominations
Consolidating multiple token fragments
Managing zero-value tokens
Optimizing token handling in complex applications
These functions are essential for building sophisticated features like liquidity pools, vaults, or other DeFi mechanisms.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
extract
| fungible_asset: &mut FungibleAsset, amount: u64 | Extracts amount from existing asset. | FungibleAsset |
|
merge
| dst_fungible_asset: &mut FungibleAsset, src_fungible_asset: FungibleAsset | Merges two fungible assets. | void |
|
destroy_zero
| fungible_asset: FungibleAsset | Destroys zero-value asset. | void |
|
zero
| metadata: Object | Creates zero-value asset. | FungibleAsset |
Store Management
Overview:
Store Management functions handle the lifecycle and state of token stores. These functions are essential when:
Initializing and managing new wallets/stores
Checking store states and balances
Managing store freeze states
Cleaning up and removing unused stores
These functions are crucial for maintaining store lifecycle and ensuring secure token storage.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
remove_store
| delete_ref: &DeleteRef | Removes empty store. | void |
|
store_exists
| store: address | Checks if store exists. | bool |
|
balance
| store: Object | Gets store balance. | u64 |
|
is_frozen
| store: Object | Checks if store is frozen. | bool |
Reference Generation
Overview:
Reference Generation functions create capability references for fungible assets. These are utilized when:
Establishing mint/burn permissions
Setting up token transfer authorities
Implementing complex permission management
Creating permission-limited smart contracts
These functions are vital for implementing tokenomics and permission management within the system.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
generate_mint_ref
| constructor_ref: &ConstructorRef | Creates mint capability. | MintRef |
|
generate_burn_ref
| constructor_ref: &ConstructorRef | Creates burn capability. | BurnRef |
|
generate_transfer_ref
| constructor_ref: &ConstructorRef | Creates transfer capability. | TransferRef |
Metadata Management
Overview:
Metadata Management functions handle token descriptive information. These functions are essential when:
Retrieving token information
Verifying supply limits and current circulation
Displaying token information in UI/UX
Validating token properties
These functions are crucial for external system integration and providing user information.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
metadata
| metadata: Object | Gets metadata struct. | Metadata |
|
supply
| metadata: Object | Gets current supply. | Option |
|
maximum
| metadata: Object | Gets maximum supply. | Option |
|
name
| metadata: Object | Gets asset name. | String |
|
symbol
| metadata: Object | Gets asset symbol. | String |
|
decimals
| metadata: Object | Gets decimal places. | u8 |
Advanced Features
Overview:
Advanced Features provide enhanced functionality for fungible assets. These are implemented when:
Requiring specialized security mechanisms
Optimizing performance with concurrent operations
Establishing special transfer restrictions
Upgrading token functionality
These functions are typically employed in complex applications or when specific advanced features are needed.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
set_frozen_flag
| ref: &TransferRef, store: Object, frozen: bool | Sets store frozen status. | void |
|
upgrade_to_concurrent
| ref: &ExtendRef | Upgrades to concurrent supply. | void |
|
upgrade_store_to_concurrent
| owner: &signer, store: Object | Upgrades store to concurrent. | void |
|
set_untransferable
| constructor_ref: &ConstructorRef | Makes asset untransferable. | void |
Dispatch Functions
Overview:
Dispatch Functions enable customization of fungible asset behavior. These are used when:
Implementing custom transfer logic
Adding operation hooks
Creating derived calculations
Implementing complex business rules
These functions are designed for advanced users who need to customize their token's operational behavior.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
register_dispatch_functions
| constructor_ref: &ConstructorRef, withdraw_function: Option, deposit_function: Option, derived_balance_function: Option | Registers dispatch hooks. | void |
|
register_derive_supply_dispatch_function
| constructor_ref: &ConstructorRef, dispatch_function: Option | Registers supply derivation. | void |
	Summary
	Summary
	Comprehensive framework for managing fungible assets in blockchain systems
Core functions for token initialization, storage, and basic transactions
Minting and burning capabilities for supply management
Asset management functions for splitting, merging, and optimizing tokens
Store management for lifecycle and state control of token stores
Reference generation for establishing permissions and authorities
Metadata management for retrieving and validating token information
Advanced features for enhanced security, performance, and customization
	Comprehensive framework for managing fungible assets in blockchain systems
	Comprehensive framework for managing fungible assets in blockchain systems
	Core functions for token initialization, storage, and basic transactions
	Core functions for token initialization, storage, and basic transactions
	Minting and burning capabilities for supply management
	Minting and burning capabilities for supply management
	Asset management functions for splitting, merging, and optimizing tokens
	Asset management functions for splitting, merging, and optimizing tokens
	Store management for lifecycle and state control of token stores
	Store management for lifecycle and state control of token stores
	Reference generation for establishing permissions and authorities
	Reference generation for establishing permissions and authorities
	Metadata management for retrieving and validating token information
	Metadata management for retrieving and validating token information
	Advanced features for enhanced security, performance, and customization
	Advanced features for enhanced security, performance, and customization
	Core Functions
	Core Functions
	Overview:
Core functions represent the fundamental building blocks of the framework, essential for establishing and managing fungible assets. These functions are utilized when:
	Overview:
	Overview:
	Core functions represent the fundamental building blocks of the framework, essential for establishing and managing fungible assets. These functions are utilized when:
	Initializing a new token type
Creating token storage facilities (stores)
Executing basic token transactions between stores
Managing deposit/withdraw operations
	Initializing a new token type
	Initializing a new token type
	Creating token storage facilities (stores)
	Creating token storage facilities (stores)
	Executing basic token transactions between stores
	Executing basic token transactions between stores
	Managing deposit/withdraw operations
	Managing deposit/withdraw operations
	This function group serves as the foundation for all other operations within the framework and represents the most frequently used functionalities.
	This function group serves as the foundation for all other operations within the framework and represents the most frequently used functionalities.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
add_fungibility
| constructor_ref:
&ConstructorRef
,
maximum_supply: Option<u128>
,
name: String
,
symbol: String
,
decimals: u8
,
icon_uri: String
,
project_uri: String
| Makes an existing object fungible by adding Metadata resource. Sets up maximum supply monitoring. | Object |
|
create_store
| constructor_ref:
&ConstructorRef
,
metadata: Object<T>
| Creates a new store for holding fungible assets with zero initial balance. | Object |
|
withdraw
| owner:
&signer
,
store: Object<T>
,
amount: u64
| Withdraws specified amount from store owned by signer. | FungibleAsset |
|
deposit
| store:
Object<T>
,
fa: FungibleAsset
| Deposits fungible asset into specified store. | void |
|
transfer
| sender:
&signer
,
from: Object<T>
,
to: Object<T>
,
amount: u64
| Transfers fungible assets between stores. | void |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>add_fungibility</code>
	add_fungibility
	| constructor_ref:
	<code>&ConstructorRef</code>
	&ConstructorRef
	,
	<code>maximum_supply: Option<u128></code>
	maximum_supply: Option<u128>
	,
	<code>name: String</code>
	name: String
	,
	<code>symbol: String</code>
	symbol: String
	,
	<code>decimals: u8</code>
	decimals: u8
	,
	<code>icon_uri: String</code>
	icon_uri: String
	,
	<code>project_uri: String</code>
	project_uri: String
	| Makes an existing object fungible by adding Metadata resource. Sets up maximum supply monitoring. | Object |
|
	<code>create_store</code>
	create_store
	| constructor_ref:
	<code>&ConstructorRef</code>
	&ConstructorRef
	,
	<code>metadata: Object<T></code>
	metadata: Object<T>
	| Creates a new store for holding fungible assets with zero initial balance. | Object |
|
	<code>withdraw</code>
	withdraw
	| owner:
	<code>&signer</code>
	&signer
	,
	<code>store: Object<T></code>
	store: Object<T>
	,
	<code>amount: u64</code>
	amount: u64
	| Withdraws specified amount from store owned by signer. | FungibleAsset |
|
	<code>deposit</code>
	deposit
	| store:
	<code>Object<T></code>
	Object<T>
	,
	<code>fa: FungibleAsset</code>
	fa: FungibleAsset
	| Deposits fungible asset into specified store. | void |
|
	<code>transfer</code>
	transfer
	| sender:
	<code>&signer</code>
	&signer
	,
	<code>from: Object<T></code>
	from: Object<T>
	,
	<code>to: Object<T></code>
	to: Object<T>
	,
	<code>amount: u64</code>
	amount: u64
	| Transfers fungible assets between stores. | void |
	Minting & Burning
	Minting & Burning
	Overview:
This group of functions handles token creation and destruction, commonly used in scenarios involving:
	Overview:
	Overview:
	This group of functions handles token creation and destruction, commonly used in scenarios involving:
	Issuing new tokens into circulation
Managing total token supply
Implementing tokenomics and emission schedules
Handling token burning events and supply reduction
	Issuing new tokens into circulation
	Issuing new tokens into circulation
	Managing total token supply
	Managing total token supply
	Implementing tokenomics and emission schedules
	Implementing tokenomics and emission schedules
	Handling token burning events and supply reduction
	Handling token burning events and supply reduction
	These functions typically have restricted access, limited to addresses with token issuance authority (such as token owners).
	These functions typically have restricted access, limited to addresses with token issuance authority (such as token owners).
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
mint
| ref: &MintRef, amount: u64 | Mints new fungible assets. | FungibleAsset |
|
mint_to
| ref: &MintRef, store: Object, amount: u64 | Mints directly to specified store. | void |
|
burn
| ref: &BurnRef, fa: FungibleAsset | Burns fungible assets. | void |
|
burn_from
| ref: &BurnRef, store: Object, amount: u64 | Burns amount from specified store. | void |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>mint</code>
	mint
	| ref: &MintRef, amount: u64 | Mints new fungible assets. | FungibleAsset |
|
	<code>mint_to</code>
	mint_to
	| ref: &MintRef, store: Object, amount: u64 | Mints directly to specified store. | void |
|
	<code>burn</code>
	burn
	| ref: &BurnRef, fa: FungibleAsset | Burns fungible assets. | void |
|
	<code>burn_from</code>
	burn_from
	| ref: &BurnRef, store: Object, amount: u64 | Burns amount from specified store. | void |
	Asset Management
	Asset Management
	Overview:
Asset Management functions facilitate the manipulation and management of fungible assets. These are particularly useful when:
	Overview:
	Overview:
	Asset Management functions facilitate the manipulation and management of fungible assets. These are particularly useful when:
	Splitting tokens into smaller denominations
Consolidating multiple token fragments
Managing zero-value tokens
Optimizing token handling in complex applications
	Splitting tokens into smaller denominations
	Splitting tokens into smaller denominations
	Consolidating multiple token fragments
	Consolidating multiple token fragments
	Managing zero-value tokens
	Managing zero-value tokens
	Optimizing token handling in complex applications
	Optimizing token handling in complex applications
	These functions are essential for building sophisticated features like liquidity pools, vaults, or other DeFi mechanisms.
	These functions are essential for building sophisticated features like liquidity pools, vaults, or other DeFi mechanisms.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
extract
| fungible_asset: &mut FungibleAsset, amount: u64 | Extracts amount from existing asset. | FungibleAsset |
|
merge
| dst_fungible_asset: &mut FungibleAsset, src_fungible_asset: FungibleAsset | Merges two fungible assets. | void |
|
destroy_zero
| fungible_asset: FungibleAsset | Destroys zero-value asset. | void |
|
zero
| metadata: Object | Creates zero-value asset. | FungibleAsset |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>extract</code>
	extract
	| fungible_asset: &mut FungibleAsset, amount: u64 | Extracts amount from existing asset. | FungibleAsset |
|
	<code>merge</code>
	merge
	| dst_fungible_asset: &mut FungibleAsset, src_fungible_asset: FungibleAsset | Merges two fungible assets. | void |
|
	<code>destroy_zero</code>
	destroy_zero
	| fungible_asset: FungibleAsset | Destroys zero-value asset. | void |
|
	<code>zero</code>
	zero
	| metadata: Object | Creates zero-value asset. | FungibleAsset |
	Store Management
	Store Management
	Overview:
Store Management functions handle the lifecycle and state of token stores. These functions are essential when:
	Overview:
	Overview:
	Store Management functions handle the lifecycle and state of token stores. These functions are essential when:
	Initializing and managing new wallets/stores
Checking store states and balances
Managing store freeze states
Cleaning up and removing unused stores
	Initializing and managing new wallets/stores
	Initializing and managing new wallets/stores
	Checking store states and balances
	Checking store states and balances
	Managing store freeze states
	Managing store freeze states
	Cleaning up and removing unused stores
	Cleaning up and removing unused stores
	These functions are crucial for maintaining store lifecycle and ensuring secure token storage.
	These functions are crucial for maintaining store lifecycle and ensuring secure token storage.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
remove_store
| delete_ref: &DeleteRef | Removes empty store. | void |
|
store_exists
| store: address | Checks if store exists. | bool |
|
balance
| store: Object | Gets store balance. | u64 |
|
is_frozen
| store: Object | Checks if store is frozen. | bool |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>remove_store</code>
	remove_store
	| delete_ref: &DeleteRef | Removes empty store. | void |
|
	<code>store_exists</code>
	store_exists
	| store: address | Checks if store exists. | bool |
|
	<code>balance</code>
	balance
	| store: Object | Gets store balance. | u64 |
|
	<code>is_frozen</code>
	is_frozen
	| store: Object | Checks if store is frozen. | bool |
	Reference Generation
	Reference Generation
	Overview:
Reference Generation functions create capability references for fungible assets. These are utilized when:
	Overview:
	Overview:
	Reference Generation functions create capability references for fungible assets. These are utilized when:
	Establishing mint/burn permissions
Setting up token transfer authorities
Implementing complex permission management
Creating permission-limited smart contracts
	Establishing mint/burn permissions
	Establishing mint/burn permissions
	Setting up token transfer authorities
	Setting up token transfer authorities
	Implementing complex permission management
	Implementing complex permission management
	Creating permission-limited smart contracts
	Creating permission-limited smart contracts
	These functions are vital for implementing tokenomics and permission management within the system.
	These functions are vital for implementing tokenomics and permission management within the system.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
generate_mint_ref
| constructor_ref: &ConstructorRef | Creates mint capability. | MintRef |
|
generate_burn_ref
| constructor_ref: &ConstructorRef | Creates burn capability. | BurnRef |
|
generate_transfer_ref
| constructor_ref: &ConstructorRef | Creates transfer capability. | TransferRef |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>generate_mint_ref</code>
	generate_mint_ref
	| constructor_ref: &ConstructorRef | Creates mint capability. | MintRef |
|
	<code>generate_burn_ref</code>
	generate_burn_ref
	| constructor_ref: &ConstructorRef | Creates burn capability. | BurnRef |
|
	<code>generate_transfer_ref</code>
	generate_transfer_ref
	| constructor_ref: &ConstructorRef | Creates transfer capability. | TransferRef |
	Metadata Management
	Metadata Management
	Overview:
Metadata Management functions handle token descriptive information. These functions are essential when:
	Overview:
	Overview:
	Metadata Management functions handle token descriptive information. These functions are essential when:
	Retrieving token information
Verifying supply limits and current circulation
Displaying token information in UI/UX
Validating token properties
	Retrieving token information
	Retrieving token information
	Verifying supply limits and current circulation
	Verifying supply limits and current circulation
	Displaying token information in UI/UX
	Displaying token information in UI/UX
	Validating token properties
	Validating token properties
	These functions are crucial for external system integration and providing user information.
	These functions are crucial for external system integration and providing user information.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
metadata
| metadata: Object | Gets metadata struct. | Metadata |
|
supply
| metadata: Object | Gets current supply. | Option |
|
maximum
| metadata: Object | Gets maximum supply. | Option |
|
name
| metadata: Object | Gets asset name. | String |
|
symbol
| metadata: Object | Gets asset symbol. | String |
|
decimals
| metadata: Object | Gets decimal places. | u8 |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>metadata</code>
	metadata
	| metadata: Object | Gets metadata struct. | Metadata |
|
	<code>supply</code>
	supply
	| metadata: Object | Gets current supply. | Option |
|
	<code>maximum</code>
	maximum
	| metadata: Object | Gets maximum supply. | Option |
|
	<code>name</code>
	name
	| metadata: Object | Gets asset name. | String |
|
	<code>symbol</code>
	symbol
	| metadata: Object | Gets asset symbol. | String |
|
	<code>decimals</code>
	decimals
	| metadata: Object | Gets decimal places. | u8 |
	Advanced Features
	Advanced Features
	Overview:
Advanced Features provide enhanced functionality for fungible assets. These are implemented when:
	Overview:
	Overview:
	Advanced Features provide enhanced functionality for fungible assets. These are implemented when:
	Requiring specialized security mechanisms
Optimizing performance with concurrent operations
Establishing special transfer restrictions
Upgrading token functionality
	Requiring specialized security mechanisms
	Requiring specialized security mechanisms
	Optimizing performance with concurrent operations
	Optimizing performance with concurrent operations
	Establishing special transfer restrictions
	Establishing special transfer restrictions
	Upgrading token functionality
	Upgrading token functionality
	These functions are typically employed in complex applications or when specific advanced features are needed.
	These functions are typically employed in complex applications or when specific advanced features are needed.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
set_frozen_flag
| ref: &TransferRef, store: Object, frozen: bool | Sets store frozen status. | void |
|
upgrade_to_concurrent
| ref: &ExtendRef | Upgrades to concurrent supply. | void |
|
upgrade_store_to_concurrent
| owner: &signer, store: Object | Upgrades store to concurrent. | void |
|
set_untransferable
| constructor_ref: &ConstructorRef | Makes asset untransferable. | void |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>set_frozen_flag</code>
	set_frozen_flag
	| ref: &TransferRef, store: Object, frozen: bool | Sets store frozen status. | void |
|
	<code>upgrade_to_concurrent</code>
	upgrade_to_concurrent
	| ref: &ExtendRef | Upgrades to concurrent supply. | void |
|
	<code>upgrade_store_to_concurrent</code>
	upgrade_store_to_concurrent
	| owner: &signer, store: Object | Upgrades store to concurrent. | void |
|
	<code>set_untransferable</code>
	set_untransferable
	| constructor_ref: &ConstructorRef | Makes asset untransferable. | void |
	Dispatch Functions
	Dispatch Functions
	Overview:
Dispatch Functions enable customization of fungible asset behavior. These are used when:
	Overview:
	Overview:
	Dispatch Functions enable customization of fungible asset behavior. These are used when:
	Implementing custom transfer logic
Adding operation hooks
Creating derived calculations
Implementing complex business rules
	Implementing custom transfer logic
	Implementing custom transfer logic
	Adding operation hooks
	Adding operation hooks
	Creating derived calculations
	Creating derived calculations
	Implementing complex business rules
	Implementing complex business rules
	These functions are designed for advanced users who need to customize their token's operational behavior.
	These functions are designed for advanced users who need to customize their token's operational behavior.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
register_dispatch_functions
| constructor_ref: &ConstructorRef, withdraw_function: Option, deposit_function: Option, derived_balance_function: Option | Registers dispatch hooks. | void |
|
register_derive_supply_dispatch_function
| constructor_ref: &ConstructorRef, dispatch_function: Option | Registers supply derivation. | void |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>register_dispatch_functions</code>
	register_dispatch_functions
	| constructor_ref: &ConstructorRef, withdraw_function: Option, deposit_function: Option, derived_balance_function: Option | Registers dispatch hooks. | void |
|
	<code>register_derive_supply_dispatch_function</code>
	register_derive_supply_dispatch_function
	| constructor_ref: &ConstructorRef, dispatch_function: Option | Registers supply derivation. | void |

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/01-fungible-asset/03-primary-fungible-store-framework-functions
Primary Fungible Store Framework Functions
Primary Fungible Store Framework Functions
On This Page
Executive Summary
Store Creation and Management
Query Functions
Basic Operations
Advanced Operations
Reference-Based Operations
Internal/Inline Functions
Primary Use Cases:
Executive Summary
The Primary Fungible Store Framework provides a comprehensive set of functions for managing fungible assets with primary stores. Key aspects include:
Store creation and management for fungible assets
Query functions for accessing store information
Basic operations for asset transfers and balance management
Advanced operations for complex asset handling
Reference-based operations for enhanced control and security
Internal functions for optimized framework support
This framework emphasizes deterministic store creation, strong security measures, and flexible asset management, making it suitable for various applications ranging from simple currency-like tokens to complex asset management systems.
Store Creation and Management
Overview:
These functions handle the creation and management of primary stores for fungible assets. They are used when:
Setting up new fungible assets with primary store support
Creating and managing user primary stores
Checking store existence and status
Managing store references
These functions form the foundation for managing primary fungible asset stores.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
create_primary_store_enabled_fungible_asset
| constructor_ref: &ConstructorRef, maximum_supply: Option, name: String, symbol: String, decimals: u8, icon_uri: String, project_uri: String | Creates a fungible asset with primary store support for automatic store creation during transfers. | void |
|
create_primary_store
| owner_addr: address, metadata: Object | Creates a primary store object for holding fungible assets for the given address. | Object |
|
ensure_primary_store_exists
| owner: address, metadata: Object | Ensures primary store exists for owner, creates if not. | Object |
|
may_be_unburn
| owner: &signer, store: Object | Unburns a store if it's burned. | void |
Query Functions
Overview:
These functions provide read-only access to store information. They are essential for:
Checking store existence and location
Querying balances and states
Getting store addresses
Verifying store conditions
These functions are commonly used in frontend integrations and for validation.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
primary_store_address
| owner: address, metadata: Object | Gets address of primary store for account. | address |
|
primary_store
| owner: address, metadata: Object | Gets primary store object for account. | Object |
|
primary_store_exists
| account: address, metadata: Object | Checks if primary store exists. | bool |
|
balance
| account: address, metadata: Object | Gets balance of account's primary store. | u64 |
|
is_balance_at_least
| account: address, metadata: Object, amount: u64 | Checks if store has sufficient balance. | bool |
|
is_frozen
| account: address, metadata: Object | Checks if store is frozen. | bool |
Basic Operations
Overview:
These functions provide core functionality for managing assets. Used for:
Basic transfer operations
Asset withdrawals and deposits
Standard asset movements
Balance management
Essential functions for day-to-day asset operations.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
withdraw
| owner: &signer, metadata: Object, amount: u64 | Withdraws from owner's primary store. | FungibleAsset |
|
deposit
| owner: address, fa: FungibleAsset | Deposits to owner's primary store. | void |
|
force_deposit
| owner: address, fa: FungibleAsset | Forces deposit to owner's store (friend function). | void |
|
transfer
| sender: &signer, metadata: Object, recipient: address, amount: u64 | Transfers between primary stores. | void |
Advanced Operations
Overview:
These functions provide enhanced control over assets. Used when:
Implementing complex transfer logic
Managing asset supply
Handling special transfers
Implementing security features
These functions are typically used in more sophisticated applications.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
mint
| mint_ref: &MintRef, owner: address, amount: u64 | Mints to owner's primary store. | void |
|
burn
| burn_ref: &BurnRef, owner: address, amount: u64 | Burns from owner's primary store. | void |
|
set_frozen_flag
| transfer_ref: &TransferRef, owner: address, frozen: bool | Sets frozen status of store. | void |
|
transfer_assert_minimum_deposit
| sender: &signer, metadata: Object, recipient: address, amount: u64, expected: u64 | Transfers with minimum deposit assertion. | void |
Reference-Based Operations
Overview:
These functions use references for enhanced control. Used for:
Privileged operations
Reference-based transfers
Secure asset movements
Special permissions handling
These functions provide additional security and control mechanisms.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
withdraw_with_ref
| transfer_ref: &TransferRef, owner: address, amount: u64 | Withdraws ignoring frozen flag. | FungibleAsset |
|
deposit_with_ref
| transfer_ref: &TransferRef, owner: address, fa: FungibleAsset | Deposits ignoring frozen flag. | void |
|
transfer_with_ref
| transfer_ref: &TransferRef, from: address, to: address, amount: u64 | Transfers between stores ignoring frozen flags. | void |
Internal/Inline Functions
Overview:
These functions provide internal support for the framework. Used for:
Internal store operations
Optimized lookups
Internal validations
Performance optimizations
These functions support the framework's internal operations.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
primary_store_address_inlined
| owner: address, metadata: Object | Gets store address (inline version). | address |
|
primary_store_inlined
| owner: address, metadata: Object | Gets store object (inline version). | Object |
|
primary_store_exists_inlined
| account: address, metadata: Object | Checks store existence (inline version). | bool |
Primary Use Cases:
Currency-like tokens requiring easy store management
Assets needing automatic store creation
Systems requiring deterministic store addresses
Applications needing unified asset management
Platforms requiring secure asset transfers
On This Page
Executive Summary
Store Creation and Management
Query Functions
Basic Operations
Advanced Operations
Reference-Based Operations
Internal/Inline Functions
Primary Use Cases:
On This Page
Executive Summary
Store Creation and Management
Query Functions
Basic Operations
Advanced Operations
Reference-Based Operations
Internal/Inline Functions
Primary Use Cases:
			On This Page
			On This Page
			Executive Summary
Store Creation and Management
Query Functions
Basic Operations
Advanced Operations
Reference-Based Operations
Internal/Inline Functions
Primary Use Cases:
			Executive Summary
			Executive Summary
			Executive Summary
			Executive Summary
			Store Creation and Management
			Store Creation and Management
			Store Creation and Management
			Store Creation and Management
			Query Functions
			Query Functions
			Query Functions
			Query Functions
			Basic Operations
			Basic Operations
			Basic Operations
			Basic Operations
			Advanced Operations
			Advanced Operations
			Advanced Operations
			Advanced Operations
			Reference-Based Operations
			Reference-Based Operations
			Reference-Based Operations
			Reference-Based Operations
			Internal/Inline Functions
Primary Use Cases:
			Internal/Inline Functions
			Internal/Inline Functions
			Internal/Inline Functions
			Primary Use Cases:
			Primary Use Cases:
			Primary Use Cases:
			Primary Use Cases:
			Primary Use Cases:
			Executive Summary
The Primary Fungible Store Framework provides a comprehensive set of functions for managing fungible assets with primary stores. Key aspects include:
Store creation and management for fungible assets
Query functions for accessing store information
Basic operations for asset transfers and balance management
Advanced operations for complex asset handling
Reference-based operations for enhanced control and security
Internal functions for optimized framework support
This framework emphasizes deterministic store creation, strong security measures, and flexible asset management, making it suitable for various applications ranging from simple currency-like tokens to complex asset management systems.
Store Creation and Management
Overview:
These functions handle the creation and management of primary stores for fungible assets. They are used when:
Setting up new fungible assets with primary store support
Creating and managing user primary stores
Checking store existence and status
Managing store references
These functions form the foundation for managing primary fungible asset stores.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
create_primary_store_enabled_fungible_asset
| constructor_ref: &ConstructorRef, maximum_supply: Option, name: String, symbol: String, decimals: u8, icon_uri: String, project_uri: String | Creates a fungible asset with primary store support for automatic store creation during transfers. | void |
|
create_primary_store
| owner_addr: address, metadata: Object | Creates a primary store object for holding fungible assets for the given address. | Object |
|
ensure_primary_store_exists
| owner: address, metadata: Object | Ensures primary store exists for owner, creates if not. | Object |
|
may_be_unburn
| owner: &signer, store: Object | Unburns a store if it's burned. | void |
Query Functions
Overview:
These functions provide read-only access to store information. They are essential for:
Checking store existence and location
Querying balances and states
Getting store addresses
Verifying store conditions
These functions are commonly used in frontend integrations and for validation.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
primary_store_address
| owner: address, metadata: Object | Gets address of primary store for account. | address |
|
primary_store
| owner: address, metadata: Object | Gets primary store object for account. | Object |
|
primary_store_exists
| account: address, metadata: Object | Checks if primary store exists. | bool |
|
balance
| account: address, metadata: Object | Gets balance of account's primary store. | u64 |
|
is_balance_at_least
| account: address, metadata: Object, amount: u64 | Checks if store has sufficient balance. | bool |
|
is_frozen
| account: address, metadata: Object | Checks if store is frozen. | bool |
Basic Operations
Overview:
These functions provide core functionality for managing assets. Used for:
Basic transfer operations
Asset withdrawals and deposits
Standard asset movements
Balance management
Essential functions for day-to-day asset operations.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
withdraw
| owner: &signer, metadata: Object, amount: u64 | Withdraws from owner's primary store. | FungibleAsset |
|
deposit
| owner: address, fa: FungibleAsset | Deposits to owner's primary store. | void |
|
force_deposit
| owner: address, fa: FungibleAsset | Forces deposit to owner's store (friend function). | void |
|
transfer
| sender: &signer, metadata: Object, recipient: address, amount: u64 | Transfers between primary stores. | void |
Advanced Operations
Overview:
These functions provide enhanced control over assets. Used when:
Implementing complex transfer logic
Managing asset supply
Handling special transfers
Implementing security features
These functions are typically used in more sophisticated applications.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
mint
| mint_ref: &MintRef, owner: address, amount: u64 | Mints to owner's primary store. | void |
|
burn
| burn_ref: &BurnRef, owner: address, amount: u64 | Burns from owner's primary store. | void |
|
set_frozen_flag
| transfer_ref: &TransferRef, owner: address, frozen: bool | Sets frozen status of store. | void |
|
transfer_assert_minimum_deposit
| sender: &signer, metadata: Object, recipient: address, amount: u64, expected: u64 | Transfers with minimum deposit assertion. | void |
Reference-Based Operations
Overview:
These functions use references for enhanced control. Used for:
Privileged operations
Reference-based transfers
Secure asset movements
Special permissions handling
These functions provide additional security and control mechanisms.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
withdraw_with_ref
| transfer_ref: &TransferRef, owner: address, amount: u64 | Withdraws ignoring frozen flag. | FungibleAsset |
|
deposit_with_ref
| transfer_ref: &TransferRef, owner: address, fa: FungibleAsset | Deposits ignoring frozen flag. | void |
|
transfer_with_ref
| transfer_ref: &TransferRef, from: address, to: address, amount: u64 | Transfers between stores ignoring frozen flags. | void |
Internal/Inline Functions
Overview:
These functions provide internal support for the framework. Used for:
Internal store operations
Optimized lookups
Internal validations
Performance optimizations
These functions support the framework's internal operations.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
primary_store_address_inlined
| owner: address, metadata: Object | Gets store address (inline version). | address |
|
primary_store_inlined
| owner: address, metadata: Object | Gets store object (inline version). | Object |
|
primary_store_exists_inlined
| account: address, metadata: Object | Checks store existence (inline version). | bool |
Primary Use Cases:
Currency-like tokens requiring easy store management
Assets needing automatic store creation
Systems requiring deterministic store addresses
Applications needing unified asset management
Platforms requiring secure asset transfers
			Executive Summary
The Primary Fungible Store Framework provides a comprehensive set of functions for managing fungible assets with primary stores. Key aspects include:
Store creation and management for fungible assets
Query functions for accessing store information
Basic operations for asset transfers and balance management
Advanced operations for complex asset handling
Reference-based operations for enhanced control and security
Internal functions for optimized framework support
This framework emphasizes deterministic store creation, strong security measures, and flexible asset management, making it suitable for various applications ranging from simple currency-like tokens to complex asset management systems.
Store Creation and Management
Overview:
These functions handle the creation and management of primary stores for fungible assets. They are used when:
Setting up new fungible assets with primary store support
Creating and managing user primary stores
Checking store existence and status
Managing store references
These functions form the foundation for managing primary fungible asset stores.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
create_primary_store_enabled_fungible_asset
| constructor_ref: &ConstructorRef, maximum_supply: Option, name: String, symbol: String, decimals: u8, icon_uri: String, project_uri: String | Creates a fungible asset with primary store support for automatic store creation during transfers. | void |
|
create_primary_store
| owner_addr: address, metadata: Object | Creates a primary store object for holding fungible assets for the given address. | Object |
|
ensure_primary_store_exists
| owner: address, metadata: Object | Ensures primary store exists for owner, creates if not. | Object |
|
may_be_unburn
| owner: &signer, store: Object | Unburns a store if it's burned. | void |
Query Functions
Overview:
These functions provide read-only access to store information. They are essential for:
Checking store existence and location
Querying balances and states
Getting store addresses
Verifying store conditions
These functions are commonly used in frontend integrations and for validation.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
primary_store_address
| owner: address, metadata: Object | Gets address of primary store for account. | address |
|
primary_store
| owner: address, metadata: Object | Gets primary store object for account. | Object |
|
primary_store_exists
| account: address, metadata: Object | Checks if primary store exists. | bool |
|
balance
| account: address, metadata: Object | Gets balance of account's primary store. | u64 |
|
is_balance_at_least
| account: address, metadata: Object, amount: u64 | Checks if store has sufficient balance. | bool |
|
is_frozen
| account: address, metadata: Object | Checks if store is frozen. | bool |
Basic Operations
Overview:
These functions provide core functionality for managing assets. Used for:
Basic transfer operations
Asset withdrawals and deposits
Standard asset movements
Balance management
Essential functions for day-to-day asset operations.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
withdraw
| owner: &signer, metadata: Object, amount: u64 | Withdraws from owner's primary store. | FungibleAsset |
|
deposit
| owner: address, fa: FungibleAsset | Deposits to owner's primary store. | void |
|
force_deposit
| owner: address, fa: FungibleAsset | Forces deposit to owner's store (friend function). | void |
|
transfer
| sender: &signer, metadata: Object, recipient: address, amount: u64 | Transfers between primary stores. | void |
Advanced Operations
Overview:
These functions provide enhanced control over assets. Used when:
Implementing complex transfer logic
Managing asset supply
Handling special transfers
Implementing security features
These functions are typically used in more sophisticated applications.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
mint
| mint_ref: &MintRef, owner: address, amount: u64 | Mints to owner's primary store. | void |
|
burn
| burn_ref: &BurnRef, owner: address, amount: u64 | Burns from owner's primary store. | void |
|
set_frozen_flag
| transfer_ref: &TransferRef, owner: address, frozen: bool | Sets frozen status of store. | void |
|
transfer_assert_minimum_deposit
| sender: &signer, metadata: Object, recipient: address, amount: u64, expected: u64 | Transfers with minimum deposit assertion. | void |
Reference-Based Operations
Overview:
These functions use references for enhanced control. Used for:
Privileged operations
Reference-based transfers
Secure asset movements
Special permissions handling
These functions provide additional security and control mechanisms.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
withdraw_with_ref
| transfer_ref: &TransferRef, owner: address, amount: u64 | Withdraws ignoring frozen flag. | FungibleAsset |
|
deposit_with_ref
| transfer_ref: &TransferRef, owner: address, fa: FungibleAsset | Deposits ignoring frozen flag. | void |
|
transfer_with_ref
| transfer_ref: &TransferRef, from: address, to: address, amount: u64 | Transfers between stores ignoring frozen flags. | void |
Internal/Inline Functions
Overview:
These functions provide internal support for the framework. Used for:
Internal store operations
Optimized lookups
Internal validations
Performance optimizations
These functions support the framework's internal operations.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
primary_store_address_inlined
| owner: address, metadata: Object | Gets store address (inline version). | address |
|
primary_store_inlined
| owner: address, metadata: Object | Gets store object (inline version). | Object |
|
primary_store_exists_inlined
| account: address, metadata: Object | Checks store existence (inline version). | bool |
Primary Use Cases:
Currency-like tokens requiring easy store management
Assets needing automatic store creation
Systems requiring deterministic store addresses
Applications needing unified asset management
Platforms requiring secure asset transfers
			Executive Summary
The Primary Fungible Store Framework provides a comprehensive set of functions for managing fungible assets with primary stores. Key aspects include:
Store creation and management for fungible assets
Query functions for accessing store information
Basic operations for asset transfers and balance management
Advanced operations for complex asset handling
Reference-based operations for enhanced control and security
Internal functions for optimized framework support
This framework emphasizes deterministic store creation, strong security measures, and flexible asset management, making it suitable for various applications ranging from simple currency-like tokens to complex asset management systems.
Store Creation and Management
Overview:
These functions handle the creation and management of primary stores for fungible assets. They are used when:
Setting up new fungible assets with primary store support
Creating and managing user primary stores
Checking store existence and status
Managing store references
These functions form the foundation for managing primary fungible asset stores.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
create_primary_store_enabled_fungible_asset
| constructor_ref: &ConstructorRef, maximum_supply: Option, name: String, symbol: String, decimals: u8, icon_uri: String, project_uri: String | Creates a fungible asset with primary store support for automatic store creation during transfers. | void |
|
create_primary_store
| owner_addr: address, metadata: Object | Creates a primary store object for holding fungible assets for the given address. | Object |
|
ensure_primary_store_exists
| owner: address, metadata: Object | Ensures primary store exists for owner, creates if not. | Object |
|
may_be_unburn
| owner: &signer, store: Object | Unburns a store if it's burned. | void |
Query Functions
Overview:
These functions provide read-only access to store information. They are essential for:
Checking store existence and location
Querying balances and states
Getting store addresses
Verifying store conditions
These functions are commonly used in frontend integrations and for validation.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
primary_store_address
| owner: address, metadata: Object | Gets address of primary store for account. | address |
|
primary_store
| owner: address, metadata: Object | Gets primary store object for account. | Object |
|
primary_store_exists
| account: address, metadata: Object | Checks if primary store exists. | bool |
|
balance
| account: address, metadata: Object | Gets balance of account's primary store. | u64 |
|
is_balance_at_least
| account: address, metadata: Object, amount: u64 | Checks if store has sufficient balance. | bool |
|
is_frozen
| account: address, metadata: Object | Checks if store is frozen. | bool |
Basic Operations
Overview:
These functions provide core functionality for managing assets. Used for:
Basic transfer operations
Asset withdrawals and deposits
Standard asset movements
Balance management
Essential functions for day-to-day asset operations.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
withdraw
| owner: &signer, metadata: Object, amount: u64 | Withdraws from owner's primary store. | FungibleAsset |
|
deposit
| owner: address, fa: FungibleAsset | Deposits to owner's primary store. | void |
|
force_deposit
| owner: address, fa: FungibleAsset | Forces deposit to owner's store (friend function). | void |
|
transfer
| sender: &signer, metadata: Object, recipient: address, amount: u64 | Transfers between primary stores. | void |
Advanced Operations
Overview:
These functions provide enhanced control over assets. Used when:
Implementing complex transfer logic
Managing asset supply
Handling special transfers
Implementing security features
These functions are typically used in more sophisticated applications.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
mint
| mint_ref: &MintRef, owner: address, amount: u64 | Mints to owner's primary store. | void |
|
burn
| burn_ref: &BurnRef, owner: address, amount: u64 | Burns from owner's primary store. | void |
|
set_frozen_flag
| transfer_ref: &TransferRef, owner: address, frozen: bool | Sets frozen status of store. | void |
|
transfer_assert_minimum_deposit
| sender: &signer, metadata: Object, recipient: address, amount: u64, expected: u64 | Transfers with minimum deposit assertion. | void |
Reference-Based Operations
Overview:
These functions use references for enhanced control. Used for:
Privileged operations
Reference-based transfers
Secure asset movements
Special permissions handling
These functions provide additional security and control mechanisms.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
withdraw_with_ref
| transfer_ref: &TransferRef, owner: address, amount: u64 | Withdraws ignoring frozen flag. | FungibleAsset |
|
deposit_with_ref
| transfer_ref: &TransferRef, owner: address, fa: FungibleAsset | Deposits ignoring frozen flag. | void |
|
transfer_with_ref
| transfer_ref: &TransferRef, from: address, to: address, amount: u64 | Transfers between stores ignoring frozen flags. | void |
Internal/Inline Functions
Overview:
These functions provide internal support for the framework. Used for:
Internal store operations
Optimized lookups
Internal validations
Performance optimizations
These functions support the framework's internal operations.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
primary_store_address_inlined
| owner: address, metadata: Object | Gets store address (inline version). | address |
|
primary_store_inlined
| owner: address, metadata: Object | Gets store object (inline version). | Object |
|
primary_store_exists_inlined
| account: address, metadata: Object | Checks store existence (inline version). | bool |
Primary Use Cases:
Currency-like tokens requiring easy store management
Assets needing automatic store creation
Systems requiring deterministic store addresses
Applications needing unified asset management
Platforms requiring secure asset transfers
	Executive Summary
	Executive Summary
	The Primary Fungible Store Framework provides a comprehensive set of functions for managing fungible assets with primary stores. Key aspects include:
	The Primary Fungible Store Framework provides a comprehensive set of functions for managing fungible assets with primary stores. Key aspects include:
	Store creation and management for fungible assets
Query functions for accessing store information
Basic operations for asset transfers and balance management
Advanced operations for complex asset handling
Reference-based operations for enhanced control and security
Internal functions for optimized framework support
	Store creation and management for fungible assets
	Store creation and management for fungible assets
	Query functions for accessing store information
	Query functions for accessing store information
	Basic operations for asset transfers and balance management
	Basic operations for asset transfers and balance management
	Advanced operations for complex asset handling
	Advanced operations for complex asset handling
	Reference-based operations for enhanced control and security
	Reference-based operations for enhanced control and security
	Internal functions for optimized framework support
	Internal functions for optimized framework support
	This framework emphasizes deterministic store creation, strong security measures, and flexible asset management, making it suitable for various applications ranging from simple currency-like tokens to complex asset management systems.
	This framework emphasizes deterministic store creation, strong security measures, and flexible asset management, making it suitable for various applications ranging from simple currency-like tokens to complex asset management systems.
	Store Creation and Management
	Store Creation and Management
	Overview:
These functions handle the creation and management of primary stores for fungible assets. They are used when:
	Overview:
	Overview:
	These functions handle the creation and management of primary stores for fungible assets. They are used when:
	Setting up new fungible assets with primary store support
Creating and managing user primary stores
Checking store existence and status
Managing store references
	Setting up new fungible assets with primary store support
	Setting up new fungible assets with primary store support
	Creating and managing user primary stores
	Creating and managing user primary stores
	Checking store existence and status
	Checking store existence and status
	Managing store references
	Managing store references
	These functions form the foundation for managing primary fungible asset stores.
	These functions form the foundation for managing primary fungible asset stores.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
create_primary_store_enabled_fungible_asset
| constructor_ref: &ConstructorRef, maximum_supply: Option, name: String, symbol: String, decimals: u8, icon_uri: String, project_uri: String | Creates a fungible asset with primary store support for automatic store creation during transfers. | void |
|
create_primary_store
| owner_addr: address, metadata: Object | Creates a primary store object for holding fungible assets for the given address. | Object |
|
ensure_primary_store_exists
| owner: address, metadata: Object | Ensures primary store exists for owner, creates if not. | Object |
|
may_be_unburn
| owner: &signer, store: Object | Unburns a store if it's burned. | void |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>create_primary_store_enabled_fungible_asset</code>
	create_primary_store_enabled_fungible_asset
	| constructor_ref: &ConstructorRef, maximum_supply: Option, name: String, symbol: String, decimals: u8, icon_uri: String, project_uri: String | Creates a fungible asset with primary store support for automatic store creation during transfers. | void |
|
	<code>create_primary_store</code>
	create_primary_store
	| owner_addr: address, metadata: Object | Creates a primary store object for holding fungible assets for the given address. | Object |
|
	<code>ensure_primary_store_exists</code>
	ensure_primary_store_exists
	| owner: address, metadata: Object | Ensures primary store exists for owner, creates if not. | Object |
|
	<code>may_be_unburn</code>
	may_be_unburn
	| owner: &signer, store: Object | Unburns a store if it's burned. | void |
	Query Functions
	Query Functions
	Overview:
These functions provide read-only access to store information. They are essential for:
	Overview:
	Overview:
	These functions provide read-only access to store information. They are essential for:
	Checking store existence and location
Querying balances and states
Getting store addresses
Verifying store conditions
	Checking store existence and location
	Checking store existence and location
	Querying balances and states
	Querying balances and states
	Getting store addresses
	Getting store addresses
	Verifying store conditions
	Verifying store conditions
	These functions are commonly used in frontend integrations and for validation.
	These functions are commonly used in frontend integrations and for validation.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
primary_store_address
| owner: address, metadata: Object | Gets address of primary store for account. | address |
|
primary_store
| owner: address, metadata: Object | Gets primary store object for account. | Object |
|
primary_store_exists
| account: address, metadata: Object | Checks if primary store exists. | bool |
|
balance
| account: address, metadata: Object | Gets balance of account's primary store. | u64 |
|
is_balance_at_least
| account: address, metadata: Object, amount: u64 | Checks if store has sufficient balance. | bool |
|
is_frozen
| account: address, metadata: Object | Checks if store is frozen. | bool |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>primary_store_address</code>
	primary_store_address
	| owner: address, metadata: Object | Gets address of primary store for account. | address |
|
	<code>primary_store</code>
	primary_store
	| owner: address, metadata: Object | Gets primary store object for account. | Object |
|
	<code>primary_store_exists</code>
	primary_store_exists
	| account: address, metadata: Object | Checks if primary store exists. | bool |
|
	<code>balance</code>
	balance
	| account: address, metadata: Object | Gets balance of account's primary store. | u64 |
|
	<code>is_balance_at_least</code>
	is_balance_at_least
	| account: address, metadata: Object, amount: u64 | Checks if store has sufficient balance. | bool |
|
	<code>is_frozen</code>
	is_frozen
	| account: address, metadata: Object | Checks if store is frozen. | bool |
	Basic Operations
	Basic Operations
	Overview:
These functions provide core functionality for managing assets. Used for:
	Overview:
	Overview:
	These functions provide core functionality for managing assets. Used for:
	Basic transfer operations
Asset withdrawals and deposits
Standard asset movements
Balance management
	Basic transfer operations
	Basic transfer operations
	Asset withdrawals and deposits
	Asset withdrawals and deposits
	Standard asset movements
	Standard asset movements
	Balance management
	Balance management
	Essential functions for day-to-day asset operations.
	Essential functions for day-to-day asset operations.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
withdraw
| owner: &signer, metadata: Object, amount: u64 | Withdraws from owner's primary store. | FungibleAsset |
|
deposit
| owner: address, fa: FungibleAsset | Deposits to owner's primary store. | void |
|
force_deposit
| owner: address, fa: FungibleAsset | Forces deposit to owner's store (friend function). | void |
|
transfer
| sender: &signer, metadata: Object, recipient: address, amount: u64 | Transfers between primary stores. | void |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>withdraw</code>
	withdraw
	| owner: &signer, metadata: Object, amount: u64 | Withdraws from owner's primary store. | FungibleAsset |
|
	<code>deposit</code>
	deposit
	| owner: address, fa: FungibleAsset | Deposits to owner's primary store. | void |
|
	<code>force_deposit</code>
	force_deposit
	| owner: address, fa: FungibleAsset | Forces deposit to owner's store (friend function). | void |
|
	<code>transfer</code>
	transfer
	| sender: &signer, metadata: Object, recipient: address, amount: u64 | Transfers between primary stores. | void |
	Advanced Operations
	Advanced Operations
	Overview:
These functions provide enhanced control over assets. Used when:
	Overview:
	Overview:
	These functions provide enhanced control over assets. Used when:
	Implementing complex transfer logic
Managing asset supply
Handling special transfers
Implementing security features
	Implementing complex transfer logic
	Implementing complex transfer logic
	Managing asset supply
	Managing asset supply
	Handling special transfers
	Handling special transfers
	Implementing security features
	Implementing security features
	These functions are typically used in more sophisticated applications.
	These functions are typically used in more sophisticated applications.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
mint
| mint_ref: &MintRef, owner: address, amount: u64 | Mints to owner's primary store. | void |
|
burn
| burn_ref: &BurnRef, owner: address, amount: u64 | Burns from owner's primary store. | void |
|
set_frozen_flag
| transfer_ref: &TransferRef, owner: address, frozen: bool | Sets frozen status of store. | void |
|
transfer_assert_minimum_deposit
| sender: &signer, metadata: Object, recipient: address, amount: u64, expected: u64 | Transfers with minimum deposit assertion. | void |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>mint</code>
	mint
	| mint_ref: &MintRef, owner: address, amount: u64 | Mints to owner's primary store. | void |
|
	<code>burn</code>
	burn
	| burn_ref: &BurnRef, owner: address, amount: u64 | Burns from owner's primary store. | void |
|
	<code>set_frozen_flag</code>
	set_frozen_flag
	| transfer_ref: &TransferRef, owner: address, frozen: bool | Sets frozen status of store. | void |
|
	<code>transfer_assert_minimum_deposit</code>
	transfer_assert_minimum_deposit
	| sender: &signer, metadata: Object, recipient: address, amount: u64, expected: u64 | Transfers with minimum deposit assertion. | void |
	Reference-Based Operations
	Reference-Based Operations
	Overview:
These functions use references for enhanced control. Used for:
	Overview:
	Overview:
	These functions use references for enhanced control. Used for:
	Privileged operations
Reference-based transfers
Secure asset movements
Special permissions handling
	Privileged operations
	Privileged operations
	Reference-based transfers
	Reference-based transfers
	Secure asset movements
	Secure asset movements
	Special permissions handling
	Special permissions handling
	These functions provide additional security and control mechanisms.
	These functions provide additional security and control mechanisms.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
withdraw_with_ref
| transfer_ref: &TransferRef, owner: address, amount: u64 | Withdraws ignoring frozen flag. | FungibleAsset |
|
deposit_with_ref
| transfer_ref: &TransferRef, owner: address, fa: FungibleAsset | Deposits ignoring frozen flag. | void |
|
transfer_with_ref
| transfer_ref: &TransferRef, from: address, to: address, amount: u64 | Transfers between stores ignoring frozen flags. | void |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>withdraw_with_ref</code>
	withdraw_with_ref
	| transfer_ref: &TransferRef, owner: address, amount: u64 | Withdraws ignoring frozen flag. | FungibleAsset |
|
	<code>deposit_with_ref</code>
	deposit_with_ref
	| transfer_ref: &TransferRef, owner: address, fa: FungibleAsset | Deposits ignoring frozen flag. | void |
|
	<code>transfer_with_ref</code>
	transfer_with_ref
	| transfer_ref: &TransferRef, from: address, to: address, amount: u64 | Transfers between stores ignoring frozen flags. | void |
	Internal/Inline Functions
	Internal/Inline Functions
	Overview:
These functions provide internal support for the framework. Used for:
	Overview:
	Overview:
	These functions provide internal support for the framework. Used for:
	Internal store operations
Optimized lookups
Internal validations
Performance optimizations
	Internal store operations
	Internal store operations
	Optimized lookups
	Optimized lookups
	Internal validations
	Internal validations
	Performance optimizations
	Performance optimizations
	These functions support the framework's internal operations.
	These functions support the framework's internal operations.
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
primary_store_address_inlined
| owner: address, metadata: Object | Gets store address (inline version). | address |
|
primary_store_inlined
| owner: address, metadata: Object | Gets store object (inline version). | Object |
|
primary_store_exists_inlined
| account: address, metadata: Object | Checks store existence (inline version). | bool |
	| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
|
	<code>primary_store_address_inlined</code>
	primary_store_address_inlined
	| owner: address, metadata: Object | Gets store address (inline version). | address |
|
	<code>primary_store_inlined</code>
	primary_store_inlined
	| owner: address, metadata: Object | Gets store object (inline version). | Object |
|
	<code>primary_store_exists_inlined</code>
	primary_store_exists_inlined
	| account: address, metadata: Object | Checks store existence (inline version). | bool |
		Primary Use Cases:
		Primary Use Cases:
		Currency-like tokens requiring easy store management
Assets needing automatic store creation
Systems requiring deterministic store addresses
Applications needing unified asset management
Platforms requiring secure asset transfers
		Currency-like tokens requiring easy store management
		Currency-like tokens requiring easy store management
		Assets needing automatic store creation
		Assets needing automatic store creation
		Systems requiring deterministic store addresses
		Systems requiring deterministic store addresses
		Applications needing unified asset management
		Applications needing unified asset management
		Platforms requiring secure asset transfers
		Platforms requiring secure asset transfers

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/01-fungible-asset/04-fungible-asset-vs-primary-fungible-store-details
Fungible Asset vs Primary Fungible Store Details
Fungible Asset vs Primary Fungible Store Details
On This Page
1. Fungible Asset
Key Characteristics
Functionality
Use Cases
2. Primary Fungible Store
Functionality
Use Cases
3. When to Use
Use Fungible Asset When:
Use Primary Fungible Store When:
4. Best Practices
Fungible Asset Framework
Primary Fungible Store Framework
5. Decision Matrix
1. Fungible Asset
Key Characteristics
module aptos_framework::fungible_asset {
    struct FungibleAsset {
        metadata: Object<Metadata>,
        amount: u64,
    }
    struct FungibleStore has key {
        metadata: Object<Metadata>,
        balance: u64,
        frozen: bool,
    }
}
Functionality
Low-level Operations
Direct token manipulation
Custom store creation
Flexible store management
Direct Control
Manual store creation
Explicit store handling
Fine-grained control
Advanced Features
Custom store implementations
Complex token behaviors
Specialized token logic
Use Cases
DeFi Protocols
// Example: Custom liquidity pool store
struct LiquidityPoolStore has key {
    store: FungibleStore,
    pool_info: PoolInfo,
    // Additional DeFi-specific fields
}
Complex Token Systems
// Example: Multi-tier token system
struct TieredStore has key {
    base_store: FungibleStore,
    tier_level: u8,
    rewards_multiplier: u64,
}
Protocol-Specific Implementations
// Example: Staking contract
struct StakingStore has key {
    tokens: FungibleStore,
    lock_period: u64,
    rewards_rate: u64,
}
2. Primary Fungible Store
Functionality
High-level Operations
Automatic store management
Simplified transfers
Standard token operations
User-Focused
Automatic store creation
Intuitive interfaces
Standard workflows
Standard Features
Basic transfer operations
Standard balance management
Common token functionalities
Use Cases
Standard Tokens
// Example: Simple token transfer
public fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
User Wallets
// Example: Check balance
public fun get_balance(account: address): u64 {
    primary_fungible_store::balance(account, get_metadata())
}
Simple Token Systems
// Example: Basic token implementation
public fun mint_to(recipient: address, amount: u64) {
    primary_fungible_store::mint(&mint_ref, recipient, amount);
}
3. When to Use
Use Fungible Asset When:
Custom Store Logic is Needed
// Example: Custom store with special logic
struct CustomStore has key {
    base_store: FungibleStore,
    custom_data: vector<u8>,
    special_rules: Rules,
}
Implementing Complex Protocols
// Example: AMM implementation
struct AMMStore has key {
    token_a: FungibleStore,
    token_b: FungibleStore,
    lp_tokens: FungibleStore,
    curve_parameters: CurveParams,
}
Detailed Control is Required
// Example: Custom transfer logic
public fun custom_transfer(
    store: &mut FungibleStore,
    amount: u64,
    rules: &TransferRules
) {
    // Custom validation
    validate_transfer(store, amount, rules);
    // Custom transfer logic
    perform_transfer(store, amount);
}
Use Primary Fungible Store When:
Implementing Simple Tokens
// Example: Basic token operations
public entry fun simple_transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    transfer(from, get_metadata(), to, amount);
}
Focusing on User Experience
// Example: User-friendly interface
public entry fun send_tokens(
    user: &signer,
    recipient: address,
    amount: u64
) {
    // No need to create store - handled automatically
    transfer(user, get_metadata(), recipient, amount);
}
Implementing Standard Token Functionality
// Example: Standard token implementation
public entry fun initialize_token(
    admin: &signer,
    name: String,
    symbol: String,
    decimals: u8
) {
    // Standard initialization with automatic store support
    create_primary_store_enabled_fungible_asset(
        admin,
        name,
        symbol,
        decimals
    );
}
4. Best Practices
Fungible Asset Framework
Custom Store Design
Clearly define store structure
Implement specific rules
Handle edge cases
Security Considerations
// Example: Secure custom store
struct SecureStore has key {
    store: FungibleStore,
    access_control: AccessControl,
    audit_trail: AuditLog,
}
Primary Fungible Store Framework
Simplicity First
Use standard operations
Leverage automatic store creation
Focus on user experience
Standard Patterns
// Example: Standard token pattern
public fun initialize_standard_token(
    admin: &signer,
    config: TokenConfig
) {
    // Use standard initialization
    create_standard_token(admin, config);
}
5. Decision Matrix
| Criteria | Fungible Asset | Primary Fungible Store |
| --- | --- | --- |
| Complexity | High | Low |
| Flexibility | High | Moderate |
| User Experience | Custom | Standardized |
| Use Case | Complex DeFi/Custom Logic | Standard Tokens |
| Development Effort | High | Low |
| Maintenance | Complex | Simple |
| Integration | Custom | Standardized |
On This Page
1. Fungible Asset
Key Characteristics
Functionality
Use Cases
2. Primary Fungible Store
Functionality
Use Cases
3. When to Use
Use Fungible Asset When:
Use Primary Fungible Store When:
4. Best Practices
Fungible Asset Framework
Primary Fungible Store Framework
5. Decision Matrix
On This Page
1. Fungible Asset
Key Characteristics
Functionality
Use Cases
2. Primary Fungible Store
Functionality
Use Cases
3. When to Use
Use Fungible Asset When:
Use Primary Fungible Store When:
4. Best Practices
Fungible Asset Framework
Primary Fungible Store Framework
5. Decision Matrix
			On This Page
			On This Page
			1. Fungible Asset
Key Characteristics
Functionality
Use Cases
2. Primary Fungible Store
Functionality
Use Cases
3. When to Use
Use Fungible Asset When:
Use Primary Fungible Store When:
4. Best Practices
Fungible Asset Framework
Primary Fungible Store Framework
5. Decision Matrix
			1. Fungible Asset
Key Characteristics
Functionality
Use Cases
			1. Fungible Asset
			1. Fungible Asset
			1. Fungible Asset
			Key Characteristics
Functionality
Use Cases
			Key Characteristics
			Key Characteristics
			Key Characteristics
			Key Characteristics
			Functionality
			Functionality
			Functionality
			Functionality
			Use Cases
			Use Cases
			Use Cases
			Use Cases
			2. Primary Fungible Store
Functionality
Use Cases
			2. Primary Fungible Store
			2. Primary Fungible Store
			2. Primary Fungible Store
			Functionality
Use Cases
			Functionality
			Functionality
			Functionality
			Functionality
			Use Cases
			Use Cases
			Use Cases
			Use Cases
			3. When to Use
Use Fungible Asset When:
Use Primary Fungible Store When:
			3. When to Use
			3. When to Use
			3. When to Use
			Use Fungible Asset When:
Use Primary Fungible Store When:
			Use Fungible Asset When:
			Use Fungible Asset When:
			Use Fungible Asset When:
			Use Fungible Asset When:
			Use Primary Fungible Store When:
			Use Primary Fungible Store When:
			Use Primary Fungible Store When:
			Use Primary Fungible Store When:
			4. Best Practices
Fungible Asset Framework
Primary Fungible Store Framework
			4. Best Practices
			4. Best Practices
			4. Best Practices
			Fungible Asset Framework
Primary Fungible Store Framework
			Fungible Asset Framework
			Fungible Asset Framework
			Fungible Asset Framework
			Fungible Asset Framework
			Primary Fungible Store Framework
			Primary Fungible Store Framework
			Primary Fungible Store Framework
			Primary Fungible Store Framework
			5. Decision Matrix
			5. Decision Matrix
			5. Decision Matrix
			5. Decision Matrix
			1. Fungible Asset
Key Characteristics
module aptos_framework::fungible_asset {
    struct FungibleAsset {
        metadata: Object<Metadata>,
        amount: u64,
    }
    struct FungibleStore has key {
        metadata: Object<Metadata>,
        balance: u64,
        frozen: bool,
    }
}
Functionality
Low-level Operations
Direct token manipulation
Custom store creation
Flexible store management
Direct Control
Manual store creation
Explicit store handling
Fine-grained control
Advanced Features
Custom store implementations
Complex token behaviors
Specialized token logic
Use Cases
DeFi Protocols
// Example: Custom liquidity pool store
struct LiquidityPoolStore has key {
    store: FungibleStore,
    pool_info: PoolInfo,
    // Additional DeFi-specific fields
}
Complex Token Systems
// Example: Multi-tier token system
struct TieredStore has key {
    base_store: FungibleStore,
    tier_level: u8,
    rewards_multiplier: u64,
}
Protocol-Specific Implementations
// Example: Staking contract
struct StakingStore has key {
    tokens: FungibleStore,
    lock_period: u64,
    rewards_rate: u64,
}
2. Primary Fungible Store
Functionality
High-level Operations
Automatic store management
Simplified transfers
Standard token operations
User-Focused
Automatic store creation
Intuitive interfaces
Standard workflows
Standard Features
Basic transfer operations
Standard balance management
Common token functionalities
Use Cases
Standard Tokens
// Example: Simple token transfer
public fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
User Wallets
// Example: Check balance
public fun get_balance(account: address): u64 {
    primary_fungible_store::balance(account, get_metadata())
}
Simple Token Systems
// Example: Basic token implementation
public fun mint_to(recipient: address, amount: u64) {
    primary_fungible_store::mint(&mint_ref, recipient, amount);
}
3. When to Use
Use Fungible Asset When:
Custom Store Logic is Needed
// Example: Custom store with special logic
struct CustomStore has key {
    base_store: FungibleStore,
    custom_data: vector<u8>,
    special_rules: Rules,
}
Implementing Complex Protocols
// Example: AMM implementation
struct AMMStore has key {
    token_a: FungibleStore,
    token_b: FungibleStore,
    lp_tokens: FungibleStore,
    curve_parameters: CurveParams,
}
Detailed Control is Required
// Example: Custom transfer logic
public fun custom_transfer(
    store: &mut FungibleStore,
    amount: u64,
    rules: &TransferRules
) {
    // Custom validation
    validate_transfer(store, amount, rules);
    // Custom transfer logic
    perform_transfer(store, amount);
}
Use Primary Fungible Store When:
Implementing Simple Tokens
// Example: Basic token operations
public entry fun simple_transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    transfer(from, get_metadata(), to, amount);
}
Focusing on User Experience
// Example: User-friendly interface
public entry fun send_tokens(
    user: &signer,
    recipient: address,
    amount: u64
) {
    // No need to create store - handled automatically
    transfer(user, get_metadata(), recipient, amount);
}
Implementing Standard Token Functionality
// Example: Standard token implementation
public entry fun initialize_token(
    admin: &signer,
    name: String,
    symbol: String,
    decimals: u8
) {
    // Standard initialization with automatic store support
    create_primary_store_enabled_fungible_asset(
        admin,
        name,
        symbol,
        decimals
    );
}
4. Best Practices
Fungible Asset Framework
Custom Store Design
Clearly define store structure
Implement specific rules
Handle edge cases
Security Considerations
// Example: Secure custom store
struct SecureStore has key {
    store: FungibleStore,
    access_control: AccessControl,
    audit_trail: AuditLog,
}
Primary Fungible Store Framework
Simplicity First
Use standard operations
Leverage automatic store creation
Focus on user experience
Standard Patterns
// Example: Standard token pattern
public fun initialize_standard_token(
    admin: &signer,
    config: TokenConfig
) {
    // Use standard initialization
    create_standard_token(admin, config);
}
5. Decision Matrix
| Criteria | Fungible Asset | Primary Fungible Store |
| --- | --- | --- |
| Complexity | High | Low |
| Flexibility | High | Moderate |
| User Experience | Custom | Standardized |
| Use Case | Complex DeFi/Custom Logic | Standard Tokens |
| Development Effort | High | Low |
| Maintenance | Complex | Simple |
| Integration | Custom | Standardized |
			1. Fungible Asset
Key Characteristics
module aptos_framework::fungible_asset {
    struct FungibleAsset {
        metadata: Object<Metadata>,
        amount: u64,
    }
    struct FungibleStore has key {
        metadata: Object<Metadata>,
        balance: u64,
        frozen: bool,
    }
}
Functionality
Low-level Operations
Direct token manipulation
Custom store creation
Flexible store management
Direct Control
Manual store creation
Explicit store handling
Fine-grained control
Advanced Features
Custom store implementations
Complex token behaviors
Specialized token logic
Use Cases
DeFi Protocols
// Example: Custom liquidity pool store
struct LiquidityPoolStore has key {
    store: FungibleStore,
    pool_info: PoolInfo,
    // Additional DeFi-specific fields
}
Complex Token Systems
// Example: Multi-tier token system
struct TieredStore has key {
    base_store: FungibleStore,
    tier_level: u8,
    rewards_multiplier: u64,
}
Protocol-Specific Implementations
// Example: Staking contract
struct StakingStore has key {
    tokens: FungibleStore,
    lock_period: u64,
    rewards_rate: u64,
}
2. Primary Fungible Store
Functionality
High-level Operations
Automatic store management
Simplified transfers
Standard token operations
User-Focused
Automatic store creation
Intuitive interfaces
Standard workflows
Standard Features
Basic transfer operations
Standard balance management
Common token functionalities
Use Cases
Standard Tokens
// Example: Simple token transfer
public fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
User Wallets
// Example: Check balance
public fun get_balance(account: address): u64 {
    primary_fungible_store::balance(account, get_metadata())
}
Simple Token Systems
// Example: Basic token implementation
public fun mint_to(recipient: address, amount: u64) {
    primary_fungible_store::mint(&mint_ref, recipient, amount);
}
3. When to Use
Use Fungible Asset When:
Custom Store Logic is Needed
// Example: Custom store with special logic
struct CustomStore has key {
    base_store: FungibleStore,
    custom_data: vector<u8>,
    special_rules: Rules,
}
Implementing Complex Protocols
// Example: AMM implementation
struct AMMStore has key {
    token_a: FungibleStore,
    token_b: FungibleStore,
    lp_tokens: FungibleStore,
    curve_parameters: CurveParams,
}
Detailed Control is Required
// Example: Custom transfer logic
public fun custom_transfer(
    store: &mut FungibleStore,
    amount: u64,
    rules: &TransferRules
) {
    // Custom validation
    validate_transfer(store, amount, rules);
    // Custom transfer logic
    perform_transfer(store, amount);
}
Use Primary Fungible Store When:
Implementing Simple Tokens
// Example: Basic token operations
public entry fun simple_transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    transfer(from, get_metadata(), to, amount);
}
Focusing on User Experience
// Example: User-friendly interface
public entry fun send_tokens(
    user: &signer,
    recipient: address,
    amount: u64
) {
    // No need to create store - handled automatically
    transfer(user, get_metadata(), recipient, amount);
}
Implementing Standard Token Functionality
// Example: Standard token implementation
public entry fun initialize_token(
    admin: &signer,
    name: String,
    symbol: String,
    decimals: u8
) {
    // Standard initialization with automatic store support
    create_primary_store_enabled_fungible_asset(
        admin,
        name,
        symbol,
        decimals
    );
}
4. Best Practices
Fungible Asset Framework
Custom Store Design
Clearly define store structure
Implement specific rules
Handle edge cases
Security Considerations
// Example: Secure custom store
struct SecureStore has key {
    store: FungibleStore,
    access_control: AccessControl,
    audit_trail: AuditLog,
}
Primary Fungible Store Framework
Simplicity First
Use standard operations
Leverage automatic store creation
Focus on user experience
Standard Patterns
// Example: Standard token pattern
public fun initialize_standard_token(
    admin: &signer,
    config: TokenConfig
) {
    // Use standard initialization
    create_standard_token(admin, config);
}
5. Decision Matrix
| Criteria | Fungible Asset | Primary Fungible Store |
| --- | --- | --- |
| Complexity | High | Low |
| Flexibility | High | Moderate |
| User Experience | Custom | Standardized |
| Use Case | Complex DeFi/Custom Logic | Standard Tokens |
| Development Effort | High | Low |
| Maintenance | Complex | Simple |
| Integration | Custom | Standardized |
			1. Fungible Asset
Key Characteristics
module aptos_framework::fungible_asset {
    struct FungibleAsset {
        metadata: Object<Metadata>,
        amount: u64,
    }
    struct FungibleStore has key {
        metadata: Object<Metadata>,
        balance: u64,
        frozen: bool,
    }
}
Functionality
Low-level Operations
Direct token manipulation
Custom store creation
Flexible store management
Direct Control
Manual store creation
Explicit store handling
Fine-grained control
Advanced Features
Custom store implementations
Complex token behaviors
Specialized token logic
Use Cases
DeFi Protocols
// Example: Custom liquidity pool store
struct LiquidityPoolStore has key {
    store: FungibleStore,
    pool_info: PoolInfo,
    // Additional DeFi-specific fields
}
Complex Token Systems
// Example: Multi-tier token system
struct TieredStore has key {
    base_store: FungibleStore,
    tier_level: u8,
    rewards_multiplier: u64,
}
Protocol-Specific Implementations
// Example: Staking contract
struct StakingStore has key {
    tokens: FungibleStore,
    lock_period: u64,
    rewards_rate: u64,
}
2. Primary Fungible Store
Functionality
High-level Operations
Automatic store management
Simplified transfers
Standard token operations
User-Focused
Automatic store creation
Intuitive interfaces
Standard workflows
Standard Features
Basic transfer operations
Standard balance management
Common token functionalities
Use Cases
Standard Tokens
// Example: Simple token transfer
public fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
User Wallets
// Example: Check balance
public fun get_balance(account: address): u64 {
    primary_fungible_store::balance(account, get_metadata())
}
Simple Token Systems
// Example: Basic token implementation
public fun mint_to(recipient: address, amount: u64) {
    primary_fungible_store::mint(&mint_ref, recipient, amount);
}
3. When to Use
Use Fungible Asset When:
Custom Store Logic is Needed
// Example: Custom store with special logic
struct CustomStore has key {
    base_store: FungibleStore,
    custom_data: vector<u8>,
    special_rules: Rules,
}
Implementing Complex Protocols
// Example: AMM implementation
struct AMMStore has key {
    token_a: FungibleStore,
    token_b: FungibleStore,
    lp_tokens: FungibleStore,
    curve_parameters: CurveParams,
}
Detailed Control is Required
// Example: Custom transfer logic
public fun custom_transfer(
    store: &mut FungibleStore,
    amount: u64,
    rules: &TransferRules
) {
    // Custom validation
    validate_transfer(store, amount, rules);
    // Custom transfer logic
    perform_transfer(store, amount);
}
Use Primary Fungible Store When:
Implementing Simple Tokens
// Example: Basic token operations
public entry fun simple_transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    transfer(from, get_metadata(), to, amount);
}
Focusing on User Experience
// Example: User-friendly interface
public entry fun send_tokens(
    user: &signer,
    recipient: address,
    amount: u64
) {
    // No need to create store - handled automatically
    transfer(user, get_metadata(), recipient, amount);
}
Implementing Standard Token Functionality
// Example: Standard token implementation
public entry fun initialize_token(
    admin: &signer,
    name: String,
    symbol: String,
    decimals: u8
) {
    // Standard initialization with automatic store support
    create_primary_store_enabled_fungible_asset(
        admin,
        name,
        symbol,
        decimals
    );
}
4. Best Practices
Fungible Asset Framework
Custom Store Design
Clearly define store structure
Implement specific rules
Handle edge cases
Security Considerations
// Example: Secure custom store
struct SecureStore has key {
    store: FungibleStore,
    access_control: AccessControl,
    audit_trail: AuditLog,
}
Primary Fungible Store Framework
Simplicity First
Use standard operations
Leverage automatic store creation
Focus on user experience
Standard Patterns
// Example: Standard token pattern
public fun initialize_standard_token(
    admin: &signer,
    config: TokenConfig
) {
    // Use standard initialization
    create_standard_token(admin, config);
}
5. Decision Matrix
| Criteria | Fungible Asset | Primary Fungible Store |
| --- | --- | --- |
| Complexity | High | Low |
| Flexibility | High | Moderate |
| User Experience | Custom | Standardized |
| Use Case | Complex DeFi/Custom Logic | Standard Tokens |
| Development Effort | High | Low |
| Maintenance | Complex | Simple |
| Integration | Custom | Standardized |
	1. Fungible Asset
	1. Fungible Asset
		Key Characteristics
		Key Characteristics
		<code>module aptos_framework::fungible_asset {
    struct FungibleAsset {
        metadata: Object<Metadata>,
        amount: u64,
    }
    struct FungibleStore has key {
        metadata: Object<Metadata>,
        balance: u64,
        frozen: bool,
    }
}</code>
		<code>module aptos_framework::fungible_asset {
    struct FungibleAsset {
        metadata: Object<Metadata>,
        amount: u64,
    }
    struct FungibleStore has key {
        metadata: Object<Metadata>,
        balance: u64,
        frozen: bool,
    }
}</code>
		module aptos_framework::fungible_asset {
    struct FungibleAsset {
        metadata: Object<Metadata>,
        amount: u64,
    }
    struct FungibleStore has key {
        metadata: Object<Metadata>,
        balance: u64,
        frozen: bool,
    }
}
		Functionality
		Functionality
		Low-level Operations
Direct token manipulation
Custom store creation
Flexible store management
Direct Control
Manual store creation
Explicit store handling
Fine-grained control
Advanced Features
Custom store implementations
Complex token behaviors
Specialized token logic
		Low-level Operations
Direct token manipulation
Custom store creation
Flexible store management
		Low-level Operations
		Low-level Operations
		Direct token manipulation
Custom store creation
Flexible store management
		Direct token manipulation
		Direct token manipulation
		Custom store creation
		Custom store creation
		Flexible store management
		Flexible store management
		Direct Control
Manual store creation
Explicit store handling
Fine-grained control
		Direct Control
		Direct Control
		Manual store creation
Explicit store handling
Fine-grained control
		Manual store creation
		Manual store creation
		Explicit store handling
		Explicit store handling
		Fine-grained control
		Fine-grained control
		Advanced Features
Custom store implementations
Complex token behaviors
Specialized token logic
		Advanced Features
		Advanced Features
		Custom store implementations
Complex token behaviors
Specialized token logic
		Custom store implementations
		Custom store implementations
		Complex token behaviors
		Complex token behaviors
		Specialized token logic
		Specialized token logic
		Use Cases
		Use Cases
		DeFi Protocols
// Example: Custom liquidity pool store
struct LiquidityPoolStore has key {
    store: FungibleStore,
    pool_info: PoolInfo,
    // Additional DeFi-specific fields
}
Complex Token Systems
// Example: Multi-tier token system
struct TieredStore has key {
    base_store: FungibleStore,
    tier_level: u8,
    rewards_multiplier: u64,
}
Protocol-Specific Implementations
// Example: Staking contract
struct StakingStore has key {
    tokens: FungibleStore,
    lock_period: u64,
    rewards_rate: u64,
}
		DeFi Protocols
// Example: Custom liquidity pool store
struct LiquidityPoolStore has key {
    store: FungibleStore,
    pool_info: PoolInfo,
    // Additional DeFi-specific fields
}
		DeFi Protocols
		DeFi Protocols
		DeFi Protocols
		<code>// Example: Custom liquidity pool store
struct LiquidityPoolStore has key {
    store: FungibleStore,
    pool_info: PoolInfo,
    // Additional DeFi-specific fields
}</code>
		<code>// Example: Custom liquidity pool store
struct LiquidityPoolStore has key {
    store: FungibleStore,
    pool_info: PoolInfo,
    // Additional DeFi-specific fields
}</code>
		// Example: Custom liquidity pool store
struct LiquidityPoolStore has key {
    store: FungibleStore,
    pool_info: PoolInfo,
    // Additional DeFi-specific fields
}
		Complex Token Systems
// Example: Multi-tier token system
struct TieredStore has key {
    base_store: FungibleStore,
    tier_level: u8,
    rewards_multiplier: u64,
}
		Complex Token Systems
		Complex Token Systems
		Complex Token Systems
		<code>// Example: Multi-tier token system
struct TieredStore has key {
    base_store: FungibleStore,
    tier_level: u8,
    rewards_multiplier: u64,
}</code>
		<code>// Example: Multi-tier token system
struct TieredStore has key {
    base_store: FungibleStore,
    tier_level: u8,
    rewards_multiplier: u64,
}</code>
		// Example: Multi-tier token system
struct TieredStore has key {
    base_store: FungibleStore,
    tier_level: u8,
    rewards_multiplier: u64,
}
		Protocol-Specific Implementations
// Example: Staking contract
struct StakingStore has key {
    tokens: FungibleStore,
    lock_period: u64,
    rewards_rate: u64,
}
		Protocol-Specific Implementations
		Protocol-Specific Implementations
		Protocol-Specific Implementations
		<code>// Example: Staking contract
struct StakingStore has key {
    tokens: FungibleStore,
    lock_period: u64,
    rewards_rate: u64,
}</code>
		<code>// Example: Staking contract
struct StakingStore has key {
    tokens: FungibleStore,
    lock_period: u64,
    rewards_rate: u64,
}</code>
		// Example: Staking contract
struct StakingStore has key {
    tokens: FungibleStore,
    lock_period: u64,
    rewards_rate: u64,
}
	2. Primary Fungible Store
	2. Primary Fungible Store
		Functionality
		Functionality
		High-level Operations
Automatic store management
Simplified transfers
Standard token operations
User-Focused
Automatic store creation
Intuitive interfaces
Standard workflows
Standard Features
Basic transfer operations
Standard balance management
Common token functionalities
		High-level Operations
Automatic store management
Simplified transfers
Standard token operations
		High-level Operations
		High-level Operations
		Automatic store management
Simplified transfers
Standard token operations
		Automatic store management
		Automatic store management
		Simplified transfers
		Simplified transfers
		Standard token operations
		Standard token operations
		User-Focused
Automatic store creation
Intuitive interfaces
Standard workflows
		User-Focused
		User-Focused
		Automatic store creation
Intuitive interfaces
Standard workflows
		Automatic store creation
		Automatic store creation
		Intuitive interfaces
		Intuitive interfaces
		Standard workflows
		Standard workflows
		Standard Features
Basic transfer operations
Standard balance management
Common token functionalities
		Standard Features
		Standard Features
		Basic transfer operations
Standard balance management
Common token functionalities
		Basic transfer operations
		Basic transfer operations
		Standard balance management
		Standard balance management
		Common token functionalities
		Common token functionalities
		Use Cases
		Use Cases
		Standard Tokens
// Example: Simple token transfer
public fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
User Wallets
// Example: Check balance
public fun get_balance(account: address): u64 {
    primary_fungible_store::balance(account, get_metadata())
}
Simple Token Systems
// Example: Basic token implementation
public fun mint_to(recipient: address, amount: u64) {
    primary_fungible_store::mint(&mint_ref, recipient, amount);
}
		Standard Tokens
// Example: Simple token transfer
public fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
		Standard Tokens
		Standard Tokens
		Standard Tokens
		<code>// Example: Simple token transfer
public fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}</code>
		<code>// Example: Simple token transfer
public fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}</code>
		// Example: Simple token transfer
public fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
		User Wallets
// Example: Check balance
public fun get_balance(account: address): u64 {
    primary_fungible_store::balance(account, get_metadata())
}
		User Wallets
		User Wallets
		User Wallets
		<code>// Example: Check balance
public fun get_balance(account: address): u64 {
    primary_fungible_store::balance(account, get_metadata())
}</code>
		<code>// Example: Check balance
public fun get_balance(account: address): u64 {
    primary_fungible_store::balance(account, get_metadata())
}</code>
		// Example: Check balance
public fun get_balance(account: address): u64 {
    primary_fungible_store::balance(account, get_metadata())
}
		Simple Token Systems
// Example: Basic token implementation
public fun mint_to(recipient: address, amount: u64) {
    primary_fungible_store::mint(&mint_ref, recipient, amount);
}
		Simple Token Systems
		Simple Token Systems
		Simple Token Systems
		<code>// Example: Basic token implementation
public fun mint_to(recipient: address, amount: u64) {
    primary_fungible_store::mint(&mint_ref, recipient, amount);
}</code>
		<code>// Example: Basic token implementation
public fun mint_to(recipient: address, amount: u64) {
    primary_fungible_store::mint(&mint_ref, recipient, amount);
}</code>
		// Example: Basic token implementation
public fun mint_to(recipient: address, amount: u64) {
    primary_fungible_store::mint(&mint_ref, recipient, amount);
}
	3. When to Use
	3. When to Use
		Use Fungible Asset When:
		Use Fungible Asset When:
		Custom Store Logic is Needed
// Example: Custom store with special logic
struct CustomStore has key {
    base_store: FungibleStore,
    custom_data: vector<u8>,
    special_rules: Rules,
}
Implementing Complex Protocols
// Example: AMM implementation
struct AMMStore has key {
    token_a: FungibleStore,
    token_b: FungibleStore,
    lp_tokens: FungibleStore,
    curve_parameters: CurveParams,
}
Detailed Control is Required
// Example: Custom transfer logic
public fun custom_transfer(
    store: &mut FungibleStore,
    amount: u64,
    rules: &TransferRules
) {
    // Custom validation
    validate_transfer(store, amount, rules);
    // Custom transfer logic
    perform_transfer(store, amount);
}
		Custom Store Logic is Needed
// Example: Custom store with special logic
struct CustomStore has key {
    base_store: FungibleStore,
    custom_data: vector<u8>,
    special_rules: Rules,
}
		Custom Store Logic is Needed
		Custom Store Logic is Needed
		Custom Store Logic is Needed
		<code>// Example: Custom store with special logic
struct CustomStore has key {
    base_store: FungibleStore,
    custom_data: vector<u8>,
    special_rules: Rules,
}</code>
		<code>// Example: Custom store with special logic
struct CustomStore has key {
    base_store: FungibleStore,
    custom_data: vector<u8>,
    special_rules: Rules,
}</code>
		// Example: Custom store with special logic
struct CustomStore has key {
    base_store: FungibleStore,
    custom_data: vector<u8>,
    special_rules: Rules,
}
		Implementing Complex Protocols
// Example: AMM implementation
struct AMMStore has key {
    token_a: FungibleStore,
    token_b: FungibleStore,
    lp_tokens: FungibleStore,
    curve_parameters: CurveParams,
}
		Implementing Complex Protocols
		Implementing Complex Protocols
		Implementing Complex Protocols
		<code>// Example: AMM implementation
struct AMMStore has key {
    token_a: FungibleStore,
    token_b: FungibleStore,
    lp_tokens: FungibleStore,
    curve_parameters: CurveParams,
}</code>
		<code>// Example: AMM implementation
struct AMMStore has key {
    token_a: FungibleStore,
    token_b: FungibleStore,
    lp_tokens: FungibleStore,
    curve_parameters: CurveParams,
}</code>
		// Example: AMM implementation
struct AMMStore has key {
    token_a: FungibleStore,
    token_b: FungibleStore,
    lp_tokens: FungibleStore,
    curve_parameters: CurveParams,
}
		Detailed Control is Required
// Example: Custom transfer logic
public fun custom_transfer(
    store: &mut FungibleStore,
    amount: u64,
    rules: &TransferRules
) {
    // Custom validation
    validate_transfer(store, amount, rules);
    // Custom transfer logic
    perform_transfer(store, amount);
}
		Detailed Control is Required
		Detailed Control is Required
		Detailed Control is Required
		<code>// Example: Custom transfer logic
public fun custom_transfer(
    store: &mut FungibleStore,
    amount: u64,
    rules: &TransferRules
) {
    // Custom validation
    validate_transfer(store, amount, rules);
    // Custom transfer logic
    perform_transfer(store, amount);
}</code>
		<code>// Example: Custom transfer logic
public fun custom_transfer(
    store: &mut FungibleStore,
    amount: u64,
    rules: &TransferRules
) {
    // Custom validation
    validate_transfer(store, amount, rules);
    // Custom transfer logic
    perform_transfer(store, amount);
}</code>
		// Example: Custom transfer logic
public fun custom_transfer(
    store: &mut FungibleStore,
    amount: u64,
    rules: &TransferRules
) {
    // Custom validation
    validate_transfer(store, amount, rules);
    // Custom transfer logic
    perform_transfer(store, amount);
}
		Use Primary Fungible Store When:
		Use Primary Fungible Store When:
		Implementing Simple Tokens
// Example: Basic token operations
public entry fun simple_transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    transfer(from, get_metadata(), to, amount);
}
Focusing on User Experience
// Example: User-friendly interface
public entry fun send_tokens(
    user: &signer,
    recipient: address,
    amount: u64
) {
    // No need to create store - handled automatically
    transfer(user, get_metadata(), recipient, amount);
}
Implementing Standard Token Functionality
// Example: Standard token implementation
public entry fun initialize_token(
    admin: &signer,
    name: String,
    symbol: String,
    decimals: u8
) {
    // Standard initialization with automatic store support
    create_primary_store_enabled_fungible_asset(
        admin,
        name,
        symbol,
        decimals
    );
}
		Implementing Simple Tokens
// Example: Basic token operations
public entry fun simple_transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    transfer(from, get_metadata(), to, amount);
}
		Implementing Simple Tokens
		Implementing Simple Tokens
		Implementing Simple Tokens
		<code>// Example: Basic token operations
public entry fun simple_transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    transfer(from, get_metadata(), to, amount);
}</code>
		<code>// Example: Basic token operations
public entry fun simple_transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    transfer(from, get_metadata(), to, amount);
}</code>
		// Example: Basic token operations
public entry fun simple_transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    transfer(from, get_metadata(), to, amount);
}
		Focusing on User Experience
// Example: User-friendly interface
public entry fun send_tokens(
    user: &signer,
    recipient: address,
    amount: u64
) {
    // No need to create store - handled automatically
    transfer(user, get_metadata(), recipient, amount);
}
		Focusing on User Experience
		Focusing on User Experience
		Focusing on User Experience
		<code>// Example: User-friendly interface
public entry fun send_tokens(
    user: &signer,
    recipient: address,
    amount: u64
) {
    // No need to create store - handled automatically
    transfer(user, get_metadata(), recipient, amount);
}</code>
		<code>// Example: User-friendly interface
public entry fun send_tokens(
    user: &signer,
    recipient: address,
    amount: u64
) {
    // No need to create store - handled automatically
    transfer(user, get_metadata(), recipient, amount);
}</code>
		// Example: User-friendly interface
public entry fun send_tokens(
    user: &signer,
    recipient: address,
    amount: u64
) {
    // No need to create store - handled automatically
    transfer(user, get_metadata(), recipient, amount);
}
		Implementing Standard Token Functionality
// Example: Standard token implementation
public entry fun initialize_token(
    admin: &signer,
    name: String,
    symbol: String,
    decimals: u8
) {
    // Standard initialization with automatic store support
    create_primary_store_enabled_fungible_asset(
        admin,
        name,
        symbol,
        decimals
    );
}
		Implementing Standard Token Functionality
		Implementing Standard Token Functionality
		Implementing Standard Token Functionality
		<code>// Example: Standard token implementation
public entry fun initialize_token(
    admin: &signer,
    name: String,
    symbol: String,
    decimals: u8
) {
    // Standard initialization with automatic store support
    create_primary_store_enabled_fungible_asset(
        admin,
        name,
        symbol,
        decimals
    );
}</code>
		<code>// Example: Standard token implementation
public entry fun initialize_token(
    admin: &signer,
    name: String,
    symbol: String,
    decimals: u8
) {
    // Standard initialization with automatic store support
    create_primary_store_enabled_fungible_asset(
        admin,
        name,
        symbol,
        decimals
    );
}</code>
		// Example: Standard token implementation
public entry fun initialize_token(
    admin: &signer,
    name: String,
    symbol: String,
    decimals: u8
) {
    // Standard initialization with automatic store support
    create_primary_store_enabled_fungible_asset(
        admin,
        name,
        symbol,
        decimals
    );
}
	4. Best Practices
	4. Best Practices
		Fungible Asset Framework
		Fungible Asset Framework
		Custom Store Design
Clearly define store structure
Implement specific rules
Handle edge cases
Security Considerations
// Example: Secure custom store
struct SecureStore has key {
    store: FungibleStore,
    access_control: AccessControl,
    audit_trail: AuditLog,
}
		Custom Store Design
Clearly define store structure
Implement specific rules
Handle edge cases
		Custom Store Design
		Custom Store Design
		Custom Store Design
		Clearly define store structure
Implement specific rules
Handle edge cases
		Clearly define store structure
		Clearly define store structure
		Implement specific rules
		Implement specific rules
		Handle edge cases
		Handle edge cases
		Security Considerations
// Example: Secure custom store
struct SecureStore has key {
    store: FungibleStore,
    access_control: AccessControl,
    audit_trail: AuditLog,
}
		Security Considerations
		Security Considerations
		Security Considerations
		<code>// Example: Secure custom store
struct SecureStore has key {
    store: FungibleStore,
    access_control: AccessControl,
    audit_trail: AuditLog,
}</code>
		<code>// Example: Secure custom store
struct SecureStore has key {
    store: FungibleStore,
    access_control: AccessControl,
    audit_trail: AuditLog,
}</code>
		// Example: Secure custom store
struct SecureStore has key {
    store: FungibleStore,
    access_control: AccessControl,
    audit_trail: AuditLog,
}
		Primary Fungible Store Framework
		Primary Fungible Store Framework
		Simplicity First
Use standard operations
Leverage automatic store creation
Focus on user experience
Standard Patterns
// Example: Standard token pattern
public fun initialize_standard_token(
    admin: &signer,
    config: TokenConfig
) {
    // Use standard initialization
    create_standard_token(admin, config);
}
		Simplicity First
Use standard operations
Leverage automatic store creation
Focus on user experience
		Simplicity First
		Simplicity First
		Simplicity First
		Use standard operations
Leverage automatic store creation
Focus on user experience
		Use standard operations
		Use standard operations
		Leverage automatic store creation
		Leverage automatic store creation
		Focus on user experience
		Focus on user experience
		Standard Patterns
// Example: Standard token pattern
public fun initialize_standard_token(
    admin: &signer,
    config: TokenConfig
) {
    // Use standard initialization
    create_standard_token(admin, config);
}
		Standard Patterns
		Standard Patterns
		Standard Patterns
		<code>// Example: Standard token pattern
public fun initialize_standard_token(
    admin: &signer,
    config: TokenConfig
) {
    // Use standard initialization
    create_standard_token(admin, config);
}</code>
		<code>// Example: Standard token pattern
public fun initialize_standard_token(
    admin: &signer,
    config: TokenConfig
) {
    // Use standard initialization
    create_standard_token(admin, config);
}</code>
		// Example: Standard token pattern
public fun initialize_standard_token(
    admin: &signer,
    config: TokenConfig
) {
    // Use standard initialization
    create_standard_token(admin, config);
}
	5. Decision Matrix
	5. Decision Matrix
	| Criteria | Fungible Asset | Primary Fungible Store |
| --- | --- | --- |
| Complexity | High | Low |
| Flexibility | High | Moderate |
| User Experience | Custom | Standardized |
| Use Case | Complex DeFi/Custom Logic | Standard Tokens |
| Development Effort | High | Low |
| Maintenance | Complex | Simple |
| Integration | Custom | Standardized |
	| Criteria | Fungible Asset | Primary Fungible Store |
| --- | --- | --- |
| Complexity | High | Low |
| Flexibility | High | Moderate |
| User Experience | Custom | Standardized |
| Use Case | Complex DeFi/Custom Logic | Standard Tokens |
| Development Effort | High | Low |
| Maintenance | Complex | Simple |
| Integration | Custom | Standardized |

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/01-fungible-asset/05-initialize-a-fungible-asset
Initialize a Fungible Asset
Initialize a Fungible Asset
On This Page
Summary
Overview
1. Introduction
2. Token Configuration Structure
3. Token Initialization
3.1. Create Metadata Object
3.2. Initialize Fungible Asset
3.3. Create and Store Management References
4. Implement View Functions
4.1. Get Metadata Function
4.2. Get Balance Function
4.3. Check Frozen Status
5. Usage Examples
Check Token Info
6. Best Practices
6.1. Error Handling
6.2. Optimization
6.3. Testing
7. Common Pitfalls and Notes
Full Code
Summary
Fungible assets are interchangeable and divisible digital tokens, similar to cryptocurrencies.
The initialization process involves setting up token configuration, creating metadata, and implementing management structures.
Essential steps include defining token properties (name, symbol, decimals), creating a metadata object, and generating management references.
View functions are implemented to retrieve token metadata, check account balances, and verify frozen status.
Best practices include proper error handling, optimization techniques, and comprehensive testing.
Common pitfalls to avoid are related to initialization, view function implementation, and testing procedures.
Overview
Fungible assets are digital tokens that are interchangeable and divisible, such as cryptocurrencies. This guide outlines the process of initializing a fungible asset on a blockchain platform, focusing on:
Setting up token configuration
Creating metadata and management structures
Implementing essential view functions
Best practices for development and testing
The tutorial provides step-by-step instructions and code examples to help developers create a robust and functional fungible asset system.
1. Introduction
This article provides detailed instructions on how to:
Initialize a Fungible Asset
Set up management references
Implement basic view functions
2. Token Configuration Structure
/// Token configuration constants
const TOKEN_NAME: vector&lt;u8&gt; = b"YourToken";
const TOKEN_SYMBOL: vector&lt;u8&gt; = b"YTK";
const TOKEN_DECIMALS: u8 = 6;
Components:
TOKEN_NAME
: Full name of the token
TOKEN_SYMBOL
: Short symbol (3–5 characters)
TOKEN_DECIMALS
: Number of decimal points (typically 6–8)
3. Token Initialization
3.1. Create Metadata Object
fun init_module(module_signer: &signer) {
    let constructor_ref = &object::create_named_object(
        module_signer,
        TOKEN_SYMBOL,
    );
Details:
module_signer
: Module signer (typically the deployer)
constructor_ref
: Reference for creating related objects
create_named_object
: Creates an object with a deterministic address
3.2. Initialize Fungible Asset
primary_fungible_store::create_primary_store_enabled_fungible_asset(
    constructor_ref,
    option::none(),                 // Maximum supply (none = unlimited)
    string::utf8(TOKEN_NAME),       // Token name
    string::utf8(TOKEN_SYMBOL),     // Token symbol
    TOKEN_DECIMALS,                 // Decimals
    string::utf8(b""),              // Icon URI
    string::utf8(b""),              // Project URI
);
Parameters:
constructor_ref
: Reference from the previous step
maximum_supply
: Supply limit (option::none() = unlimited)
name
: Token name
symbol
: Token symbol
decimals
: Number of decimals
icon_uri
: Token icon URL
project_uri
: Project URL
3.3. Create and Store Management References
// Generate refs
let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
// Store refs
let metadata_signer = &object::generate_signer(constructor_ref);
move_to(
    metadata_signer,
    TokenManagement {
        mint_ref,
        burn_ref,
        transfer_ref,
    }
);
References:
mint_ref
: Authority to create new tokens
burn_ref
: Authority to destroy tokens
transfer_ref
: Authority to manage transfers and frozen status
4. Implement View Functions
4.1. Get Metadata Function
#[view]
public fun get_metadata(): object::Object&lt;fungible_asset::Metadata&gt; {
    object::address_to_object(
        object::create_object_address(&@module_addr, TOKEN_SYMBOL)
    )
}
Function:
Returns the token's metadata object
Uses module address and token symbol to calculate the address
Marked as a view function to optimize gas usage
4.2. Get Balance Function
#[view]
public fun get_balance(account: address): u64 {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::balance(account, get_metadata())
    } else {
        0
    }
}
Flow:
Check if the store exists
If the store exists, return the balance
If not, return 0
4.3. Check Frozen Status
#[view]
public fun is_frozen(account: address): bool {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::is_frozen(account, get_metadata())
    } else {
        false
    }
}
Flow:
Check if the store exists
If the store exists, return the frozen status
If not, return false
5. Usage Examples
Check Token Info
// Get token metadata
let metadata = get_metadata();
// Check account balance
let balance = get_balance(@user);
// Check if account is frozen
let is_frozen = is_frozen(@user);
6. Best Practices
6.1. Error Handling
const ESTORE_NOT_FOUND: u64 = 1;
const EINVALID_METADATA: u64 = 2;
public fun safe_get_balance(account: address): u64 {
    assert!(primary_fungible_store::primary_store_exists(account, get_metadata()),
        ESTORE_NOT_FOUND
    );
    get_balance(account)
}
6.2. Optimization
// Cache metadata object for frequent use
let cached_metadata = get_metadata();
let balance1 = get_balance(addr1);
let balance2 = get_balance(addr2);
6.3. Testing
#[test]
fun test_view_functions() {
    // Initialize token
    init_module(...)
    // Test balance view
    assert!(get_balance(@user) == 0, 1);
    // Test frozen status
    assert!(!is_frozen(@user), 2);
}
7. Common Pitfalls and Notes
Initialization
Should only be called once when deploying the module
Refs cannot be recreated after initialization
URIs can be empty but should be provided in production
View Functions
Always handle cases where the store doesn't exist
Consider caching for improved performance
Ensure appropriate error handling
Testing
Test all edge cases
Verify initialization success
Check view function accuracy
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    // =================== Constants ===================
    // Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    // =================== Resources & Structs ===================
    // Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    // =================== Initialization ===================
    // Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    // =================== View Functions ===================
    // Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    // Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    // Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
}
On This Page
Summary
Overview
1. Introduction
2. Token Configuration Structure
3. Token Initialization
3.1. Create Metadata Object
3.2. Initialize Fungible Asset
3.3. Create and Store Management References
4. Implement View Functions
4.1. Get Metadata Function
4.2. Get Balance Function
4.3. Check Frozen Status
5. Usage Examples
Check Token Info
6. Best Practices
6.1. Error Handling
6.2. Optimization
6.3. Testing
7. Common Pitfalls and Notes
Full Code
On This Page
Summary
Overview
1. Introduction
2. Token Configuration Structure
3. Token Initialization
3.1. Create Metadata Object
3.2. Initialize Fungible Asset
3.3. Create and Store Management References
4. Implement View Functions
4.1. Get Metadata Function
4.2. Get Balance Function
4.3. Check Frozen Status
5. Usage Examples
Check Token Info
6. Best Practices
6.1. Error Handling
6.2. Optimization
6.3. Testing
7. Common Pitfalls and Notes
Full Code
			On This Page
			On This Page
			Summary
Overview
1. Introduction
2. Token Configuration Structure
3. Token Initialization
3.1. Create Metadata Object
3.2. Initialize Fungible Asset
3.3. Create and Store Management References
4. Implement View Functions
4.1. Get Metadata Function
4.2. Get Balance Function
4.3. Check Frozen Status
5. Usage Examples
Check Token Info
6. Best Practices
6.1. Error Handling
6.2. Optimization
6.3. Testing
7. Common Pitfalls and Notes
Full Code
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			1. Introduction
			1. Introduction
			1. Introduction
			1. Introduction
			2. Token Configuration Structure
			2. Token Configuration Structure
			2. Token Configuration Structure
			2. Token Configuration Structure
			3. Token Initialization
3.1. Create Metadata Object
3.2. Initialize Fungible Asset
3.3. Create and Store Management References
			3. Token Initialization
			3. Token Initialization
			3. Token Initialization
			3.1. Create Metadata Object
3.2. Initialize Fungible Asset
3.3. Create and Store Management References
			3.1. Create Metadata Object
			3.1. Create Metadata Object
			3.1. Create Metadata Object
			3.1. Create Metadata Object
			3.2. Initialize Fungible Asset
			3.2. Initialize Fungible Asset
			3.2. Initialize Fungible Asset
			3.2. Initialize Fungible Asset
			3.3. Create and Store Management References
			3.3. Create and Store Management References
			3.3. Create and Store Management References
			3.3. Create and Store Management References
			4. Implement View Functions
4.1. Get Metadata Function
4.2. Get Balance Function
4.3. Check Frozen Status
			4. Implement View Functions
			4. Implement View Functions
			4. Implement View Functions
			4.1. Get Metadata Function
4.2. Get Balance Function
4.3. Check Frozen Status
			4.1. Get Metadata Function
			4.1. Get Metadata Function
			4.1. Get Metadata Function
			4.1. Get Metadata Function
			4.2. Get Balance Function
			4.2. Get Balance Function
			4.2. Get Balance Function
			4.2. Get Balance Function
			4.3. Check Frozen Status
			4.3. Check Frozen Status
			4.3. Check Frozen Status
			4.3. Check Frozen Status
			5. Usage Examples
Check Token Info
			5. Usage Examples
			5. Usage Examples
			5. Usage Examples
			Check Token Info
			Check Token Info
			Check Token Info
			Check Token Info
			Check Token Info
			6. Best Practices
6.1. Error Handling
6.2. Optimization
6.3. Testing
			6. Best Practices
			6. Best Practices
			6. Best Practices
			6.1. Error Handling
6.2. Optimization
6.3. Testing
			6.1. Error Handling
			6.1. Error Handling
			6.1. Error Handling
			6.1. Error Handling
			6.2. Optimization
			6.2. Optimization
			6.2. Optimization
			6.2. Optimization
			6.3. Testing
			6.3. Testing
			6.3. Testing
			6.3. Testing
			7. Common Pitfalls and Notes
			7. Common Pitfalls and Notes
			7. Common Pitfalls and Notes
			7. Common Pitfalls and Notes
			Full Code
			Full Code
			Full Code
			Full Code
			Summary
Fungible assets are interchangeable and divisible digital tokens, similar to cryptocurrencies.
The initialization process involves setting up token configuration, creating metadata, and implementing management structures.
Essential steps include defining token properties (name, symbol, decimals), creating a metadata object, and generating management references.
View functions are implemented to retrieve token metadata, check account balances, and verify frozen status.
Best practices include proper error handling, optimization techniques, and comprehensive testing.
Common pitfalls to avoid are related to initialization, view function implementation, and testing procedures.
Overview
Fungible assets are digital tokens that are interchangeable and divisible, such as cryptocurrencies. This guide outlines the process of initializing a fungible asset on a blockchain platform, focusing on:
Setting up token configuration
Creating metadata and management structures
Implementing essential view functions
Best practices for development and testing
The tutorial provides step-by-step instructions and code examples to help developers create a robust and functional fungible asset system.
1. Introduction
This article provides detailed instructions on how to:
Initialize a Fungible Asset
Set up management references
Implement basic view functions
2. Token Configuration Structure
/// Token configuration constants
const TOKEN_NAME: vector&lt;u8&gt; = b"YourToken";
const TOKEN_SYMBOL: vector&lt;u8&gt; = b"YTK";
const TOKEN_DECIMALS: u8 = 6;
Components:
TOKEN_NAME
: Full name of the token
TOKEN_SYMBOL
: Short symbol (3–5 characters)
TOKEN_DECIMALS
: Number of decimal points (typically 6–8)
3. Token Initialization
3.1. Create Metadata Object
fun init_module(module_signer: &signer) {
    let constructor_ref = &object::create_named_object(
        module_signer,
        TOKEN_SYMBOL,
    );
Details:
module_signer
: Module signer (typically the deployer)
constructor_ref
: Reference for creating related objects
create_named_object
: Creates an object with a deterministic address
3.2. Initialize Fungible Asset
primary_fungible_store::create_primary_store_enabled_fungible_asset(
    constructor_ref,
    option::none(),                 // Maximum supply (none = unlimited)
    string::utf8(TOKEN_NAME),       // Token name
    string::utf8(TOKEN_SYMBOL),     // Token symbol
    TOKEN_DECIMALS,                 // Decimals
    string::utf8(b""),              // Icon URI
    string::utf8(b""),              // Project URI
);
Parameters:
constructor_ref
: Reference from the previous step
maximum_supply
: Supply limit (option::none() = unlimited)
name
: Token name
symbol
: Token symbol
decimals
: Number of decimals
icon_uri
: Token icon URL
project_uri
: Project URL
3.3. Create and Store Management References
// Generate refs
let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
// Store refs
let metadata_signer = &object::generate_signer(constructor_ref);
move_to(
    metadata_signer,
    TokenManagement {
        mint_ref,
        burn_ref,
        transfer_ref,
    }
);
References:
mint_ref
: Authority to create new tokens
burn_ref
: Authority to destroy tokens
transfer_ref
: Authority to manage transfers and frozen status
4. Implement View Functions
4.1. Get Metadata Function
#[view]
public fun get_metadata(): object::Object&lt;fungible_asset::Metadata&gt; {
    object::address_to_object(
        object::create_object_address(&@module_addr, TOKEN_SYMBOL)
    )
}
Function:
Returns the token's metadata object
Uses module address and token symbol to calculate the address
Marked as a view function to optimize gas usage
4.2. Get Balance Function
#[view]
public fun get_balance(account: address): u64 {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::balance(account, get_metadata())
    } else {
        0
    }
}
Flow:
Check if the store exists
If the store exists, return the balance
If not, return 0
4.3. Check Frozen Status
#[view]
public fun is_frozen(account: address): bool {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::is_frozen(account, get_metadata())
    } else {
        false
    }
}
Flow:
Check if the store exists
If the store exists, return the frozen status
If not, return false
5. Usage Examples
Check Token Info
// Get token metadata
let metadata = get_metadata();
// Check account balance
let balance = get_balance(@user);
// Check if account is frozen
let is_frozen = is_frozen(@user);
6. Best Practices
6.1. Error Handling
const ESTORE_NOT_FOUND: u64 = 1;
const EINVALID_METADATA: u64 = 2;
public fun safe_get_balance(account: address): u64 {
    assert!(primary_fungible_store::primary_store_exists(account, get_metadata()),
        ESTORE_NOT_FOUND
    );
    get_balance(account)
}
6.2. Optimization
// Cache metadata object for frequent use
let cached_metadata = get_metadata();
let balance1 = get_balance(addr1);
let balance2 = get_balance(addr2);
6.3. Testing
#[test]
fun test_view_functions() {
    // Initialize token
    init_module(...)
    // Test balance view
    assert!(get_balance(@user) == 0, 1);
    // Test frozen status
    assert!(!is_frozen(@user), 2);
}
7. Common Pitfalls and Notes
Initialization
Should only be called once when deploying the module
Refs cannot be recreated after initialization
URIs can be empty but should be provided in production
View Functions
Always handle cases where the store doesn't exist
Consider caching for improved performance
Ensure appropriate error handling
Testing
Test all edge cases
Verify initialization success
Check view function accuracy
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    // =================== Constants ===================
    // Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    // =================== Resources & Structs ===================
    // Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    // =================== Initialization ===================
    // Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    // =================== View Functions ===================
    // Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    // Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    // Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
}
			Summary
Fungible assets are interchangeable and divisible digital tokens, similar to cryptocurrencies.
The initialization process involves setting up token configuration, creating metadata, and implementing management structures.
Essential steps include defining token properties (name, symbol, decimals), creating a metadata object, and generating management references.
View functions are implemented to retrieve token metadata, check account balances, and verify frozen status.
Best practices include proper error handling, optimization techniques, and comprehensive testing.
Common pitfalls to avoid are related to initialization, view function implementation, and testing procedures.
Overview
Fungible assets are digital tokens that are interchangeable and divisible, such as cryptocurrencies. This guide outlines the process of initializing a fungible asset on a blockchain platform, focusing on:
Setting up token configuration
Creating metadata and management structures
Implementing essential view functions
Best practices for development and testing
The tutorial provides step-by-step instructions and code examples to help developers create a robust and functional fungible asset system.
1. Introduction
This article provides detailed instructions on how to:
Initialize a Fungible Asset
Set up management references
Implement basic view functions
2. Token Configuration Structure
/// Token configuration constants
const TOKEN_NAME: vector&lt;u8&gt; = b"YourToken";
const TOKEN_SYMBOL: vector&lt;u8&gt; = b"YTK";
const TOKEN_DECIMALS: u8 = 6;
Components:
TOKEN_NAME
: Full name of the token
TOKEN_SYMBOL
: Short symbol (3–5 characters)
TOKEN_DECIMALS
: Number of decimal points (typically 6–8)
3. Token Initialization
3.1. Create Metadata Object
fun init_module(module_signer: &signer) {
    let constructor_ref = &object::create_named_object(
        module_signer,
        TOKEN_SYMBOL,
    );
Details:
module_signer
: Module signer (typically the deployer)
constructor_ref
: Reference for creating related objects
create_named_object
: Creates an object with a deterministic address
3.2. Initialize Fungible Asset
primary_fungible_store::create_primary_store_enabled_fungible_asset(
    constructor_ref,
    option::none(),                 // Maximum supply (none = unlimited)
    string::utf8(TOKEN_NAME),       // Token name
    string::utf8(TOKEN_SYMBOL),     // Token symbol
    TOKEN_DECIMALS,                 // Decimals
    string::utf8(b""),              // Icon URI
    string::utf8(b""),              // Project URI
);
Parameters:
constructor_ref
: Reference from the previous step
maximum_supply
: Supply limit (option::none() = unlimited)
name
: Token name
symbol
: Token symbol
decimals
: Number of decimals
icon_uri
: Token icon URL
project_uri
: Project URL
3.3. Create and Store Management References
// Generate refs
let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
// Store refs
let metadata_signer = &object::generate_signer(constructor_ref);
move_to(
    metadata_signer,
    TokenManagement {
        mint_ref,
        burn_ref,
        transfer_ref,
    }
);
References:
mint_ref
: Authority to create new tokens
burn_ref
: Authority to destroy tokens
transfer_ref
: Authority to manage transfers and frozen status
4. Implement View Functions
4.1. Get Metadata Function
#[view]
public fun get_metadata(): object::Object&lt;fungible_asset::Metadata&gt; {
    object::address_to_object(
        object::create_object_address(&@module_addr, TOKEN_SYMBOL)
    )
}
Function:
Returns the token's metadata object
Uses module address and token symbol to calculate the address
Marked as a view function to optimize gas usage
4.2. Get Balance Function
#[view]
public fun get_balance(account: address): u64 {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::balance(account, get_metadata())
    } else {
        0
    }
}
Flow:
Check if the store exists
If the store exists, return the balance
If not, return 0
4.3. Check Frozen Status
#[view]
public fun is_frozen(account: address): bool {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::is_frozen(account, get_metadata())
    } else {
        false
    }
}
Flow:
Check if the store exists
If the store exists, return the frozen status
If not, return false
5. Usage Examples
Check Token Info
// Get token metadata
let metadata = get_metadata();
// Check account balance
let balance = get_balance(@user);
// Check if account is frozen
let is_frozen = is_frozen(@user);
6. Best Practices
6.1. Error Handling
const ESTORE_NOT_FOUND: u64 = 1;
const EINVALID_METADATA: u64 = 2;
public fun safe_get_balance(account: address): u64 {
    assert!(primary_fungible_store::primary_store_exists(account, get_metadata()),
        ESTORE_NOT_FOUND
    );
    get_balance(account)
}
6.2. Optimization
// Cache metadata object for frequent use
let cached_metadata = get_metadata();
let balance1 = get_balance(addr1);
let balance2 = get_balance(addr2);
6.3. Testing
#[test]
fun test_view_functions() {
    // Initialize token
    init_module(...)
    // Test balance view
    assert!(get_balance(@user) == 0, 1);
    // Test frozen status
    assert!(!is_frozen(@user), 2);
}
7. Common Pitfalls and Notes
Initialization
Should only be called once when deploying the module
Refs cannot be recreated after initialization
URIs can be empty but should be provided in production
View Functions
Always handle cases where the store doesn't exist
Consider caching for improved performance
Ensure appropriate error handling
Testing
Test all edge cases
Verify initialization success
Check view function accuracy
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    // =================== Constants ===================
    // Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    // =================== Resources & Structs ===================
    // Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    // =================== Initialization ===================
    // Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    // =================== View Functions ===================
    // Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    // Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    // Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
}
			Summary
Fungible assets are interchangeable and divisible digital tokens, similar to cryptocurrencies.
The initialization process involves setting up token configuration, creating metadata, and implementing management structures.
Essential steps include defining token properties (name, symbol, decimals), creating a metadata object, and generating management references.
View functions are implemented to retrieve token metadata, check account balances, and verify frozen status.
Best practices include proper error handling, optimization techniques, and comprehensive testing.
Common pitfalls to avoid are related to initialization, view function implementation, and testing procedures.
Overview
Fungible assets are digital tokens that are interchangeable and divisible, such as cryptocurrencies. This guide outlines the process of initializing a fungible asset on a blockchain platform, focusing on:
Setting up token configuration
Creating metadata and management structures
Implementing essential view functions
Best practices for development and testing
The tutorial provides step-by-step instructions and code examples to help developers create a robust and functional fungible asset system.
1. Introduction
This article provides detailed instructions on how to:
Initialize a Fungible Asset
Set up management references
Implement basic view functions
2. Token Configuration Structure
/// Token configuration constants
const TOKEN_NAME: vector&lt;u8&gt; = b"YourToken";
const TOKEN_SYMBOL: vector&lt;u8&gt; = b"YTK";
const TOKEN_DECIMALS: u8 = 6;
Components:
TOKEN_NAME
: Full name of the token
TOKEN_SYMBOL
: Short symbol (3–5 characters)
TOKEN_DECIMALS
: Number of decimal points (typically 6–8)
3. Token Initialization
3.1. Create Metadata Object
fun init_module(module_signer: &signer) {
    let constructor_ref = &object::create_named_object(
        module_signer,
        TOKEN_SYMBOL,
    );
Details:
module_signer
: Module signer (typically the deployer)
constructor_ref
: Reference for creating related objects
create_named_object
: Creates an object with a deterministic address
3.2. Initialize Fungible Asset
primary_fungible_store::create_primary_store_enabled_fungible_asset(
    constructor_ref,
    option::none(),                 // Maximum supply (none = unlimited)
    string::utf8(TOKEN_NAME),       // Token name
    string::utf8(TOKEN_SYMBOL),     // Token symbol
    TOKEN_DECIMALS,                 // Decimals
    string::utf8(b""),              // Icon URI
    string::utf8(b""),              // Project URI
);
Parameters:
constructor_ref
: Reference from the previous step
maximum_supply
: Supply limit (option::none() = unlimited)
name
: Token name
symbol
: Token symbol
decimals
: Number of decimals
icon_uri
: Token icon URL
project_uri
: Project URL
3.3. Create and Store Management References
// Generate refs
let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
// Store refs
let metadata_signer = &object::generate_signer(constructor_ref);
move_to(
    metadata_signer,
    TokenManagement {
        mint_ref,
        burn_ref,
        transfer_ref,
    }
);
References:
mint_ref
: Authority to create new tokens
burn_ref
: Authority to destroy tokens
transfer_ref
: Authority to manage transfers and frozen status
4. Implement View Functions
4.1. Get Metadata Function
#[view]
public fun get_metadata(): object::Object&lt;fungible_asset::Metadata&gt; {
    object::address_to_object(
        object::create_object_address(&@module_addr, TOKEN_SYMBOL)
    )
}
Function:
Returns the token's metadata object
Uses module address and token symbol to calculate the address
Marked as a view function to optimize gas usage
4.2. Get Balance Function
#[view]
public fun get_balance(account: address): u64 {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::balance(account, get_metadata())
    } else {
        0
    }
}
Flow:
Check if the store exists
If the store exists, return the balance
If not, return 0
4.3. Check Frozen Status
#[view]
public fun is_frozen(account: address): bool {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::is_frozen(account, get_metadata())
    } else {
        false
    }
}
Flow:
Check if the store exists
If the store exists, return the frozen status
If not, return false
5. Usage Examples
Check Token Info
// Get token metadata
let metadata = get_metadata();
// Check account balance
let balance = get_balance(@user);
// Check if account is frozen
let is_frozen = is_frozen(@user);
6. Best Practices
6.1. Error Handling
const ESTORE_NOT_FOUND: u64 = 1;
const EINVALID_METADATA: u64 = 2;
public fun safe_get_balance(account: address): u64 {
    assert!(primary_fungible_store::primary_store_exists(account, get_metadata()),
        ESTORE_NOT_FOUND
    );
    get_balance(account)
}
6.2. Optimization
// Cache metadata object for frequent use
let cached_metadata = get_metadata();
let balance1 = get_balance(addr1);
let balance2 = get_balance(addr2);
6.3. Testing
#[test]
fun test_view_functions() {
    // Initialize token
    init_module(...)
    // Test balance view
    assert!(get_balance(@user) == 0, 1);
    // Test frozen status
    assert!(!is_frozen(@user), 2);
}
7. Common Pitfalls and Notes
Initialization
Should only be called once when deploying the module
Refs cannot be recreated after initialization
URIs can be empty but should be provided in production
View Functions
Always handle cases where the store doesn't exist
Consider caching for improved performance
Ensure appropriate error handling
Testing
Test all edge cases
Verify initialization success
Check view function accuracy
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    // =================== Constants ===================
    // Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    // =================== Resources & Structs ===================
    // Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    // =================== Initialization ===================
    // Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    // =================== View Functions ===================
    // Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    // Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    // Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
}
		Summary
		Summary
		Fungible assets are interchangeable and divisible digital tokens, similar to cryptocurrencies.
The initialization process involves setting up token configuration, creating metadata, and implementing management structures.
Essential steps include defining token properties (name, symbol, decimals), creating a metadata object, and generating management references.
View functions are implemented to retrieve token metadata, check account balances, and verify frozen status.
Best practices include proper error handling, optimization techniques, and comprehensive testing.
Common pitfalls to avoid are related to initialization, view function implementation, and testing procedures.
		Fungible assets are interchangeable and divisible digital tokens, similar to cryptocurrencies.
		Fungible assets are interchangeable and divisible digital tokens, similar to cryptocurrencies.
		The initialization process involves setting up token configuration, creating metadata, and implementing management structures.
		The initialization process involves setting up token configuration, creating metadata, and implementing management structures.
		Essential steps include defining token properties (name, symbol, decimals), creating a metadata object, and generating management references.
		Essential steps include defining token properties (name, symbol, decimals), creating a metadata object, and generating management references.
		View functions are implemented to retrieve token metadata, check account balances, and verify frozen status.
		View functions are implemented to retrieve token metadata, check account balances, and verify frozen status.
		Best practices include proper error handling, optimization techniques, and comprehensive testing.
		Best practices include proper error handling, optimization techniques, and comprehensive testing.
		Common pitfalls to avoid are related to initialization, view function implementation, and testing procedures.
		Common pitfalls to avoid are related to initialization, view function implementation, and testing procedures.
	Overview
	Overview
	Fungible assets are digital tokens that are interchangeable and divisible, such as cryptocurrencies. This guide outlines the process of initializing a fungible asset on a blockchain platform, focusing on:
	Fungible assets are digital tokens that are interchangeable and divisible, such as cryptocurrencies. This guide outlines the process of initializing a fungible asset on a blockchain platform, focusing on:
	Setting up token configuration
Creating metadata and management structures
Implementing essential view functions
Best practices for development and testing
	Setting up token configuration
	Setting up token configuration
	Creating metadata and management structures
	Creating metadata and management structures
	Implementing essential view functions
	Implementing essential view functions
	Best practices for development and testing
	Best practices for development and testing
	The tutorial provides step-by-step instructions and code examples to help developers create a robust and functional fungible asset system.
	The tutorial provides step-by-step instructions and code examples to help developers create a robust and functional fungible asset system.
	1. Introduction
	1. Introduction
	This article provides detailed instructions on how to:
	This article provides detailed instructions on how to:
	Initialize a Fungible Asset
Set up management references
Implement basic view functions
	Initialize a Fungible Asset
	Initialize a Fungible Asset
	Set up management references
	Set up management references
	Implement basic view functions
	Implement basic view functions
	2. Token Configuration Structure
	2. Token Configuration Structure
	<code>/// Token configuration constants
const TOKEN_NAME: vector&lt;u8&gt; = b"YourToken";
const TOKEN_SYMBOL: vector&lt;u8&gt; = b"YTK";
const TOKEN_DECIMALS: u8 = 6;</code>
	<code>/// Token configuration constants
const TOKEN_NAME: vector&lt;u8&gt; = b"YourToken";
const TOKEN_SYMBOL: vector&lt;u8&gt; = b"YTK";
const TOKEN_DECIMALS: u8 = 6;</code>
	/// Token configuration constants
const TOKEN_NAME: vector&lt;u8&gt; = b"YourToken";
const TOKEN_SYMBOL: vector&lt;u8&gt; = b"YTK";
const TOKEN_DECIMALS: u8 = 6;
	Components:
	Components:
	Components:
	TOKEN_NAME
: Full name of the token
TOKEN_SYMBOL
: Short symbol (3–5 characters)
TOKEN_DECIMALS
: Number of decimal points (typically 6–8)
	TOKEN_NAME
: Full name of the token
	<code>TOKEN_NAME</code>
	TOKEN_NAME
	: Full name of the token
	TOKEN_SYMBOL
: Short symbol (3–5 characters)
	<code>TOKEN_SYMBOL</code>
	TOKEN_SYMBOL
	: Short symbol (3–5 characters)
	TOKEN_DECIMALS
: Number of decimal points (typically 6–8)
	<code>TOKEN_DECIMALS</code>
	TOKEN_DECIMALS
	: Number of decimal points (typically 6–8)
	3. Token Initialization
	3. Token Initialization
		3.1. Create Metadata Object
		3.1. Create Metadata Object
		<code>fun init_module(module_signer: &signer) {
    let constructor_ref = &object::create_named_object(
        module_signer,
        TOKEN_SYMBOL,
    );</code>
		<code>fun init_module(module_signer: &signer) {
    let constructor_ref = &object::create_named_object(
        module_signer,
        TOKEN_SYMBOL,
    );</code>
		fun init_module(module_signer: &signer) {
    let constructor_ref = &object::create_named_object(
        module_signer,
        TOKEN_SYMBOL,
    );
		Details:
		Details:
		Details:
		module_signer
: Module signer (typically the deployer)
constructor_ref
: Reference for creating related objects
create_named_object
: Creates an object with a deterministic address
		module_signer
: Module signer (typically the deployer)
		<code>module_signer</code>
		module_signer
		: Module signer (typically the deployer)
		constructor_ref
: Reference for creating related objects
		<code>constructor_ref</code>
		constructor_ref
		: Reference for creating related objects
		create_named_object
: Creates an object with a deterministic address
		<code>create_named_object</code>
		create_named_object
		: Creates an object with a deterministic address
		3.2. Initialize Fungible Asset
		3.2. Initialize Fungible Asset
		<code>primary_fungible_store::create_primary_store_enabled_fungible_asset(
    constructor_ref,
    option::none(),                 // Maximum supply (none = unlimited)
    string::utf8(TOKEN_NAME),       // Token name
    string::utf8(TOKEN_SYMBOL),     // Token symbol
    TOKEN_DECIMALS,                 // Decimals
    string::utf8(b""),              // Icon URI
    string::utf8(b""),              // Project URI
);</code>
		<code>primary_fungible_store::create_primary_store_enabled_fungible_asset(
    constructor_ref,
    option::none(),                 // Maximum supply (none = unlimited)
    string::utf8(TOKEN_NAME),       // Token name
    string::utf8(TOKEN_SYMBOL),     // Token symbol
    TOKEN_DECIMALS,                 // Decimals
    string::utf8(b""),              // Icon URI
    string::utf8(b""),              // Project URI
);</code>
		primary_fungible_store::create_primary_store_enabled_fungible_asset(
    constructor_ref,
    option::none(),                 // Maximum supply (none = unlimited)
    string::utf8(TOKEN_NAME),       // Token name
    string::utf8(TOKEN_SYMBOL),     // Token symbol
    TOKEN_DECIMALS,                 // Decimals
    string::utf8(b""),              // Icon URI
    string::utf8(b""),              // Project URI
);
		Parameters:
		Parameters:
		Parameters:
		constructor_ref
: Reference from the previous step
maximum_supply
: Supply limit (option::none() = unlimited)
name
: Token name
symbol
: Token symbol
decimals
: Number of decimals
icon_uri
: Token icon URL
project_uri
: Project URL
		constructor_ref
: Reference from the previous step
		<code>constructor_ref</code>
		constructor_ref
		: Reference from the previous step
		maximum_supply
: Supply limit (option::none() = unlimited)
		<code>maximum_supply</code>
		maximum_supply
		: Supply limit (option::none() = unlimited)
		name
: Token name
		<code>name</code>
		name
		: Token name
		symbol
: Token symbol
		<code>symbol</code>
		symbol
		: Token symbol
		decimals
: Number of decimals
		<code>decimals</code>
		decimals
		: Number of decimals
		icon_uri
: Token icon URL
		<code>icon_uri</code>
		icon_uri
		: Token icon URL
		project_uri
: Project URL
		<code>project_uri</code>
		project_uri
		: Project URL
		3.3. Create and Store Management References
		3.3. Create and Store Management References
		<code>// Generate refs
let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
// Store refs
let metadata_signer = &object::generate_signer(constructor_ref);
move_to(
    metadata_signer,
    TokenManagement {
        mint_ref,
        burn_ref,
        transfer_ref,
    }
);</code>
		<code>// Generate refs
let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
// Store refs
let metadata_signer = &object::generate_signer(constructor_ref);
move_to(
    metadata_signer,
    TokenManagement {
        mint_ref,
        burn_ref,
        transfer_ref,
    }
);</code>
		// Generate refs
let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
// Store refs
let metadata_signer = &object::generate_signer(constructor_ref);
move_to(
    metadata_signer,
    TokenManagement {
        mint_ref,
        burn_ref,
        transfer_ref,
    }
);
		References:
		References:
		References:
		mint_ref
: Authority to create new tokens
burn_ref
: Authority to destroy tokens
transfer_ref
: Authority to manage transfers and frozen status
		mint_ref
: Authority to create new tokens
		<code>mint_ref</code>
		mint_ref
		: Authority to create new tokens
		burn_ref
: Authority to destroy tokens
		<code>burn_ref</code>
		burn_ref
		: Authority to destroy tokens
		transfer_ref
: Authority to manage transfers and frozen status
		<code>transfer_ref</code>
		transfer_ref
		: Authority to manage transfers and frozen status
	4. Implement View Functions
	4. Implement View Functions
		4.1. Get Metadata Function
		4.1. Get Metadata Function
		<code>#[view]
public fun get_metadata(): object::Object&lt;fungible_asset::Metadata&gt; {
    object::address_to_object(
        object::create_object_address(&@module_addr, TOKEN_SYMBOL)
    )
}</code>
		<code>#[view]
public fun get_metadata(): object::Object&lt;fungible_asset::Metadata&gt; {
    object::address_to_object(
        object::create_object_address(&@module_addr, TOKEN_SYMBOL)
    )
}</code>
		#[view]
public fun get_metadata(): object::Object&lt;fungible_asset::Metadata&gt; {
    object::address_to_object(
        object::create_object_address(&@module_addr, TOKEN_SYMBOL)
    )
}
		Function:
		Function:
		Function:
		Returns the token's metadata object
Uses module address and token symbol to calculate the address
Marked as a view function to optimize gas usage
		Returns the token's metadata object
		Returns the token's metadata object
		Uses module address and token symbol to calculate the address
		Uses module address and token symbol to calculate the address
		Marked as a view function to optimize gas usage
		Marked as a view function to optimize gas usage
		4.2. Get Balance Function
		4.2. Get Balance Function
		<code>#[view]
public fun get_balance(account: address): u64 {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::balance(account, get_metadata())
    } else {
        0
    }
}</code>
		<code>#[view]
public fun get_balance(account: address): u64 {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::balance(account, get_metadata())
    } else {
        0
    }
}</code>
		#[view]
public fun get_balance(account: address): u64 {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::balance(account, get_metadata())
    } else {
        0
    }
}
		Flow:
		Flow:
		Flow:
		Check if the store exists
If the store exists, return the balance
If not, return 0
		Check if the store exists
		Check if the store exists
		If the store exists, return the balance
		If the store exists, return the balance
		If not, return 0
		If not, return 0
		4.3. Check Frozen Status
		4.3. Check Frozen Status
		<code>#[view]
public fun is_frozen(account: address): bool {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::is_frozen(account, get_metadata())
    } else {
        false
    }
}</code>
		<code>#[view]
public fun is_frozen(account: address): bool {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::is_frozen(account, get_metadata())
    } else {
        false
    }
}</code>
		#[view]
public fun is_frozen(account: address): bool {
    if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
        primary_fungible_store::is_frozen(account, get_metadata())
    } else {
        false
    }
}
		Flow:
		Flow:
		Flow:
		Check if the store exists
If the store exists, return the frozen status
If not, return false
		Check if the store exists
		Check if the store exists
		If the store exists, return the frozen status
		If the store exists, return the frozen status
		If not, return false
		If not, return false
	5. Usage Examples
	5. Usage Examples
		Check Token Info
		Check Token Info
		<code>// Get token metadata
let metadata = get_metadata();
// Check account balance
let balance = get_balance(@user);
// Check if account is frozen
let is_frozen = is_frozen(@user);</code>
		<code>// Get token metadata
let metadata = get_metadata();
// Check account balance
let balance = get_balance(@user);
// Check if account is frozen
let is_frozen = is_frozen(@user);</code>
		// Get token metadata
let metadata = get_metadata();
// Check account balance
let balance = get_balance(@user);
// Check if account is frozen
let is_frozen = is_frozen(@user);
	6. Best Practices
	6. Best Practices
		6.1. Error Handling
		6.1. Error Handling
		<code>const ESTORE_NOT_FOUND: u64 = 1;
const EINVALID_METADATA: u64 = 2;
public fun safe_get_balance(account: address): u64 {
    assert!(primary_fungible_store::primary_store_exists(account, get_metadata()),
        ESTORE_NOT_FOUND
    );
    get_balance(account)
}</code>
		<code>const ESTORE_NOT_FOUND: u64 = 1;
const EINVALID_METADATA: u64 = 2;
public fun safe_get_balance(account: address): u64 {
    assert!(primary_fungible_store::primary_store_exists(account, get_metadata()),
        ESTORE_NOT_FOUND
    );
    get_balance(account)
}</code>
		const ESTORE_NOT_FOUND: u64 = 1;
const EINVALID_METADATA: u64 = 2;
public fun safe_get_balance(account: address): u64 {
    assert!(primary_fungible_store::primary_store_exists(account, get_metadata()),
        ESTORE_NOT_FOUND
    );
    get_balance(account)
}
		6.2. Optimization
		6.2. Optimization
		<code>// Cache metadata object for frequent use
let cached_metadata = get_metadata();
let balance1 = get_balance(addr1);
let balance2 = get_balance(addr2);</code>
		<code>// Cache metadata object for frequent use
let cached_metadata = get_metadata();
let balance1 = get_balance(addr1);
let balance2 = get_balance(addr2);</code>
		// Cache metadata object for frequent use
let cached_metadata = get_metadata();
let balance1 = get_balance(addr1);
let balance2 = get_balance(addr2);
		6.3. Testing
		6.3. Testing
		<code>#[test]
fun test_view_functions() {
    // Initialize token
    init_module(...)
    // Test balance view
    assert!(get_balance(@user) == 0, 1);
    // Test frozen status
    assert!(!is_frozen(@user), 2);
}</code>
		<code>#[test]
fun test_view_functions() {
    // Initialize token
    init_module(...)
    // Test balance view
    assert!(get_balance(@user) == 0, 1);
    // Test frozen status
    assert!(!is_frozen(@user), 2);
}</code>
		#[test]
fun test_view_functions() {
    // Initialize token
    init_module(...)
    // Test balance view
    assert!(get_balance(@user) == 0, 1);
    // Test frozen status
    assert!(!is_frozen(@user), 2);
}
	7. Common Pitfalls and Notes
	7. Common Pitfalls and Notes
	Initialization
Should only be called once when deploying the module
Refs cannot be recreated after initialization
URIs can be empty but should be provided in production
View Functions
Always handle cases where the store doesn't exist
Consider caching for improved performance
Ensure appropriate error handling
Testing
Test all edge cases
Verify initialization success
Check view function accuracy
	Initialization
Should only be called once when deploying the module
Refs cannot be recreated after initialization
URIs can be empty but should be provided in production
	Initialization
	Initialization
	Should only be called once when deploying the module
Refs cannot be recreated after initialization
URIs can be empty but should be provided in production
	Should only be called once when deploying the module
	Should only be called once when deploying the module
	Refs cannot be recreated after initialization
	Refs cannot be recreated after initialization
	URIs can be empty but should be provided in production
	URIs can be empty but should be provided in production
	View Functions
Always handle cases where the store doesn't exist
Consider caching for improved performance
Ensure appropriate error handling
	View Functions
	View Functions
	Always handle cases where the store doesn't exist
Consider caching for improved performance
Ensure appropriate error handling
	Always handle cases where the store doesn't exist
	Always handle cases where the store doesn't exist
	Consider caching for improved performance
	Consider caching for improved performance
	Ensure appropriate error handling
	Ensure appropriate error handling
	Testing
Test all edge cases
Verify initialization success
Check view function accuracy
	Testing
	Testing
	Test all edge cases
Verify initialization success
Check view function accuracy
	Test all edge cases
	Test all edge cases
	Verify initialization success
	Verify initialization success
	Check view function accuracy
	Check view function accuracy
Full Code
Full Code
<code>module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    // =================== Constants ===================
    // Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    // =================== Resources & Structs ===================
    // Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    // =================== Initialization ===================
    // Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    // =================== View Functions ===================
    // Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    // Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    // Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
}</code>
<code>module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    // =================== Constants ===================
    // Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    // =================== Resources & Structs ===================
    // Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    // =================== Initialization ===================
    // Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    // =================== View Functions ===================
    // Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    // Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    // Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
}</code>
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    // =================== Constants ===================
    // Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    // =================== Resources & Structs ===================
    // Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    // =================== Initialization ===================
    // Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    // =================== View Functions ===================
    // Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    // Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    // Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/01-fungible-asset/06-management-functions-fungible-asset-framework
Management Functions Fungible Asset Framework
Management Functions Fungible Asset Framework
On This Page
1. Overview
2. Events and Error Codes
2.1 Event Structures
2.2 Error Constants
3. Mint Function Implementation
3.1 Function Signature
3.2 Detailed Implementation
4. Burn Function Implementation
4.1 Function Signature
4.2 Detailed Implementation
5. Freeze Function Implementation
5.1 Function Signature
5.2 Detailed Implementation
6. Usage Examples
6.1 Minting Tokens
6.2 Burning Tokens
6.3 Freezing Account
Full Code
1. Overview
Management Functions are special functions used to manage tokens in the Fungible Asset Framework. These functions are crucial for controlling the token supply and user access. Let's explore the main management functions:
Minting (creating new) tokens: This function allows authorized users to create and distribute new tokens.
Burning (destroying) tokens: This function removes tokens from circulation, which can be useful for managing token supply or implementing certain economic models.
Managing the frozen status of accounts: This function allows administrators to restrict token transfers for specific accounts, which can be useful for security or compliance purposes.
2. Events and Error Codes
Events and error codes are essential for tracking operations and handling exceptions in your smart contract. Let's break them down:
2.1 Event Structures
Events are emitted when certain actions occur, allowing off-chain systems to track and react to on-chain activities. Here are the main event structures:
// Event emitted when new tokens are minted
struct MintEvent has drop, store {
    amount: u64,      // Amount of tokens minted
    recipient: address, // Address receiving the minted tokens
}
// Event emitted when tokens are burned
struct BurnEvent has drop, store {
    amount: u64,  // Amount of tokens burned
    from: address, // Address from which tokens were burned
}
// Event emitted when an account's frozen status changes
struct FreezeEvent has drop, store {
    account: address, // Address of the affected account
    frozen: bool,     // New frozen status (true if frozen, false if unfrozen)
}
These events help in tracking token minting, burning, and account freezing operations.
2.2 Error Constants
Error constants are used to provide meaningful error messages when operations fail. Here are the main error constants:
const EZERO_MINT_AMOUNT: u64 = 1;  // Error when trying to mint zero tokens
const EZERO_BURN_AMOUNT: u64 = 2;  // Error when trying to burn zero tokens
const ENOT_AUTHORIZED: u64 = 3;    // Error when an unauthorized user attempts a restricted operation
Using these error constants helps in providing clear feedback when operations fail, making it easier to debug and handle exceptions.
3. Mint Function Implementation
The mint function is used to create new tokens and assign them to a specific address. Let's break down its implementation:
3.1 Function Signature
public entry fun mint_to(
    admin: &signer,    // The administrator's signer reference
    recipient: address, // The address to receive the minted tokens
    amount: u64        // The amount of tokens to mint
) acquires MovementManagement
This function signature indicates that only an admin can call this function, and it requires access to the MovementManagement resource.
3.2 Detailed Implementation
public entry fun mint_to(
    admin: &signer,
    recipient: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_MINT_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Mint tokens
    primary_fungible_store::mint(&management.mint_ref, recipient, amount);
    // 4. Emit event
    event::emit(MintEvent {
        amount,
        recipient,
    });
}
Flow Analysis:
Validation
The function first checks if the amount to be minted is greater than zero. This prevents minting of zero tokens, which would be pointless and potentially confusing.
The authorization check is implicit through the use of mint_ref, ensuring only authorized users can mint tokens.
Management Access
The function retrieves the MovementManagement struct, which contains references to perform token operations.
The mint_ref is accessed from this struct, providing the capability to mint tokens.
Mint Operation
The primary_fungible_store::mint function is called to actually create and assign the new tokens.
If the recipient doesn't have a token store, one is automatically created.
Event Emission
After successful minting, a MintEvent is emitted to record the transaction.
This event includes the amount minted and the recipient's address, allowing for easy tracking and auditing of minting operations.
4. Burn Function Implementation
The burn function is used to destroy existing tokens, effectively removing them from circulation. Here's a detailed look at its implementation:
4.1 Function Signature
public entry fun burn_from(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address from which to burn tokens
    amount: u64      // The amount of tokens to burn
) acquires MovementManagement
Similar to the mint function, this function can only be called by an admin and requires access to the MovementManagement resource.
4.2 Detailed Implementation
public entry fun burn_from(
    admin: &signer,
    account: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_BURN_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Burn tokens
    primary_fungible_store::burn(&management.burn_ref, account, amount);
    // 4. Emit event
    event::emit(BurnEvent {
        amount,
        from: account,
    });
}
Flow Analysis:
Validation
The function checks if the amount to be burned is greater than zero, preventing attempts to burn zero tokens.
The balance check is implicitly performed in the burn operation, ensuring the account has sufficient tokens to burn.
Management Access
The burn_ref is retrieved from the MovementManagement struct, providing the capability to burn tokens.
This step also verifies that the caller has the necessary authorization to perform the burn operation.
Burn Operation
The primary_fungible_store::burn function is called to destroy the specified amount of tokens from the given account.
This operation reduces the total supply of tokens in circulation.
Event Emission
After successful burning, a BurnEvent is emitted to record the transaction.
This event includes the amount burned and the source account, allowing for easy tracking and auditing of burning operations.
5. Freeze Function Implementation
The freeze function is used to restrict or enable token transfers for specific accounts. This can be useful for various purposes such as implementing security measures or complying with regulations. Let's examine its implementation:
5.1 Function Signature
public entry fun set_frozen(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address to be frozen or unfrozen
    frozen: bool     // The new frozen status (true to freeze, false to unfreeze)
) acquires MovementManagement
As with the other management functions, this can only be called by an admin and requires access to the MovementManagement resource.
5.2 Detailed Implementation
public entry fun set_frozen(
    admin: &signer,
    account: address,
    frozen: bool
) acquires MovementManagement {
    // 1. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 2. Set frozen status
    primary_fungible_store::set_frozen_flag(
        &management.transfer_ref,
        account,
        frozen
    );
    // 3. Emit event
    event::emit(FreezeEvent {
        account,
        frozen,
    });
}
Flow Analysis:
Management Access
The function retrieves the transfer_ref from the MovementManagement struct, which provides the capability to modify account frozen status.
This step implicitly verifies that the caller has the necessary admin rights to perform the operation.
State Update
The primary_fungible_store::set_frozen_flag function is called to update the frozen status of the specified account.
If frozen is set to true, the account will be unable to transfer tokens. If false, transfers will be allowed.
Event Emission
After successfully updating the frozen status, a FreezeEvent is emitted to record the change.
This event includes the affected account address and the new frozen status, allowing for easy tracking of account restrictions.
6. Usage Examples
To better understand how these management functions work in practice, let's look at some usage examples:
6.1 Minting Tokens
// Mint 1000 tokens to user
public entry fun mint_example(admin: &signer) acquires MovementManagement {
    mint_to(admin, @user, 1000);
}
In this example, we're minting 1000 tokens and assigning them to the @user address. The admin signer is required to authorize this operation.
6.2 Burning Tokens
// Burn 500 tokens from user
public entry fun burn_example(admin: &signer) acquires MovementManagement {
    burn_from(admin, @user, 500);
}
This example demonstrates burning 500 tokens from the @user address. Again, the admin signer is needed to perform this operation.
6.3 Freezing Account
// Freeze user account
public entry fun freeze_example(admin: &signer) acquires MovementManagement {
    set_frozen(admin, @user, true);
}
In this example, we're freezing the @user account, preventing it from making token transfers. The admin signer authorizes this action.
These examples demonstrate how to use the management functions in your smart contract. Remember to always handle these functions with care, as they have significant impacts on token circulation and user access.
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}
On This Page
1. Overview
2. Events and Error Codes
2.1 Event Structures
2.2 Error Constants
3. Mint Function Implementation
3.1 Function Signature
3.2 Detailed Implementation
4. Burn Function Implementation
4.1 Function Signature
4.2 Detailed Implementation
5. Freeze Function Implementation
5.1 Function Signature
5.2 Detailed Implementation
6. Usage Examples
6.1 Minting Tokens
6.2 Burning Tokens
6.3 Freezing Account
Full Code
On This Page
1. Overview
2. Events and Error Codes
2.1 Event Structures
2.2 Error Constants
3. Mint Function Implementation
3.1 Function Signature
3.2 Detailed Implementation
4. Burn Function Implementation
4.1 Function Signature
4.2 Detailed Implementation
5. Freeze Function Implementation
5.1 Function Signature
5.2 Detailed Implementation
6. Usage Examples
6.1 Minting Tokens
6.2 Burning Tokens
6.3 Freezing Account
Full Code
			On This Page
			On This Page
			1. Overview
2. Events and Error Codes
2.1 Event Structures
2.2 Error Constants
3. Mint Function Implementation
3.1 Function Signature
3.2 Detailed Implementation
4. Burn Function Implementation
4.1 Function Signature
4.2 Detailed Implementation
5. Freeze Function Implementation
5.1 Function Signature
5.2 Detailed Implementation
6. Usage Examples
6.1 Minting Tokens
6.2 Burning Tokens
6.3 Freezing Account
Full Code
			1. Overview
			1. Overview
			1. Overview
			1. Overview
			2. Events and Error Codes
2.1 Event Structures
2.2 Error Constants
			2. Events and Error Codes
			2. Events and Error Codes
			2. Events and Error Codes
			2.1 Event Structures
2.2 Error Constants
			2.1 Event Structures
			2.1 Event Structures
			2.1 Event Structures
			2.1 Event Structures
			2.2 Error Constants
			2.2 Error Constants
			2.2 Error Constants
			2.2 Error Constants
			3. Mint Function Implementation
3.1 Function Signature
3.2 Detailed Implementation
			3. Mint Function Implementation
			3. Mint Function Implementation
			3. Mint Function Implementation
			3.1 Function Signature
3.2 Detailed Implementation
			3.1 Function Signature
			3.1 Function Signature
			3.1 Function Signature
			3.1 Function Signature
			3.2 Detailed Implementation
			3.2 Detailed Implementation
			3.2 Detailed Implementation
			3.2 Detailed Implementation
			4. Burn Function Implementation
4.1 Function Signature
4.2 Detailed Implementation
			4. Burn Function Implementation
			4. Burn Function Implementation
			4. Burn Function Implementation
			4.1 Function Signature
4.2 Detailed Implementation
			4.1 Function Signature
			4.1 Function Signature
			4.1 Function Signature
			4.1 Function Signature
			4.2 Detailed Implementation
			4.2 Detailed Implementation
			4.2 Detailed Implementation
			4.2 Detailed Implementation
			5. Freeze Function Implementation
5.1 Function Signature
5.2 Detailed Implementation
			5. Freeze Function Implementation
			5. Freeze Function Implementation
			5. Freeze Function Implementation
			5.1 Function Signature
5.2 Detailed Implementation
			5.1 Function Signature
			5.1 Function Signature
			5.1 Function Signature
			5.1 Function Signature
			5.2 Detailed Implementation
			5.2 Detailed Implementation
			5.2 Detailed Implementation
			5.2 Detailed Implementation
			6. Usage Examples
6.1 Minting Tokens
6.2 Burning Tokens
6.3 Freezing Account
			6. Usage Examples
			6. Usage Examples
			6. Usage Examples
			6.1 Minting Tokens
6.2 Burning Tokens
6.3 Freezing Account
			6.1 Minting Tokens
			6.1 Minting Tokens
			6.1 Minting Tokens
			6.1 Minting Tokens
			6.2 Burning Tokens
			6.2 Burning Tokens
			6.2 Burning Tokens
			6.2 Burning Tokens
			6.3 Freezing Account
			6.3 Freezing Account
			6.3 Freezing Account
			6.3 Freezing Account
			Full Code
			Full Code
			Full Code
			Full Code
			1. Overview
Management Functions are special functions used to manage tokens in the Fungible Asset Framework. These functions are crucial for controlling the token supply and user access. Let's explore the main management functions:
Minting (creating new) tokens: This function allows authorized users to create and distribute new tokens.
Burning (destroying) tokens: This function removes tokens from circulation, which can be useful for managing token supply or implementing certain economic models.
Managing the frozen status of accounts: This function allows administrators to restrict token transfers for specific accounts, which can be useful for security or compliance purposes.
2. Events and Error Codes
Events and error codes are essential for tracking operations and handling exceptions in your smart contract. Let's break them down:
2.1 Event Structures
Events are emitted when certain actions occur, allowing off-chain systems to track and react to on-chain activities. Here are the main event structures:
// Event emitted when new tokens are minted
struct MintEvent has drop, store {
    amount: u64,      // Amount of tokens minted
    recipient: address, // Address receiving the minted tokens
}
// Event emitted when tokens are burned
struct BurnEvent has drop, store {
    amount: u64,  // Amount of tokens burned
    from: address, // Address from which tokens were burned
}
// Event emitted when an account's frozen status changes
struct FreezeEvent has drop, store {
    account: address, // Address of the affected account
    frozen: bool,     // New frozen status (true if frozen, false if unfrozen)
}
These events help in tracking token minting, burning, and account freezing operations.
2.2 Error Constants
Error constants are used to provide meaningful error messages when operations fail. Here are the main error constants:
const EZERO_MINT_AMOUNT: u64 = 1;  // Error when trying to mint zero tokens
const EZERO_BURN_AMOUNT: u64 = 2;  // Error when trying to burn zero tokens
const ENOT_AUTHORIZED: u64 = 3;    // Error when an unauthorized user attempts a restricted operation
Using these error constants helps in providing clear feedback when operations fail, making it easier to debug and handle exceptions.
3. Mint Function Implementation
The mint function is used to create new tokens and assign them to a specific address. Let's break down its implementation:
3.1 Function Signature
public entry fun mint_to(
    admin: &signer,    // The administrator's signer reference
    recipient: address, // The address to receive the minted tokens
    amount: u64        // The amount of tokens to mint
) acquires MovementManagement
This function signature indicates that only an admin can call this function, and it requires access to the MovementManagement resource.
3.2 Detailed Implementation
public entry fun mint_to(
    admin: &signer,
    recipient: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_MINT_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Mint tokens
    primary_fungible_store::mint(&management.mint_ref, recipient, amount);
    // 4. Emit event
    event::emit(MintEvent {
        amount,
        recipient,
    });
}
Flow Analysis:
Validation
The function first checks if the amount to be minted is greater than zero. This prevents minting of zero tokens, which would be pointless and potentially confusing.
The authorization check is implicit through the use of mint_ref, ensuring only authorized users can mint tokens.
Management Access
The function retrieves the MovementManagement struct, which contains references to perform token operations.
The mint_ref is accessed from this struct, providing the capability to mint tokens.
Mint Operation
The primary_fungible_store::mint function is called to actually create and assign the new tokens.
If the recipient doesn't have a token store, one is automatically created.
Event Emission
After successful minting, a MintEvent is emitted to record the transaction.
This event includes the amount minted and the recipient's address, allowing for easy tracking and auditing of minting operations.
4. Burn Function Implementation
The burn function is used to destroy existing tokens, effectively removing them from circulation. Here's a detailed look at its implementation:
4.1 Function Signature
public entry fun burn_from(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address from which to burn tokens
    amount: u64      // The amount of tokens to burn
) acquires MovementManagement
Similar to the mint function, this function can only be called by an admin and requires access to the MovementManagement resource.
4.2 Detailed Implementation
public entry fun burn_from(
    admin: &signer,
    account: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_BURN_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Burn tokens
    primary_fungible_store::burn(&management.burn_ref, account, amount);
    // 4. Emit event
    event::emit(BurnEvent {
        amount,
        from: account,
    });
}
Flow Analysis:
Validation
The function checks if the amount to be burned is greater than zero, preventing attempts to burn zero tokens.
The balance check is implicitly performed in the burn operation, ensuring the account has sufficient tokens to burn.
Management Access
The burn_ref is retrieved from the MovementManagement struct, providing the capability to burn tokens.
This step also verifies that the caller has the necessary authorization to perform the burn operation.
Burn Operation
The primary_fungible_store::burn function is called to destroy the specified amount of tokens from the given account.
This operation reduces the total supply of tokens in circulation.
Event Emission
After successful burning, a BurnEvent is emitted to record the transaction.
This event includes the amount burned and the source account, allowing for easy tracking and auditing of burning operations.
5. Freeze Function Implementation
The freeze function is used to restrict or enable token transfers for specific accounts. This can be useful for various purposes such as implementing security measures or complying with regulations. Let's examine its implementation:
5.1 Function Signature
public entry fun set_frozen(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address to be frozen or unfrozen
    frozen: bool     // The new frozen status (true to freeze, false to unfreeze)
) acquires MovementManagement
As with the other management functions, this can only be called by an admin and requires access to the MovementManagement resource.
5.2 Detailed Implementation
public entry fun set_frozen(
    admin: &signer,
    account: address,
    frozen: bool
) acquires MovementManagement {
    // 1. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 2. Set frozen status
    primary_fungible_store::set_frozen_flag(
        &management.transfer_ref,
        account,
        frozen
    );
    // 3. Emit event
    event::emit(FreezeEvent {
        account,
        frozen,
    });
}
Flow Analysis:
Management Access
The function retrieves the transfer_ref from the MovementManagement struct, which provides the capability to modify account frozen status.
This step implicitly verifies that the caller has the necessary admin rights to perform the operation.
State Update
The primary_fungible_store::set_frozen_flag function is called to update the frozen status of the specified account.
If frozen is set to true, the account will be unable to transfer tokens. If false, transfers will be allowed.
Event Emission
After successfully updating the frozen status, a FreezeEvent is emitted to record the change.
This event includes the affected account address and the new frozen status, allowing for easy tracking of account restrictions.
6. Usage Examples
To better understand how these management functions work in practice, let's look at some usage examples:
6.1 Minting Tokens
// Mint 1000 tokens to user
public entry fun mint_example(admin: &signer) acquires MovementManagement {
    mint_to(admin, @user, 1000);
}
In this example, we're minting 1000 tokens and assigning them to the @user address. The admin signer is required to authorize this operation.
6.2 Burning Tokens
// Burn 500 tokens from user
public entry fun burn_example(admin: &signer) acquires MovementManagement {
    burn_from(admin, @user, 500);
}
This example demonstrates burning 500 tokens from the @user address. Again, the admin signer is needed to perform this operation.
6.3 Freezing Account
// Freeze user account
public entry fun freeze_example(admin: &signer) acquires MovementManagement {
    set_frozen(admin, @user, true);
}
In this example, we're freezing the @user account, preventing it from making token transfers. The admin signer authorizes this action.
These examples demonstrate how to use the management functions in your smart contract. Remember to always handle these functions with care, as they have significant impacts on token circulation and user access.
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}
			1. Overview
Management Functions are special functions used to manage tokens in the Fungible Asset Framework. These functions are crucial for controlling the token supply and user access. Let's explore the main management functions:
Minting (creating new) tokens: This function allows authorized users to create and distribute new tokens.
Burning (destroying) tokens: This function removes tokens from circulation, which can be useful for managing token supply or implementing certain economic models.
Managing the frozen status of accounts: This function allows administrators to restrict token transfers for specific accounts, which can be useful for security or compliance purposes.
2. Events and Error Codes
Events and error codes are essential for tracking operations and handling exceptions in your smart contract. Let's break them down:
2.1 Event Structures
Events are emitted when certain actions occur, allowing off-chain systems to track and react to on-chain activities. Here are the main event structures:
// Event emitted when new tokens are minted
struct MintEvent has drop, store {
    amount: u64,      // Amount of tokens minted
    recipient: address, // Address receiving the minted tokens
}
// Event emitted when tokens are burned
struct BurnEvent has drop, store {
    amount: u64,  // Amount of tokens burned
    from: address, // Address from which tokens were burned
}
// Event emitted when an account's frozen status changes
struct FreezeEvent has drop, store {
    account: address, // Address of the affected account
    frozen: bool,     // New frozen status (true if frozen, false if unfrozen)
}
These events help in tracking token minting, burning, and account freezing operations.
2.2 Error Constants
Error constants are used to provide meaningful error messages when operations fail. Here are the main error constants:
const EZERO_MINT_AMOUNT: u64 = 1;  // Error when trying to mint zero tokens
const EZERO_BURN_AMOUNT: u64 = 2;  // Error when trying to burn zero tokens
const ENOT_AUTHORIZED: u64 = 3;    // Error when an unauthorized user attempts a restricted operation
Using these error constants helps in providing clear feedback when operations fail, making it easier to debug and handle exceptions.
3. Mint Function Implementation
The mint function is used to create new tokens and assign them to a specific address. Let's break down its implementation:
3.1 Function Signature
public entry fun mint_to(
    admin: &signer,    // The administrator's signer reference
    recipient: address, // The address to receive the minted tokens
    amount: u64        // The amount of tokens to mint
) acquires MovementManagement
This function signature indicates that only an admin can call this function, and it requires access to the MovementManagement resource.
3.2 Detailed Implementation
public entry fun mint_to(
    admin: &signer,
    recipient: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_MINT_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Mint tokens
    primary_fungible_store::mint(&management.mint_ref, recipient, amount);
    // 4. Emit event
    event::emit(MintEvent {
        amount,
        recipient,
    });
}
Flow Analysis:
Validation
The function first checks if the amount to be minted is greater than zero. This prevents minting of zero tokens, which would be pointless and potentially confusing.
The authorization check is implicit through the use of mint_ref, ensuring only authorized users can mint tokens.
Management Access
The function retrieves the MovementManagement struct, which contains references to perform token operations.
The mint_ref is accessed from this struct, providing the capability to mint tokens.
Mint Operation
The primary_fungible_store::mint function is called to actually create and assign the new tokens.
If the recipient doesn't have a token store, one is automatically created.
Event Emission
After successful minting, a MintEvent is emitted to record the transaction.
This event includes the amount minted and the recipient's address, allowing for easy tracking and auditing of minting operations.
4. Burn Function Implementation
The burn function is used to destroy existing tokens, effectively removing them from circulation. Here's a detailed look at its implementation:
4.1 Function Signature
public entry fun burn_from(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address from which to burn tokens
    amount: u64      // The amount of tokens to burn
) acquires MovementManagement
Similar to the mint function, this function can only be called by an admin and requires access to the MovementManagement resource.
4.2 Detailed Implementation
public entry fun burn_from(
    admin: &signer,
    account: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_BURN_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Burn tokens
    primary_fungible_store::burn(&management.burn_ref, account, amount);
    // 4. Emit event
    event::emit(BurnEvent {
        amount,
        from: account,
    });
}
Flow Analysis:
Validation
The function checks if the amount to be burned is greater than zero, preventing attempts to burn zero tokens.
The balance check is implicitly performed in the burn operation, ensuring the account has sufficient tokens to burn.
Management Access
The burn_ref is retrieved from the MovementManagement struct, providing the capability to burn tokens.
This step also verifies that the caller has the necessary authorization to perform the burn operation.
Burn Operation
The primary_fungible_store::burn function is called to destroy the specified amount of tokens from the given account.
This operation reduces the total supply of tokens in circulation.
Event Emission
After successful burning, a BurnEvent is emitted to record the transaction.
This event includes the amount burned and the source account, allowing for easy tracking and auditing of burning operations.
5. Freeze Function Implementation
The freeze function is used to restrict or enable token transfers for specific accounts. This can be useful for various purposes such as implementing security measures or complying with regulations. Let's examine its implementation:
5.1 Function Signature
public entry fun set_frozen(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address to be frozen or unfrozen
    frozen: bool     // The new frozen status (true to freeze, false to unfreeze)
) acquires MovementManagement
As with the other management functions, this can only be called by an admin and requires access to the MovementManagement resource.
5.2 Detailed Implementation
public entry fun set_frozen(
    admin: &signer,
    account: address,
    frozen: bool
) acquires MovementManagement {
    // 1. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 2. Set frozen status
    primary_fungible_store::set_frozen_flag(
        &management.transfer_ref,
        account,
        frozen
    );
    // 3. Emit event
    event::emit(FreezeEvent {
        account,
        frozen,
    });
}
Flow Analysis:
Management Access
The function retrieves the transfer_ref from the MovementManagement struct, which provides the capability to modify account frozen status.
This step implicitly verifies that the caller has the necessary admin rights to perform the operation.
State Update
The primary_fungible_store::set_frozen_flag function is called to update the frozen status of the specified account.
If frozen is set to true, the account will be unable to transfer tokens. If false, transfers will be allowed.
Event Emission
After successfully updating the frozen status, a FreezeEvent is emitted to record the change.
This event includes the affected account address and the new frozen status, allowing for easy tracking of account restrictions.
6. Usage Examples
To better understand how these management functions work in practice, let's look at some usage examples:
6.1 Minting Tokens
// Mint 1000 tokens to user
public entry fun mint_example(admin: &signer) acquires MovementManagement {
    mint_to(admin, @user, 1000);
}
In this example, we're minting 1000 tokens and assigning them to the @user address. The admin signer is required to authorize this operation.
6.2 Burning Tokens
// Burn 500 tokens from user
public entry fun burn_example(admin: &signer) acquires MovementManagement {
    burn_from(admin, @user, 500);
}
This example demonstrates burning 500 tokens from the @user address. Again, the admin signer is needed to perform this operation.
6.3 Freezing Account
// Freeze user account
public entry fun freeze_example(admin: &signer) acquires MovementManagement {
    set_frozen(admin, @user, true);
}
In this example, we're freezing the @user account, preventing it from making token transfers. The admin signer authorizes this action.
These examples demonstrate how to use the management functions in your smart contract. Remember to always handle these functions with care, as they have significant impacts on token circulation and user access.
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}
			1. Overview
Management Functions are special functions used to manage tokens in the Fungible Asset Framework. These functions are crucial for controlling the token supply and user access. Let's explore the main management functions:
Minting (creating new) tokens: This function allows authorized users to create and distribute new tokens.
Burning (destroying) tokens: This function removes tokens from circulation, which can be useful for managing token supply or implementing certain economic models.
Managing the frozen status of accounts: This function allows administrators to restrict token transfers for specific accounts, which can be useful for security or compliance purposes.
2. Events and Error Codes
Events and error codes are essential for tracking operations and handling exceptions in your smart contract. Let's break them down:
2.1 Event Structures
Events are emitted when certain actions occur, allowing off-chain systems to track and react to on-chain activities. Here are the main event structures:
// Event emitted when new tokens are minted
struct MintEvent has drop, store {
    amount: u64,      // Amount of tokens minted
    recipient: address, // Address receiving the minted tokens
}
// Event emitted when tokens are burned
struct BurnEvent has drop, store {
    amount: u64,  // Amount of tokens burned
    from: address, // Address from which tokens were burned
}
// Event emitted when an account's frozen status changes
struct FreezeEvent has drop, store {
    account: address, // Address of the affected account
    frozen: bool,     // New frozen status (true if frozen, false if unfrozen)
}
These events help in tracking token minting, burning, and account freezing operations.
2.2 Error Constants
Error constants are used to provide meaningful error messages when operations fail. Here are the main error constants:
const EZERO_MINT_AMOUNT: u64 = 1;  // Error when trying to mint zero tokens
const EZERO_BURN_AMOUNT: u64 = 2;  // Error when trying to burn zero tokens
const ENOT_AUTHORIZED: u64 = 3;    // Error when an unauthorized user attempts a restricted operation
Using these error constants helps in providing clear feedback when operations fail, making it easier to debug and handle exceptions.
3. Mint Function Implementation
The mint function is used to create new tokens and assign them to a specific address. Let's break down its implementation:
3.1 Function Signature
public entry fun mint_to(
    admin: &signer,    // The administrator's signer reference
    recipient: address, // The address to receive the minted tokens
    amount: u64        // The amount of tokens to mint
) acquires MovementManagement
This function signature indicates that only an admin can call this function, and it requires access to the MovementManagement resource.
3.2 Detailed Implementation
public entry fun mint_to(
    admin: &signer,
    recipient: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_MINT_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Mint tokens
    primary_fungible_store::mint(&management.mint_ref, recipient, amount);
    // 4. Emit event
    event::emit(MintEvent {
        amount,
        recipient,
    });
}
Flow Analysis:
Validation
The function first checks if the amount to be minted is greater than zero. This prevents minting of zero tokens, which would be pointless and potentially confusing.
The authorization check is implicit through the use of mint_ref, ensuring only authorized users can mint tokens.
Management Access
The function retrieves the MovementManagement struct, which contains references to perform token operations.
The mint_ref is accessed from this struct, providing the capability to mint tokens.
Mint Operation
The primary_fungible_store::mint function is called to actually create and assign the new tokens.
If the recipient doesn't have a token store, one is automatically created.
Event Emission
After successful minting, a MintEvent is emitted to record the transaction.
This event includes the amount minted and the recipient's address, allowing for easy tracking and auditing of minting operations.
4. Burn Function Implementation
The burn function is used to destroy existing tokens, effectively removing them from circulation. Here's a detailed look at its implementation:
4.1 Function Signature
public entry fun burn_from(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address from which to burn tokens
    amount: u64      // The amount of tokens to burn
) acquires MovementManagement
Similar to the mint function, this function can only be called by an admin and requires access to the MovementManagement resource.
4.2 Detailed Implementation
public entry fun burn_from(
    admin: &signer,
    account: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_BURN_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Burn tokens
    primary_fungible_store::burn(&management.burn_ref, account, amount);
    // 4. Emit event
    event::emit(BurnEvent {
        amount,
        from: account,
    });
}
Flow Analysis:
Validation
The function checks if the amount to be burned is greater than zero, preventing attempts to burn zero tokens.
The balance check is implicitly performed in the burn operation, ensuring the account has sufficient tokens to burn.
Management Access
The burn_ref is retrieved from the MovementManagement struct, providing the capability to burn tokens.
This step also verifies that the caller has the necessary authorization to perform the burn operation.
Burn Operation
The primary_fungible_store::burn function is called to destroy the specified amount of tokens from the given account.
This operation reduces the total supply of tokens in circulation.
Event Emission
After successful burning, a BurnEvent is emitted to record the transaction.
This event includes the amount burned and the source account, allowing for easy tracking and auditing of burning operations.
5. Freeze Function Implementation
The freeze function is used to restrict or enable token transfers for specific accounts. This can be useful for various purposes such as implementing security measures or complying with regulations. Let's examine its implementation:
5.1 Function Signature
public entry fun set_frozen(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address to be frozen or unfrozen
    frozen: bool     // The new frozen status (true to freeze, false to unfreeze)
) acquires MovementManagement
As with the other management functions, this can only be called by an admin and requires access to the MovementManagement resource.
5.2 Detailed Implementation
public entry fun set_frozen(
    admin: &signer,
    account: address,
    frozen: bool
) acquires MovementManagement {
    // 1. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 2. Set frozen status
    primary_fungible_store::set_frozen_flag(
        &management.transfer_ref,
        account,
        frozen
    );
    // 3. Emit event
    event::emit(FreezeEvent {
        account,
        frozen,
    });
}
Flow Analysis:
Management Access
The function retrieves the transfer_ref from the MovementManagement struct, which provides the capability to modify account frozen status.
This step implicitly verifies that the caller has the necessary admin rights to perform the operation.
State Update
The primary_fungible_store::set_frozen_flag function is called to update the frozen status of the specified account.
If frozen is set to true, the account will be unable to transfer tokens. If false, transfers will be allowed.
Event Emission
After successfully updating the frozen status, a FreezeEvent is emitted to record the change.
This event includes the affected account address and the new frozen status, allowing for easy tracking of account restrictions.
6. Usage Examples
To better understand how these management functions work in practice, let's look at some usage examples:
6.1 Minting Tokens
// Mint 1000 tokens to user
public entry fun mint_example(admin: &signer) acquires MovementManagement {
    mint_to(admin, @user, 1000);
}
In this example, we're minting 1000 tokens and assigning them to the @user address. The admin signer is required to authorize this operation.
6.2 Burning Tokens
// Burn 500 tokens from user
public entry fun burn_example(admin: &signer) acquires MovementManagement {
    burn_from(admin, @user, 500);
}
This example demonstrates burning 500 tokens from the @user address. Again, the admin signer is needed to perform this operation.
6.3 Freezing Account
// Freeze user account
public entry fun freeze_example(admin: &signer) acquires MovementManagement {
    set_frozen(admin, @user, true);
}
In this example, we're freezing the @user account, preventing it from making token transfers. The admin signer authorizes this action.
These examples demonstrate how to use the management functions in your smart contract. Remember to always handle these functions with care, as they have significant impacts on token circulation and user access.
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}
	1. Overview
	1. Overview
	Management Functions are special functions used to manage tokens in the Fungible Asset Framework. These functions are crucial for controlling the token supply and user access. Let's explore the main management functions:
	Management Functions are special functions used to manage tokens in the Fungible Asset Framework. These functions are crucial for controlling the token supply and user access. Let's explore the main management functions:
	Minting (creating new) tokens: This function allows authorized users to create and distribute new tokens.
Burning (destroying) tokens: This function removes tokens from circulation, which can be useful for managing token supply or implementing certain economic models.
Managing the frozen status of accounts: This function allows administrators to restrict token transfers for specific accounts, which can be useful for security or compliance purposes.
	Minting (creating new) tokens: This function allows authorized users to create and distribute new tokens.
	Minting (creating new) tokens: This function allows authorized users to create and distribute new tokens.
	Burning (destroying) tokens: This function removes tokens from circulation, which can be useful for managing token supply or implementing certain economic models.
	Burning (destroying) tokens: This function removes tokens from circulation, which can be useful for managing token supply or implementing certain economic models.
	Managing the frozen status of accounts: This function allows administrators to restrict token transfers for specific accounts, which can be useful for security or compliance purposes.
	Managing the frozen status of accounts: This function allows administrators to restrict token transfers for specific accounts, which can be useful for security or compliance purposes.
	2. Events and Error Codes
	2. Events and Error Codes
	Events and error codes are essential for tracking operations and handling exceptions in your smart contract. Let's break them down:
	Events and error codes are essential for tracking operations and handling exceptions in your smart contract. Let's break them down:
		2.1 Event Structures
		2.1 Event Structures
		Events are emitted when certain actions occur, allowing off-chain systems to track and react to on-chain activities. Here are the main event structures:
		Events are emitted when certain actions occur, allowing off-chain systems to track and react to on-chain activities. Here are the main event structures:
		<code>// Event emitted when new tokens are minted
struct MintEvent has drop, store {
    amount: u64,      // Amount of tokens minted
    recipient: address, // Address receiving the minted tokens
}
// Event emitted when tokens are burned
struct BurnEvent has drop, store {
    amount: u64,  // Amount of tokens burned
    from: address, // Address from which tokens were burned
}
// Event emitted when an account's frozen status changes
struct FreezeEvent has drop, store {
    account: address, // Address of the affected account
    frozen: bool,     // New frozen status (true if frozen, false if unfrozen)
}</code>
		<code>// Event emitted when new tokens are minted
struct MintEvent has drop, store {
    amount: u64,      // Amount of tokens minted
    recipient: address, // Address receiving the minted tokens
}
// Event emitted when tokens are burned
struct BurnEvent has drop, store {
    amount: u64,  // Amount of tokens burned
    from: address, // Address from which tokens were burned
}
// Event emitted when an account's frozen status changes
struct FreezeEvent has drop, store {
    account: address, // Address of the affected account
    frozen: bool,     // New frozen status (true if frozen, false if unfrozen)
}</code>
		// Event emitted when new tokens are minted
struct MintEvent has drop, store {
    amount: u64,      // Amount of tokens minted
    recipient: address, // Address receiving the minted tokens
}
// Event emitted when tokens are burned
struct BurnEvent has drop, store {
    amount: u64,  // Amount of tokens burned
    from: address, // Address from which tokens were burned
}
// Event emitted when an account's frozen status changes
struct FreezeEvent has drop, store {
    account: address, // Address of the affected account
    frozen: bool,     // New frozen status (true if frozen, false if unfrozen)
}
		These events help in tracking token minting, burning, and account freezing operations.
		These events help in tracking token minting, burning, and account freezing operations.
		2.2 Error Constants
		2.2 Error Constants
		Error constants are used to provide meaningful error messages when operations fail. Here are the main error constants:
		Error constants are used to provide meaningful error messages when operations fail. Here are the main error constants:
		<code>const EZERO_MINT_AMOUNT: u64 = 1;  // Error when trying to mint zero tokens
const EZERO_BURN_AMOUNT: u64 = 2;  // Error when trying to burn zero tokens
const ENOT_AUTHORIZED: u64 = 3;    // Error when an unauthorized user attempts a restricted operation</code>
		<code>const EZERO_MINT_AMOUNT: u64 = 1;  // Error when trying to mint zero tokens
const EZERO_BURN_AMOUNT: u64 = 2;  // Error when trying to burn zero tokens
const ENOT_AUTHORIZED: u64 = 3;    // Error when an unauthorized user attempts a restricted operation</code>
		const EZERO_MINT_AMOUNT: u64 = 1;  // Error when trying to mint zero tokens
const EZERO_BURN_AMOUNT: u64 = 2;  // Error when trying to burn zero tokens
const ENOT_AUTHORIZED: u64 = 3;    // Error when an unauthorized user attempts a restricted operation
		Using these error constants helps in providing clear feedback when operations fail, making it easier to debug and handle exceptions.
		Using these error constants helps in providing clear feedback when operations fail, making it easier to debug and handle exceptions.
	3. Mint Function Implementation
	3. Mint Function Implementation
	The mint function is used to create new tokens and assign them to a specific address. Let's break down its implementation:
	The mint function is used to create new tokens and assign them to a specific address. Let's break down its implementation:
		3.1 Function Signature
		3.1 Function Signature
		<code>public entry fun mint_to(
    admin: &signer,    // The administrator's signer reference
    recipient: address, // The address to receive the minted tokens
    amount: u64        // The amount of tokens to mint
) acquires MovementManagement</code>
		<code>public entry fun mint_to(
    admin: &signer,    // The administrator's signer reference
    recipient: address, // The address to receive the minted tokens
    amount: u64        // The amount of tokens to mint
) acquires MovementManagement</code>
		public entry fun mint_to(
    admin: &signer,    // The administrator's signer reference
    recipient: address, // The address to receive the minted tokens
    amount: u64        // The amount of tokens to mint
) acquires MovementManagement
		This function signature indicates that only an admin can call this function, and it requires access to the MovementManagement resource.
		This function signature indicates that only an admin can call this function, and it requires access to the MovementManagement resource.
		3.2 Detailed Implementation
		3.2 Detailed Implementation
		<code>public entry fun mint_to(
    admin: &signer,
    recipient: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_MINT_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Mint tokens
    primary_fungible_store::mint(&management.mint_ref, recipient, amount);
    // 4. Emit event
    event::emit(MintEvent {
        amount,
        recipient,
    });
}</code>
		<code>public entry fun mint_to(
    admin: &signer,
    recipient: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_MINT_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Mint tokens
    primary_fungible_store::mint(&management.mint_ref, recipient, amount);
    // 4. Emit event
    event::emit(MintEvent {
        amount,
        recipient,
    });
}</code>
		public entry fun mint_to(
    admin: &signer,
    recipient: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_MINT_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Mint tokens
    primary_fungible_store::mint(&management.mint_ref, recipient, amount);
    // 4. Emit event
    event::emit(MintEvent {
        amount,
        recipient,
    });
}
		Flow Analysis:
		Flow Analysis:
		Flow Analysis:
		Validation
The function first checks if the amount to be minted is greater than zero. This prevents minting of zero tokens, which would be pointless and potentially confusing.
The authorization check is implicit through the use of mint_ref, ensuring only authorized users can mint tokens.
Management Access
The function retrieves the MovementManagement struct, which contains references to perform token operations.
The mint_ref is accessed from this struct, providing the capability to mint tokens.
Mint Operation
The primary_fungible_store::mint function is called to actually create and assign the new tokens.
If the recipient doesn't have a token store, one is automatically created.
Event Emission
After successful minting, a MintEvent is emitted to record the transaction.
This event includes the amount minted and the recipient's address, allowing for easy tracking and auditing of minting operations.
		Validation
The function first checks if the amount to be minted is greater than zero. This prevents minting of zero tokens, which would be pointless and potentially confusing.
The authorization check is implicit through the use of mint_ref, ensuring only authorized users can mint tokens.
		Validation
		Validation
		The function first checks if the amount to be minted is greater than zero. This prevents minting of zero tokens, which would be pointless and potentially confusing.
The authorization check is implicit through the use of mint_ref, ensuring only authorized users can mint tokens.
		The function first checks if the amount to be minted is greater than zero. This prevents minting of zero tokens, which would be pointless and potentially confusing.
		The function first checks if the amount to be minted is greater than zero. This prevents minting of zero tokens, which would be pointless and potentially confusing.
		The authorization check is implicit through the use of mint_ref, ensuring only authorized users can mint tokens.
		The authorization check is implicit through the use of mint_ref, ensuring only authorized users can mint tokens.
		Management Access
The function retrieves the MovementManagement struct, which contains references to perform token operations.
The mint_ref is accessed from this struct, providing the capability to mint tokens.
		Management Access
		Management Access
		The function retrieves the MovementManagement struct, which contains references to perform token operations.
The mint_ref is accessed from this struct, providing the capability to mint tokens.
		The function retrieves the MovementManagement struct, which contains references to perform token operations.
		The function retrieves the MovementManagement struct, which contains references to perform token operations.
		The mint_ref is accessed from this struct, providing the capability to mint tokens.
		The mint_ref is accessed from this struct, providing the capability to mint tokens.
		Mint Operation
The primary_fungible_store::mint function is called to actually create and assign the new tokens.
If the recipient doesn't have a token store, one is automatically created.
		Mint Operation
		Mint Operation
		The primary_fungible_store::mint function is called to actually create and assign the new tokens.
If the recipient doesn't have a token store, one is automatically created.
		The primary_fungible_store::mint function is called to actually create and assign the new tokens.
		The primary_fungible_store::mint function is called to actually create and assign the new tokens.
		If the recipient doesn't have a token store, one is automatically created.
		If the recipient doesn't have a token store, one is automatically created.
		Event Emission
After successful minting, a MintEvent is emitted to record the transaction.
This event includes the amount minted and the recipient's address, allowing for easy tracking and auditing of minting operations.
		Event Emission
		Event Emission
		After successful minting, a MintEvent is emitted to record the transaction.
This event includes the amount minted and the recipient's address, allowing for easy tracking and auditing of minting operations.
		After successful minting, a MintEvent is emitted to record the transaction.
		After successful minting, a MintEvent is emitted to record the transaction.
		This event includes the amount minted and the recipient's address, allowing for easy tracking and auditing of minting operations.
		This event includes the amount minted and the recipient's address, allowing for easy tracking and auditing of minting operations.
	4. Burn Function Implementation
	4. Burn Function Implementation
	The burn function is used to destroy existing tokens, effectively removing them from circulation. Here's a detailed look at its implementation:
	The burn function is used to destroy existing tokens, effectively removing them from circulation. Here's a detailed look at its implementation:
		4.1 Function Signature
		4.1 Function Signature
		<code>public entry fun burn_from(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address from which to burn tokens
    amount: u64      // The amount of tokens to burn
) acquires MovementManagement</code>
		<code>public entry fun burn_from(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address from which to burn tokens
    amount: u64      // The amount of tokens to burn
) acquires MovementManagement</code>
		public entry fun burn_from(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address from which to burn tokens
    amount: u64      // The amount of tokens to burn
) acquires MovementManagement
		Similar to the mint function, this function can only be called by an admin and requires access to the MovementManagement resource.
		Similar to the mint function, this function can only be called by an admin and requires access to the MovementManagement resource.
		4.2 Detailed Implementation
		4.2 Detailed Implementation
		<code>public entry fun burn_from(
    admin: &signer,
    account: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_BURN_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Burn tokens
    primary_fungible_store::burn(&management.burn_ref, account, amount);
    // 4. Emit event
    event::emit(BurnEvent {
        amount,
        from: account,
    });
}</code>
		<code>public entry fun burn_from(
    admin: &signer,
    account: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_BURN_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Burn tokens
    primary_fungible_store::burn(&management.burn_ref, account, amount);
    // 4. Emit event
    event::emit(BurnEvent {
        amount,
        from: account,
    });
}</code>
		public entry fun burn_from(
    admin: &signer,
    account: address,
    amount: u64
) acquires MovementManagement {
    // 1. Validate amount
    assert!(amount > 0, EZERO_BURN_AMOUNT);
    // 2. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 3. Burn tokens
    primary_fungible_store::burn(&management.burn_ref, account, amount);
    // 4. Emit event
    event::emit(BurnEvent {
        amount,
        from: account,
    });
}
		Flow Analysis:
		Flow Analysis:
		Flow Analysis:
		Validation
The function checks if the amount to be burned is greater than zero, preventing attempts to burn zero tokens.
The balance check is implicitly performed in the burn operation, ensuring the account has sufficient tokens to burn.
Management Access
The burn_ref is retrieved from the MovementManagement struct, providing the capability to burn tokens.
This step also verifies that the caller has the necessary authorization to perform the burn operation.
Burn Operation
The primary_fungible_store::burn function is called to destroy the specified amount of tokens from the given account.
This operation reduces the total supply of tokens in circulation.
Event Emission
After successful burning, a BurnEvent is emitted to record the transaction.
This event includes the amount burned and the source account, allowing for easy tracking and auditing of burning operations.
		Validation
The function checks if the amount to be burned is greater than zero, preventing attempts to burn zero tokens.
The balance check is implicitly performed in the burn operation, ensuring the account has sufficient tokens to burn.
		Validation
		Validation
		The function checks if the amount to be burned is greater than zero, preventing attempts to burn zero tokens.
The balance check is implicitly performed in the burn operation, ensuring the account has sufficient tokens to burn.
		The function checks if the amount to be burned is greater than zero, preventing attempts to burn zero tokens.
		The function checks if the amount to be burned is greater than zero, preventing attempts to burn zero tokens.
		The balance check is implicitly performed in the burn operation, ensuring the account has sufficient tokens to burn.
		The balance check is implicitly performed in the burn operation, ensuring the account has sufficient tokens to burn.
		Management Access
The burn_ref is retrieved from the MovementManagement struct, providing the capability to burn tokens.
This step also verifies that the caller has the necessary authorization to perform the burn operation.
		Management Access
		Management Access
		The burn_ref is retrieved from the MovementManagement struct, providing the capability to burn tokens.
This step also verifies that the caller has the necessary authorization to perform the burn operation.
		The burn_ref is retrieved from the MovementManagement struct, providing the capability to burn tokens.
		The burn_ref is retrieved from the MovementManagement struct, providing the capability to burn tokens.
		This step also verifies that the caller has the necessary authorization to perform the burn operation.
		This step also verifies that the caller has the necessary authorization to perform the burn operation.
		Burn Operation
The primary_fungible_store::burn function is called to destroy the specified amount of tokens from the given account.
This operation reduces the total supply of tokens in circulation.
		Burn Operation
		Burn Operation
		The primary_fungible_store::burn function is called to destroy the specified amount of tokens from the given account.
This operation reduces the total supply of tokens in circulation.
		The primary_fungible_store::burn function is called to destroy the specified amount of tokens from the given account.
		The primary_fungible_store::burn function is called to destroy the specified amount of tokens from the given account.
		This operation reduces the total supply of tokens in circulation.
		This operation reduces the total supply of tokens in circulation.
		Event Emission
After successful burning, a BurnEvent is emitted to record the transaction.
This event includes the amount burned and the source account, allowing for easy tracking and auditing of burning operations.
		Event Emission
		Event Emission
		After successful burning, a BurnEvent is emitted to record the transaction.
This event includes the amount burned and the source account, allowing for easy tracking and auditing of burning operations.
		After successful burning, a BurnEvent is emitted to record the transaction.
		After successful burning, a BurnEvent is emitted to record the transaction.
		This event includes the amount burned and the source account, allowing for easy tracking and auditing of burning operations.
		This event includes the amount burned and the source account, allowing for easy tracking and auditing of burning operations.
	5. Freeze Function Implementation
	5. Freeze Function Implementation
	The freeze function is used to restrict or enable token transfers for specific accounts. This can be useful for various purposes such as implementing security measures or complying with regulations. Let's examine its implementation:
	The freeze function is used to restrict or enable token transfers for specific accounts. This can be useful for various purposes such as implementing security measures or complying with regulations. Let's examine its implementation:
		5.1 Function Signature
		5.1 Function Signature
		<code>public entry fun set_frozen(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address to be frozen or unfrozen
    frozen: bool     // The new frozen status (true to freeze, false to unfreeze)
) acquires MovementManagement</code>
		<code>public entry fun set_frozen(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address to be frozen or unfrozen
    frozen: bool     // The new frozen status (true to freeze, false to unfreeze)
) acquires MovementManagement</code>
		public entry fun set_frozen(
    admin: &signer,  // The administrator's signer reference
    account: address, // The address to be frozen or unfrozen
    frozen: bool     // The new frozen status (true to freeze, false to unfreeze)
) acquires MovementManagement
		As with the other management functions, this can only be called by an admin and requires access to the MovementManagement resource.
		As with the other management functions, this can only be called by an admin and requires access to the MovementManagement resource.
		5.2 Detailed Implementation
		5.2 Detailed Implementation
		<code>public entry fun set_frozen(
    admin: &signer,
    account: address,
    frozen: bool
) acquires MovementManagement {
    // 1. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 2. Set frozen status
    primary_fungible_store::set_frozen_flag(
        &management.transfer_ref,
        account,
        frozen
    );
    // 3. Emit event
    event::emit(FreezeEvent {
        account,
        frozen,
    });
}</code>
		<code>public entry fun set_frozen(
    admin: &signer,
    account: address,
    frozen: bool
) acquires MovementManagement {
    // 1. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 2. Set frozen status
    primary_fungible_store::set_frozen_flag(
        &management.transfer_ref,
        account,
        frozen
    );
    // 3. Emit event
    event::emit(FreezeEvent {
        account,
        frozen,
    });
}</code>
		public entry fun set_frozen(
    admin: &signer,
    account: address,
    frozen: bool
) acquires MovementManagement {
    // 1. Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // 2. Set frozen status
    primary_fungible_store::set_frozen_flag(
        &management.transfer_ref,
        account,
        frozen
    );
    // 3. Emit event
    event::emit(FreezeEvent {
        account,
        frozen,
    });
}
		Flow Analysis:
		Flow Analysis:
		Flow Analysis:
		Management Access
The function retrieves the transfer_ref from the MovementManagement struct, which provides the capability to modify account frozen status.
This step implicitly verifies that the caller has the necessary admin rights to perform the operation.
State Update
The primary_fungible_store::set_frozen_flag function is called to update the frozen status of the specified account.
If frozen is set to true, the account will be unable to transfer tokens. If false, transfers will be allowed.
Event Emission
After successfully updating the frozen status, a FreezeEvent is emitted to record the change.
This event includes the affected account address and the new frozen status, allowing for easy tracking of account restrictions.
		Management Access
The function retrieves the transfer_ref from the MovementManagement struct, which provides the capability to modify account frozen status.
This step implicitly verifies that the caller has the necessary admin rights to perform the operation.
		Management Access
		Management Access
		The function retrieves the transfer_ref from the MovementManagement struct, which provides the capability to modify account frozen status.
This step implicitly verifies that the caller has the necessary admin rights to perform the operation.
		The function retrieves the transfer_ref from the MovementManagement struct, which provides the capability to modify account frozen status.
		The function retrieves the transfer_ref from the MovementManagement struct, which provides the capability to modify account frozen status.
		This step implicitly verifies that the caller has the necessary admin rights to perform the operation.
		This step implicitly verifies that the caller has the necessary admin rights to perform the operation.
		State Update
The primary_fungible_store::set_frozen_flag function is called to update the frozen status of the specified account.
If frozen is set to true, the account will be unable to transfer tokens. If false, transfers will be allowed.
		State Update
		State Update
		The primary_fungible_store::set_frozen_flag function is called to update the frozen status of the specified account.
If frozen is set to true, the account will be unable to transfer tokens. If false, transfers will be allowed.
		The primary_fungible_store::set_frozen_flag function is called to update the frozen status of the specified account.
		The primary_fungible_store::set_frozen_flag function is called to update the frozen status of the specified account.
		If frozen is set to true, the account will be unable to transfer tokens. If false, transfers will be allowed.
		If frozen is set to true, the account will be unable to transfer tokens. If false, transfers will be allowed.
		Event Emission
After successfully updating the frozen status, a FreezeEvent is emitted to record the change.
This event includes the affected account address and the new frozen status, allowing for easy tracking of account restrictions.
		Event Emission
		Event Emission
		After successfully updating the frozen status, a FreezeEvent is emitted to record the change.
This event includes the affected account address and the new frozen status, allowing for easy tracking of account restrictions.
		After successfully updating the frozen status, a FreezeEvent is emitted to record the change.
		After successfully updating the frozen status, a FreezeEvent is emitted to record the change.
		This event includes the affected account address and the new frozen status, allowing for easy tracking of account restrictions.
		This event includes the affected account address and the new frozen status, allowing for easy tracking of account restrictions.
	6. Usage Examples
	6. Usage Examples
	To better understand how these management functions work in practice, let's look at some usage examples:
	To better understand how these management functions work in practice, let's look at some usage examples:
		6.1 Minting Tokens
		6.1 Minting Tokens
		<code>// Mint 1000 tokens to user
public entry fun mint_example(admin: &signer) acquires MovementManagement {
    mint_to(admin, @user, 1000);
}</code>
		<code>// Mint 1000 tokens to user
public entry fun mint_example(admin: &signer) acquires MovementManagement {
    mint_to(admin, @user, 1000);
}</code>
		// Mint 1000 tokens to user
public entry fun mint_example(admin: &signer) acquires MovementManagement {
    mint_to(admin, @user, 1000);
}
		In this example, we're minting 1000 tokens and assigning them to the @user address. The admin signer is required to authorize this operation.
		In this example, we're minting 1000 tokens and assigning them to the @user address. The admin signer is required to authorize this operation.
		6.2 Burning Tokens
		6.2 Burning Tokens
		<code>// Burn 500 tokens from user
public entry fun burn_example(admin: &signer) acquires MovementManagement {
    burn_from(admin, @user, 500);
}</code>
		<code>// Burn 500 tokens from user
public entry fun burn_example(admin: &signer) acquires MovementManagement {
    burn_from(admin, @user, 500);
}</code>
		// Burn 500 tokens from user
public entry fun burn_example(admin: &signer) acquires MovementManagement {
    burn_from(admin, @user, 500);
}
		This example demonstrates burning 500 tokens from the @user address. Again, the admin signer is needed to perform this operation.
		This example demonstrates burning 500 tokens from the @user address. Again, the admin signer is needed to perform this operation.
		6.3 Freezing Account
		6.3 Freezing Account
		<code>// Freeze user account
public entry fun freeze_example(admin: &signer) acquires MovementManagement {
    set_frozen(admin, @user, true);
}</code>
		<code>// Freeze user account
public entry fun freeze_example(admin: &signer) acquires MovementManagement {
    set_frozen(admin, @user, true);
}</code>
		// Freeze user account
public entry fun freeze_example(admin: &signer) acquires MovementManagement {
    set_frozen(admin, @user, true);
}
		In this example, we're freezing the @user account, preventing it from making token transfers. The admin signer authorizes this action.
		In this example, we're freezing the @user account, preventing it from making token transfers. The admin signer authorizes this action.
		These examples demonstrate how to use the management functions in your smart contract. Remember to always handle these functions with care, as they have significant impacts on token circulation and user access.
		These examples demonstrate how to use the management functions in your smart contract. Remember to always handle these functions with care, as they have significant impacts on token circulation and user access.
Full Code
Full Code
<code>module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}</code>
<code>module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}</code>
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/01-fungible-asset/07-transfer-a-fungible-asset
Transfer a Fungible Asset
Transfer a Fungible Asset
On This Page
1. Overview of Transfer Functions in Fungible Asset Systems
1.1. Purpose and Importance of User Functions
1.2. Types of Transfer Functions
2. Events and Error Handling
2.1. Event Structure
2.2. Error Constants
3. Regular Transfer Implementation
3.1. Function Signature
3.2. Detailed Implementation
3.3. Flow Analysis
3.3.1. Validation Steps
3.3.2. Transfer Process
3.3.3. Error Handling
4. Force Transfer Implementation
4.1. Function Signature
4.2. Detailed Implementation
Regular Transfer Example
Force Transfer Example
Full Code
1. Overview of Transfer Functions in Fungible Asset Systems
1.1. Purpose and Importance of User Functions
User Functions play a crucial role in fungible asset systems, providing essential capabilities for end users to interact with their tokens. These functions are designed with user-friendliness and security in mind, enabling individuals to:
Perform token transfers: Move assets between accounts safely and efficiently
Manage their tokens: Check balances, view transaction history, and handle asset-related tasks
Interact with the token system: Engage in various token-related activities within the ecosystem
By offering these functionalities, User Functions empower users to have full control over their digital assets while maintaining the integrity and security of the overall system.
1.2. Types of Transfer Functions
Transfer functions are a critical component of User Functions, allowing for the movement of tokens between accounts. There are two primary types of transfer functions, each serving different purposes and use cases:
Regular Transfer
Definition: A standard token transfer initiated by the token owner
Key characteristics:
Sender must be the rightful owner of the tokens
Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
Requires sufficient balance in the sender's account
Use cases:
Peer-to-peer transactions
Payments for goods or services
Moving tokens between personal accounts
Force Transfer
Definition: A mandatory token transfer executed by an administrator
Key characteristics:
Admin-only privilege, restricted to authorized system administrators
Bypasses frozen status, allowing transfers involving frozen accounts
Can be executed without the token owner's consent
Use cases:
Regulatory compliance and legal orders
Error correction and dispute resolution
System maintenance and upgrades
Important considerations:
Should be used sparingly and only when absolutely necessary
Requires robust governance and oversight to prevent misuse
May have implications for user trust and system decentralization
2. Events and Error Handling
In Move programming, events and error handling are crucial for creating robust and user-friendly smart contracts. Let's dive into these concepts with some practical examples.
2.1. Event Structure
Events in Move are used to emit important information about state changes. Here's an example of a TransferEvent structure:
// This event is emitted when a transfer occurs
struct TransferEvent has drop, store {
    amount: u64,   // The amount of tokens transferred
    from: address, // The address sending the tokens
    to: address,   // The address receiving the tokens
}
// Usage example:
event::emit(TransferEvent {
    amount: 100,
    from: @0x1234,
    to: @0x5678,
});
In this example, we define a TransferEvent that captures the essential information of a token transfer. The 'drop' and 'store' abilities allow this struct to be discarded and stored in global storage, respectively.
2.2. Error Constants
Error constants help in providing clear and consistent error messages. Here's an expanded set of error constants:
// Error constants for better error handling
const EINSUFFICIENT_BALANCE: u64 = 1;
const EZERO_AMOUNT: u64 = 2;
const EFROZEN_ACCOUNT: u64 = 3;
const EINVALID_RECIPIENT: u64 = 4;
const EUNAUTHORIZED: u64 = 5;
// Usage example:
assert!(balance >= amount, EINSUFFICIENT_BALANCE);
These constants make your code more readable and maintainable. When an error occurs, you can easily identify the issue based on the error code.
3. Regular Transfer Implementation
Now, let's implement a regular transfer function with detailed explanations and error handling.
3.1. Function Signature
public entry fun transfer(
    from: &signer,  // The account initiating the transfer
    to: address,    // The recipient's address
    amount: u64     // The amount to transfer
)
This function signature defines a public entry function that can be called directly from outside the module.
3.2. Detailed Implementation
public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // 1. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 2. Check if the recipient address is valid
    assert!(to != @0x0, EINVALID_RECIPIENT);
    // 3. Get the sender's address
    let sender = signer::address_of(from);
    // 4. Check if the sender has sufficient balance
    assert!(balance::get(sender) >= amount, EINSUFFICIENT_BALANCE);
    // 5. Check if either account is frozen
    assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    // 6. Perform transfer
    primary_fungible_store::transfer(
        from,
        get_metadata(),
        to,
        amount
    );
    // 7. Emit transfer event
    event::emit(TransferEvent {
        amount,
        from: sender,
        to,
    });
}
This implementation includes several important steps:
We validate that the amount is not zero.
We ensure the recipient address is valid.
We get the sender's address from the signer.
We check if the sender has sufficient balance.
We verify that neither account is frozen.
We perform the actual transfer using the primary_fungible_store module.
Finally, we emit a TransferEvent to log the transfer.
Each step includes error handling to ensure the transfer meets all requirements before execution.
3.3. Flow Analysis
Let's break down the transfer function to understand its flow and key components. This analysis will help newcomers grasp the intricacies of implementing a secure token transfer system.
3.3.1. Validation Steps
Before executing the transfer, we perform several crucial checks:
// Amount validation
assert!(amount > 0, EZERO_AMOUNT);
// Sender's balance check
let sender_balance = balance::get(sender);
assert!(sender_balance >= amount, EINSUFFICIENT_BALANCE);
// Frozen status check
assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
// Recipient address validation
assert!(to != @0x0, EINVALID_RECIPIENT);
Let's examine each validation step:
Amount Validation: We ensure the transfer amount is greater than zero to prevent meaningless transactions.
Balance Check: We verify that the sender has sufficient funds for the transfer.
Frozen Status: We check if either the sender's or recipient's account is frozen, preventing transfers involving frozen accounts.
Recipient Validation: We confirm that the recipient's address is valid and not the zero address.
These checks help maintain the integrity and security of the transfer process.
3.3.2. Transfer Process
Once all validations pass, we proceed with the actual transfer:
// Transfer using primary store
primary_fungible_store::transfer(from, get_metadata(), to, amount);
This function call encapsulates several important steps:
Store Creation: If the recipient doesn't have a store for this token, one is automatically created.
Withdrawal: The specified amount is withdrawn from the sender's account.
Deposit: The withdrawn amount is deposited into the recipient's account.
Error Handling: Any issues during these steps (e.g., insufficient balance) are automatically handled.
After the transfer, we emit an event to log the transaction:
// Emit transfer event
event::emit(TransferEvent {
    amount,
    from: sender,
    to,
});
This event emission is crucial for maintaining a transparent record of all transfers, which can be used for auditing or providing transaction history to users.
3.3.3. Error Handling
Throughout the process, we use assert! statements for error handling. When an assertion fails, it aborts the transaction with a specific error code. For example:
assert!(amount > 0, EZERO_AMOUNT);
If amount is zero or negative, the transaction will abort with the EZERO_AMOUNT error. This approach ensures that invalid operations are caught early and prevented from executing.
4. Force Transfer Implementation
Force transfer is a powerful feature that allows authorized administrators to move tokens between accounts without the sender's consent. This functionality is crucial for certain scenarios but should be used with caution.
4.1. Function Signature
Let's break down the function signature for force transfer:
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement
Here's what each parameter means:
admin: &signer - The administrator initiating the force transfer
from: address - The address from which tokens will be taken
to: address - The address receiving the tokens
amount: u64 - The number of tokens to transfer
The 'acquires MovementManagement' clause indicates that this function will access the MovementManagement resource.
4.2. Detailed Implementation
Now, let's examine the implementation step-by-step:
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // 1. Verify admin rights
    assert!(is_admin(signer::address_of(admin)), EUNAUTHORIZED);
    // 2. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 3. Get management struct
    let management = borrow_global&lt;MovementManagement&gt;(
        object::object_address(&get_metadata())
    );
    // 4. Check if either account is frozen (optional for force transfer)
    if (!is_force_transfer_allowed_when_frozen()) {
        assert!(!is_account_frozen(from) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    }
    // 5. Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // 6. Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
    // 7. Log force transfer for auditing
    log_force_transfer(admin, from, to, amount);
}
Let's break down each step:
Verify admin rights: We first check if the signer is an authorized admin.
Amount validation: Ensure the transfer amount is greater than zero.
Get management struct: Retrieve the MovementManagement resource, which contains necessary references for the transfer.
Frozen account check: Optionally check if accounts are frozen, based on system configuration.
Perform force transfer: Use the transfer_with_ref function to move tokens without the sender's signature.
Emit event: Log the transfer event for transparency.
Audit logging: Record the force transfer details for future auditing.
This implementation ensures that only authorized admins can perform force transfers, maintains proper event logging, and includes optional checks for frozen accounts. The use of transfer_with_ref allows bypassing normal transfer restrictions.
Regular Transfer Example
public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // Verify amount
    assert!(amount > 0, EINSUFFICIENT_BALANCE);
    // Perform transfer
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
Force Transfer Example
/// Force transfer (admin only)
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
}
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct TransferEvent has drop, store {
        amount: u64,
        from: address,
        to: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== User Functions ===================
    /// Transfer tokens from sender to recipient
    public entry fun transfer(
        from: &signer,
        to: address,
        amount: u64
    ) {
        // Verify amount
        assert!(amount > 0, EINSUFFICIENT_BALANCE);
        // Perform transfer
        primary_fungible_store::transfer(from, get_metadata(), to, amount);
    }
    /// Force transfer (admin only)
    public entry fun force_transfer(
        admin: &signer,
        from: address,
        to: address,
        amount: u64
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Perform force transfer
        primary_fungible_store::transfer_with_ref(
            &management.transfer_ref,
            from,
            to,
            amount
        );
        // Emit event
        event::emit(TransferEvent {
            amount,
            from,
            to,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}
On This Page
1. Overview of Transfer Functions in Fungible Asset Systems
1.1. Purpose and Importance of User Functions
1.2. Types of Transfer Functions
2. Events and Error Handling
2.1. Event Structure
2.2. Error Constants
3. Regular Transfer Implementation
3.1. Function Signature
3.2. Detailed Implementation
3.3. Flow Analysis
3.3.1. Validation Steps
3.3.2. Transfer Process
3.3.3. Error Handling
4. Force Transfer Implementation
4.1. Function Signature
4.2. Detailed Implementation
Regular Transfer Example
Force Transfer Example
Full Code
On This Page
1. Overview of Transfer Functions in Fungible Asset Systems
1.1. Purpose and Importance of User Functions
1.2. Types of Transfer Functions
2. Events and Error Handling
2.1. Event Structure
2.2. Error Constants
3. Regular Transfer Implementation
3.1. Function Signature
3.2. Detailed Implementation
3.3. Flow Analysis
3.3.1. Validation Steps
3.3.2. Transfer Process
3.3.3. Error Handling
4. Force Transfer Implementation
4.1. Function Signature
4.2. Detailed Implementation
Regular Transfer Example
Force Transfer Example
Full Code
			On This Page
			On This Page
			1. Overview of Transfer Functions in Fungible Asset Systems
1.1. Purpose and Importance of User Functions
1.2. Types of Transfer Functions
2. Events and Error Handling
2.1. Event Structure
2.2. Error Constants
3. Regular Transfer Implementation
3.1. Function Signature
3.2. Detailed Implementation
3.3. Flow Analysis
3.3.1. Validation Steps
3.3.2. Transfer Process
3.3.3. Error Handling
4. Force Transfer Implementation
4.1. Function Signature
4.2. Detailed Implementation
Regular Transfer Example
Force Transfer Example
Full Code
			1. Overview of Transfer Functions in Fungible Asset Systems
1.1. Purpose and Importance of User Functions
1.2. Types of Transfer Functions
			1. Overview of Transfer Functions in Fungible Asset Systems
			1. Overview of Transfer Functions in Fungible Asset Systems
			1. Overview of Transfer Functions in Fungible Asset Systems
			1.1. Purpose and Importance of User Functions
1.2. Types of Transfer Functions
			1.1. Purpose and Importance of User Functions
			1.1. Purpose and Importance of User Functions
			1.1. Purpose and Importance of User Functions
			1.1. Purpose and Importance of User Functions
			1.2. Types of Transfer Functions
			1.2. Types of Transfer Functions
			1.2. Types of Transfer Functions
			1.2. Types of Transfer Functions
			2. Events and Error Handling
2.1. Event Structure
2.2. Error Constants
			2. Events and Error Handling
			2. Events and Error Handling
			2. Events and Error Handling
			2.1. Event Structure
2.2. Error Constants
			2.1. Event Structure
			2.1. Event Structure
			2.1. Event Structure
			2.1. Event Structure
			2.2. Error Constants
			2.2. Error Constants
			2.2. Error Constants
			2.2. Error Constants
			3. Regular Transfer Implementation
3.1. Function Signature
3.2. Detailed Implementation
3.3. Flow Analysis
3.3.1. Validation Steps
3.3.2. Transfer Process
3.3.3. Error Handling
			3. Regular Transfer Implementation
			3. Regular Transfer Implementation
			3. Regular Transfer Implementation
			3.1. Function Signature
3.2. Detailed Implementation
3.3. Flow Analysis
3.3.1. Validation Steps
3.3.2. Transfer Process
3.3.3. Error Handling
			3.1. Function Signature
			3.1. Function Signature
			3.1. Function Signature
			3.1. Function Signature
			3.2. Detailed Implementation
			3.2. Detailed Implementation
			3.2. Detailed Implementation
			3.2. Detailed Implementation
			3.3. Flow Analysis
			3.3. Flow Analysis
			3.3. Flow Analysis
			3.3. Flow Analysis
			3.3.1. Validation Steps
			3.3.1. Validation Steps
			3.3.1. Validation Steps
			3.3.1. Validation Steps
			3.3.2. Transfer Process
			3.3.2. Transfer Process
			3.3.2. Transfer Process
			3.3.2. Transfer Process
			3.3.3. Error Handling
			3.3.3. Error Handling
			3.3.3. Error Handling
			3.3.3. Error Handling
			4. Force Transfer Implementation
4.1. Function Signature
4.2. Detailed Implementation
Regular Transfer Example
Force Transfer Example
			4. Force Transfer Implementation
			4. Force Transfer Implementation
			4. Force Transfer Implementation
			4.1. Function Signature
4.2. Detailed Implementation
Regular Transfer Example
Force Transfer Example
			4.1. Function Signature
			4.1. Function Signature
			4.1. Function Signature
			4.1. Function Signature
			4.2. Detailed Implementation
			4.2. Detailed Implementation
			4.2. Detailed Implementation
			4.2. Detailed Implementation
			Regular Transfer Example
			Regular Transfer Example
			Regular Transfer Example
			Regular Transfer Example
			Force Transfer Example
			Force Transfer Example
			Force Transfer Example
			Force Transfer Example
			Full Code
			Full Code
			Full Code
			Full Code
			1. Overview of Transfer Functions in Fungible Asset Systems
1.1. Purpose and Importance of User Functions
User Functions play a crucial role in fungible asset systems, providing essential capabilities for end users to interact with their tokens. These functions are designed with user-friendliness and security in mind, enabling individuals to:
Perform token transfers: Move assets between accounts safely and efficiently
Manage their tokens: Check balances, view transaction history, and handle asset-related tasks
Interact with the token system: Engage in various token-related activities within the ecosystem
By offering these functionalities, User Functions empower users to have full control over their digital assets while maintaining the integrity and security of the overall system.
1.2. Types of Transfer Functions
Transfer functions are a critical component of User Functions, allowing for the movement of tokens between accounts. There are two primary types of transfer functions, each serving different purposes and use cases:
Regular Transfer
Definition: A standard token transfer initiated by the token owner
Key characteristics:
Sender must be the rightful owner of the tokens
Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
Requires sufficient balance in the sender's account
Use cases:
Peer-to-peer transactions
Payments for goods or services
Moving tokens between personal accounts
Force Transfer
Definition: A mandatory token transfer executed by an administrator
Key characteristics:
Admin-only privilege, restricted to authorized system administrators
Bypasses frozen status, allowing transfers involving frozen accounts
Can be executed without the token owner's consent
Use cases:
Regulatory compliance and legal orders
Error correction and dispute resolution
System maintenance and upgrades
Important considerations:
Should be used sparingly and only when absolutely necessary
Requires robust governance and oversight to prevent misuse
May have implications for user trust and system decentralization
2. Events and Error Handling
In Move programming, events and error handling are crucial for creating robust and user-friendly smart contracts. Let's dive into these concepts with some practical examples.
2.1. Event Structure
Events in Move are used to emit important information about state changes. Here's an example of a TransferEvent structure:
// This event is emitted when a transfer occurs
struct TransferEvent has drop, store {
    amount: u64,   // The amount of tokens transferred
    from: address, // The address sending the tokens
    to: address,   // The address receiving the tokens
}
// Usage example:
event::emit(TransferEvent {
    amount: 100,
    from: @0x1234,
    to: @0x5678,
});
In this example, we define a TransferEvent that captures the essential information of a token transfer. The 'drop' and 'store' abilities allow this struct to be discarded and stored in global storage, respectively.
2.2. Error Constants
Error constants help in providing clear and consistent error messages. Here's an expanded set of error constants:
// Error constants for better error handling
const EINSUFFICIENT_BALANCE: u64 = 1;
const EZERO_AMOUNT: u64 = 2;
const EFROZEN_ACCOUNT: u64 = 3;
const EINVALID_RECIPIENT: u64 = 4;
const EUNAUTHORIZED: u64 = 5;
// Usage example:
assert!(balance >= amount, EINSUFFICIENT_BALANCE);
These constants make your code more readable and maintainable. When an error occurs, you can easily identify the issue based on the error code.
3. Regular Transfer Implementation
Now, let's implement a regular transfer function with detailed explanations and error handling.
3.1. Function Signature
public entry fun transfer(
    from: &signer,  // The account initiating the transfer
    to: address,    // The recipient's address
    amount: u64     // The amount to transfer
)
This function signature defines a public entry function that can be called directly from outside the module.
3.2. Detailed Implementation
public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // 1. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 2. Check if the recipient address is valid
    assert!(to != @0x0, EINVALID_RECIPIENT);
    // 3. Get the sender's address
    let sender = signer::address_of(from);
    // 4. Check if the sender has sufficient balance
    assert!(balance::get(sender) >= amount, EINSUFFICIENT_BALANCE);
    // 5. Check if either account is frozen
    assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    // 6. Perform transfer
    primary_fungible_store::transfer(
        from,
        get_metadata(),
        to,
        amount
    );
    // 7. Emit transfer event
    event::emit(TransferEvent {
        amount,
        from: sender,
        to,
    });
}
This implementation includes several important steps:
We validate that the amount is not zero.
We ensure the recipient address is valid.
We get the sender's address from the signer.
We check if the sender has sufficient balance.
We verify that neither account is frozen.
We perform the actual transfer using the primary_fungible_store module.
Finally, we emit a TransferEvent to log the transfer.
Each step includes error handling to ensure the transfer meets all requirements before execution.
3.3. Flow Analysis
Let's break down the transfer function to understand its flow and key components. This analysis will help newcomers grasp the intricacies of implementing a secure token transfer system.
3.3.1. Validation Steps
Before executing the transfer, we perform several crucial checks:
// Amount validation
assert!(amount > 0, EZERO_AMOUNT);
// Sender's balance check
let sender_balance = balance::get(sender);
assert!(sender_balance >= amount, EINSUFFICIENT_BALANCE);
// Frozen status check
assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
// Recipient address validation
assert!(to != @0x0, EINVALID_RECIPIENT);
Let's examine each validation step:
Amount Validation: We ensure the transfer amount is greater than zero to prevent meaningless transactions.
Balance Check: We verify that the sender has sufficient funds for the transfer.
Frozen Status: We check if either the sender's or recipient's account is frozen, preventing transfers involving frozen accounts.
Recipient Validation: We confirm that the recipient's address is valid and not the zero address.
These checks help maintain the integrity and security of the transfer process.
3.3.2. Transfer Process
Once all validations pass, we proceed with the actual transfer:
// Transfer using primary store
primary_fungible_store::transfer(from, get_metadata(), to, amount);
This function call encapsulates several important steps:
Store Creation: If the recipient doesn't have a store for this token, one is automatically created.
Withdrawal: The specified amount is withdrawn from the sender's account.
Deposit: The withdrawn amount is deposited into the recipient's account.
Error Handling: Any issues during these steps (e.g., insufficient balance) are automatically handled.
After the transfer, we emit an event to log the transaction:
// Emit transfer event
event::emit(TransferEvent {
    amount,
    from: sender,
    to,
});
This event emission is crucial for maintaining a transparent record of all transfers, which can be used for auditing or providing transaction history to users.
3.3.3. Error Handling
Throughout the process, we use assert! statements for error handling. When an assertion fails, it aborts the transaction with a specific error code. For example:
assert!(amount > 0, EZERO_AMOUNT);
If amount is zero or negative, the transaction will abort with the EZERO_AMOUNT error. This approach ensures that invalid operations are caught early and prevented from executing.
4. Force Transfer Implementation
Force transfer is a powerful feature that allows authorized administrators to move tokens between accounts without the sender's consent. This functionality is crucial for certain scenarios but should be used with caution.
4.1. Function Signature
Let's break down the function signature for force transfer:
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement
Here's what each parameter means:
admin: &signer - The administrator initiating the force transfer
from: address - The address from which tokens will be taken
to: address - The address receiving the tokens
amount: u64 - The number of tokens to transfer
The 'acquires MovementManagement' clause indicates that this function will access the MovementManagement resource.
4.2. Detailed Implementation
Now, let's examine the implementation step-by-step:
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // 1. Verify admin rights
    assert!(is_admin(signer::address_of(admin)), EUNAUTHORIZED);
    // 2. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 3. Get management struct
    let management = borrow_global&lt;MovementManagement&gt;(
        object::object_address(&get_metadata())
    );
    // 4. Check if either account is frozen (optional for force transfer)
    if (!is_force_transfer_allowed_when_frozen()) {
        assert!(!is_account_frozen(from) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    }
    // 5. Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // 6. Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
    // 7. Log force transfer for auditing
    log_force_transfer(admin, from, to, amount);
}
Let's break down each step:
Verify admin rights: We first check if the signer is an authorized admin.
Amount validation: Ensure the transfer amount is greater than zero.
Get management struct: Retrieve the MovementManagement resource, which contains necessary references for the transfer.
Frozen account check: Optionally check if accounts are frozen, based on system configuration.
Perform force transfer: Use the transfer_with_ref function to move tokens without the sender's signature.
Emit event: Log the transfer event for transparency.
Audit logging: Record the force transfer details for future auditing.
This implementation ensures that only authorized admins can perform force transfers, maintains proper event logging, and includes optional checks for frozen accounts. The use of transfer_with_ref allows bypassing normal transfer restrictions.
Regular Transfer Example
public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // Verify amount
    assert!(amount > 0, EINSUFFICIENT_BALANCE);
    // Perform transfer
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
Force Transfer Example
/// Force transfer (admin only)
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
}
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct TransferEvent has drop, store {
        amount: u64,
        from: address,
        to: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== User Functions ===================
    /// Transfer tokens from sender to recipient
    public entry fun transfer(
        from: &signer,
        to: address,
        amount: u64
    ) {
        // Verify amount
        assert!(amount > 0, EINSUFFICIENT_BALANCE);
        // Perform transfer
        primary_fungible_store::transfer(from, get_metadata(), to, amount);
    }
    /// Force transfer (admin only)
    public entry fun force_transfer(
        admin: &signer,
        from: address,
        to: address,
        amount: u64
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Perform force transfer
        primary_fungible_store::transfer_with_ref(
            &management.transfer_ref,
            from,
            to,
            amount
        );
        // Emit event
        event::emit(TransferEvent {
            amount,
            from,
            to,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}
			1. Overview of Transfer Functions in Fungible Asset Systems
1.1. Purpose and Importance of User Functions
User Functions play a crucial role in fungible asset systems, providing essential capabilities for end users to interact with their tokens. These functions are designed with user-friendliness and security in mind, enabling individuals to:
Perform token transfers: Move assets between accounts safely and efficiently
Manage their tokens: Check balances, view transaction history, and handle asset-related tasks
Interact with the token system: Engage in various token-related activities within the ecosystem
By offering these functionalities, User Functions empower users to have full control over their digital assets while maintaining the integrity and security of the overall system.
1.2. Types of Transfer Functions
Transfer functions are a critical component of User Functions, allowing for the movement of tokens between accounts. There are two primary types of transfer functions, each serving different purposes and use cases:
Regular Transfer
Definition: A standard token transfer initiated by the token owner
Key characteristics:
Sender must be the rightful owner of the tokens
Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
Requires sufficient balance in the sender's account
Use cases:
Peer-to-peer transactions
Payments for goods or services
Moving tokens between personal accounts
Force Transfer
Definition: A mandatory token transfer executed by an administrator
Key characteristics:
Admin-only privilege, restricted to authorized system administrators
Bypasses frozen status, allowing transfers involving frozen accounts
Can be executed without the token owner's consent
Use cases:
Regulatory compliance and legal orders
Error correction and dispute resolution
System maintenance and upgrades
Important considerations:
Should be used sparingly and only when absolutely necessary
Requires robust governance and oversight to prevent misuse
May have implications for user trust and system decentralization
2. Events and Error Handling
In Move programming, events and error handling are crucial for creating robust and user-friendly smart contracts. Let's dive into these concepts with some practical examples.
2.1. Event Structure
Events in Move are used to emit important information about state changes. Here's an example of a TransferEvent structure:
// This event is emitted when a transfer occurs
struct TransferEvent has drop, store {
    amount: u64,   // The amount of tokens transferred
    from: address, // The address sending the tokens
    to: address,   // The address receiving the tokens
}
// Usage example:
event::emit(TransferEvent {
    amount: 100,
    from: @0x1234,
    to: @0x5678,
});
In this example, we define a TransferEvent that captures the essential information of a token transfer. The 'drop' and 'store' abilities allow this struct to be discarded and stored in global storage, respectively.
2.2. Error Constants
Error constants help in providing clear and consistent error messages. Here's an expanded set of error constants:
// Error constants for better error handling
const EINSUFFICIENT_BALANCE: u64 = 1;
const EZERO_AMOUNT: u64 = 2;
const EFROZEN_ACCOUNT: u64 = 3;
const EINVALID_RECIPIENT: u64 = 4;
const EUNAUTHORIZED: u64 = 5;
// Usage example:
assert!(balance >= amount, EINSUFFICIENT_BALANCE);
These constants make your code more readable and maintainable. When an error occurs, you can easily identify the issue based on the error code.
3. Regular Transfer Implementation
Now, let's implement a regular transfer function with detailed explanations and error handling.
3.1. Function Signature
public entry fun transfer(
    from: &signer,  // The account initiating the transfer
    to: address,    // The recipient's address
    amount: u64     // The amount to transfer
)
This function signature defines a public entry function that can be called directly from outside the module.
3.2. Detailed Implementation
public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // 1. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 2. Check if the recipient address is valid
    assert!(to != @0x0, EINVALID_RECIPIENT);
    // 3. Get the sender's address
    let sender = signer::address_of(from);
    // 4. Check if the sender has sufficient balance
    assert!(balance::get(sender) >= amount, EINSUFFICIENT_BALANCE);
    // 5. Check if either account is frozen
    assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    // 6. Perform transfer
    primary_fungible_store::transfer(
        from,
        get_metadata(),
        to,
        amount
    );
    // 7. Emit transfer event
    event::emit(TransferEvent {
        amount,
        from: sender,
        to,
    });
}
This implementation includes several important steps:
We validate that the amount is not zero.
We ensure the recipient address is valid.
We get the sender's address from the signer.
We check if the sender has sufficient balance.
We verify that neither account is frozen.
We perform the actual transfer using the primary_fungible_store module.
Finally, we emit a TransferEvent to log the transfer.
Each step includes error handling to ensure the transfer meets all requirements before execution.
3.3. Flow Analysis
Let's break down the transfer function to understand its flow and key components. This analysis will help newcomers grasp the intricacies of implementing a secure token transfer system.
3.3.1. Validation Steps
Before executing the transfer, we perform several crucial checks:
// Amount validation
assert!(amount > 0, EZERO_AMOUNT);
// Sender's balance check
let sender_balance = balance::get(sender);
assert!(sender_balance >= amount, EINSUFFICIENT_BALANCE);
// Frozen status check
assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
// Recipient address validation
assert!(to != @0x0, EINVALID_RECIPIENT);
Let's examine each validation step:
Amount Validation: We ensure the transfer amount is greater than zero to prevent meaningless transactions.
Balance Check: We verify that the sender has sufficient funds for the transfer.
Frozen Status: We check if either the sender's or recipient's account is frozen, preventing transfers involving frozen accounts.
Recipient Validation: We confirm that the recipient's address is valid and not the zero address.
These checks help maintain the integrity and security of the transfer process.
3.3.2. Transfer Process
Once all validations pass, we proceed with the actual transfer:
// Transfer using primary store
primary_fungible_store::transfer(from, get_metadata(), to, amount);
This function call encapsulates several important steps:
Store Creation: If the recipient doesn't have a store for this token, one is automatically created.
Withdrawal: The specified amount is withdrawn from the sender's account.
Deposit: The withdrawn amount is deposited into the recipient's account.
Error Handling: Any issues during these steps (e.g., insufficient balance) are automatically handled.
After the transfer, we emit an event to log the transaction:
// Emit transfer event
event::emit(TransferEvent {
    amount,
    from: sender,
    to,
});
This event emission is crucial for maintaining a transparent record of all transfers, which can be used for auditing or providing transaction history to users.
3.3.3. Error Handling
Throughout the process, we use assert! statements for error handling. When an assertion fails, it aborts the transaction with a specific error code. For example:
assert!(amount > 0, EZERO_AMOUNT);
If amount is zero or negative, the transaction will abort with the EZERO_AMOUNT error. This approach ensures that invalid operations are caught early and prevented from executing.
4. Force Transfer Implementation
Force transfer is a powerful feature that allows authorized administrators to move tokens between accounts without the sender's consent. This functionality is crucial for certain scenarios but should be used with caution.
4.1. Function Signature
Let's break down the function signature for force transfer:
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement
Here's what each parameter means:
admin: &signer - The administrator initiating the force transfer
from: address - The address from which tokens will be taken
to: address - The address receiving the tokens
amount: u64 - The number of tokens to transfer
The 'acquires MovementManagement' clause indicates that this function will access the MovementManagement resource.
4.2. Detailed Implementation
Now, let's examine the implementation step-by-step:
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // 1. Verify admin rights
    assert!(is_admin(signer::address_of(admin)), EUNAUTHORIZED);
    // 2. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 3. Get management struct
    let management = borrow_global&lt;MovementManagement&gt;(
        object::object_address(&get_metadata())
    );
    // 4. Check if either account is frozen (optional for force transfer)
    if (!is_force_transfer_allowed_when_frozen()) {
        assert!(!is_account_frozen(from) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    }
    // 5. Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // 6. Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
    // 7. Log force transfer for auditing
    log_force_transfer(admin, from, to, amount);
}
Let's break down each step:
Verify admin rights: We first check if the signer is an authorized admin.
Amount validation: Ensure the transfer amount is greater than zero.
Get management struct: Retrieve the MovementManagement resource, which contains necessary references for the transfer.
Frozen account check: Optionally check if accounts are frozen, based on system configuration.
Perform force transfer: Use the transfer_with_ref function to move tokens without the sender's signature.
Emit event: Log the transfer event for transparency.
Audit logging: Record the force transfer details for future auditing.
This implementation ensures that only authorized admins can perform force transfers, maintains proper event logging, and includes optional checks for frozen accounts. The use of transfer_with_ref allows bypassing normal transfer restrictions.
Regular Transfer Example
public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // Verify amount
    assert!(amount > 0, EINSUFFICIENT_BALANCE);
    // Perform transfer
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
Force Transfer Example
/// Force transfer (admin only)
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
}
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct TransferEvent has drop, store {
        amount: u64,
        from: address,
        to: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== User Functions ===================
    /// Transfer tokens from sender to recipient
    public entry fun transfer(
        from: &signer,
        to: address,
        amount: u64
    ) {
        // Verify amount
        assert!(amount > 0, EINSUFFICIENT_BALANCE);
        // Perform transfer
        primary_fungible_store::transfer(from, get_metadata(), to, amount);
    }
    /// Force transfer (admin only)
    public entry fun force_transfer(
        admin: &signer,
        from: address,
        to: address,
        amount: u64
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Perform force transfer
        primary_fungible_store::transfer_with_ref(
            &management.transfer_ref,
            from,
            to,
            amount
        );
        // Emit event
        event::emit(TransferEvent {
            amount,
            from,
            to,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}
			1. Overview of Transfer Functions in Fungible Asset Systems
1.1. Purpose and Importance of User Functions
User Functions play a crucial role in fungible asset systems, providing essential capabilities for end users to interact with their tokens. These functions are designed with user-friendliness and security in mind, enabling individuals to:
Perform token transfers: Move assets between accounts safely and efficiently
Manage their tokens: Check balances, view transaction history, and handle asset-related tasks
Interact with the token system: Engage in various token-related activities within the ecosystem
By offering these functionalities, User Functions empower users to have full control over their digital assets while maintaining the integrity and security of the overall system.
1.2. Types of Transfer Functions
Transfer functions are a critical component of User Functions, allowing for the movement of tokens between accounts. There are two primary types of transfer functions, each serving different purposes and use cases:
Regular Transfer
Definition: A standard token transfer initiated by the token owner
Key characteristics:
Sender must be the rightful owner of the tokens
Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
Requires sufficient balance in the sender's account
Use cases:
Peer-to-peer transactions
Payments for goods or services
Moving tokens between personal accounts
Force Transfer
Definition: A mandatory token transfer executed by an administrator
Key characteristics:
Admin-only privilege, restricted to authorized system administrators
Bypasses frozen status, allowing transfers involving frozen accounts
Can be executed without the token owner's consent
Use cases:
Regulatory compliance and legal orders
Error correction and dispute resolution
System maintenance and upgrades
Important considerations:
Should be used sparingly and only when absolutely necessary
Requires robust governance and oversight to prevent misuse
May have implications for user trust and system decentralization
2. Events and Error Handling
In Move programming, events and error handling are crucial for creating robust and user-friendly smart contracts. Let's dive into these concepts with some practical examples.
2.1. Event Structure
Events in Move are used to emit important information about state changes. Here's an example of a TransferEvent structure:
// This event is emitted when a transfer occurs
struct TransferEvent has drop, store {
    amount: u64,   // The amount of tokens transferred
    from: address, // The address sending the tokens
    to: address,   // The address receiving the tokens
}
// Usage example:
event::emit(TransferEvent {
    amount: 100,
    from: @0x1234,
    to: @0x5678,
});
In this example, we define a TransferEvent that captures the essential information of a token transfer. The 'drop' and 'store' abilities allow this struct to be discarded and stored in global storage, respectively.
2.2. Error Constants
Error constants help in providing clear and consistent error messages. Here's an expanded set of error constants:
// Error constants for better error handling
const EINSUFFICIENT_BALANCE: u64 = 1;
const EZERO_AMOUNT: u64 = 2;
const EFROZEN_ACCOUNT: u64 = 3;
const EINVALID_RECIPIENT: u64 = 4;
const EUNAUTHORIZED: u64 = 5;
// Usage example:
assert!(balance >= amount, EINSUFFICIENT_BALANCE);
These constants make your code more readable and maintainable. When an error occurs, you can easily identify the issue based on the error code.
3. Regular Transfer Implementation
Now, let's implement a regular transfer function with detailed explanations and error handling.
3.1. Function Signature
public entry fun transfer(
    from: &signer,  // The account initiating the transfer
    to: address,    // The recipient's address
    amount: u64     // The amount to transfer
)
This function signature defines a public entry function that can be called directly from outside the module.
3.2. Detailed Implementation
public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // 1. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 2. Check if the recipient address is valid
    assert!(to != @0x0, EINVALID_RECIPIENT);
    // 3. Get the sender's address
    let sender = signer::address_of(from);
    // 4. Check if the sender has sufficient balance
    assert!(balance::get(sender) >= amount, EINSUFFICIENT_BALANCE);
    // 5. Check if either account is frozen
    assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    // 6. Perform transfer
    primary_fungible_store::transfer(
        from,
        get_metadata(),
        to,
        amount
    );
    // 7. Emit transfer event
    event::emit(TransferEvent {
        amount,
        from: sender,
        to,
    });
}
This implementation includes several important steps:
We validate that the amount is not zero.
We ensure the recipient address is valid.
We get the sender's address from the signer.
We check if the sender has sufficient balance.
We verify that neither account is frozen.
We perform the actual transfer using the primary_fungible_store module.
Finally, we emit a TransferEvent to log the transfer.
Each step includes error handling to ensure the transfer meets all requirements before execution.
3.3. Flow Analysis
Let's break down the transfer function to understand its flow and key components. This analysis will help newcomers grasp the intricacies of implementing a secure token transfer system.
3.3.1. Validation Steps
Before executing the transfer, we perform several crucial checks:
// Amount validation
assert!(amount > 0, EZERO_AMOUNT);
// Sender's balance check
let sender_balance = balance::get(sender);
assert!(sender_balance >= amount, EINSUFFICIENT_BALANCE);
// Frozen status check
assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
// Recipient address validation
assert!(to != @0x0, EINVALID_RECIPIENT);
Let's examine each validation step:
Amount Validation: We ensure the transfer amount is greater than zero to prevent meaningless transactions.
Balance Check: We verify that the sender has sufficient funds for the transfer.
Frozen Status: We check if either the sender's or recipient's account is frozen, preventing transfers involving frozen accounts.
Recipient Validation: We confirm that the recipient's address is valid and not the zero address.
These checks help maintain the integrity and security of the transfer process.
3.3.2. Transfer Process
Once all validations pass, we proceed with the actual transfer:
// Transfer using primary store
primary_fungible_store::transfer(from, get_metadata(), to, amount);
This function call encapsulates several important steps:
Store Creation: If the recipient doesn't have a store for this token, one is automatically created.
Withdrawal: The specified amount is withdrawn from the sender's account.
Deposit: The withdrawn amount is deposited into the recipient's account.
Error Handling: Any issues during these steps (e.g., insufficient balance) are automatically handled.
After the transfer, we emit an event to log the transaction:
// Emit transfer event
event::emit(TransferEvent {
    amount,
    from: sender,
    to,
});
This event emission is crucial for maintaining a transparent record of all transfers, which can be used for auditing or providing transaction history to users.
3.3.3. Error Handling
Throughout the process, we use assert! statements for error handling. When an assertion fails, it aborts the transaction with a specific error code. For example:
assert!(amount > 0, EZERO_AMOUNT);
If amount is zero or negative, the transaction will abort with the EZERO_AMOUNT error. This approach ensures that invalid operations are caught early and prevented from executing.
4. Force Transfer Implementation
Force transfer is a powerful feature that allows authorized administrators to move tokens between accounts without the sender's consent. This functionality is crucial for certain scenarios but should be used with caution.
4.1. Function Signature
Let's break down the function signature for force transfer:
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement
Here's what each parameter means:
admin: &signer - The administrator initiating the force transfer
from: address - The address from which tokens will be taken
to: address - The address receiving the tokens
amount: u64 - The number of tokens to transfer
The 'acquires MovementManagement' clause indicates that this function will access the MovementManagement resource.
4.2. Detailed Implementation
Now, let's examine the implementation step-by-step:
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // 1. Verify admin rights
    assert!(is_admin(signer::address_of(admin)), EUNAUTHORIZED);
    // 2. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 3. Get management struct
    let management = borrow_global&lt;MovementManagement&gt;(
        object::object_address(&get_metadata())
    );
    // 4. Check if either account is frozen (optional for force transfer)
    if (!is_force_transfer_allowed_when_frozen()) {
        assert!(!is_account_frozen(from) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    }
    // 5. Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // 6. Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
    // 7. Log force transfer for auditing
    log_force_transfer(admin, from, to, amount);
}
Let's break down each step:
Verify admin rights: We first check if the signer is an authorized admin.
Amount validation: Ensure the transfer amount is greater than zero.
Get management struct: Retrieve the MovementManagement resource, which contains necessary references for the transfer.
Frozen account check: Optionally check if accounts are frozen, based on system configuration.
Perform force transfer: Use the transfer_with_ref function to move tokens without the sender's signature.
Emit event: Log the transfer event for transparency.
Audit logging: Record the force transfer details for future auditing.
This implementation ensures that only authorized admins can perform force transfers, maintains proper event logging, and includes optional checks for frozen accounts. The use of transfer_with_ref allows bypassing normal transfer restrictions.
Regular Transfer Example
public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // Verify amount
    assert!(amount > 0, EINSUFFICIENT_BALANCE);
    // Perform transfer
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
Force Transfer Example
/// Force transfer (admin only)
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
}
Full Code
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct TransferEvent has drop, store {
        amount: u64,
        from: address,
        to: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== User Functions ===================
    /// Transfer tokens from sender to recipient
    public entry fun transfer(
        from: &signer,
        to: address,
        amount: u64
    ) {
        // Verify amount
        assert!(amount > 0, EINSUFFICIENT_BALANCE);
        // Perform transfer
        primary_fungible_store::transfer(from, get_metadata(), to, amount);
    }
    /// Force transfer (admin only)
    public entry fun force_transfer(
        admin: &signer,
        from: address,
        to: address,
        amount: u64
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Perform force transfer
        primary_fungible_store::transfer_with_ref(
            &management.transfer_ref,
            from,
            to,
            amount
        );
        // Emit event
        event::emit(TransferEvent {
            amount,
            from,
            to,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}
	1. Overview of Transfer Functions in Fungible Asset Systems
	1. Overview of Transfer Functions in Fungible Asset Systems
		1.1. Purpose and Importance of User Functions
		1.1. Purpose and Importance of User Functions
		User Functions play a crucial role in fungible asset systems, providing essential capabilities for end users to interact with their tokens. These functions are designed with user-friendliness and security in mind, enabling individuals to:
		User Functions play a crucial role in fungible asset systems, providing essential capabilities for end users to interact with their tokens. These functions are designed with user-friendliness and security in mind, enabling individuals to:
		Perform token transfers: Move assets between accounts safely and efficiently
Manage their tokens: Check balances, view transaction history, and handle asset-related tasks
Interact with the token system: Engage in various token-related activities within the ecosystem
		Perform token transfers: Move assets between accounts safely and efficiently
		Perform token transfers: Move assets between accounts safely and efficiently
		Manage their tokens: Check balances, view transaction history, and handle asset-related tasks
		Manage their tokens: Check balances, view transaction history, and handle asset-related tasks
		Interact with the token system: Engage in various token-related activities within the ecosystem
		Interact with the token system: Engage in various token-related activities within the ecosystem
		By offering these functionalities, User Functions empower users to have full control over their digital assets while maintaining the integrity and security of the overall system.
		By offering these functionalities, User Functions empower users to have full control over their digital assets while maintaining the integrity and security of the overall system.
		1.2. Types of Transfer Functions
		1.2. Types of Transfer Functions
		Transfer functions are a critical component of User Functions, allowing for the movement of tokens between accounts. There are two primary types of transfer functions, each serving different purposes and use cases:
		Transfer functions are a critical component of User Functions, allowing for the movement of tokens between accounts. There are two primary types of transfer functions, each serving different purposes and use cases:
		Regular Transfer
Definition: A standard token transfer initiated by the token owner
Key characteristics:
Sender must be the rightful owner of the tokens
Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
Requires sufficient balance in the sender's account
Use cases:
Peer-to-peer transactions
Payments for goods or services
Moving tokens between personal accounts
Force Transfer
Definition: A mandatory token transfer executed by an administrator
Key characteristics:
Admin-only privilege, restricted to authorized system administrators
Bypasses frozen status, allowing transfers involving frozen accounts
Can be executed without the token owner's consent
Use cases:
Regulatory compliance and legal orders
Error correction and dispute resolution
System maintenance and upgrades
Important considerations:
Should be used sparingly and only when absolutely necessary
Requires robust governance and oversight to prevent misuse
May have implications for user trust and system decentralization
		Regular Transfer
Definition: A standard token transfer initiated by the token owner
Key characteristics:
Sender must be the rightful owner of the tokens
Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
Requires sufficient balance in the sender's account
Use cases:
Peer-to-peer transactions
Payments for goods or services
Moving tokens between personal accounts
		Regular Transfer
		Regular Transfer
		Definition: A standard token transfer initiated by the token owner
Key characteristics:
Sender must be the rightful owner of the tokens
Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
Requires sufficient balance in the sender's account
Use cases:
Peer-to-peer transactions
Payments for goods or services
Moving tokens between personal accounts
		Definition: A standard token transfer initiated by the token owner
		Definition: A standard token transfer initiated by the token owner
		Key characteristics:
Sender must be the rightful owner of the tokens
Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
Requires sufficient balance in the sender's account
		Key characteristics:
		Sender must be the rightful owner of the tokens
Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
Requires sufficient balance in the sender's account
		Sender must be the rightful owner of the tokens
		Sender must be the rightful owner of the tokens
		Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
		Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
		Requires sufficient balance in the sender's account
		Requires sufficient balance in the sender's account
		Use cases:
Peer-to-peer transactions
Payments for goods or services
Moving tokens between personal accounts
		Use cases:
		Peer-to-peer transactions
Payments for goods or services
Moving tokens between personal accounts
		Peer-to-peer transactions
		Peer-to-peer transactions
		Payments for goods or services
		Payments for goods or services
		Moving tokens between personal accounts
		Moving tokens between personal accounts
		Force Transfer
Definition: A mandatory token transfer executed by an administrator
Key characteristics:
Admin-only privilege, restricted to authorized system administrators
Bypasses frozen status, allowing transfers involving frozen accounts
Can be executed without the token owner's consent
Use cases:
Regulatory compliance and legal orders
Error correction and dispute resolution
System maintenance and upgrades
Important considerations:
Should be used sparingly and only when absolutely necessary
Requires robust governance and oversight to prevent misuse
May have implications for user trust and system decentralization
		Force Transfer
		Force Transfer
		Definition: A mandatory token transfer executed by an administrator
Key characteristics:
Admin-only privilege, restricted to authorized system administrators
Bypasses frozen status, allowing transfers involving frozen accounts
Can be executed without the token owner's consent
Use cases:
Regulatory compliance and legal orders
Error correction and dispute resolution
System maintenance and upgrades
Important considerations:
Should be used sparingly and only when absolutely necessary
Requires robust governance and oversight to prevent misuse
May have implications for user trust and system decentralization
		Definition: A mandatory token transfer executed by an administrator
		Definition: A mandatory token transfer executed by an administrator
		Key characteristics:
Admin-only privilege, restricted to authorized system administrators
Bypasses frozen status, allowing transfers involving frozen accounts
Can be executed without the token owner's consent
		Key characteristics:
		Admin-only privilege, restricted to authorized system administrators
Bypasses frozen status, allowing transfers involving frozen accounts
Can be executed without the token owner's consent
		Admin-only privilege, restricted to authorized system administrators
		Admin-only privilege, restricted to authorized system administrators
		Bypasses frozen status, allowing transfers involving frozen accounts
		Bypasses frozen status, allowing transfers involving frozen accounts
		Can be executed without the token owner's consent
		Can be executed without the token owner's consent
		Use cases:
Regulatory compliance and legal orders
Error correction and dispute resolution
System maintenance and upgrades
		Use cases:
		Regulatory compliance and legal orders
Error correction and dispute resolution
System maintenance and upgrades
		Regulatory compliance and legal orders
		Regulatory compliance and legal orders
		Error correction and dispute resolution
		Error correction and dispute resolution
		System maintenance and upgrades
		System maintenance and upgrades
		Important considerations:
Should be used sparingly and only when absolutely necessary
Requires robust governance and oversight to prevent misuse
May have implications for user trust and system decentralization
		Important considerations:
		Should be used sparingly and only when absolutely necessary
Requires robust governance and oversight to prevent misuse
May have implications for user trust and system decentralization
		Should be used sparingly and only when absolutely necessary
		Should be used sparingly and only when absolutely necessary
		Requires robust governance and oversight to prevent misuse
		Requires robust governance and oversight to prevent misuse
		May have implications for user trust and system decentralization
		May have implications for user trust and system decentralization
	2. Events and Error Handling
	2. Events and Error Handling
	In Move programming, events and error handling are crucial for creating robust and user-friendly smart contracts. Let's dive into these concepts with some practical examples.
	In Move programming, events and error handling are crucial for creating robust and user-friendly smart contracts. Let's dive into these concepts with some practical examples.
		2.1. Event Structure
		2.1. Event Structure
		Events in Move are used to emit important information about state changes. Here's an example of a TransferEvent structure:
		Events in Move are used to emit important information about state changes. Here's an example of a TransferEvent structure:
		<code>// This event is emitted when a transfer occurs
struct TransferEvent has drop, store {
    amount: u64,   // The amount of tokens transferred
    from: address, // The address sending the tokens
    to: address,   // The address receiving the tokens
}
// Usage example:
event::emit(TransferEvent {
    amount: 100,
    from: @0x1234,
    to: @0x5678,
});</code>
		<code>// This event is emitted when a transfer occurs
struct TransferEvent has drop, store {
    amount: u64,   // The amount of tokens transferred
    from: address, // The address sending the tokens
    to: address,   // The address receiving the tokens
}
// Usage example:
event::emit(TransferEvent {
    amount: 100,
    from: @0x1234,
    to: @0x5678,
});</code>
		// This event is emitted when a transfer occurs
struct TransferEvent has drop, store {
    amount: u64,   // The amount of tokens transferred
    from: address, // The address sending the tokens
    to: address,   // The address receiving the tokens
}
// Usage example:
event::emit(TransferEvent {
    amount: 100,
    from: @0x1234,
    to: @0x5678,
});
		In this example, we define a TransferEvent that captures the essential information of a token transfer. The 'drop' and 'store' abilities allow this struct to be discarded and stored in global storage, respectively.
		In this example, we define a TransferEvent that captures the essential information of a token transfer. The 'drop' and 'store' abilities allow this struct to be discarded and stored in global storage, respectively.
		2.2. Error Constants
		2.2. Error Constants
		Error constants help in providing clear and consistent error messages. Here's an expanded set of error constants:
		Error constants help in providing clear and consistent error messages. Here's an expanded set of error constants:
		<code>// Error constants for better error handling
const EINSUFFICIENT_BALANCE: u64 = 1;
const EZERO_AMOUNT: u64 = 2;
const EFROZEN_ACCOUNT: u64 = 3;
const EINVALID_RECIPIENT: u64 = 4;
const EUNAUTHORIZED: u64 = 5;
// Usage example:
assert!(balance >= amount, EINSUFFICIENT_BALANCE);</code>
		<code>// Error constants for better error handling
const EINSUFFICIENT_BALANCE: u64 = 1;
const EZERO_AMOUNT: u64 = 2;
const EFROZEN_ACCOUNT: u64 = 3;
const EINVALID_RECIPIENT: u64 = 4;
const EUNAUTHORIZED: u64 = 5;
// Usage example:
assert!(balance >= amount, EINSUFFICIENT_BALANCE);</code>
		// Error constants for better error handling
const EINSUFFICIENT_BALANCE: u64 = 1;
const EZERO_AMOUNT: u64 = 2;
const EFROZEN_ACCOUNT: u64 = 3;
const EINVALID_RECIPIENT: u64 = 4;
const EUNAUTHORIZED: u64 = 5;
// Usage example:
assert!(balance >= amount, EINSUFFICIENT_BALANCE);
		These constants make your code more readable and maintainable. When an error occurs, you can easily identify the issue based on the error code.
		These constants make your code more readable and maintainable. When an error occurs, you can easily identify the issue based on the error code.
	3. Regular Transfer Implementation
	3. Regular Transfer Implementation
	Now, let's implement a regular transfer function with detailed explanations and error handling.
	Now, let's implement a regular transfer function with detailed explanations and error handling.
		3.1. Function Signature
		3.1. Function Signature
		<code>public entry fun transfer(
    from: &signer,  // The account initiating the transfer
    to: address,    // The recipient's address
    amount: u64     // The amount to transfer
)</code>
		<code>public entry fun transfer(
    from: &signer,  // The account initiating the transfer
    to: address,    // The recipient's address
    amount: u64     // The amount to transfer
)</code>
		public entry fun transfer(
    from: &signer,  // The account initiating the transfer
    to: address,    // The recipient's address
    amount: u64     // The amount to transfer
)
		This function signature defines a public entry function that can be called directly from outside the module.
		This function signature defines a public entry function that can be called directly from outside the module.
		3.2. Detailed Implementation
		3.2. Detailed Implementation
		<code>public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // 1. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 2. Check if the recipient address is valid
    assert!(to != @0x0, EINVALID_RECIPIENT);
    // 3. Get the sender's address
    let sender = signer::address_of(from);
    // 4. Check if the sender has sufficient balance
    assert!(balance::get(sender) >= amount, EINSUFFICIENT_BALANCE);
    // 5. Check if either account is frozen
    assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    // 6. Perform transfer
    primary_fungible_store::transfer(
        from,
        get_metadata(),
        to,
        amount
    );
    // 7. Emit transfer event
    event::emit(TransferEvent {
        amount,
        from: sender,
        to,
    });
}</code>
		<code>public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // 1. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 2. Check if the recipient address is valid
    assert!(to != @0x0, EINVALID_RECIPIENT);
    // 3. Get the sender's address
    let sender = signer::address_of(from);
    // 4. Check if the sender has sufficient balance
    assert!(balance::get(sender) >= amount, EINSUFFICIENT_BALANCE);
    // 5. Check if either account is frozen
    assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    // 6. Perform transfer
    primary_fungible_store::transfer(
        from,
        get_metadata(),
        to,
        amount
    );
    // 7. Emit transfer event
    event::emit(TransferEvent {
        amount,
        from: sender,
        to,
    });
}</code>
		public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // 1. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 2. Check if the recipient address is valid
    assert!(to != @0x0, EINVALID_RECIPIENT);
    // 3. Get the sender's address
    let sender = signer::address_of(from);
    // 4. Check if the sender has sufficient balance
    assert!(balance::get(sender) >= amount, EINSUFFICIENT_BALANCE);
    // 5. Check if either account is frozen
    assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    // 6. Perform transfer
    primary_fungible_store::transfer(
        from,
        get_metadata(),
        to,
        amount
    );
    // 7. Emit transfer event
    event::emit(TransferEvent {
        amount,
        from: sender,
        to,
    });
}
		This implementation includes several important steps:
		This implementation includes several important steps:
		We validate that the amount is not zero.
We ensure the recipient address is valid.
We get the sender's address from the signer.
We check if the sender has sufficient balance.
We verify that neither account is frozen.
We perform the actual transfer using the primary_fungible_store module.
Finally, we emit a TransferEvent to log the transfer.
		We validate that the amount is not zero.
		We validate that the amount is not zero.
		We ensure the recipient address is valid.
		We ensure the recipient address is valid.
		We get the sender's address from the signer.
		We get the sender's address from the signer.
		We check if the sender has sufficient balance.
		We check if the sender has sufficient balance.
		We verify that neither account is frozen.
		We verify that neither account is frozen.
		We perform the actual transfer using the primary_fungible_store module.
		We perform the actual transfer using the primary_fungible_store module.
		Finally, we emit a TransferEvent to log the transfer.
		Finally, we emit a TransferEvent to log the transfer.
		Each step includes error handling to ensure the transfer meets all requirements before execution.
		Each step includes error handling to ensure the transfer meets all requirements before execution.
		3.3. Flow Analysis
		3.3. Flow Analysis
		Let's break down the transfer function to understand its flow and key components. This analysis will help newcomers grasp the intricacies of implementing a secure token transfer system.
		Let's break down the transfer function to understand its flow and key components. This analysis will help newcomers grasp the intricacies of implementing a secure token transfer system.
		3.3.1. Validation Steps
		3.3.1. Validation Steps
		Before executing the transfer, we perform several crucial checks:
		Before executing the transfer, we perform several crucial checks:
		<code>// Amount validation
assert!(amount > 0, EZERO_AMOUNT);
// Sender's balance check
let sender_balance = balance::get(sender);
assert!(sender_balance >= amount, EINSUFFICIENT_BALANCE);
// Frozen status check
assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
// Recipient address validation
assert!(to != @0x0, EINVALID_RECIPIENT);</code>
		<code>// Amount validation
assert!(amount > 0, EZERO_AMOUNT);
// Sender's balance check
let sender_balance = balance::get(sender);
assert!(sender_balance >= amount, EINSUFFICIENT_BALANCE);
// Frozen status check
assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
// Recipient address validation
assert!(to != @0x0, EINVALID_RECIPIENT);</code>
		// Amount validation
assert!(amount > 0, EZERO_AMOUNT);
// Sender's balance check
let sender_balance = balance::get(sender);
assert!(sender_balance >= amount, EINSUFFICIENT_BALANCE);
// Frozen status check
assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
// Recipient address validation
assert!(to != @0x0, EINVALID_RECIPIENT);
		Let's examine each validation step:
		Let's examine each validation step:
		Amount Validation: We ensure the transfer amount is greater than zero to prevent meaningless transactions.
Balance Check: We verify that the sender has sufficient funds for the transfer.
Frozen Status: We check if either the sender's or recipient's account is frozen, preventing transfers involving frozen accounts.
Recipient Validation: We confirm that the recipient's address is valid and not the zero address.
		Amount Validation: We ensure the transfer amount is greater than zero to prevent meaningless transactions.
		Amount Validation: We ensure the transfer amount is greater than zero to prevent meaningless transactions.
		Balance Check: We verify that the sender has sufficient funds for the transfer.
		Balance Check: We verify that the sender has sufficient funds for the transfer.
		Frozen Status: We check if either the sender's or recipient's account is frozen, preventing transfers involving frozen accounts.
		Frozen Status: We check if either the sender's or recipient's account is frozen, preventing transfers involving frozen accounts.
		Recipient Validation: We confirm that the recipient's address is valid and not the zero address.
		Recipient Validation: We confirm that the recipient's address is valid and not the zero address.
		These checks help maintain the integrity and security of the transfer process.
		These checks help maintain the integrity and security of the transfer process.
		3.3.2. Transfer Process
		3.3.2. Transfer Process
		Once all validations pass, we proceed with the actual transfer:
		Once all validations pass, we proceed with the actual transfer:
		<code>// Transfer using primary store
primary_fungible_store::transfer(from, get_metadata(), to, amount);</code>
		<code>// Transfer using primary store
primary_fungible_store::transfer(from, get_metadata(), to, amount);</code>
		// Transfer using primary store
primary_fungible_store::transfer(from, get_metadata(), to, amount);
		This function call encapsulates several important steps:
		This function call encapsulates several important steps:
		Store Creation: If the recipient doesn't have a store for this token, one is automatically created.
Withdrawal: The specified amount is withdrawn from the sender's account.
Deposit: The withdrawn amount is deposited into the recipient's account.
Error Handling: Any issues during these steps (e.g., insufficient balance) are automatically handled.
		Store Creation: If the recipient doesn't have a store for this token, one is automatically created.
		Store Creation: If the recipient doesn't have a store for this token, one is automatically created.
		Withdrawal: The specified amount is withdrawn from the sender's account.
		Withdrawal: The specified amount is withdrawn from the sender's account.
		Deposit: The withdrawn amount is deposited into the recipient's account.
		Deposit: The withdrawn amount is deposited into the recipient's account.
		Error Handling: Any issues during these steps (e.g., insufficient balance) are automatically handled.
		Error Handling: Any issues during these steps (e.g., insufficient balance) are automatically handled.
		After the transfer, we emit an event to log the transaction:
		After the transfer, we emit an event to log the transaction:
		<code>// Emit transfer event
event::emit(TransferEvent {
    amount,
    from: sender,
    to,
});</code>
		<code>// Emit transfer event
event::emit(TransferEvent {
    amount,
    from: sender,
    to,
});</code>
		// Emit transfer event
event::emit(TransferEvent {
    amount,
    from: sender,
    to,
});
		This event emission is crucial for maintaining a transparent record of all transfers, which can be used for auditing or providing transaction history to users.
		This event emission is crucial for maintaining a transparent record of all transfers, which can be used for auditing or providing transaction history to users.
		3.3.3. Error Handling
		3.3.3. Error Handling
		Throughout the process, we use assert! statements for error handling. When an assertion fails, it aborts the transaction with a specific error code. For example:
		Throughout the process, we use assert! statements for error handling. When an assertion fails, it aborts the transaction with a specific error code. For example:
		<code>assert!(amount > 0, EZERO_AMOUNT);</code>
		<code>assert!(amount > 0, EZERO_AMOUNT);</code>
		assert!(amount > 0, EZERO_AMOUNT);
		If amount is zero or negative, the transaction will abort with the EZERO_AMOUNT error. This approach ensures that invalid operations are caught early and prevented from executing.
		If amount is zero or negative, the transaction will abort with the EZERO_AMOUNT error. This approach ensures that invalid operations are caught early and prevented from executing.
	4. Force Transfer Implementation
	4. Force Transfer Implementation
	Force transfer is a powerful feature that allows authorized administrators to move tokens between accounts without the sender's consent. This functionality is crucial for certain scenarios but should be used with caution.
	Force transfer is a powerful feature that allows authorized administrators to move tokens between accounts without the sender's consent. This functionality is crucial for certain scenarios but should be used with caution.
		4.1. Function Signature
		4.1. Function Signature
		Let's break down the function signature for force transfer:
		Let's break down the function signature for force transfer:
		<code>public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement</code>
		<code>public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement</code>
		public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement
		Here's what each parameter means:
		Here's what each parameter means:
		admin: &signer - The administrator initiating the force transfer
from: address - The address from which tokens will be taken
to: address - The address receiving the tokens
amount: u64 - The number of tokens to transfer
		admin: &signer - The administrator initiating the force transfer
		admin: &signer - The administrator initiating the force transfer
		from: address - The address from which tokens will be taken
		from: address - The address from which tokens will be taken
		to: address - The address receiving the tokens
		to: address - The address receiving the tokens
		amount: u64 - The number of tokens to transfer
		amount: u64 - The number of tokens to transfer
		The 'acquires MovementManagement' clause indicates that this function will access the MovementManagement resource.
		The 'acquires MovementManagement' clause indicates that this function will access the MovementManagement resource.
		4.2. Detailed Implementation
		4.2. Detailed Implementation
		Now, let's examine the implementation step-by-step:
		Now, let's examine the implementation step-by-step:
		<code>public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // 1. Verify admin rights
    assert!(is_admin(signer::address_of(admin)), EUNAUTHORIZED);
    // 2. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 3. Get management struct
    let management = borrow_global&lt;MovementManagement&gt;(
        object::object_address(&get_metadata())
    );
    // 4. Check if either account is frozen (optional for force transfer)
    if (!is_force_transfer_allowed_when_frozen()) {
        assert!(!is_account_frozen(from) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    }
    // 5. Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // 6. Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
    // 7. Log force transfer for auditing
    log_force_transfer(admin, from, to, amount);
}</code>
		<code>public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // 1. Verify admin rights
    assert!(is_admin(signer::address_of(admin)), EUNAUTHORIZED);
    // 2. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 3. Get management struct
    let management = borrow_global&lt;MovementManagement&gt;(
        object::object_address(&get_metadata())
    );
    // 4. Check if either account is frozen (optional for force transfer)
    if (!is_force_transfer_allowed_when_frozen()) {
        assert!(!is_account_frozen(from) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    }
    // 5. Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // 6. Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
    // 7. Log force transfer for auditing
    log_force_transfer(admin, from, to, amount);
}</code>
		public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // 1. Verify admin rights
    assert!(is_admin(signer::address_of(admin)), EUNAUTHORIZED);
    // 2. Amount validation
    assert!(amount > 0, EZERO_AMOUNT);
    // 3. Get management struct
    let management = borrow_global&lt;MovementManagement&gt;(
        object::object_address(&get_metadata())
    );
    // 4. Check if either account is frozen (optional for force transfer)
    if (!is_force_transfer_allowed_when_frozen()) {
        assert!(!is_account_frozen(from) && !is_account_frozen(to), EFROZEN_ACCOUNT);
    }
    // 5. Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // 6. Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
    // 7. Log force transfer for auditing
    log_force_transfer(admin, from, to, amount);
}
		Let's break down each step:
		Let's break down each step:
		Verify admin rights: We first check if the signer is an authorized admin.
Amount validation: Ensure the transfer amount is greater than zero.
Get management struct: Retrieve the MovementManagement resource, which contains necessary references for the transfer.
Frozen account check: Optionally check if accounts are frozen, based on system configuration.
Perform force transfer: Use the transfer_with_ref function to move tokens without the sender's signature.
Emit event: Log the transfer event for transparency.
Audit logging: Record the force transfer details for future auditing.
		Verify admin rights: We first check if the signer is an authorized admin.
		Verify admin rights: We first check if the signer is an authorized admin.
		Amount validation: Ensure the transfer amount is greater than zero.
		Amount validation: Ensure the transfer amount is greater than zero.
		Get management struct: Retrieve the MovementManagement resource, which contains necessary references for the transfer.
		Get management struct: Retrieve the MovementManagement resource, which contains necessary references for the transfer.
		Frozen account check: Optionally check if accounts are frozen, based on system configuration.
		Frozen account check: Optionally check if accounts are frozen, based on system configuration.
		Perform force transfer: Use the transfer_with_ref function to move tokens without the sender's signature.
		Perform force transfer: Use the transfer_with_ref function to move tokens without the sender's signature.
		Emit event: Log the transfer event for transparency.
		Emit event: Log the transfer event for transparency.
		Audit logging: Record the force transfer details for future auditing.
		Audit logging: Record the force transfer details for future auditing.
		This implementation ensures that only authorized admins can perform force transfers, maintains proper event logging, and includes optional checks for frozen accounts. The use of transfer_with_ref allows bypassing normal transfer restrictions.
		This implementation ensures that only authorized admins can perform force transfers, maintains proper event logging, and includes optional checks for frozen accounts. The use of transfer_with_ref allows bypassing normal transfer restrictions.
		Regular Transfer Example
		Regular Transfer Example
		<code>public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // Verify amount
    assert!(amount > 0, EINSUFFICIENT_BALANCE);
    // Perform transfer
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}</code>
		<code>public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // Verify amount
    assert!(amount > 0, EINSUFFICIENT_BALANCE);
    // Perform transfer
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}</code>
		public entry fun transfer(
    from: &signer,
    to: address,
    amount: u64
) {
    // Verify amount
    assert!(amount > 0, EINSUFFICIENT_BALANCE);
    // Perform transfer
    primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
		Force Transfer Example
		Force Transfer Example
		<code>/// Force transfer (admin only)
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
}</code>
		<code>/// Force transfer (admin only)
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
}</code>
		/// Force transfer (admin only)
public entry fun force_transfer(
    admin: &signer,
    from: address,
    to: address,
    amount: u64
) acquires MovementManagement {
    // Get management struct
    let management = borrow_global<MovementManagement>(
        object::object_address(&get_metadata())
    );
    // Perform force transfer
    primary_fungible_store::transfer_with_ref(
        &management.transfer_ref,
        from,
        to,
        amount
    );
    // Emit event
    event::emit(TransferEvent {
        amount,
        from,
        to,
    });
}
Full Code
Full Code
<code>module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct TransferEvent has drop, store {
        amount: u64,
        from: address,
        to: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== User Functions ===================
    /// Transfer tokens from sender to recipient
    public entry fun transfer(
        from: &signer,
        to: address,
        amount: u64
    ) {
        // Verify amount
        assert!(amount > 0, EINSUFFICIENT_BALANCE);
        // Perform transfer
        primary_fungible_store::transfer(from, get_metadata(), to, amount);
    }
    /// Force transfer (admin only)
    public entry fun force_transfer(
        admin: &signer,
        from: address,
        to: address,
        amount: u64
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Perform force transfer
        primary_fungible_store::transfer_with_ref(
            &management.transfer_ref,
            from,
            to,
            amount
        );
        // Emit event
        event::emit(TransferEvent {
            amount,
            from,
            to,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}</code>
<code>module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct TransferEvent has drop, store {
        amount: u64,
        from: address,
        to: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== User Functions ===================
    /// Transfer tokens from sender to recipient
    public entry fun transfer(
        from: &signer,
        to: address,
        amount: u64
    ) {
        // Verify amount
        assert!(amount > 0, EINSUFFICIENT_BALANCE);
        // Perform transfer
        primary_fungible_store::transfer(from, get_metadata(), to, amount);
    }
    /// Force transfer (admin only)
    public entry fun force_transfer(
        admin: &signer,
        from: address,
        to: address,
        amount: u64
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Perform force transfer
        primary_fungible_store::transfer_with_ref(
            &management.transfer_ref,
            from,
            to,
            amount
        );
        // Emit event
        event::emit(TransferEvent {
            amount,
            from,
            to,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}</code>
module movement::fungible_token_tutorial {
    use std::string;
    use std::option;
    use aptos_framework::object;
    use aptos_framework::event;
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore, Metadata};
    use aptos_framework::primary_fungible_store;
    /// =================== Constants ===================
    /// Token configuration
    const MOVEMENT_NAME: vector<u8> = b"Movement";
    const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
    const MOVEMENT_DECIMALS: u8 = 6;
    /// Error codes
    const ENOT_AUTHORIZED: u64 = 1;
    const EINSUFFICIENT_BALANCE: u64 = 2;
    const ESTORE_FROZEN: u64 = 3;
    const EZERO_MINT_AMOUNT: u64 = 4;
    const EZERO_BURN_AMOUNT: u64 = 5;
    /// =================== Resources & Structs ===================
    /// Holds the refs for managing Movement
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementManagement has key {
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    /// Events
    #[event]
    struct MintEvent has drop, store {
        amount: u64,
        recipient: address,
    }
    #[event]
    struct BurnEvent has drop, store {
        amount: u64,
        from: address,
    }
    #[event]
    struct TransferEvent has drop, store {
        amount: u64,
        from: address,
        to: address,
    }
    #[event]
    struct FreezeEvent has drop, store {
        account: address,
        frozen: bool,
    }
    /// =================== Initialization ===================
    /// Initialize the Movement token
    fun init_module(module_signer: &signer) {
        // Create metadata object with deterministic address
        let constructor_ref = &object::create_named_object(
            module_signer,
            MOVEMENT_SYMBOL,
        );
        // Create the fungible asset with support for primary stores
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            constructor_ref,
            option::none(), // No maximum supply
            string::utf8(MOVEMENT_NAME),
            string::utf8(MOVEMENT_SYMBOL),
            MOVEMENT_DECIMALS,
            string::utf8(b""), // Empty icon URI
            string::utf8(b""), // Empty project URI
        );
        // Generate management references
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
        // Store the management refs in metadata object
        let metadata_signer = &object::generate_signer(constructor_ref);
        move_to(
            metadata_signer,
            MovementManagement {
                mint_ref,
                burn_ref,
                transfer_ref,
            }
        );
    }
    /// =================== View Functions ===================
    /// Get the metadata object of Movement
    #[view]
    public fun get_metadata(): object::Object<fungible_asset::Metadata> {
        object::address_to_object(
            object::create_object_address(&@movement, MOVEMENT_SYMBOL)
        )
    }
    /// Get the balance of an account
    #[view]
    public fun get_balance(account: address): u64 {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::balance(account, get_metadata())
        } else {
            0
        }
    }
    /// Check if account store is frozen
    #[view]
    public fun is_frozen(account: address): bool {
        if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
            primary_fungible_store::is_frozen(account, get_metadata())
        } else {
            false
        }
    }
    /// =================== Management Functions ===================
    /// Mint new tokens to recipient
    public entry fun mint_to(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_MINT_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Mint tokens
        primary_fungible_store::mint(&management.mint_ref, recipient, amount);
        // Emit event
        event::emit(MintEvent {
            amount,
            recipient,
        });
    }
    /// Burn tokens from an account
    public entry fun burn_from(
        admin: &signer,
        account: address,
        amount: u64
    ) acquires MovementManagement {
        // Verify amount
        assert!(amount > 0, EZERO_BURN_AMOUNT);
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Burn tokens
        primary_fungible_store::burn(&management.burn_ref, account, amount);
        // Emit event
        event::emit(BurnEvent {
            amount,
            from: account,
        });
    }
    /// Freeze or unfreeze an account
    public entry fun set_frozen(
        admin: &signer,
        account: address,
        frozen: bool
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Set frozen status
        primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
        // Emit event
        event::emit(FreezeEvent {
            account,
            frozen,
        });
    }
    /// =================== User Functions ===================
    /// Transfer tokens from sender to recipient
    public entry fun transfer(
        from: &signer,
        to: address,
        amount: u64
    ) {
        // Verify amount
        assert!(amount > 0, EINSUFFICIENT_BALANCE);
        // Perform transfer
        primary_fungible_store::transfer(from, get_metadata(), to, amount);
    }
    /// Force transfer (admin only)
    public entry fun force_transfer(
        admin: &signer,
        from: address,
        to: address,
        amount: u64
    ) acquires MovementManagement {
        // Get management struct
        let management = borrow_global<MovementManagement>(
            object::object_address(&get_metadata())
        );
        // Perform force transfer
        primary_fungible_store::transfer_with_ref(
            &management.transfer_ref,
            from,
            to,
            amount
        );
        // Emit event
        event::emit(TransferEvent {
            amount,
            from,
            to,
        });
    }
    /// =================== Tests ===================
    #[test_only]
    use aptos_framework::account;
    #[test(creator = @movement)]
    fun test_init_and_mint(creator: &signer) acquires MovementManagement {
        // Initialize token
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Verify balance
        assert!(get_balance(@0x123) == 1000, 1);
    }
    #[test(creator = @movement)]
    fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
        // Initialize
        init_module(creator);
        // Create test account
        let test_account = account::create_account_for_test(@0x123);
        // Mint tokens
        mint_to(creator, @0x123, 1000);
        // Freeze account
        set_frozen(creator, @0x123, true);
        assert!(is_frozen(@0x123), 1);
        // Unfreeze account
        set_frozen(creator, @0x123, false);
        assert!(!is_frozen(@0x123), 2);
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/02-swap
Swap
Swap
Start
Start
AMM and Constant Product Formula The Foundation of
Start
Foundation and Basic Structures
Start
Creating Trading Pairs in a DEX
Start
Adding Liquidity in a DEX
Start
Removing Liquidity
Start
Swapping Token
Start
DEX Full Code
Start
AMM and Constant Product Formula The Foundation of
Start
AMM and Constant Product Formula The Foundation of
Start
AMM and Constant Product Formula The Foundation of
AMM and Constant Product Formula The Foundation of
Start
Start
Foundation and Basic Structures
Start
Foundation and Basic Structures
Start
Foundation and Basic Structures
Foundation and Basic Structures
Start
Start
Creating Trading Pairs in a DEX
Start
Creating Trading Pairs in a DEX
Start
Creating Trading Pairs in a DEX
Creating Trading Pairs in a DEX
Start
Start
Adding Liquidity in a DEX
Start
Adding Liquidity in a DEX
Start
Adding Liquidity in a DEX
Adding Liquidity in a DEX
Start
Start
Removing Liquidity
Start
Removing Liquidity
Start
Removing Liquidity
Removing Liquidity
Start
Start
Swapping Token
Start
Swapping Token
Start
Swapping Token
Swapping Token
Start
Start
DEX Full Code
Start
DEX Full Code
Start
DEX Full Code
DEX Full Code
Start
Start

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/02-swap/01-amm-and-constant-product-formula-the-foundation-of
AMM and Constant Product Formula The Foundation of
AMM and Constant Product Formula The Foundation of
On This Page
1. Traditional Markets vs AMM
Traditional Markets
AMM Approach
2. Understanding Liquidity Pools
2.1 Basic Concept
2.2 Simple Example
3. Constant Product Formula Deep Dive
3.1 The Basic Formula
3.2 Real-world Examples
Example 1: Small Trade
3.3 Understanding Price Impact
4. Liquidity Provider Mechanics
4.1 Adding Liquidity
4.2 LP Token Distribution
5. Real-world Scenarios
5.1 Trading Example
5.2 Providing Liquidity Example
1. Traditional Markets vs AMM
Traditional Markets
In traditional markets (such as stock exchanges):
Buyers and sellers place orders
Orders are matched when prices align
Participants must wait for a matching counterparty
An order book system is used
Example of an order book:
Buy Orders:     Sell Orders:
$10.00 - 100    $10.20 - 150
$9.90  - 200    $10.30 - 100
$9.80  - 150    $10.40 - 200
In this example, buyers are willing to buy at $10.00 or lower, while sellers are asking $10.20 or higher. A trade occurs when these prices meet.
AMM Approach
In Automated Market Makers (AMM):
No order book is used
Buyers and sellers don't need to be matched
Trades occur against a liquidity pool
Prices are determined by a mathematical formula
Instant trades are available at any time
Let's look at a simple AMM example:
// Simple AMM swap function
fun swap(amount_in: u64, reserve_in: u64, reserve_out: u64): u64 {
    let fee = 3; // 0.3% fee (3 basis points)
    let amount_in_with_fee = amount_in * (1000 - fee) / 1000;
    let numerator = (amount_in_with_fee as u128) * (reserve_out as u128);
    let denominator = (reserve_in as u128) + (amount_in_with_fee as u128);
    ((numerator / denominator) as u64)
}
This code demonstrates a basic AMM swap. Users can trade instantly without waiting for a counterparty, and the price is determined by the ratio of tokens in the pool.
2. Understanding Liquidity Pools
2.1 Basic Concept
Imagine a liquidity pool as two interconnected water tanks:
Tank X [1000 X] ←→ Tank Y [1000 Y]
Adding X yields Y
Adding Y yields X
The ratio between X and Y determines the price
This code demonstrates how a liquidity pool maintains balance and adjusts prices based on trades.
2.2 Simple Example
Initial pool:
Pool X: 1000 tokens
Pool Y: 1000 tokens
Price: 1 X = 1 Y
After swapping 100 X:
Pool X: 1100 tokens
Pool Y: 909.09 tokens (approximately)
Price: 1 X = 0.826 Y
Let's calculate this swap step-by-step:
fun swap_tokens(
    initial_x: u64,
    initial_y: u64,
    swap_amount: u64
): (u64, u64, FixedPoint32) {
    let new_y = (initial_x as u128) * (initial_y as u128) / ((initial_x + swap_amount) as u128);
    let y_out = initial_y - (new_y as u64);
    let new_x = initial_x + swap_amount;
    let new_price = FixedPoint32::create_from_rational(new_y as u64, new_x)
    (y_out, new_y as u64, new_price)
}
This code shows how to calculate the exact amounts for a swap and the resulting price change. Understanding these calculations is crucial for grasping how AMMs work.
3. Constant Product Formula Deep Dive
3.1 The Basic Formula
The core of AMM is the constant product formula:
x * y = k
Where:
x and y are the quantities of two tokens in the pool
k is a constant that remains the same before and after trades
Here's how we can represent this in Move code:
fun check_constant_product(
    x1: u64,      // initial amount of token X
    y1: u64,      // initial amount of token Y
    x2: u64,      // final amount of token X
    y2: u64       // final amount of token Y
): bool {
    let k1 = (x1 as u128) * (y1 as u128);
    let k2 = (x2 as u128) * (y2 as u128);
    k1 == k2
}
This function checks if the product of token amounts remains constant before and after a trade. We use u128 to avoid overflow in multiplication.
3.2 Real-world Examples
Example 1: Small Trade
Let's start with a simple pool:
Pool X = 1000 tokens
Pool Y = 1000 tokens
k = 1,000,000
Now, let's say a user wants to swap 10 X tokens. We can calculate how many Y tokens they'll receive:
(1000 + 10) * (1000 - y) = 1,000,000
1010 * (1000 - y) = 1,000,000
y ≈ 9.9 Y tokens (received)
Here's a Move function to calculate this:
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
This function calculates how many tokens a user will receive based on the amount they're putting in and the current reserves. We use u128 for intermediate calculations to avoid overflow.
3.3 Understanding Price Impact
Price impact occurs because larger trades cause more significant price movements. Here's how we can calculate it:
public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
This function calculates the percentage change in price caused by a trade. Here's a breakdown:
We calculate the initial price (reserve_out / reserve_in).
We determine how many tokens the user will receive (amount_out).
We calculate the new reserves after the trade.
We determine the new price after the trade.
Finally, we calculate the percentage difference between the initial and final prices.
Understanding price impact is crucial for traders, as it helps them anticipate how their trades will affect the market and their returns.
4. Liquidity Provider Mechanics
4.1 Adding Liquidity
When adding liquidity to a pool, it's crucial to maintain the existing ratio of tokens. This ensures the pool's balance and price remain stable. Here's how to calculate the amount of token Y you need to add based on the amount of token X:
Amount Y to add = (Amount X to add * Pool Y) / Pool X
Let's break this down with a step-by-step example:
Initial Pool State:
Pool X: 1000 tokens
Pool Y: 2000 tokens
Current Price: 1 X = 2 Y
Step 1: Decide how much of token X you want to add
Let's say you want to add 100 X tokens.
Step 2: Calculate the required amount of Y tokens
Y needed = (100 * 2000) / 1000 = 200 Y
Step 3: Add liquidity
You'll need to add 100 X tokens and 200 Y tokens to maintain the pool's ratio.
This calculation ensures that you're adding liquidity in the correct proportion, preserving the pool's price equilibrium.
4.2 LP Token Distribution
Liquidity Provider (LP) tokens represent your share of the pool. They're crucial for tracking ownership and distributing rewards. Let's explore how LP tokens are calculated for both the first provider and subsequent providers.
For the first liquidity provider:
fun calculate_initial_lp_tokens(
    amount_x: u64,
    amount_y: u64
): u64 {
    let product = (amount_x as u128) * (amount_y as u128);
    let sqrt_product = math::sqrt(product);
    ((sqrt_product - MINIMUM_LIQUIDITY) as u64)
}
// Example usage:
let initial_x = 1000;
let initial_y = 2000;
let initial_lp_tokens = calculate_initial_lp_tokens(initial_x, initial_y);
This function calculates the initial LP tokens by taking the square root of the product of the two token amounts. We subtract a small amount (MINIMUM_LIQUIDITY) to prevent the first provider from owning 100% of the pool, which could lead to manipulation.
5. Real-world Scenarios
5.1 Trading Example
Let's walk through a complete trading scenario to understand how AMMs work in practice:
Initial Pool State:
Pool X: 10,000 tokens
Pool Y: 20,000 tokens
Initial Price: 1 X = 2 Y
// You can verify this price:
Price of X in terms of Y = Pool Y / Pool X = 20,000 / 10,000 = 2 Y per X
User wants to swap 1,000 X tokens:
// Step 1: Calculate Y tokens received before fee
// y = (Pool Y * Amount X) / (Pool X + Amount X)
// y = (20,000 * 1,000) / (10,000 + 1,000) = 1,818.18 Y
// Step 2: Apply the 0.25% fee
// y_after_fee = 1,818.18 * (1 - 0.0025) = 1,813.63 Y
// Let's implement this in code:
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
Final Pool State:
Pool X: 11,000 tokens (10,000 + 1,000)
Pool Y: 18,186.37 tokens (20,000 - 1,813.63)
New Price: 1 X = 1.65 Y (18,186.37 / 11,000)
// Verify the constant product:
Before trade: 10,000 * 20,000 = 200,000,000
After trade: 11,000 * 18,186.37 ≈ 200,050,070 (slight increase due to fees)
This example demonstrates how a trade affects the pool's balance and price. The price of X in terms of Y decreased because we added X to the pool and removed Y.
5.2 Providing Liquidity Example
Initial Pool:
// Pool X: 10,000 tokens
// Pool Y: 20,000 tokens
// LP Total Supply: 14,142 tokens (sqrt(10,000 * 20,000))
// Let's implement this in code:
fun calculate_initial_lp_supply(reserve_x: u64, reserve_y: u64): u64 {
    let product = (reserve_x as u128) * (reserve_y as u128);
    (math::sqrt(product) as u64)
}
Adding 1,000 X and 2,000 Y:
// Step 1: Calculate the share of the pool
// share = min((1,000 / 10,000), (2,000 / 20,000)) = 0.1 or 10%
// Step 2: Calculate new LP tokens
// new_lp_tokens = 0.1 * 14,142 = 1,414.2 LP tokens
// Let's implement this in code:
fun calculate_lp_tokens_to_mint(
    amount_x: u64,
    amount_y: u64,
    reserve_x: u64,
    reserve_y: u64,
    total_supply: u64
): u64 {
    let share_x = ((amount_x as u128) * (total_supply as u128)) / (reserve_x as u128);
    let share_y = ((amount_y as u128) * (total_supply as u128)) / (reserve_y as u128);
    min(share_x, share_y) as u64
}
This example shows how to calculate the number of LP tokens a liquidity provider receives when adding to an existing pool. The provider receives LP tokens proportional to their share of the pool's liquidity.
On This Page
1. Traditional Markets vs AMM
Traditional Markets
AMM Approach
2. Understanding Liquidity Pools
2.1 Basic Concept
2.2 Simple Example
3. Constant Product Formula Deep Dive
3.1 The Basic Formula
3.2 Real-world Examples
Example 1: Small Trade
3.3 Understanding Price Impact
4. Liquidity Provider Mechanics
4.1 Adding Liquidity
4.2 LP Token Distribution
5. Real-world Scenarios
5.1 Trading Example
5.2 Providing Liquidity Example
On This Page
1. Traditional Markets vs AMM
Traditional Markets
AMM Approach
2. Understanding Liquidity Pools
2.1 Basic Concept
2.2 Simple Example
3. Constant Product Formula Deep Dive
3.1 The Basic Formula
3.2 Real-world Examples
Example 1: Small Trade
3.3 Understanding Price Impact
4. Liquidity Provider Mechanics
4.1 Adding Liquidity
4.2 LP Token Distribution
5. Real-world Scenarios
5.1 Trading Example
5.2 Providing Liquidity Example
			On This Page
			On This Page
			1. Traditional Markets vs AMM
Traditional Markets
AMM Approach
2. Understanding Liquidity Pools
2.1 Basic Concept
2.2 Simple Example
3. Constant Product Formula Deep Dive
3.1 The Basic Formula
3.2 Real-world Examples
Example 1: Small Trade
3.3 Understanding Price Impact
4. Liquidity Provider Mechanics
4.1 Adding Liquidity
4.2 LP Token Distribution
5. Real-world Scenarios
5.1 Trading Example
5.2 Providing Liquidity Example
			1. Traditional Markets vs AMM
Traditional Markets
AMM Approach
			1. Traditional Markets vs AMM
			1. Traditional Markets vs AMM
			1. Traditional Markets vs AMM
			Traditional Markets
AMM Approach
			Traditional Markets
			Traditional Markets
			Traditional Markets
			Traditional Markets
			AMM Approach
			AMM Approach
			AMM Approach
			AMM Approach
			2. Understanding Liquidity Pools
2.1 Basic Concept
2.2 Simple Example
			2. Understanding Liquidity Pools
			2. Understanding Liquidity Pools
			2. Understanding Liquidity Pools
			2.1 Basic Concept
2.2 Simple Example
			2.1 Basic Concept
			2.1 Basic Concept
			2.1 Basic Concept
			2.1 Basic Concept
			2.2 Simple Example
			2.2 Simple Example
			2.2 Simple Example
			2.2 Simple Example
			3. Constant Product Formula Deep Dive
3.1 The Basic Formula
3.2 Real-world Examples
Example 1: Small Trade
3.3 Understanding Price Impact
			3. Constant Product Formula Deep Dive
			3. Constant Product Formula Deep Dive
			3. Constant Product Formula Deep Dive
			3.1 The Basic Formula
3.2 Real-world Examples
Example 1: Small Trade
3.3 Understanding Price Impact
			3.1 The Basic Formula
			3.1 The Basic Formula
			3.1 The Basic Formula
			3.1 The Basic Formula
			3.2 Real-world Examples
			3.2 Real-world Examples
			3.2 Real-world Examples
			3.2 Real-world Examples
			Example 1: Small Trade
			Example 1: Small Trade
			Example 1: Small Trade
			Example 1: Small Trade
			3.3 Understanding Price Impact
			3.3 Understanding Price Impact
			3.3 Understanding Price Impact
			3.3 Understanding Price Impact
			4. Liquidity Provider Mechanics
4.1 Adding Liquidity
4.2 LP Token Distribution
			4. Liquidity Provider Mechanics
			4. Liquidity Provider Mechanics
			4. Liquidity Provider Mechanics
			4.1 Adding Liquidity
4.2 LP Token Distribution
			4.1 Adding Liquidity
			4.1 Adding Liquidity
			4.1 Adding Liquidity
			4.1 Adding Liquidity
			4.2 LP Token Distribution
			4.2 LP Token Distribution
			4.2 LP Token Distribution
			4.2 LP Token Distribution
			5. Real-world Scenarios
5.1 Trading Example
5.2 Providing Liquidity Example
			5. Real-world Scenarios
			5. Real-world Scenarios
			5. Real-world Scenarios
			5.1 Trading Example
5.2 Providing Liquidity Example
			5.1 Trading Example
			5.1 Trading Example
			5.1 Trading Example
			5.1 Trading Example
			5.2 Providing Liquidity Example
			5.2 Providing Liquidity Example
			5.2 Providing Liquidity Example
			5.2 Providing Liquidity Example
			1. Traditional Markets vs AMM
Traditional Markets
In traditional markets (such as stock exchanges):
Buyers and sellers place orders
Orders are matched when prices align
Participants must wait for a matching counterparty
An order book system is used
Example of an order book:
Buy Orders:     Sell Orders:
$10.00 - 100    $10.20 - 150
$9.90  - 200    $10.30 - 100
$9.80  - 150    $10.40 - 200
In this example, buyers are willing to buy at $10.00 or lower, while sellers are asking $10.20 or higher. A trade occurs when these prices meet.
AMM Approach
In Automated Market Makers (AMM):
No order book is used
Buyers and sellers don't need to be matched
Trades occur against a liquidity pool
Prices are determined by a mathematical formula
Instant trades are available at any time
Let's look at a simple AMM example:
// Simple AMM swap function
fun swap(amount_in: u64, reserve_in: u64, reserve_out: u64): u64 {
    let fee = 3; // 0.3% fee (3 basis points)
    let amount_in_with_fee = amount_in * (1000 - fee) / 1000;
    let numerator = (amount_in_with_fee as u128) * (reserve_out as u128);
    let denominator = (reserve_in as u128) + (amount_in_with_fee as u128);
    ((numerator / denominator) as u64)
}
This code demonstrates a basic AMM swap. Users can trade instantly without waiting for a counterparty, and the price is determined by the ratio of tokens in the pool.
2. Understanding Liquidity Pools
2.1 Basic Concept
Imagine a liquidity pool as two interconnected water tanks:
Tank X [1000 X] ←→ Tank Y [1000 Y]
Adding X yields Y
Adding Y yields X
The ratio between X and Y determines the price
This code demonstrates how a liquidity pool maintains balance and adjusts prices based on trades.
2.2 Simple Example
Initial pool:
Pool X: 1000 tokens
Pool Y: 1000 tokens
Price: 1 X = 1 Y
After swapping 100 X:
Pool X: 1100 tokens
Pool Y: 909.09 tokens (approximately)
Price: 1 X = 0.826 Y
Let's calculate this swap step-by-step:
fun swap_tokens(
    initial_x: u64,
    initial_y: u64,
    swap_amount: u64
): (u64, u64, FixedPoint32) {
    let new_y = (initial_x as u128) * (initial_y as u128) / ((initial_x + swap_amount) as u128);
    let y_out = initial_y - (new_y as u64);
    let new_x = initial_x + swap_amount;
    let new_price = FixedPoint32::create_from_rational(new_y as u64, new_x)
    (y_out, new_y as u64, new_price)
}
This code shows how to calculate the exact amounts for a swap and the resulting price change. Understanding these calculations is crucial for grasping how AMMs work.
3. Constant Product Formula Deep Dive
3.1 The Basic Formula
The core of AMM is the constant product formula:
x * y = k
Where:
x and y are the quantities of two tokens in the pool
k is a constant that remains the same before and after trades
Here's how we can represent this in Move code:
fun check_constant_product(
    x1: u64,      // initial amount of token X
    y1: u64,      // initial amount of token Y
    x2: u64,      // final amount of token X
    y2: u64       // final amount of token Y
): bool {
    let k1 = (x1 as u128) * (y1 as u128);
    let k2 = (x2 as u128) * (y2 as u128);
    k1 == k2
}
This function checks if the product of token amounts remains constant before and after a trade. We use u128 to avoid overflow in multiplication.
3.2 Real-world Examples
Example 1: Small Trade
Let's start with a simple pool:
Pool X = 1000 tokens
Pool Y = 1000 tokens
k = 1,000,000
Now, let's say a user wants to swap 10 X tokens. We can calculate how many Y tokens they'll receive:
(1000 + 10) * (1000 - y) = 1,000,000
1010 * (1000 - y) = 1,000,000
y ≈ 9.9 Y tokens (received)
Here's a Move function to calculate this:
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
This function calculates how many tokens a user will receive based on the amount they're putting in and the current reserves. We use u128 for intermediate calculations to avoid overflow.
3.3 Understanding Price Impact
Price impact occurs because larger trades cause more significant price movements. Here's how we can calculate it:
public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
This function calculates the percentage change in price caused by a trade. Here's a breakdown:
We calculate the initial price (reserve_out / reserve_in).
We determine how many tokens the user will receive (amount_out).
We calculate the new reserves after the trade.
We determine the new price after the trade.
Finally, we calculate the percentage difference between the initial and final prices.
Understanding price impact is crucial for traders, as it helps them anticipate how their trades will affect the market and their returns.
4. Liquidity Provider Mechanics
4.1 Adding Liquidity
When adding liquidity to a pool, it's crucial to maintain the existing ratio of tokens. This ensures the pool's balance and price remain stable. Here's how to calculate the amount of token Y you need to add based on the amount of token X:
Amount Y to add = (Amount X to add * Pool Y) / Pool X
Let's break this down with a step-by-step example:
Initial Pool State:
Pool X: 1000 tokens
Pool Y: 2000 tokens
Current Price: 1 X = 2 Y
Step 1: Decide how much of token X you want to add
Let's say you want to add 100 X tokens.
Step 2: Calculate the required amount of Y tokens
Y needed = (100 * 2000) / 1000 = 200 Y
Step 3: Add liquidity
You'll need to add 100 X tokens and 200 Y tokens to maintain the pool's ratio.
This calculation ensures that you're adding liquidity in the correct proportion, preserving the pool's price equilibrium.
4.2 LP Token Distribution
Liquidity Provider (LP) tokens represent your share of the pool. They're crucial for tracking ownership and distributing rewards. Let's explore how LP tokens are calculated for both the first provider and subsequent providers.
For the first liquidity provider:
fun calculate_initial_lp_tokens(
    amount_x: u64,
    amount_y: u64
): u64 {
    let product = (amount_x as u128) * (amount_y as u128);
    let sqrt_product = math::sqrt(product);
    ((sqrt_product - MINIMUM_LIQUIDITY) as u64)
}
// Example usage:
let initial_x = 1000;
let initial_y = 2000;
let initial_lp_tokens = calculate_initial_lp_tokens(initial_x, initial_y);
This function calculates the initial LP tokens by taking the square root of the product of the two token amounts. We subtract a small amount (MINIMUM_LIQUIDITY) to prevent the first provider from owning 100% of the pool, which could lead to manipulation.
5. Real-world Scenarios
5.1 Trading Example
Let's walk through a complete trading scenario to understand how AMMs work in practice:
Initial Pool State:
Pool X: 10,000 tokens
Pool Y: 20,000 tokens
Initial Price: 1 X = 2 Y
// You can verify this price:
Price of X in terms of Y = Pool Y / Pool X = 20,000 / 10,000 = 2 Y per X
User wants to swap 1,000 X tokens:
// Step 1: Calculate Y tokens received before fee
// y = (Pool Y * Amount X) / (Pool X + Amount X)
// y = (20,000 * 1,000) / (10,000 + 1,000) = 1,818.18 Y
// Step 2: Apply the 0.25% fee
// y_after_fee = 1,818.18 * (1 - 0.0025) = 1,813.63 Y
// Let's implement this in code:
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
Final Pool State:
Pool X: 11,000 tokens (10,000 + 1,000)
Pool Y: 18,186.37 tokens (20,000 - 1,813.63)
New Price: 1 X = 1.65 Y (18,186.37 / 11,000)
// Verify the constant product:
Before trade: 10,000 * 20,000 = 200,000,000
After trade: 11,000 * 18,186.37 ≈ 200,050,070 (slight increase due to fees)
This example demonstrates how a trade affects the pool's balance and price. The price of X in terms of Y decreased because we added X to the pool and removed Y.
5.2 Providing Liquidity Example
Initial Pool:
// Pool X: 10,000 tokens
// Pool Y: 20,000 tokens
// LP Total Supply: 14,142 tokens (sqrt(10,000 * 20,000))
// Let's implement this in code:
fun calculate_initial_lp_supply(reserve_x: u64, reserve_y: u64): u64 {
    let product = (reserve_x as u128) * (reserve_y as u128);
    (math::sqrt(product) as u64)
}
Adding 1,000 X and 2,000 Y:
// Step 1: Calculate the share of the pool
// share = min((1,000 / 10,000), (2,000 / 20,000)) = 0.1 or 10%
// Step 2: Calculate new LP tokens
// new_lp_tokens = 0.1 * 14,142 = 1,414.2 LP tokens
// Let's implement this in code:
fun calculate_lp_tokens_to_mint(
    amount_x: u64,
    amount_y: u64,
    reserve_x: u64,
    reserve_y: u64,
    total_supply: u64
): u64 {
    let share_x = ((amount_x as u128) * (total_supply as u128)) / (reserve_x as u128);
    let share_y = ((amount_y as u128) * (total_supply as u128)) / (reserve_y as u128);
    min(share_x, share_y) as u64
}
This example shows how to calculate the number of LP tokens a liquidity provider receives when adding to an existing pool. The provider receives LP tokens proportional to their share of the pool's liquidity.
			1. Traditional Markets vs AMM
Traditional Markets
In traditional markets (such as stock exchanges):
Buyers and sellers place orders
Orders are matched when prices align
Participants must wait for a matching counterparty
An order book system is used
Example of an order book:
Buy Orders:     Sell Orders:
$10.00 - 100    $10.20 - 150
$9.90  - 200    $10.30 - 100
$9.80  - 150    $10.40 - 200
In this example, buyers are willing to buy at $10.00 or lower, while sellers are asking $10.20 or higher. A trade occurs when these prices meet.
AMM Approach
In Automated Market Makers (AMM):
No order book is used
Buyers and sellers don't need to be matched
Trades occur against a liquidity pool
Prices are determined by a mathematical formula
Instant trades are available at any time
Let's look at a simple AMM example:
// Simple AMM swap function
fun swap(amount_in: u64, reserve_in: u64, reserve_out: u64): u64 {
    let fee = 3; // 0.3% fee (3 basis points)
    let amount_in_with_fee = amount_in * (1000 - fee) / 1000;
    let numerator = (amount_in_with_fee as u128) * (reserve_out as u128);
    let denominator = (reserve_in as u128) + (amount_in_with_fee as u128);
    ((numerator / denominator) as u64)
}
This code demonstrates a basic AMM swap. Users can trade instantly without waiting for a counterparty, and the price is determined by the ratio of tokens in the pool.
2. Understanding Liquidity Pools
2.1 Basic Concept
Imagine a liquidity pool as two interconnected water tanks:
Tank X [1000 X] ←→ Tank Y [1000 Y]
Adding X yields Y
Adding Y yields X
The ratio between X and Y determines the price
This code demonstrates how a liquidity pool maintains balance and adjusts prices based on trades.
2.2 Simple Example
Initial pool:
Pool X: 1000 tokens
Pool Y: 1000 tokens
Price: 1 X = 1 Y
After swapping 100 X:
Pool X: 1100 tokens
Pool Y: 909.09 tokens (approximately)
Price: 1 X = 0.826 Y
Let's calculate this swap step-by-step:
fun swap_tokens(
    initial_x: u64,
    initial_y: u64,
    swap_amount: u64
): (u64, u64, FixedPoint32) {
    let new_y = (initial_x as u128) * (initial_y as u128) / ((initial_x + swap_amount) as u128);
    let y_out = initial_y - (new_y as u64);
    let new_x = initial_x + swap_amount;
    let new_price = FixedPoint32::create_from_rational(new_y as u64, new_x)
    (y_out, new_y as u64, new_price)
}
This code shows how to calculate the exact amounts for a swap and the resulting price change. Understanding these calculations is crucial for grasping how AMMs work.
3. Constant Product Formula Deep Dive
3.1 The Basic Formula
The core of AMM is the constant product formula:
x * y = k
Where:
x and y are the quantities of two tokens in the pool
k is a constant that remains the same before and after trades
Here's how we can represent this in Move code:
fun check_constant_product(
    x1: u64,      // initial amount of token X
    y1: u64,      // initial amount of token Y
    x2: u64,      // final amount of token X
    y2: u64       // final amount of token Y
): bool {
    let k1 = (x1 as u128) * (y1 as u128);
    let k2 = (x2 as u128) * (y2 as u128);
    k1 == k2
}
This function checks if the product of token amounts remains constant before and after a trade. We use u128 to avoid overflow in multiplication.
3.2 Real-world Examples
Example 1: Small Trade
Let's start with a simple pool:
Pool X = 1000 tokens
Pool Y = 1000 tokens
k = 1,000,000
Now, let's say a user wants to swap 10 X tokens. We can calculate how many Y tokens they'll receive:
(1000 + 10) * (1000 - y) = 1,000,000
1010 * (1000 - y) = 1,000,000
y ≈ 9.9 Y tokens (received)
Here's a Move function to calculate this:
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
This function calculates how many tokens a user will receive based on the amount they're putting in and the current reserves. We use u128 for intermediate calculations to avoid overflow.
3.3 Understanding Price Impact
Price impact occurs because larger trades cause more significant price movements. Here's how we can calculate it:
public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
This function calculates the percentage change in price caused by a trade. Here's a breakdown:
We calculate the initial price (reserve_out / reserve_in).
We determine how many tokens the user will receive (amount_out).
We calculate the new reserves after the trade.
We determine the new price after the trade.
Finally, we calculate the percentage difference between the initial and final prices.
Understanding price impact is crucial for traders, as it helps them anticipate how their trades will affect the market and their returns.
4. Liquidity Provider Mechanics
4.1 Adding Liquidity
When adding liquidity to a pool, it's crucial to maintain the existing ratio of tokens. This ensures the pool's balance and price remain stable. Here's how to calculate the amount of token Y you need to add based on the amount of token X:
Amount Y to add = (Amount X to add * Pool Y) / Pool X
Let's break this down with a step-by-step example:
Initial Pool State:
Pool X: 1000 tokens
Pool Y: 2000 tokens
Current Price: 1 X = 2 Y
Step 1: Decide how much of token X you want to add
Let's say you want to add 100 X tokens.
Step 2: Calculate the required amount of Y tokens
Y needed = (100 * 2000) / 1000 = 200 Y
Step 3: Add liquidity
You'll need to add 100 X tokens and 200 Y tokens to maintain the pool's ratio.
This calculation ensures that you're adding liquidity in the correct proportion, preserving the pool's price equilibrium.
4.2 LP Token Distribution
Liquidity Provider (LP) tokens represent your share of the pool. They're crucial for tracking ownership and distributing rewards. Let's explore how LP tokens are calculated for both the first provider and subsequent providers.
For the first liquidity provider:
fun calculate_initial_lp_tokens(
    amount_x: u64,
    amount_y: u64
): u64 {
    let product = (amount_x as u128) * (amount_y as u128);
    let sqrt_product = math::sqrt(product);
    ((sqrt_product - MINIMUM_LIQUIDITY) as u64)
}
// Example usage:
let initial_x = 1000;
let initial_y = 2000;
let initial_lp_tokens = calculate_initial_lp_tokens(initial_x, initial_y);
This function calculates the initial LP tokens by taking the square root of the product of the two token amounts. We subtract a small amount (MINIMUM_LIQUIDITY) to prevent the first provider from owning 100% of the pool, which could lead to manipulation.
5. Real-world Scenarios
5.1 Trading Example
Let's walk through a complete trading scenario to understand how AMMs work in practice:
Initial Pool State:
Pool X: 10,000 tokens
Pool Y: 20,000 tokens
Initial Price: 1 X = 2 Y
// You can verify this price:
Price of X in terms of Y = Pool Y / Pool X = 20,000 / 10,000 = 2 Y per X
User wants to swap 1,000 X tokens:
// Step 1: Calculate Y tokens received before fee
// y = (Pool Y * Amount X) / (Pool X + Amount X)
// y = (20,000 * 1,000) / (10,000 + 1,000) = 1,818.18 Y
// Step 2: Apply the 0.25% fee
// y_after_fee = 1,818.18 * (1 - 0.0025) = 1,813.63 Y
// Let's implement this in code:
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
Final Pool State:
Pool X: 11,000 tokens (10,000 + 1,000)
Pool Y: 18,186.37 tokens (20,000 - 1,813.63)
New Price: 1 X = 1.65 Y (18,186.37 / 11,000)
// Verify the constant product:
Before trade: 10,000 * 20,000 = 200,000,000
After trade: 11,000 * 18,186.37 ≈ 200,050,070 (slight increase due to fees)
This example demonstrates how a trade affects the pool's balance and price. The price of X in terms of Y decreased because we added X to the pool and removed Y.
5.2 Providing Liquidity Example
Initial Pool:
// Pool X: 10,000 tokens
// Pool Y: 20,000 tokens
// LP Total Supply: 14,142 tokens (sqrt(10,000 * 20,000))
// Let's implement this in code:
fun calculate_initial_lp_supply(reserve_x: u64, reserve_y: u64): u64 {
    let product = (reserve_x as u128) * (reserve_y as u128);
    (math::sqrt(product) as u64)
}
Adding 1,000 X and 2,000 Y:
// Step 1: Calculate the share of the pool
// share = min((1,000 / 10,000), (2,000 / 20,000)) = 0.1 or 10%
// Step 2: Calculate new LP tokens
// new_lp_tokens = 0.1 * 14,142 = 1,414.2 LP tokens
// Let's implement this in code:
fun calculate_lp_tokens_to_mint(
    amount_x: u64,
    amount_y: u64,
    reserve_x: u64,
    reserve_y: u64,
    total_supply: u64
): u64 {
    let share_x = ((amount_x as u128) * (total_supply as u128)) / (reserve_x as u128);
    let share_y = ((amount_y as u128) * (total_supply as u128)) / (reserve_y as u128);
    min(share_x, share_y) as u64
}
This example shows how to calculate the number of LP tokens a liquidity provider receives when adding to an existing pool. The provider receives LP tokens proportional to their share of the pool's liquidity.
			1. Traditional Markets vs AMM
Traditional Markets
In traditional markets (such as stock exchanges):
Buyers and sellers place orders
Orders are matched when prices align
Participants must wait for a matching counterparty
An order book system is used
Example of an order book:
Buy Orders:     Sell Orders:
$10.00 - 100    $10.20 - 150
$9.90  - 200    $10.30 - 100
$9.80  - 150    $10.40 - 200
In this example, buyers are willing to buy at $10.00 or lower, while sellers are asking $10.20 or higher. A trade occurs when these prices meet.
AMM Approach
In Automated Market Makers (AMM):
No order book is used
Buyers and sellers don't need to be matched
Trades occur against a liquidity pool
Prices are determined by a mathematical formula
Instant trades are available at any time
Let's look at a simple AMM example:
// Simple AMM swap function
fun swap(amount_in: u64, reserve_in: u64, reserve_out: u64): u64 {
    let fee = 3; // 0.3% fee (3 basis points)
    let amount_in_with_fee = amount_in * (1000 - fee) / 1000;
    let numerator = (amount_in_with_fee as u128) * (reserve_out as u128);
    let denominator = (reserve_in as u128) + (amount_in_with_fee as u128);
    ((numerator / denominator) as u64)
}
This code demonstrates a basic AMM swap. Users can trade instantly without waiting for a counterparty, and the price is determined by the ratio of tokens in the pool.
2. Understanding Liquidity Pools
2.1 Basic Concept
Imagine a liquidity pool as two interconnected water tanks:
Tank X [1000 X] ←→ Tank Y [1000 Y]
Adding X yields Y
Adding Y yields X
The ratio between X and Y determines the price
This code demonstrates how a liquidity pool maintains balance and adjusts prices based on trades.
2.2 Simple Example
Initial pool:
Pool X: 1000 tokens
Pool Y: 1000 tokens
Price: 1 X = 1 Y
After swapping 100 X:
Pool X: 1100 tokens
Pool Y: 909.09 tokens (approximately)
Price: 1 X = 0.826 Y
Let's calculate this swap step-by-step:
fun swap_tokens(
    initial_x: u64,
    initial_y: u64,
    swap_amount: u64
): (u64, u64, FixedPoint32) {
    let new_y = (initial_x as u128) * (initial_y as u128) / ((initial_x + swap_amount) as u128);
    let y_out = initial_y - (new_y as u64);
    let new_x = initial_x + swap_amount;
    let new_price = FixedPoint32::create_from_rational(new_y as u64, new_x)
    (y_out, new_y as u64, new_price)
}
This code shows how to calculate the exact amounts for a swap and the resulting price change. Understanding these calculations is crucial for grasping how AMMs work.
3. Constant Product Formula Deep Dive
3.1 The Basic Formula
The core of AMM is the constant product formula:
x * y = k
Where:
x and y are the quantities of two tokens in the pool
k is a constant that remains the same before and after trades
Here's how we can represent this in Move code:
fun check_constant_product(
    x1: u64,      // initial amount of token X
    y1: u64,      // initial amount of token Y
    x2: u64,      // final amount of token X
    y2: u64       // final amount of token Y
): bool {
    let k1 = (x1 as u128) * (y1 as u128);
    let k2 = (x2 as u128) * (y2 as u128);
    k1 == k2
}
This function checks if the product of token amounts remains constant before and after a trade. We use u128 to avoid overflow in multiplication.
3.2 Real-world Examples
Example 1: Small Trade
Let's start with a simple pool:
Pool X = 1000 tokens
Pool Y = 1000 tokens
k = 1,000,000
Now, let's say a user wants to swap 10 X tokens. We can calculate how many Y tokens they'll receive:
(1000 + 10) * (1000 - y) = 1,000,000
1010 * (1000 - y) = 1,000,000
y ≈ 9.9 Y tokens (received)
Here's a Move function to calculate this:
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
This function calculates how many tokens a user will receive based on the amount they're putting in and the current reserves. We use u128 for intermediate calculations to avoid overflow.
3.3 Understanding Price Impact
Price impact occurs because larger trades cause more significant price movements. Here's how we can calculate it:
public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
This function calculates the percentage change in price caused by a trade. Here's a breakdown:
We calculate the initial price (reserve_out / reserve_in).
We determine how many tokens the user will receive (amount_out).
We calculate the new reserves after the trade.
We determine the new price after the trade.
Finally, we calculate the percentage difference between the initial and final prices.
Understanding price impact is crucial for traders, as it helps them anticipate how their trades will affect the market and their returns.
4. Liquidity Provider Mechanics
4.1 Adding Liquidity
When adding liquidity to a pool, it's crucial to maintain the existing ratio of tokens. This ensures the pool's balance and price remain stable. Here's how to calculate the amount of token Y you need to add based on the amount of token X:
Amount Y to add = (Amount X to add * Pool Y) / Pool X
Let's break this down with a step-by-step example:
Initial Pool State:
Pool X: 1000 tokens
Pool Y: 2000 tokens
Current Price: 1 X = 2 Y
Step 1: Decide how much of token X you want to add
Let's say you want to add 100 X tokens.
Step 2: Calculate the required amount of Y tokens
Y needed = (100 * 2000) / 1000 = 200 Y
Step 3: Add liquidity
You'll need to add 100 X tokens and 200 Y tokens to maintain the pool's ratio.
This calculation ensures that you're adding liquidity in the correct proportion, preserving the pool's price equilibrium.
4.2 LP Token Distribution
Liquidity Provider (LP) tokens represent your share of the pool. They're crucial for tracking ownership and distributing rewards. Let's explore how LP tokens are calculated for both the first provider and subsequent providers.
For the first liquidity provider:
fun calculate_initial_lp_tokens(
    amount_x: u64,
    amount_y: u64
): u64 {
    let product = (amount_x as u128) * (amount_y as u128);
    let sqrt_product = math::sqrt(product);
    ((sqrt_product - MINIMUM_LIQUIDITY) as u64)
}
// Example usage:
let initial_x = 1000;
let initial_y = 2000;
let initial_lp_tokens = calculate_initial_lp_tokens(initial_x, initial_y);
This function calculates the initial LP tokens by taking the square root of the product of the two token amounts. We subtract a small amount (MINIMUM_LIQUIDITY) to prevent the first provider from owning 100% of the pool, which could lead to manipulation.
5. Real-world Scenarios
5.1 Trading Example
Let's walk through a complete trading scenario to understand how AMMs work in practice:
Initial Pool State:
Pool X: 10,000 tokens
Pool Y: 20,000 tokens
Initial Price: 1 X = 2 Y
// You can verify this price:
Price of X in terms of Y = Pool Y / Pool X = 20,000 / 10,000 = 2 Y per X
User wants to swap 1,000 X tokens:
// Step 1: Calculate Y tokens received before fee
// y = (Pool Y * Amount X) / (Pool X + Amount X)
// y = (20,000 * 1,000) / (10,000 + 1,000) = 1,818.18 Y
// Step 2: Apply the 0.25% fee
// y_after_fee = 1,818.18 * (1 - 0.0025) = 1,813.63 Y
// Let's implement this in code:
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
Final Pool State:
Pool X: 11,000 tokens (10,000 + 1,000)
Pool Y: 18,186.37 tokens (20,000 - 1,813.63)
New Price: 1 X = 1.65 Y (18,186.37 / 11,000)
// Verify the constant product:
Before trade: 10,000 * 20,000 = 200,000,000
After trade: 11,000 * 18,186.37 ≈ 200,050,070 (slight increase due to fees)
This example demonstrates how a trade affects the pool's balance and price. The price of X in terms of Y decreased because we added X to the pool and removed Y.
5.2 Providing Liquidity Example
Initial Pool:
// Pool X: 10,000 tokens
// Pool Y: 20,000 tokens
// LP Total Supply: 14,142 tokens (sqrt(10,000 * 20,000))
// Let's implement this in code:
fun calculate_initial_lp_supply(reserve_x: u64, reserve_y: u64): u64 {
    let product = (reserve_x as u128) * (reserve_y as u128);
    (math::sqrt(product) as u64)
}
Adding 1,000 X and 2,000 Y:
// Step 1: Calculate the share of the pool
// share = min((1,000 / 10,000), (2,000 / 20,000)) = 0.1 or 10%
// Step 2: Calculate new LP tokens
// new_lp_tokens = 0.1 * 14,142 = 1,414.2 LP tokens
// Let's implement this in code:
fun calculate_lp_tokens_to_mint(
    amount_x: u64,
    amount_y: u64,
    reserve_x: u64,
    reserve_y: u64,
    total_supply: u64
): u64 {
    let share_x = ((amount_x as u128) * (total_supply as u128)) / (reserve_x as u128);
    let share_y = ((amount_y as u128) * (total_supply as u128)) / (reserve_y as u128);
    min(share_x, share_y) as u64
}
This example shows how to calculate the number of LP tokens a liquidity provider receives when adding to an existing pool. The provider receives LP tokens proportional to their share of the pool's liquidity.
	1. Traditional Markets vs AMM
	1. Traditional Markets vs AMM
		Traditional Markets
		Traditional Markets
		In traditional markets (such as stock exchanges):
		In traditional markets (such as stock exchanges):
		Buyers and sellers place orders
Orders are matched when prices align
Participants must wait for a matching counterparty
An order book system is used
		Buyers and sellers place orders
		Buyers and sellers place orders
		Orders are matched when prices align
		Orders are matched when prices align
		Participants must wait for a matching counterparty
		Participants must wait for a matching counterparty
		An order book system is used
		An order book system is used
		Example of an order book:
		Example of an order book:
		<code>Buy Orders:     Sell Orders:
$10.00 - 100    $10.20 - 150
$9.90  - 200    $10.30 - 100
$9.80  - 150    $10.40 - 200</code>
		<code>Buy Orders:     Sell Orders:
$10.00 - 100    $10.20 - 150
$9.90  - 200    $10.30 - 100
$9.80  - 150    $10.40 - 200</code>
		Buy Orders:     Sell Orders:
$10.00 - 100    $10.20 - 150
$9.90  - 200    $10.30 - 100
$9.80  - 150    $10.40 - 200
		In this example, buyers are willing to buy at $10.00 or lower, while sellers are asking $10.20 or higher. A trade occurs when these prices meet.
		In this example, buyers are willing to buy at $10.00 or lower, while sellers are asking $10.20 or higher. A trade occurs when these prices meet.
		AMM Approach
		AMM Approach
		In Automated Market Makers (AMM):
		In Automated Market Makers (AMM):
		No order book is used
Buyers and sellers don't need to be matched
Trades occur against a liquidity pool
Prices are determined by a mathematical formula
Instant trades are available at any time
		No order book is used
		No order book is used
		Buyers and sellers don't need to be matched
		Buyers and sellers don't need to be matched
		Trades occur against a liquidity pool
		Trades occur against a liquidity pool
		Prices are determined by a mathematical formula
		Prices are determined by a mathematical formula
		Instant trades are available at any time
		Instant trades are available at any time
		Let's look at a simple AMM example:
		Let's look at a simple AMM example:
		<code>// Simple AMM swap function
fun swap(amount_in: u64, reserve_in: u64, reserve_out: u64): u64 {
    let fee = 3; // 0.3% fee (3 basis points)
    let amount_in_with_fee = amount_in * (1000 - fee) / 1000;
    let numerator = (amount_in_with_fee as u128) * (reserve_out as u128);
    let denominator = (reserve_in as u128) + (amount_in_with_fee as u128);
    ((numerator / denominator) as u64)
}</code>
		<code>// Simple AMM swap function
fun swap(amount_in: u64, reserve_in: u64, reserve_out: u64): u64 {
    let fee = 3; // 0.3% fee (3 basis points)
    let amount_in_with_fee = amount_in * (1000 - fee) / 1000;
    let numerator = (amount_in_with_fee as u128) * (reserve_out as u128);
    let denominator = (reserve_in as u128) + (amount_in_with_fee as u128);
    ((numerator / denominator) as u64)
}</code>
		// Simple AMM swap function
fun swap(amount_in: u64, reserve_in: u64, reserve_out: u64): u64 {
    let fee = 3; // 0.3% fee (3 basis points)
    let amount_in_with_fee = amount_in * (1000 - fee) / 1000;
    let numerator = (amount_in_with_fee as u128) * (reserve_out as u128);
    let denominator = (reserve_in as u128) + (amount_in_with_fee as u128);
    ((numerator / denominator) as u64)
}
		This code demonstrates a basic AMM swap. Users can trade instantly without waiting for a counterparty, and the price is determined by the ratio of tokens in the pool.
		This code demonstrates a basic AMM swap. Users can trade instantly without waiting for a counterparty, and the price is determined by the ratio of tokens in the pool.
	2. Understanding Liquidity Pools
	2. Understanding Liquidity Pools
		2.1 Basic Concept
		2.1 Basic Concept
		Imagine a liquidity pool as two interconnected water tanks:
		Imagine a liquidity pool as two interconnected water tanks:
		<code>Tank X [1000 X] ←→ Tank Y [1000 Y]</code>
		<code>Tank X [1000 X] ←→ Tank Y [1000 Y]</code>
		Tank X [1000 X] ←→ Tank Y [1000 Y]
		Adding X yields Y
Adding Y yields X
The ratio between X and Y determines the price
		Adding X yields Y
		Adding X yields Y
		Adding Y yields X
		Adding Y yields X
		The ratio between X and Y determines the price
		The ratio between X and Y determines the price
		This code demonstrates how a liquidity pool maintains balance and adjusts prices based on trades.
		This code demonstrates how a liquidity pool maintains balance and adjusts prices based on trades.
		2.2 Simple Example
		2.2 Simple Example
		Initial pool:
		Initial pool:
		<code>Pool X: 1000 tokens
Pool Y: 1000 tokens
Price: 1 X = 1 Y</code>
		<code>Pool X: 1000 tokens
Pool Y: 1000 tokens
Price: 1 X = 1 Y</code>
		Pool X: 1000 tokens
Pool Y: 1000 tokens
Price: 1 X = 1 Y
		After swapping 100 X:
		After swapping 100 X:
		<code>Pool X: 1100 tokens
Pool Y: 909.09 tokens (approximately)
Price: 1 X = 0.826 Y</code>
		<code>Pool X: 1100 tokens
Pool Y: 909.09 tokens (approximately)
Price: 1 X = 0.826 Y</code>
		Pool X: 1100 tokens
Pool Y: 909.09 tokens (approximately)
Price: 1 X = 0.826 Y
		Let's calculate this swap step-by-step:
		Let's calculate this swap step-by-step:
		<code>fun swap_tokens(
    initial_x: u64,
    initial_y: u64,
    swap_amount: u64
): (u64, u64, FixedPoint32) {
    let new_y = (initial_x as u128) * (initial_y as u128) / ((initial_x + swap_amount) as u128);
    let y_out = initial_y - (new_y as u64);
    let new_x = initial_x + swap_amount;
    let new_price = FixedPoint32::create_from_rational(new_y as u64, new_x)
    (y_out, new_y as u64, new_price)
}</code>
		<code>fun swap_tokens(
    initial_x: u64,
    initial_y: u64,
    swap_amount: u64
): (u64, u64, FixedPoint32) {
    let new_y = (initial_x as u128) * (initial_y as u128) / ((initial_x + swap_amount) as u128);
    let y_out = initial_y - (new_y as u64);
    let new_x = initial_x + swap_amount;
    let new_price = FixedPoint32::create_from_rational(new_y as u64, new_x)
    (y_out, new_y as u64, new_price)
}</code>
		fun swap_tokens(
    initial_x: u64,
    initial_y: u64,
    swap_amount: u64
): (u64, u64, FixedPoint32) {
    let new_y = (initial_x as u128) * (initial_y as u128) / ((initial_x + swap_amount) as u128);
    let y_out = initial_y - (new_y as u64);
    let new_x = initial_x + swap_amount;
    let new_price = FixedPoint32::create_from_rational(new_y as u64, new_x)
    (y_out, new_y as u64, new_price)
}
		This code shows how to calculate the exact amounts for a swap and the resulting price change. Understanding these calculations is crucial for grasping how AMMs work.
		This code shows how to calculate the exact amounts for a swap and the resulting price change. Understanding these calculations is crucial for grasping how AMMs work.
	3. Constant Product Formula Deep Dive
	3. Constant Product Formula Deep Dive
		3.1 The Basic Formula
		3.1 The Basic Formula
		The core of AMM is the constant product formula:
		The core of AMM is the constant product formula:
		<code>x * y = k</code>
		<code>x * y = k</code>
		x * y = k
		Where:
		Where:
		x and y are the quantities of two tokens in the pool
k is a constant that remains the same before and after trades
		x and y are the quantities of two tokens in the pool
		x and y are the quantities of two tokens in the pool
		k is a constant that remains the same before and after trades
		k is a constant that remains the same before and after trades
		Here's how we can represent this in Move code:
		Here's how we can represent this in Move code:
		<code>fun check_constant_product(
    x1: u64,      // initial amount of token X
    y1: u64,      // initial amount of token Y
    x2: u64,      // final amount of token X
    y2: u64       // final amount of token Y
): bool {
    let k1 = (x1 as u128) * (y1 as u128);
    let k2 = (x2 as u128) * (y2 as u128);
    k1 == k2
}</code>
		<code>fun check_constant_product(
    x1: u64,      // initial amount of token X
    y1: u64,      // initial amount of token Y
    x2: u64,      // final amount of token X
    y2: u64       // final amount of token Y
): bool {
    let k1 = (x1 as u128) * (y1 as u128);
    let k2 = (x2 as u128) * (y2 as u128);
    k1 == k2
}</code>
		fun check_constant_product(
    x1: u64,      // initial amount of token X
    y1: u64,      // initial amount of token Y
    x2: u64,      // final amount of token X
    y2: u64       // final amount of token Y
): bool {
    let k1 = (x1 as u128) * (y1 as u128);
    let k2 = (x2 as u128) * (y2 as u128);
    k1 == k2
}
		This function checks if the product of token amounts remains constant before and after a trade. We use u128 to avoid overflow in multiplication.
		This function checks if the product of token amounts remains constant before and after a trade. We use u128 to avoid overflow in multiplication.
		3.2 Real-world Examples
		3.2 Real-world Examples
		Example 1: Small Trade
		Example 1: Small Trade
		Let's start with a simple pool:
		Let's start with a simple pool:
		<code>Pool X = 1000 tokens
Pool Y = 1000 tokens
k = 1,000,000</code>
		<code>Pool X = 1000 tokens
Pool Y = 1000 tokens
k = 1,000,000</code>
		Pool X = 1000 tokens
Pool Y = 1000 tokens
k = 1,000,000
		Now, let's say a user wants to swap 10 X tokens. We can calculate how many Y tokens they'll receive:
		Now, let's say a user wants to swap 10 X tokens. We can calculate how many Y tokens they'll receive:
		<code>(1000 + 10) * (1000 - y) = 1,000,000
1010 * (1000 - y) = 1,000,000
y ≈ 9.9 Y tokens (received)</code>
		<code>(1000 + 10) * (1000 - y) = 1,000,000
1010 * (1000 - y) = 1,000,000
y ≈ 9.9 Y tokens (received)</code>
		(1000 + 10) * (1000 - y) = 1,000,000
1010 * (1000 - y) = 1,000,000
y ≈ 9.9 Y tokens (received)
		Here's a Move function to calculate this:
		Here's a Move function to calculate this:
		<code>public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}</code>
		<code>public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}</code>
		public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
		This function calculates how many tokens a user will receive based on the amount they're putting in and the current reserves. We use u128 for intermediate calculations to avoid overflow.
		This function calculates how many tokens a user will receive based on the amount they're putting in and the current reserves. We use u128 for intermediate calculations to avoid overflow.
		3.3 Understanding Price Impact
		3.3 Understanding Price Impact
		Price impact occurs because larger trades cause more significant price movements. Here's how we can calculate it:
		Price impact occurs because larger trades cause more significant price movements. Here's how we can calculate it:
		<code>public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}</code>
		<code>public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}</code>
		public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
		This function calculates the percentage change in price caused by a trade. Here's a breakdown:
		This function calculates the percentage change in price caused by a trade. Here's a breakdown:
		We calculate the initial price (reserve_out / reserve_in).
We determine how many tokens the user will receive (amount_out).
We calculate the new reserves after the trade.
We determine the new price after the trade.
Finally, we calculate the percentage difference between the initial and final prices.
		We calculate the initial price (reserve_out / reserve_in).
		We calculate the initial price (reserve_out / reserve_in).
		We determine how many tokens the user will receive (amount_out).
		We determine how many tokens the user will receive (amount_out).
		We calculate the new reserves after the trade.
		We calculate the new reserves after the trade.
		We determine the new price after the trade.
		We determine the new price after the trade.
		Finally, we calculate the percentage difference between the initial and final prices.
		Finally, we calculate the percentage difference between the initial and final prices.
		Understanding price impact is crucial for traders, as it helps them anticipate how their trades will affect the market and their returns.
		Understanding price impact is crucial for traders, as it helps them anticipate how their trades will affect the market and their returns.
	4. Liquidity Provider Mechanics
	4. Liquidity Provider Mechanics
		4.1 Adding Liquidity
		4.1 Adding Liquidity
		When adding liquidity to a pool, it's crucial to maintain the existing ratio of tokens. This ensures the pool's balance and price remain stable. Here's how to calculate the amount of token Y you need to add based on the amount of token X:
		When adding liquidity to a pool, it's crucial to maintain the existing ratio of tokens. This ensures the pool's balance and price remain stable. Here's how to calculate the amount of token Y you need to add based on the amount of token X:
		<code>Amount Y to add = (Amount X to add * Pool Y) / Pool X</code>
		<code>Amount Y to add = (Amount X to add * Pool Y) / Pool X</code>
		Amount Y to add = (Amount X to add * Pool Y) / Pool X
		Let's break this down with a step-by-step example:
		Let's break this down with a step-by-step example:
		<code>Initial Pool State:
Pool X: 1000 tokens
Pool Y: 2000 tokens
Current Price: 1 X = 2 Y
Step 1: Decide how much of token X you want to add
Let's say you want to add 100 X tokens.
Step 2: Calculate the required amount of Y tokens
Y needed = (100 * 2000) / 1000 = 200 Y
Step 3: Add liquidity
You'll need to add 100 X tokens and 200 Y tokens to maintain the pool's ratio.</code>
		<code>Initial Pool State:
Pool X: 1000 tokens
Pool Y: 2000 tokens
Current Price: 1 X = 2 Y
Step 1: Decide how much of token X you want to add
Let's say you want to add 100 X tokens.
Step 2: Calculate the required amount of Y tokens
Y needed = (100 * 2000) / 1000 = 200 Y
Step 3: Add liquidity
You'll need to add 100 X tokens and 200 Y tokens to maintain the pool's ratio.</code>
		Initial Pool State:
Pool X: 1000 tokens
Pool Y: 2000 tokens
Current Price: 1 X = 2 Y
Step 1: Decide how much of token X you want to add
Let's say you want to add 100 X tokens.
Step 2: Calculate the required amount of Y tokens
Y needed = (100 * 2000) / 1000 = 200 Y
Step 3: Add liquidity
You'll need to add 100 X tokens and 200 Y tokens to maintain the pool's ratio.
		This calculation ensures that you're adding liquidity in the correct proportion, preserving the pool's price equilibrium.
		This calculation ensures that you're adding liquidity in the correct proportion, preserving the pool's price equilibrium.
		4.2 LP Token Distribution
		4.2 LP Token Distribution
		Liquidity Provider (LP) tokens represent your share of the pool. They're crucial for tracking ownership and distributing rewards. Let's explore how LP tokens are calculated for both the first provider and subsequent providers.
		Liquidity Provider (LP) tokens represent your share of the pool. They're crucial for tracking ownership and distributing rewards. Let's explore how LP tokens are calculated for both the first provider and subsequent providers.
		For the first liquidity provider:
		For the first liquidity provider:
		<code>fun calculate_initial_lp_tokens(
    amount_x: u64,
    amount_y: u64
): u64 {
    let product = (amount_x as u128) * (amount_y as u128);
    let sqrt_product = math::sqrt(product);
    ((sqrt_product - MINIMUM_LIQUIDITY) as u64)
}
// Example usage:
let initial_x = 1000;
let initial_y = 2000;
let initial_lp_tokens = calculate_initial_lp_tokens(initial_x, initial_y);</code>
		<code>fun calculate_initial_lp_tokens(
    amount_x: u64,
    amount_y: u64
): u64 {
    let product = (amount_x as u128) * (amount_y as u128);
    let sqrt_product = math::sqrt(product);
    ((sqrt_product - MINIMUM_LIQUIDITY) as u64)
}
// Example usage:
let initial_x = 1000;
let initial_y = 2000;
let initial_lp_tokens = calculate_initial_lp_tokens(initial_x, initial_y);</code>
		fun calculate_initial_lp_tokens(
    amount_x: u64,
    amount_y: u64
): u64 {
    let product = (amount_x as u128) * (amount_y as u128);
    let sqrt_product = math::sqrt(product);
    ((sqrt_product - MINIMUM_LIQUIDITY) as u64)
}
// Example usage:
let initial_x = 1000;
let initial_y = 2000;
let initial_lp_tokens = calculate_initial_lp_tokens(initial_x, initial_y);
		This function calculates the initial LP tokens by taking the square root of the product of the two token amounts. We subtract a small amount (MINIMUM_LIQUIDITY) to prevent the first provider from owning 100% of the pool, which could lead to manipulation.
		This function calculates the initial LP tokens by taking the square root of the product of the two token amounts. We subtract a small amount (MINIMUM_LIQUIDITY) to prevent the first provider from owning 100% of the pool, which could lead to manipulation.
	5. Real-world Scenarios
	5. Real-world Scenarios
		5.1 Trading Example
		5.1 Trading Example
		Let's walk through a complete trading scenario to understand how AMMs work in practice:
		Let's walk through a complete trading scenario to understand how AMMs work in practice:
		Initial Pool State:
		Initial Pool State:
		Initial Pool State:
		<code>Pool X: 10,000 tokens
Pool Y: 20,000 tokens
Initial Price: 1 X = 2 Y
// You can verify this price:
Price of X in terms of Y = Pool Y / Pool X = 20,000 / 10,000 = 2 Y per X</code>
		<code>Pool X: 10,000 tokens
Pool Y: 20,000 tokens
Initial Price: 1 X = 2 Y
// You can verify this price:
Price of X in terms of Y = Pool Y / Pool X = 20,000 / 10,000 = 2 Y per X</code>
		Pool X: 10,000 tokens
Pool Y: 20,000 tokens
Initial Price: 1 X = 2 Y
// You can verify this price:
Price of X in terms of Y = Pool Y / Pool X = 20,000 / 10,000 = 2 Y per X
		User wants to swap 1,000 X tokens:
		User wants to swap 1,000 X tokens:
		User wants to swap 1,000 X tokens:
		<code>// Step 1: Calculate Y tokens received before fee
// y = (Pool Y * Amount X) / (Pool X + Amount X)
// y = (20,000 * 1,000) / (10,000 + 1,000) = 1,818.18 Y
// Step 2: Apply the 0.25% fee
// y_after_fee = 1,818.18 * (1 - 0.0025) = 1,813.63 Y
// Let's implement this in code:
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}</code>
		<code>// Step 1: Calculate Y tokens received before fee
// y = (Pool Y * Amount X) / (Pool X + Amount X)
// y = (20,000 * 1,000) / (10,000 + 1,000) = 1,818.18 Y
// Step 2: Apply the 0.25% fee
// y_after_fee = 1,818.18 * (1 - 0.0025) = 1,813.63 Y
// Let's implement this in code:
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}</code>
		// Step 1: Calculate Y tokens received before fee
// y = (Pool Y * Amount X) / (Pool X + Amount X)
// y = (20,000 * 1,000) / (10,000 + 1,000) = 1,818.18 Y
// Step 2: Apply the 0.25% fee
// y_after_fee = 1,818.18 * (1 - 0.0025) = 1,813.63 Y
// Let's implement this in code:
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 9975u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
		Final Pool State:
		Final Pool State:
		Final Pool State:
		<code>Pool X: 11,000 tokens (10,000 + 1,000)
Pool Y: 18,186.37 tokens (20,000 - 1,813.63)
New Price: 1 X = 1.65 Y (18,186.37 / 11,000)
// Verify the constant product:
Before trade: 10,000 * 20,000 = 200,000,000
After trade: 11,000 * 18,186.37 ≈ 200,050,070 (slight increase due to fees)</code>
		<code>Pool X: 11,000 tokens (10,000 + 1,000)
Pool Y: 18,186.37 tokens (20,000 - 1,813.63)
New Price: 1 X = 1.65 Y (18,186.37 / 11,000)
// Verify the constant product:
Before trade: 10,000 * 20,000 = 200,000,000
After trade: 11,000 * 18,186.37 ≈ 200,050,070 (slight increase due to fees)</code>
		Pool X: 11,000 tokens (10,000 + 1,000)
Pool Y: 18,186.37 tokens (20,000 - 1,813.63)
New Price: 1 X = 1.65 Y (18,186.37 / 11,000)
// Verify the constant product:
Before trade: 10,000 * 20,000 = 200,000,000
After trade: 11,000 * 18,186.37 ≈ 200,050,070 (slight increase due to fees)
		This example demonstrates how a trade affects the pool's balance and price. The price of X in terms of Y decreased because we added X to the pool and removed Y.
		This example demonstrates how a trade affects the pool's balance and price. The price of X in terms of Y decreased because we added X to the pool and removed Y.
		5.2 Providing Liquidity Example
		5.2 Providing Liquidity Example
		Initial Pool:
		Initial Pool:
		Initial Pool:
		<code>// Pool X: 10,000 tokens
// Pool Y: 20,000 tokens
// LP Total Supply: 14,142 tokens (sqrt(10,000 * 20,000))
// Let's implement this in code:
fun calculate_initial_lp_supply(reserve_x: u64, reserve_y: u64): u64 {
    let product = (reserve_x as u128) * (reserve_y as u128);
    (math::sqrt(product) as u64)
}</code>
		<code>// Pool X: 10,000 tokens
// Pool Y: 20,000 tokens
// LP Total Supply: 14,142 tokens (sqrt(10,000 * 20,000))
// Let's implement this in code:
fun calculate_initial_lp_supply(reserve_x: u64, reserve_y: u64): u64 {
    let product = (reserve_x as u128) * (reserve_y as u128);
    (math::sqrt(product) as u64)
}</code>
		// Pool X: 10,000 tokens
// Pool Y: 20,000 tokens
// LP Total Supply: 14,142 tokens (sqrt(10,000 * 20,000))
// Let's implement this in code:
fun calculate_initial_lp_supply(reserve_x: u64, reserve_y: u64): u64 {
    let product = (reserve_x as u128) * (reserve_y as u128);
    (math::sqrt(product) as u64)
}
		Adding 1,000 X and 2,000 Y:
		Adding 1,000 X and 2,000 Y:
		Adding 1,000 X and 2,000 Y:
		<code>// Step 1: Calculate the share of the pool
// share = min((1,000 / 10,000), (2,000 / 20,000)) = 0.1 or 10%
// Step 2: Calculate new LP tokens
// new_lp_tokens = 0.1 * 14,142 = 1,414.2 LP tokens
// Let's implement this in code:
fun calculate_lp_tokens_to_mint(
    amount_x: u64,
    amount_y: u64,
    reserve_x: u64,
    reserve_y: u64,
    total_supply: u64
): u64 {
    let share_x = ((amount_x as u128) * (total_supply as u128)) / (reserve_x as u128);
    let share_y = ((amount_y as u128) * (total_supply as u128)) / (reserve_y as u128);
    min(share_x, share_y) as u64
}</code>
		<code>// Step 1: Calculate the share of the pool
// share = min((1,000 / 10,000), (2,000 / 20,000)) = 0.1 or 10%
// Step 2: Calculate new LP tokens
// new_lp_tokens = 0.1 * 14,142 = 1,414.2 LP tokens
// Let's implement this in code:
fun calculate_lp_tokens_to_mint(
    amount_x: u64,
    amount_y: u64,
    reserve_x: u64,
    reserve_y: u64,
    total_supply: u64
): u64 {
    let share_x = ((amount_x as u128) * (total_supply as u128)) / (reserve_x as u128);
    let share_y = ((amount_y as u128) * (total_supply as u128)) / (reserve_y as u128);
    min(share_x, share_y) as u64
}</code>
		// Step 1: Calculate the share of the pool
// share = min((1,000 / 10,000), (2,000 / 20,000)) = 0.1 or 10%
// Step 2: Calculate new LP tokens
// new_lp_tokens = 0.1 * 14,142 = 1,414.2 LP tokens
// Let's implement this in code:
fun calculate_lp_tokens_to_mint(
    amount_x: u64,
    amount_y: u64,
    reserve_x: u64,
    reserve_y: u64,
    total_supply: u64
): u64 {
    let share_x = ((amount_x as u128) * (total_supply as u128)) / (reserve_x as u128);
    let share_y = ((amount_y as u128) * (total_supply as u128)) / (reserve_y as u128);
    min(share_x, share_y) as u64
}
		This example shows how to calculate the number of LP tokens a liquidity provider receives when adding to an existing pool. The provider receives LP tokens proportional to their share of the pool's liquidity.
		This example shows how to calculate the number of LP tokens a liquidity provider receives when adding to an existing pool. The provider receives LP tokens proportional to their share of the pool's liquidity.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/02-swap/02-foundation-and-basic-structures
Foundation and Basic Structures
Foundation and Basic Structures
On This Page
Key Points:
Introduction
Core Data Structures
1. LPToken Structure
2. TokenPairMetadata Structure
3. TokenPairReserve Structure
4. SwapInfo Structure
Constants and Error Codes
Module Initialization
Event Structures
Next Steps
Key Points:
This guide covers building a Decentralized Exchange (DEX) using Move on the Movement blockchain
Core data structures include LPToken, TokenPairMetadata, TokenPairReserve, and SwapInfo
Constants and error codes are defined for consistency and error handling
Module initialization sets up basic DEX infrastructure
Event structures track important DEX operations
The tutorial covers fundamental components and will progress to implementing core functionalities
Introduction
Welcome to our comprehensive guide on building a Decentralized Exchange (DEX) using Move, the programming language for the Movement blockchain. In this tutorial, we'll break down the fundamental components of a DEX, making it accessible for beginners while providing in-depth explanations for more advanced concepts.
Core Data Structures
Let's start by exploring the essential data structures that form the backbone of our DEX. We'll explain each structure in detail, providing examples and use cases to help you understand their roles in the system.
1. LPToken Structure
struct LPToken<phantom X, phantom Y> has key {}
This structure represents Liquidity Provider (LP) tokens, which are given to users who provide liquidity to the exchange. Let's break it down:
struct LPToken
: Defines a new type called LPToken.
&lt;phantom X, phantom Y&gt;
: These are generic type parameters representing the two tokens in a trading pair. The
phantom
keyword means these types are used only for type checking, not for data storage.
has key
: This ability allows the struct to be stored as a top-level item in global storage.
Example usage:
// Creating an LPToken for a BTC-ETH pair
let btc_eth_lp_token: LPToken<BTC, ETH>;
2. TokenPairMetadata Structure
struct TokenPairMetadata<phantom X, phantom Y> has key {
    creator: address,
    fee_amount: coin::Coin<LPToken<X, Y>>,
    k_last: u128,
    balance_x: coin::Coin<X>,
    balance_y: coin::Coin<Y>,
    mint_cap: coin::MintCapability<LPToken<X, Y>>,
    burn_cap: coin::BurnCapability<LPToken<X, Y>>,
    freeze_cap: coin::FreezeCapability<LPToken<X, Y>>
}
This structure stores crucial information about each trading pair. Let's examine each field:
creator
: The address of the account that created this trading pair.
fee_amount
: Accumulated trading fees in the form of LP tokens.
k_last
: The last recorded product of reserves, used for fee calculations in constant product AMMs.
balance_x
and
balance_y
: Current balances of both tokens in the pair.
mint_cap
,
burn_cap
,
freeze_cap
: Capabilities for managing LP tokens.
Example usage:
let btc_eth_metadata = TokenPairMetadata<BTC, ETH> {
    creator: @0x1,
    fee_amount: coin::zero(),
    k_last: 1000000, // Initial k value
    balance_x: coin::zero<BTC>(),
    balance_y: coin::zero<ETH>(),
    mint_cap: // ... obtain mint capability
    burn_cap: // ... obtain burn capability
    freeze_cap: // ... obtain freeze capability
};
3. TokenPairReserve Structure
struct TokenPairReserve<phantom X, phantom Y> has key {
    reserve_x: u64,
    reserve_y: u64,
    block_timestamp_last: u64
}
This structure keeps track of the current state of liquidity reserves for a trading pair:
reserve_x
and
reserve_y
: Current reserves for both tokens in the pair.
block_timestamp_last
: Timestamp of the last update to the reserves.
4. SwapInfo Structure
struct SwapInfo has key {
    signer_cap: account::SignerCapability,
    fee_to: address,
    admin: address,
    pair_created: event::EventHandle<PairCreatedEvent>
}
This structure stores global configuration for the DEX:
signer_cap
: Capability to sign transactions on behalf of the DEX.
fee_to
: Address where trading fees are sent.
admin
: Address of the DEX administrator.
pair_created
: Event handle for tracking new trading pair creations.
Constants and Error Codes
Constants and error codes are crucial for maintaining consistency and proper error handling in your DEX. Let's break them down:
const ZERO_ACCOUNT: address = @0x0;
const DEFAULT_ADMIN: address = @movement;
const MINIMUM_LIQUIDITY: u128 = 1000;
const MAX_COIN_NAME_LENGTH: u64 = 32;
These constants define important values used throughout the DEX:
ZERO_ACCOUNT
: Represents an empty or null address.
DEFAULT_ADMIN
: The default administrator address for the DEX.
MINIMUM_LIQUIDITY
: The smallest amount of liquidity required to create a new pool.
MAX_COIN_NAME_LENGTH
: Maximum allowed length for coin names.
Error codes:
const ERROR_ONLY_ADMIN: u64 = 0x0001;
const ERROR_ALREADY_INITIALIZED: u64 = 0x001;
// ... (other error codes)
These error codes help identify specific issues that may occur during DEX operations:
ERROR_ONLY_ADMIN
: Thrown when a non-admin tries to perform an admin-only action.
ERROR_ALREADY_INITIALIZED
: Thrown when trying to initialize an already initialized component.
Module Initialization
The initialization function sets up the basic DEX infrastructure:
fun init_module(sender: &signer) {
    let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEFAULT_ADMIN);
    let resource_signer = account::create_signer_with_capability(&signer_cap);
    move_to(&resource_signer, SwapInfo {
        signer_cap,
        fee_to: ZERO_ACCOUNT,
        admin: DEFAULT_ADMIN,
        pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
    });
}
Let's break down this initialization process:
Retrieve the resource account capability using the sender and DEFAULT_ADMIN address.
Create a resource signer using the obtained capability.
Initialize the SwapInfo structure with default values.
Store the SwapInfo in the global storage using the resource signer.
Event Structures
Events are crucial for tracking important operations in your DEX. Let's examine the event structures:
struct PairCreatedEvent has drop, store {
    user: address,
    token_x: string::String,
    token_y: string::String
}
struct PairEventHolder<phantom X, phantom Y> has key {
    add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
    remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
    swap: event::EventHandle<SwapEvent<X, Y>>
}
These structures enable event tracking for various DEX operations:
PairCreatedEvent
: Emitted when a new trading pair is created.
PairEventHolder
: Holds event handles for liquidity operations and swaps.
Next Steps
Now that we've covered the fundamental structures and initialization of our DEX, in the next part of this tutorial, we'll delve into implementing core functionalities:
Creating and managing trading pairs
Implementing liquidity provision and removal
Developing the token swap mechanism
Calculating and distributing fees
Stay tuned for Part 2, where we'll build upon these foundations to create a fully functional DEX!
On This Page
Key Points:
Introduction
Core Data Structures
1. LPToken Structure
2. TokenPairMetadata Structure
3. TokenPairReserve Structure
4. SwapInfo Structure
Constants and Error Codes
Module Initialization
Event Structures
Next Steps
On This Page
Key Points:
Introduction
Core Data Structures
1. LPToken Structure
2. TokenPairMetadata Structure
3. TokenPairReserve Structure
4. SwapInfo Structure
Constants and Error Codes
Module Initialization
Event Structures
Next Steps
			On This Page
			On This Page
			Key Points:
Introduction
Core Data Structures
1. LPToken Structure
2. TokenPairMetadata Structure
3. TokenPairReserve Structure
4. SwapInfo Structure
Constants and Error Codes
Module Initialization
Event Structures
Next Steps
			Key Points:
			Key Points:
			Key Points:
			Key Points:
			Introduction
			Introduction
			Introduction
			Introduction
			Core Data Structures
1. LPToken Structure
2. TokenPairMetadata Structure
3. TokenPairReserve Structure
4. SwapInfo Structure
			Core Data Structures
			Core Data Structures
			Core Data Structures
			1. LPToken Structure
2. TokenPairMetadata Structure
3. TokenPairReserve Structure
4. SwapInfo Structure
			1. LPToken Structure
			1. LPToken Structure
			1. LPToken Structure
			1. LPToken Structure
			2. TokenPairMetadata Structure
			2. TokenPairMetadata Structure
			2. TokenPairMetadata Structure
			2. TokenPairMetadata Structure
			3. TokenPairReserve Structure
			3. TokenPairReserve Structure
			3. TokenPairReserve Structure
			3. TokenPairReserve Structure
			4. SwapInfo Structure
			4. SwapInfo Structure
			4. SwapInfo Structure
			4. SwapInfo Structure
			Constants and Error Codes
			Constants and Error Codes
			Constants and Error Codes
			Constants and Error Codes
			Module Initialization
			Module Initialization
			Module Initialization
			Module Initialization
			Event Structures
			Event Structures
			Event Structures
			Event Structures
			Next Steps
			Next Steps
			Next Steps
			Next Steps
			Key Points:
This guide covers building a Decentralized Exchange (DEX) using Move on the Movement blockchain
Core data structures include LPToken, TokenPairMetadata, TokenPairReserve, and SwapInfo
Constants and error codes are defined for consistency and error handling
Module initialization sets up basic DEX infrastructure
Event structures track important DEX operations
The tutorial covers fundamental components and will progress to implementing core functionalities
Introduction
Welcome to our comprehensive guide on building a Decentralized Exchange (DEX) using Move, the programming language for the Movement blockchain. In this tutorial, we'll break down the fundamental components of a DEX, making it accessible for beginners while providing in-depth explanations for more advanced concepts.
Core Data Structures
Let's start by exploring the essential data structures that form the backbone of our DEX. We'll explain each structure in detail, providing examples and use cases to help you understand their roles in the system.
1. LPToken Structure
struct LPToken<phantom X, phantom Y> has key {}
This structure represents Liquidity Provider (LP) tokens, which are given to users who provide liquidity to the exchange. Let's break it down:
struct LPToken
: Defines a new type called LPToken.
&lt;phantom X, phantom Y&gt;
: These are generic type parameters representing the two tokens in a trading pair. The
phantom
keyword means these types are used only for type checking, not for data storage.
has key
: This ability allows the struct to be stored as a top-level item in global storage.
Example usage:
// Creating an LPToken for a BTC-ETH pair
let btc_eth_lp_token: LPToken<BTC, ETH>;
2. TokenPairMetadata Structure
struct TokenPairMetadata<phantom X, phantom Y> has key {
    creator: address,
    fee_amount: coin::Coin<LPToken<X, Y>>,
    k_last: u128,
    balance_x: coin::Coin<X>,
    balance_y: coin::Coin<Y>,
    mint_cap: coin::MintCapability<LPToken<X, Y>>,
    burn_cap: coin::BurnCapability<LPToken<X, Y>>,
    freeze_cap: coin::FreezeCapability<LPToken<X, Y>>
}
This structure stores crucial information about each trading pair. Let's examine each field:
creator
: The address of the account that created this trading pair.
fee_amount
: Accumulated trading fees in the form of LP tokens.
k_last
: The last recorded product of reserves, used for fee calculations in constant product AMMs.
balance_x
and
balance_y
: Current balances of both tokens in the pair.
mint_cap
,
burn_cap
,
freeze_cap
: Capabilities for managing LP tokens.
Example usage:
let btc_eth_metadata = TokenPairMetadata<BTC, ETH> {
    creator: @0x1,
    fee_amount: coin::zero(),
    k_last: 1000000, // Initial k value
    balance_x: coin::zero<BTC>(),
    balance_y: coin::zero<ETH>(),
    mint_cap: // ... obtain mint capability
    burn_cap: // ... obtain burn capability
    freeze_cap: // ... obtain freeze capability
};
3. TokenPairReserve Structure
struct TokenPairReserve<phantom X, phantom Y> has key {
    reserve_x: u64,
    reserve_y: u64,
    block_timestamp_last: u64
}
This structure keeps track of the current state of liquidity reserves for a trading pair:
reserve_x
and
reserve_y
: Current reserves for both tokens in the pair.
block_timestamp_last
: Timestamp of the last update to the reserves.
4. SwapInfo Structure
struct SwapInfo has key {
    signer_cap: account::SignerCapability,
    fee_to: address,
    admin: address,
    pair_created: event::EventHandle<PairCreatedEvent>
}
This structure stores global configuration for the DEX:
signer_cap
: Capability to sign transactions on behalf of the DEX.
fee_to
: Address where trading fees are sent.
admin
: Address of the DEX administrator.
pair_created
: Event handle for tracking new trading pair creations.
Constants and Error Codes
Constants and error codes are crucial for maintaining consistency and proper error handling in your DEX. Let's break them down:
const ZERO_ACCOUNT: address = @0x0;
const DEFAULT_ADMIN: address = @movement;
const MINIMUM_LIQUIDITY: u128 = 1000;
const MAX_COIN_NAME_LENGTH: u64 = 32;
These constants define important values used throughout the DEX:
ZERO_ACCOUNT
: Represents an empty or null address.
DEFAULT_ADMIN
: The default administrator address for the DEX.
MINIMUM_LIQUIDITY
: The smallest amount of liquidity required to create a new pool.
MAX_COIN_NAME_LENGTH
: Maximum allowed length for coin names.
Error codes:
const ERROR_ONLY_ADMIN: u64 = 0x0001;
const ERROR_ALREADY_INITIALIZED: u64 = 0x001;
// ... (other error codes)
These error codes help identify specific issues that may occur during DEX operations:
ERROR_ONLY_ADMIN
: Thrown when a non-admin tries to perform an admin-only action.
ERROR_ALREADY_INITIALIZED
: Thrown when trying to initialize an already initialized component.
Module Initialization
The initialization function sets up the basic DEX infrastructure:
fun init_module(sender: &signer) {
    let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEFAULT_ADMIN);
    let resource_signer = account::create_signer_with_capability(&signer_cap);
    move_to(&resource_signer, SwapInfo {
        signer_cap,
        fee_to: ZERO_ACCOUNT,
        admin: DEFAULT_ADMIN,
        pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
    });
}
Let's break down this initialization process:
Retrieve the resource account capability using the sender and DEFAULT_ADMIN address.
Create a resource signer using the obtained capability.
Initialize the SwapInfo structure with default values.
Store the SwapInfo in the global storage using the resource signer.
Event Structures
Events are crucial for tracking important operations in your DEX. Let's examine the event structures:
struct PairCreatedEvent has drop, store {
    user: address,
    token_x: string::String,
    token_y: string::String
}
struct PairEventHolder<phantom X, phantom Y> has key {
    add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
    remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
    swap: event::EventHandle<SwapEvent<X, Y>>
}
These structures enable event tracking for various DEX operations:
PairCreatedEvent
: Emitted when a new trading pair is created.
PairEventHolder
: Holds event handles for liquidity operations and swaps.
Next Steps
Now that we've covered the fundamental structures and initialization of our DEX, in the next part of this tutorial, we'll delve into implementing core functionalities:
Creating and managing trading pairs
Implementing liquidity provision and removal
Developing the token swap mechanism
Calculating and distributing fees
Stay tuned for Part 2, where we'll build upon these foundations to create a fully functional DEX!
			Key Points:
This guide covers building a Decentralized Exchange (DEX) using Move on the Movement blockchain
Core data structures include LPToken, TokenPairMetadata, TokenPairReserve, and SwapInfo
Constants and error codes are defined for consistency and error handling
Module initialization sets up basic DEX infrastructure
Event structures track important DEX operations
The tutorial covers fundamental components and will progress to implementing core functionalities
Introduction
Welcome to our comprehensive guide on building a Decentralized Exchange (DEX) using Move, the programming language for the Movement blockchain. In this tutorial, we'll break down the fundamental components of a DEX, making it accessible for beginners while providing in-depth explanations for more advanced concepts.
Core Data Structures
Let's start by exploring the essential data structures that form the backbone of our DEX. We'll explain each structure in detail, providing examples and use cases to help you understand their roles in the system.
1. LPToken Structure
struct LPToken<phantom X, phantom Y> has key {}
This structure represents Liquidity Provider (LP) tokens, which are given to users who provide liquidity to the exchange. Let's break it down:
struct LPToken
: Defines a new type called LPToken.
&lt;phantom X, phantom Y&gt;
: These are generic type parameters representing the two tokens in a trading pair. The
phantom
keyword means these types are used only for type checking, not for data storage.
has key
: This ability allows the struct to be stored as a top-level item in global storage.
Example usage:
// Creating an LPToken for a BTC-ETH pair
let btc_eth_lp_token: LPToken<BTC, ETH>;
2. TokenPairMetadata Structure
struct TokenPairMetadata<phantom X, phantom Y> has key {
    creator: address,
    fee_amount: coin::Coin<LPToken<X, Y>>,
    k_last: u128,
    balance_x: coin::Coin<X>,
    balance_y: coin::Coin<Y>,
    mint_cap: coin::MintCapability<LPToken<X, Y>>,
    burn_cap: coin::BurnCapability<LPToken<X, Y>>,
    freeze_cap: coin::FreezeCapability<LPToken<X, Y>>
}
This structure stores crucial information about each trading pair. Let's examine each field:
creator
: The address of the account that created this trading pair.
fee_amount
: Accumulated trading fees in the form of LP tokens.
k_last
: The last recorded product of reserves, used for fee calculations in constant product AMMs.
balance_x
and
balance_y
: Current balances of both tokens in the pair.
mint_cap
,
burn_cap
,
freeze_cap
: Capabilities for managing LP tokens.
Example usage:
let btc_eth_metadata = TokenPairMetadata<BTC, ETH> {
    creator: @0x1,
    fee_amount: coin::zero(),
    k_last: 1000000, // Initial k value
    balance_x: coin::zero<BTC>(),
    balance_y: coin::zero<ETH>(),
    mint_cap: // ... obtain mint capability
    burn_cap: // ... obtain burn capability
    freeze_cap: // ... obtain freeze capability
};
3. TokenPairReserve Structure
struct TokenPairReserve<phantom X, phantom Y> has key {
    reserve_x: u64,
    reserve_y: u64,
    block_timestamp_last: u64
}
This structure keeps track of the current state of liquidity reserves for a trading pair:
reserve_x
and
reserve_y
: Current reserves for both tokens in the pair.
block_timestamp_last
: Timestamp of the last update to the reserves.
4. SwapInfo Structure
struct SwapInfo has key {
    signer_cap: account::SignerCapability,
    fee_to: address,
    admin: address,
    pair_created: event::EventHandle<PairCreatedEvent>
}
This structure stores global configuration for the DEX:
signer_cap
: Capability to sign transactions on behalf of the DEX.
fee_to
: Address where trading fees are sent.
admin
: Address of the DEX administrator.
pair_created
: Event handle for tracking new trading pair creations.
Constants and Error Codes
Constants and error codes are crucial for maintaining consistency and proper error handling in your DEX. Let's break them down:
const ZERO_ACCOUNT: address = @0x0;
const DEFAULT_ADMIN: address = @movement;
const MINIMUM_LIQUIDITY: u128 = 1000;
const MAX_COIN_NAME_LENGTH: u64 = 32;
These constants define important values used throughout the DEX:
ZERO_ACCOUNT
: Represents an empty or null address.
DEFAULT_ADMIN
: The default administrator address for the DEX.
MINIMUM_LIQUIDITY
: The smallest amount of liquidity required to create a new pool.
MAX_COIN_NAME_LENGTH
: Maximum allowed length for coin names.
Error codes:
const ERROR_ONLY_ADMIN: u64 = 0x0001;
const ERROR_ALREADY_INITIALIZED: u64 = 0x001;
// ... (other error codes)
These error codes help identify specific issues that may occur during DEX operations:
ERROR_ONLY_ADMIN
: Thrown when a non-admin tries to perform an admin-only action.
ERROR_ALREADY_INITIALIZED
: Thrown when trying to initialize an already initialized component.
Module Initialization
The initialization function sets up the basic DEX infrastructure:
fun init_module(sender: &signer) {
    let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEFAULT_ADMIN);
    let resource_signer = account::create_signer_with_capability(&signer_cap);
    move_to(&resource_signer, SwapInfo {
        signer_cap,
        fee_to: ZERO_ACCOUNT,
        admin: DEFAULT_ADMIN,
        pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
    });
}
Let's break down this initialization process:
Retrieve the resource account capability using the sender and DEFAULT_ADMIN address.
Create a resource signer using the obtained capability.
Initialize the SwapInfo structure with default values.
Store the SwapInfo in the global storage using the resource signer.
Event Structures
Events are crucial for tracking important operations in your DEX. Let's examine the event structures:
struct PairCreatedEvent has drop, store {
    user: address,
    token_x: string::String,
    token_y: string::String
}
struct PairEventHolder<phantom X, phantom Y> has key {
    add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
    remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
    swap: event::EventHandle<SwapEvent<X, Y>>
}
These structures enable event tracking for various DEX operations:
PairCreatedEvent
: Emitted when a new trading pair is created.
PairEventHolder
: Holds event handles for liquidity operations and swaps.
Next Steps
Now that we've covered the fundamental structures and initialization of our DEX, in the next part of this tutorial, we'll delve into implementing core functionalities:
Creating and managing trading pairs
Implementing liquidity provision and removal
Developing the token swap mechanism
Calculating and distributing fees
Stay tuned for Part 2, where we'll build upon these foundations to create a fully functional DEX!
			Key Points:
This guide covers building a Decentralized Exchange (DEX) using Move on the Movement blockchain
Core data structures include LPToken, TokenPairMetadata, TokenPairReserve, and SwapInfo
Constants and error codes are defined for consistency and error handling
Module initialization sets up basic DEX infrastructure
Event structures track important DEX operations
The tutorial covers fundamental components and will progress to implementing core functionalities
Introduction
Welcome to our comprehensive guide on building a Decentralized Exchange (DEX) using Move, the programming language for the Movement blockchain. In this tutorial, we'll break down the fundamental components of a DEX, making it accessible for beginners while providing in-depth explanations for more advanced concepts.
Core Data Structures
Let's start by exploring the essential data structures that form the backbone of our DEX. We'll explain each structure in detail, providing examples and use cases to help you understand their roles in the system.
1. LPToken Structure
struct LPToken<phantom X, phantom Y> has key {}
This structure represents Liquidity Provider (LP) tokens, which are given to users who provide liquidity to the exchange. Let's break it down:
struct LPToken
: Defines a new type called LPToken.
&lt;phantom X, phantom Y&gt;
: These are generic type parameters representing the two tokens in a trading pair. The
phantom
keyword means these types are used only for type checking, not for data storage.
has key
: This ability allows the struct to be stored as a top-level item in global storage.
Example usage:
// Creating an LPToken for a BTC-ETH pair
let btc_eth_lp_token: LPToken<BTC, ETH>;
2. TokenPairMetadata Structure
struct TokenPairMetadata<phantom X, phantom Y> has key {
    creator: address,
    fee_amount: coin::Coin<LPToken<X, Y>>,
    k_last: u128,
    balance_x: coin::Coin<X>,
    balance_y: coin::Coin<Y>,
    mint_cap: coin::MintCapability<LPToken<X, Y>>,
    burn_cap: coin::BurnCapability<LPToken<X, Y>>,
    freeze_cap: coin::FreezeCapability<LPToken<X, Y>>
}
This structure stores crucial information about each trading pair. Let's examine each field:
creator
: The address of the account that created this trading pair.
fee_amount
: Accumulated trading fees in the form of LP tokens.
k_last
: The last recorded product of reserves, used for fee calculations in constant product AMMs.
balance_x
and
balance_y
: Current balances of both tokens in the pair.
mint_cap
,
burn_cap
,
freeze_cap
: Capabilities for managing LP tokens.
Example usage:
let btc_eth_metadata = TokenPairMetadata<BTC, ETH> {
    creator: @0x1,
    fee_amount: coin::zero(),
    k_last: 1000000, // Initial k value
    balance_x: coin::zero<BTC>(),
    balance_y: coin::zero<ETH>(),
    mint_cap: // ... obtain mint capability
    burn_cap: // ... obtain burn capability
    freeze_cap: // ... obtain freeze capability
};
3. TokenPairReserve Structure
struct TokenPairReserve<phantom X, phantom Y> has key {
    reserve_x: u64,
    reserve_y: u64,
    block_timestamp_last: u64
}
This structure keeps track of the current state of liquidity reserves for a trading pair:
reserve_x
and
reserve_y
: Current reserves for both tokens in the pair.
block_timestamp_last
: Timestamp of the last update to the reserves.
4. SwapInfo Structure
struct SwapInfo has key {
    signer_cap: account::SignerCapability,
    fee_to: address,
    admin: address,
    pair_created: event::EventHandle<PairCreatedEvent>
}
This structure stores global configuration for the DEX:
signer_cap
: Capability to sign transactions on behalf of the DEX.
fee_to
: Address where trading fees are sent.
admin
: Address of the DEX administrator.
pair_created
: Event handle for tracking new trading pair creations.
Constants and Error Codes
Constants and error codes are crucial for maintaining consistency and proper error handling in your DEX. Let's break them down:
const ZERO_ACCOUNT: address = @0x0;
const DEFAULT_ADMIN: address = @movement;
const MINIMUM_LIQUIDITY: u128 = 1000;
const MAX_COIN_NAME_LENGTH: u64 = 32;
These constants define important values used throughout the DEX:
ZERO_ACCOUNT
: Represents an empty or null address.
DEFAULT_ADMIN
: The default administrator address for the DEX.
MINIMUM_LIQUIDITY
: The smallest amount of liquidity required to create a new pool.
MAX_COIN_NAME_LENGTH
: Maximum allowed length for coin names.
Error codes:
const ERROR_ONLY_ADMIN: u64 = 0x0001;
const ERROR_ALREADY_INITIALIZED: u64 = 0x001;
// ... (other error codes)
These error codes help identify specific issues that may occur during DEX operations:
ERROR_ONLY_ADMIN
: Thrown when a non-admin tries to perform an admin-only action.
ERROR_ALREADY_INITIALIZED
: Thrown when trying to initialize an already initialized component.
Module Initialization
The initialization function sets up the basic DEX infrastructure:
fun init_module(sender: &signer) {
    let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEFAULT_ADMIN);
    let resource_signer = account::create_signer_with_capability(&signer_cap);
    move_to(&resource_signer, SwapInfo {
        signer_cap,
        fee_to: ZERO_ACCOUNT,
        admin: DEFAULT_ADMIN,
        pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
    });
}
Let's break down this initialization process:
Retrieve the resource account capability using the sender and DEFAULT_ADMIN address.
Create a resource signer using the obtained capability.
Initialize the SwapInfo structure with default values.
Store the SwapInfo in the global storage using the resource signer.
Event Structures
Events are crucial for tracking important operations in your DEX. Let's examine the event structures:
struct PairCreatedEvent has drop, store {
    user: address,
    token_x: string::String,
    token_y: string::String
}
struct PairEventHolder<phantom X, phantom Y> has key {
    add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
    remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
    swap: event::EventHandle<SwapEvent<X, Y>>
}
These structures enable event tracking for various DEX operations:
PairCreatedEvent
: Emitted when a new trading pair is created.
PairEventHolder
: Holds event handles for liquidity operations and swaps.
Next Steps
Now that we've covered the fundamental structures and initialization of our DEX, in the next part of this tutorial, we'll delve into implementing core functionalities:
Creating and managing trading pairs
Implementing liquidity provision and removal
Developing the token swap mechanism
Calculating and distributing fees
Stay tuned for Part 2, where we'll build upon these foundations to create a fully functional DEX!
		Key Points:
		Key Points:
		This guide covers building a Decentralized Exchange (DEX) using Move on the Movement blockchain
Core data structures include LPToken, TokenPairMetadata, TokenPairReserve, and SwapInfo
Constants and error codes are defined for consistency and error handling
Module initialization sets up basic DEX infrastructure
Event structures track important DEX operations
The tutorial covers fundamental components and will progress to implementing core functionalities
		This guide covers building a Decentralized Exchange (DEX) using Move on the Movement blockchain
		This guide covers building a Decentralized Exchange (DEX) using Move on the Movement blockchain
		Core data structures include LPToken, TokenPairMetadata, TokenPairReserve, and SwapInfo
		Core data structures include LPToken, TokenPairMetadata, TokenPairReserve, and SwapInfo
		Constants and error codes are defined for consistency and error handling
		Constants and error codes are defined for consistency and error handling
		Module initialization sets up basic DEX infrastructure
		Module initialization sets up basic DEX infrastructure
		Event structures track important DEX operations
		Event structures track important DEX operations
		The tutorial covers fundamental components and will progress to implementing core functionalities
		The tutorial covers fundamental components and will progress to implementing core functionalities
	Introduction
	Introduction
	Welcome to our comprehensive guide on building a Decentralized Exchange (DEX) using Move, the programming language for the Movement blockchain. In this tutorial, we'll break down the fundamental components of a DEX, making it accessible for beginners while providing in-depth explanations for more advanced concepts.
	Welcome to our comprehensive guide on building a Decentralized Exchange (DEX) using Move, the programming language for the Movement blockchain. In this tutorial, we'll break down the fundamental components of a DEX, making it accessible for beginners while providing in-depth explanations for more advanced concepts.
	Core Data Structures
	Core Data Structures
	Let's start by exploring the essential data structures that form the backbone of our DEX. We'll explain each structure in detail, providing examples and use cases to help you understand their roles in the system.
	Let's start by exploring the essential data structures that form the backbone of our DEX. We'll explain each structure in detail, providing examples and use cases to help you understand their roles in the system.
		1. LPToken Structure
		1. LPToken Structure
		<code>struct LPToken<phantom X, phantom Y> has key {}</code>
		<code>struct LPToken<phantom X, phantom Y> has key {}</code>
		struct LPToken<phantom X, phantom Y> has key {}
		This structure represents Liquidity Provider (LP) tokens, which are given to users who provide liquidity to the exchange. Let's break it down:
		This structure represents Liquidity Provider (LP) tokens, which are given to users who provide liquidity to the exchange. Let's break it down:
		struct LPToken
: Defines a new type called LPToken.
&lt;phantom X, phantom Y&gt;
: These are generic type parameters representing the two tokens in a trading pair. The
phantom
keyword means these types are used only for type checking, not for data storage.
has key
: This ability allows the struct to be stored as a top-level item in global storage.
		struct LPToken
: Defines a new type called LPToken.
		<code>struct LPToken</code>
		struct LPToken
		: Defines a new type called LPToken.
		&lt;phantom X, phantom Y&gt;
: These are generic type parameters representing the two tokens in a trading pair. The
phantom
keyword means these types are used only for type checking, not for data storage.
		<code>&lt;phantom X, phantom Y&gt;</code>
		&lt;phantom X, phantom Y&gt;
		: These are generic type parameters representing the two tokens in a trading pair. The
		<code>phantom</code>
		phantom
		keyword means these types are used only for type checking, not for data storage.
		has key
: This ability allows the struct to be stored as a top-level item in global storage.
		<code>has key</code>
		has key
		: This ability allows the struct to be stored as a top-level item in global storage.
		Example usage:
		Example usage:
		<code>// Creating an LPToken for a BTC-ETH pair
let btc_eth_lp_token: LPToken<BTC, ETH>;</code>
		<code>// Creating an LPToken for a BTC-ETH pair
let btc_eth_lp_token: LPToken<BTC, ETH>;</code>
		// Creating an LPToken for a BTC-ETH pair
let btc_eth_lp_token: LPToken<BTC, ETH>;
		2. TokenPairMetadata Structure
		2. TokenPairMetadata Structure
		<code>struct TokenPairMetadata<phantom X, phantom Y> has key {
    creator: address,
    fee_amount: coin::Coin<LPToken<X, Y>>,
    k_last: u128,
    balance_x: coin::Coin<X>,
    balance_y: coin::Coin<Y>,
    mint_cap: coin::MintCapability<LPToken<X, Y>>,
    burn_cap: coin::BurnCapability<LPToken<X, Y>>,
    freeze_cap: coin::FreezeCapability<LPToken<X, Y>>
}</code>
		<code>struct TokenPairMetadata<phantom X, phantom Y> has key {
    creator: address,
    fee_amount: coin::Coin<LPToken<X, Y>>,
    k_last: u128,
    balance_x: coin::Coin<X>,
    balance_y: coin::Coin<Y>,
    mint_cap: coin::MintCapability<LPToken<X, Y>>,
    burn_cap: coin::BurnCapability<LPToken<X, Y>>,
    freeze_cap: coin::FreezeCapability<LPToken<X, Y>>
}</code>
		struct TokenPairMetadata<phantom X, phantom Y> has key {
    creator: address,
    fee_amount: coin::Coin<LPToken<X, Y>>,
    k_last: u128,
    balance_x: coin::Coin<X>,
    balance_y: coin::Coin<Y>,
    mint_cap: coin::MintCapability<LPToken<X, Y>>,
    burn_cap: coin::BurnCapability<LPToken<X, Y>>,
    freeze_cap: coin::FreezeCapability<LPToken<X, Y>>
}
		This structure stores crucial information about each trading pair. Let's examine each field:
		This structure stores crucial information about each trading pair. Let's examine each field:
		creator
: The address of the account that created this trading pair.
fee_amount
: Accumulated trading fees in the form of LP tokens.
k_last
: The last recorded product of reserves, used for fee calculations in constant product AMMs.
balance_x
and
balance_y
: Current balances of both tokens in the pair.
mint_cap
,
burn_cap
,
freeze_cap
: Capabilities for managing LP tokens.
		creator
: The address of the account that created this trading pair.
		<code>creator</code>
		creator
		: The address of the account that created this trading pair.
		fee_amount
: Accumulated trading fees in the form of LP tokens.
		<code>fee_amount</code>
		fee_amount
		: Accumulated trading fees in the form of LP tokens.
		k_last
: The last recorded product of reserves, used for fee calculations in constant product AMMs.
		<code>k_last</code>
		k_last
		: The last recorded product of reserves, used for fee calculations in constant product AMMs.
		balance_x
and
balance_y
: Current balances of both tokens in the pair.
		<code>balance_x</code>
		balance_x
		and
		<code>balance_y</code>
		balance_y
		: Current balances of both tokens in the pair.
		mint_cap
,
burn_cap
,
freeze_cap
: Capabilities for managing LP tokens.
		<code>mint_cap</code>
		mint_cap
		,
		<code>burn_cap</code>
		burn_cap
		,
		<code>freeze_cap</code>
		freeze_cap
		: Capabilities for managing LP tokens.
		Example usage:
		Example usage:
		<code>let btc_eth_metadata = TokenPairMetadata<BTC, ETH> {
    creator: @0x1,
    fee_amount: coin::zero(),
    k_last: 1000000, // Initial k value
    balance_x: coin::zero<BTC>(),
    balance_y: coin::zero<ETH>(),
    mint_cap: // ... obtain mint capability
    burn_cap: // ... obtain burn capability
    freeze_cap: // ... obtain freeze capability
};</code>
		<code>let btc_eth_metadata = TokenPairMetadata<BTC, ETH> {
    creator: @0x1,
    fee_amount: coin::zero(),
    k_last: 1000000, // Initial k value
    balance_x: coin::zero<BTC>(),
    balance_y: coin::zero<ETH>(),
    mint_cap: // ... obtain mint capability
    burn_cap: // ... obtain burn capability
    freeze_cap: // ... obtain freeze capability
};</code>
		let btc_eth_metadata = TokenPairMetadata<BTC, ETH> {
    creator: @0x1,
    fee_amount: coin::zero(),
    k_last: 1000000, // Initial k value
    balance_x: coin::zero<BTC>(),
    balance_y: coin::zero<ETH>(),
    mint_cap: // ... obtain mint capability
    burn_cap: // ... obtain burn capability
    freeze_cap: // ... obtain freeze capability
};
		3. TokenPairReserve Structure
		3. TokenPairReserve Structure
		<code>struct TokenPairReserve<phantom X, phantom Y> has key {
    reserve_x: u64,
    reserve_y: u64,
    block_timestamp_last: u64
}</code>
		<code>struct TokenPairReserve<phantom X, phantom Y> has key {
    reserve_x: u64,
    reserve_y: u64,
    block_timestamp_last: u64
}</code>
		struct TokenPairReserve<phantom X, phantom Y> has key {
    reserve_x: u64,
    reserve_y: u64,
    block_timestamp_last: u64
}
		This structure keeps track of the current state of liquidity reserves for a trading pair:
		This structure keeps track of the current state of liquidity reserves for a trading pair:
		reserve_x
and
reserve_y
: Current reserves for both tokens in the pair.
block_timestamp_last
: Timestamp of the last update to the reserves.
		reserve_x
and
reserve_y
: Current reserves for both tokens in the pair.
		<code>reserve_x</code>
		reserve_x
		and
		<code>reserve_y</code>
		reserve_y
		: Current reserves for both tokens in the pair.
		block_timestamp_last
: Timestamp of the last update to the reserves.
		<code>block_timestamp_last</code>
		block_timestamp_last
		: Timestamp of the last update to the reserves.
		4. SwapInfo Structure
		4. SwapInfo Structure
		<code>struct SwapInfo has key {
    signer_cap: account::SignerCapability,
    fee_to: address,
    admin: address,
    pair_created: event::EventHandle<PairCreatedEvent>
}</code>
		<code>struct SwapInfo has key {
    signer_cap: account::SignerCapability,
    fee_to: address,
    admin: address,
    pair_created: event::EventHandle<PairCreatedEvent>
}</code>
		struct SwapInfo has key {
    signer_cap: account::SignerCapability,
    fee_to: address,
    admin: address,
    pair_created: event::EventHandle<PairCreatedEvent>
}
		This structure stores global configuration for the DEX:
		This structure stores global configuration for the DEX:
		signer_cap
: Capability to sign transactions on behalf of the DEX.
fee_to
: Address where trading fees are sent.
admin
: Address of the DEX administrator.
pair_created
: Event handle for tracking new trading pair creations.
		signer_cap
: Capability to sign transactions on behalf of the DEX.
		<code>signer_cap</code>
		signer_cap
		: Capability to sign transactions on behalf of the DEX.
		fee_to
: Address where trading fees are sent.
		<code>fee_to</code>
		fee_to
		: Address where trading fees are sent.
		admin
: Address of the DEX administrator.
		<code>admin</code>
		admin
		: Address of the DEX administrator.
		pair_created
: Event handle for tracking new trading pair creations.
		<code>pair_created</code>
		pair_created
		: Event handle for tracking new trading pair creations.
	Constants and Error Codes
	Constants and Error Codes
	Constants and error codes are crucial for maintaining consistency and proper error handling in your DEX. Let's break them down:
	Constants and error codes are crucial for maintaining consistency and proper error handling in your DEX. Let's break them down:
	<code>const ZERO_ACCOUNT: address = @0x0;
const DEFAULT_ADMIN: address = @movement;
const MINIMUM_LIQUIDITY: u128 = 1000;
const MAX_COIN_NAME_LENGTH: u64 = 32;</code>
	<code>const ZERO_ACCOUNT: address = @0x0;
const DEFAULT_ADMIN: address = @movement;
const MINIMUM_LIQUIDITY: u128 = 1000;
const MAX_COIN_NAME_LENGTH: u64 = 32;</code>
	const ZERO_ACCOUNT: address = @0x0;
const DEFAULT_ADMIN: address = @movement;
const MINIMUM_LIQUIDITY: u128 = 1000;
const MAX_COIN_NAME_LENGTH: u64 = 32;
	These constants define important values used throughout the DEX:
	These constants define important values used throughout the DEX:
	ZERO_ACCOUNT
: Represents an empty or null address.
DEFAULT_ADMIN
: The default administrator address for the DEX.
MINIMUM_LIQUIDITY
: The smallest amount of liquidity required to create a new pool.
MAX_COIN_NAME_LENGTH
: Maximum allowed length for coin names.
	ZERO_ACCOUNT
: Represents an empty or null address.
	<code>ZERO_ACCOUNT</code>
	ZERO_ACCOUNT
	: Represents an empty or null address.
	DEFAULT_ADMIN
: The default administrator address for the DEX.
	<code>DEFAULT_ADMIN</code>
	DEFAULT_ADMIN
	: The default administrator address for the DEX.
	MINIMUM_LIQUIDITY
: The smallest amount of liquidity required to create a new pool.
	<code>MINIMUM_LIQUIDITY</code>
	MINIMUM_LIQUIDITY
	: The smallest amount of liquidity required to create a new pool.
	MAX_COIN_NAME_LENGTH
: Maximum allowed length for coin names.
	<code>MAX_COIN_NAME_LENGTH</code>
	MAX_COIN_NAME_LENGTH
	: Maximum allowed length for coin names.
	Error codes:
	Error codes:
	<code>const ERROR_ONLY_ADMIN: u64 = 0x0001;
const ERROR_ALREADY_INITIALIZED: u64 = 0x001;
// ... (other error codes)</code>
	<code>const ERROR_ONLY_ADMIN: u64 = 0x0001;
const ERROR_ALREADY_INITIALIZED: u64 = 0x001;
// ... (other error codes)</code>
	const ERROR_ONLY_ADMIN: u64 = 0x0001;
const ERROR_ALREADY_INITIALIZED: u64 = 0x001;
// ... (other error codes)
	These error codes help identify specific issues that may occur during DEX operations:
	These error codes help identify specific issues that may occur during DEX operations:
	ERROR_ONLY_ADMIN
: Thrown when a non-admin tries to perform an admin-only action.
ERROR_ALREADY_INITIALIZED
: Thrown when trying to initialize an already initialized component.
	ERROR_ONLY_ADMIN
: Thrown when a non-admin tries to perform an admin-only action.
	<code>ERROR_ONLY_ADMIN</code>
	ERROR_ONLY_ADMIN
	: Thrown when a non-admin tries to perform an admin-only action.
	ERROR_ALREADY_INITIALIZED
: Thrown when trying to initialize an already initialized component.
	<code>ERROR_ALREADY_INITIALIZED</code>
	ERROR_ALREADY_INITIALIZED
	: Thrown when trying to initialize an already initialized component.
	Module Initialization
	Module Initialization
	The initialization function sets up the basic DEX infrastructure:
	The initialization function sets up the basic DEX infrastructure:
	<code>fun init_module(sender: &signer) {
    let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEFAULT_ADMIN);
    let resource_signer = account::create_signer_with_capability(&signer_cap);
    move_to(&resource_signer, SwapInfo {
        signer_cap,
        fee_to: ZERO_ACCOUNT,
        admin: DEFAULT_ADMIN,
        pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
    });
}</code>
	<code>fun init_module(sender: &signer) {
    let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEFAULT_ADMIN);
    let resource_signer = account::create_signer_with_capability(&signer_cap);
    move_to(&resource_signer, SwapInfo {
        signer_cap,
        fee_to: ZERO_ACCOUNT,
        admin: DEFAULT_ADMIN,
        pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
    });
}</code>
	fun init_module(sender: &signer) {
    let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEFAULT_ADMIN);
    let resource_signer = account::create_signer_with_capability(&signer_cap);
    move_to(&resource_signer, SwapInfo {
        signer_cap,
        fee_to: ZERO_ACCOUNT,
        admin: DEFAULT_ADMIN,
        pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
    });
}
	Let's break down this initialization process:
	Let's break down this initialization process:
	Retrieve the resource account capability using the sender and DEFAULT_ADMIN address.
Create a resource signer using the obtained capability.
Initialize the SwapInfo structure with default values.
Store the SwapInfo in the global storage using the resource signer.
	Retrieve the resource account capability using the sender and DEFAULT_ADMIN address.
	Retrieve the resource account capability using the sender and DEFAULT_ADMIN address.
	Create a resource signer using the obtained capability.
	Create a resource signer using the obtained capability.
	Initialize the SwapInfo structure with default values.
	Initialize the SwapInfo structure with default values.
	Store the SwapInfo in the global storage using the resource signer.
	Store the SwapInfo in the global storage using the resource signer.
	Event Structures
	Event Structures
	Events are crucial for tracking important operations in your DEX. Let's examine the event structures:
	Events are crucial for tracking important operations in your DEX. Let's examine the event structures:
	<code>struct PairCreatedEvent has drop, store {
    user: address,
    token_x: string::String,
    token_y: string::String
}
struct PairEventHolder<phantom X, phantom Y> has key {
    add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
    remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
    swap: event::EventHandle<SwapEvent<X, Y>>
}</code>
	<code>struct PairCreatedEvent has drop, store {
    user: address,
    token_x: string::String,
    token_y: string::String
}
struct PairEventHolder<phantom X, phantom Y> has key {
    add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
    remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
    swap: event::EventHandle<SwapEvent<X, Y>>
}</code>
	struct PairCreatedEvent has drop, store {
    user: address,
    token_x: string::String,
    token_y: string::String
}
struct PairEventHolder<phantom X, phantom Y> has key {
    add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
    remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
    swap: event::EventHandle<SwapEvent<X, Y>>
}
	These structures enable event tracking for various DEX operations:
	These structures enable event tracking for various DEX operations:
	PairCreatedEvent
: Emitted when a new trading pair is created.
PairEventHolder
: Holds event handles for liquidity operations and swaps.
	PairCreatedEvent
: Emitted when a new trading pair is created.
	<code>PairCreatedEvent</code>
	PairCreatedEvent
	: Emitted when a new trading pair is created.
	PairEventHolder
: Holds event handles for liquidity operations and swaps.
	<code>PairEventHolder</code>
	PairEventHolder
	: Holds event handles for liquidity operations and swaps.
	Next Steps
	Next Steps
	Now that we've covered the fundamental structures and initialization of our DEX, in the next part of this tutorial, we'll delve into implementing core functionalities:
	Now that we've covered the fundamental structures and initialization of our DEX, in the next part of this tutorial, we'll delve into implementing core functionalities:
	Creating and managing trading pairs
Implementing liquidity provision and removal
Developing the token swap mechanism
Calculating and distributing fees
	Creating and managing trading pairs
	Creating and managing trading pairs
	Implementing liquidity provision and removal
	Implementing liquidity provision and removal
	Developing the token swap mechanism
	Developing the token swap mechanism
	Calculating and distributing fees
	Calculating and distributing fees
	Stay tuned for Part 2, where we'll build upon these foundations to create a fully functional DEX!
	Stay tuned for Part 2, where we'll build upon these foundations to create a fully functional DEX!

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/02-swap/03-creating-trading-pairs-in-a-dex
Creating Trading Pairs in a DEX
Creating Trading Pairs in a DEX
On This Page
Key points covered:
Introduction to Creating Trading Pairs in a DEX
1. Understanding the create_pair Function
2. Initial Checks and Setup
3. Creating the LP Token Name
4. Initializing the LP Token
5. Setting Up the Pool State
6. Setting Up Events and Finalizing
Conclusion
Key points covered:
Understanding the
create_pair
function and its parameters
Performing initial checks and setup for pair creation
Generating a unique name for the LP (Liquidity Provider) token
Initializing the LP token with specific attributes
Setting up pool state data structures
Configuring event tracking for liquidity and swap actions
Emitting a PairCreatedEvent to notify listeners
Registering the ability to hold LP tokens
Introduction to Creating Trading Pairs in a DEX
Welcome to this beginner-friendly tutorial on creating trading pairs in a Decentralized Exchange (DEX). We'll explore the
create_pair
function, which is the foundation of setting up liquidity pools for token trading. Don't worry if some terms are unfamiliar - we'll break everything down step-by-step!
1. Understanding the create_pair Function
Let's start by looking at the basic structure of our
create_pair
function:
public fun create_pair<X, Y>(sender: &signer) acquires SwapInfo {
    // Implementation will go here
}
Here's what each part means:
public fun
: This function can be called by anyone
<X, Y>
: These are generic type parameters representing our two tokens
sender: &signer
: The user creating the pair must sign the transaction
acquires SwapInfo
: This function will access global state information
2. Initial Checks and Setup
Before creating a new pair, we need to perform some checks and setup:
assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
let sender_addr = signer::address_of(sender);
let swap_info = borrow_global_mut<SwapInfo>(DEFAULT_ADMIN);
let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
Let's break this down:
We first check if the pair already exists. If it does, we stop the process.
We get the address of the sender for later use.
We borrow the global SwapInfo to access shared state.
We create a special "resource signer" that allows the contract to manage resources.
3. Creating the LP Token Name
LP stands for "Liquidity Provider". We need to create a unique name for our LP token:
let lp_name: string::String = string::utf8(b"movement-");
let name_x = coin::symbol<X>();
let name_y = coin::symbol<Y>();
string::append(&mut lp_name, name_x);
string::append_utf8(&mut lp_name, b"-");
string::append(&mut lp_name, name_y);
string::append_utf8(&mut lp_name, b"-LP");
if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
    lp_name = string::utf8(b"movement LPs");
};
This code does the following:
Starts with "movement-"
Adds the symbols of both tokens
Ends with "-LP"
If the name is too long, it uses a generic "movement LPs" instead
4. Initializing the LP Token
Now we create the actual LP token:
let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
    &resource_signer,
    lp_name,
    string::utf8(b"Move-LP"),
    8,
    true
);
This function call does several things:
Creates a new token type
LPToken<X, Y>
Sets its name to our generated
lp_name
Sets its symbol to "Move-LP"
Sets 8 decimal places
Enables supply tracking
Returns capabilities for burning, freezing, and minting these tokens
5. Setting Up the Pool State
We need to initialize some data structures to keep track of our trading pair:
move_to<TokenPairReserve<X, Y>>(
    &resource_signer,
    TokenPairReserve {
        reserve_x: 0,
        reserve_y: 0,
        block_timestamp_last: 0
    }
);
move_to<TokenPairMetadata<X, Y>>(
    &resource_signer,
    TokenPairMetadata {
        creator: sender_addr,
        fee_amount: coin::zero<LPToken<X, Y>>(),
        k_last: 0,
        balance_x: coin::zero<X>(),
        balance_y: coin::zero<Y>(),
        mint_cap,
        burn_cap,
        freeze_cap,
    }
);
This initializes two important structures:
TokenPairReserve
: Keeps track of the current amounts of each token in the pool
TokenPairMetadata
: Stores various pieces of information about the pair, including who created it, accumulated fees, and token balances
6. Setting Up Events and Finalizing
Lastly, we set up event tracking and finalize the pair creation:
move_to<PairEventHolder<X, Y>>(
    &resource_signer,
    PairEventHolder {
        add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
        remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
        swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
    }
);
let token_x = type_info::type_name<X>();
let token_y = type_info::type_name<Y>();
event::emit_event<PairCreatedEvent>(
    &mut swap_info.pair_created,
    PairCreatedEvent {
        user: sender_addr,
        token_x,
        token_y
    }
);
register_lp<X, Y>(&resource_signer);
This final part:
Sets up event handlers for adding liquidity, removing liquidity, and swapping
Emits a "PairCreatedEvent" to notify listeners that a new pair has been created
Registers the ability to hold LP tokens
Conclusion
Congratulations! You've just learned about the intricate process of creating a trading pair in a DEX. This function sets up the foundation for users to provide liquidity and trade tokens. In the next part of this tutorial, we'll explore how to add liquidity to our newly created pair. Stay tuned!
On This Page
Key points covered:
Introduction to Creating Trading Pairs in a DEX
1. Understanding the create_pair Function
2. Initial Checks and Setup
3. Creating the LP Token Name
4. Initializing the LP Token
5. Setting Up the Pool State
6. Setting Up Events and Finalizing
Conclusion
On This Page
Key points covered:
Introduction to Creating Trading Pairs in a DEX
1. Understanding the create_pair Function
2. Initial Checks and Setup
3. Creating the LP Token Name
4. Initializing the LP Token
5. Setting Up the Pool State
6. Setting Up Events and Finalizing
Conclusion
			On This Page
			On This Page
			Key points covered:
Introduction to Creating Trading Pairs in a DEX
1. Understanding the create_pair Function
2. Initial Checks and Setup
3. Creating the LP Token Name
4. Initializing the LP Token
5. Setting Up the Pool State
6. Setting Up Events and Finalizing
Conclusion
			Key points covered:
			Key points covered:
			Key points covered:
			Key points covered:
			Introduction to Creating Trading Pairs in a DEX
			Introduction to Creating Trading Pairs in a DEX
			Introduction to Creating Trading Pairs in a DEX
			Introduction to Creating Trading Pairs in a DEX
			1. Understanding the create_pair Function
			1. Understanding the create_pair Function
			1. Understanding the create_pair Function
			1. Understanding the create_pair Function
			2. Initial Checks and Setup
			2. Initial Checks and Setup
			2. Initial Checks and Setup
			2. Initial Checks and Setup
			3. Creating the LP Token Name
			3. Creating the LP Token Name
			3. Creating the LP Token Name
			3. Creating the LP Token Name
			4. Initializing the LP Token
			4. Initializing the LP Token
			4. Initializing the LP Token
			4. Initializing the LP Token
			5. Setting Up the Pool State
			5. Setting Up the Pool State
			5. Setting Up the Pool State
			5. Setting Up the Pool State
			6. Setting Up Events and Finalizing
			6. Setting Up Events and Finalizing
			6. Setting Up Events and Finalizing
			6. Setting Up Events and Finalizing
			Conclusion
			Conclusion
			Conclusion
			Conclusion
			Key points covered:
Understanding the
create_pair
function and its parameters
Performing initial checks and setup for pair creation
Generating a unique name for the LP (Liquidity Provider) token
Initializing the LP token with specific attributes
Setting up pool state data structures
Configuring event tracking for liquidity and swap actions
Emitting a PairCreatedEvent to notify listeners
Registering the ability to hold LP tokens
Introduction to Creating Trading Pairs in a DEX
Welcome to this beginner-friendly tutorial on creating trading pairs in a Decentralized Exchange (DEX). We'll explore the
create_pair
function, which is the foundation of setting up liquidity pools for token trading. Don't worry if some terms are unfamiliar - we'll break everything down step-by-step!
1. Understanding the create_pair Function
Let's start by looking at the basic structure of our
create_pair
function:
public fun create_pair<X, Y>(sender: &signer) acquires SwapInfo {
    // Implementation will go here
}
Here's what each part means:
public fun
: This function can be called by anyone
<X, Y>
: These are generic type parameters representing our two tokens
sender: &signer
: The user creating the pair must sign the transaction
acquires SwapInfo
: This function will access global state information
2. Initial Checks and Setup
Before creating a new pair, we need to perform some checks and setup:
assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
let sender_addr = signer::address_of(sender);
let swap_info = borrow_global_mut<SwapInfo>(DEFAULT_ADMIN);
let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
Let's break this down:
We first check if the pair already exists. If it does, we stop the process.
We get the address of the sender for later use.
We borrow the global SwapInfo to access shared state.
We create a special "resource signer" that allows the contract to manage resources.
3. Creating the LP Token Name
LP stands for "Liquidity Provider". We need to create a unique name for our LP token:
let lp_name: string::String = string::utf8(b"movement-");
let name_x = coin::symbol<X>();
let name_y = coin::symbol<Y>();
string::append(&mut lp_name, name_x);
string::append_utf8(&mut lp_name, b"-");
string::append(&mut lp_name, name_y);
string::append_utf8(&mut lp_name, b"-LP");
if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
    lp_name = string::utf8(b"movement LPs");
};
This code does the following:
Starts with "movement-"
Adds the symbols of both tokens
Ends with "-LP"
If the name is too long, it uses a generic "movement LPs" instead
4. Initializing the LP Token
Now we create the actual LP token:
let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
    &resource_signer,
    lp_name,
    string::utf8(b"Move-LP"),
    8,
    true
);
This function call does several things:
Creates a new token type
LPToken<X, Y>
Sets its name to our generated
lp_name
Sets its symbol to "Move-LP"
Sets 8 decimal places
Enables supply tracking
Returns capabilities for burning, freezing, and minting these tokens
5. Setting Up the Pool State
We need to initialize some data structures to keep track of our trading pair:
move_to<TokenPairReserve<X, Y>>(
    &resource_signer,
    TokenPairReserve {
        reserve_x: 0,
        reserve_y: 0,
        block_timestamp_last: 0
    }
);
move_to<TokenPairMetadata<X, Y>>(
    &resource_signer,
    TokenPairMetadata {
        creator: sender_addr,
        fee_amount: coin::zero<LPToken<X, Y>>(),
        k_last: 0,
        balance_x: coin::zero<X>(),
        balance_y: coin::zero<Y>(),
        mint_cap,
        burn_cap,
        freeze_cap,
    }
);
This initializes two important structures:
TokenPairReserve
: Keeps track of the current amounts of each token in the pool
TokenPairMetadata
: Stores various pieces of information about the pair, including who created it, accumulated fees, and token balances
6. Setting Up Events and Finalizing
Lastly, we set up event tracking and finalize the pair creation:
move_to<PairEventHolder<X, Y>>(
    &resource_signer,
    PairEventHolder {
        add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
        remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
        swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
    }
);
let token_x = type_info::type_name<X>();
let token_y = type_info::type_name<Y>();
event::emit_event<PairCreatedEvent>(
    &mut swap_info.pair_created,
    PairCreatedEvent {
        user: sender_addr,
        token_x,
        token_y
    }
);
register_lp<X, Y>(&resource_signer);
This final part:
Sets up event handlers for adding liquidity, removing liquidity, and swapping
Emits a "PairCreatedEvent" to notify listeners that a new pair has been created
Registers the ability to hold LP tokens
Conclusion
Congratulations! You've just learned about the intricate process of creating a trading pair in a DEX. This function sets up the foundation for users to provide liquidity and trade tokens. In the next part of this tutorial, we'll explore how to add liquidity to our newly created pair. Stay tuned!
			Key points covered:
Understanding the
create_pair
function and its parameters
Performing initial checks and setup for pair creation
Generating a unique name for the LP (Liquidity Provider) token
Initializing the LP token with specific attributes
Setting up pool state data structures
Configuring event tracking for liquidity and swap actions
Emitting a PairCreatedEvent to notify listeners
Registering the ability to hold LP tokens
Introduction to Creating Trading Pairs in a DEX
Welcome to this beginner-friendly tutorial on creating trading pairs in a Decentralized Exchange (DEX). We'll explore the
create_pair
function, which is the foundation of setting up liquidity pools for token trading. Don't worry if some terms are unfamiliar - we'll break everything down step-by-step!
1. Understanding the create_pair Function
Let's start by looking at the basic structure of our
create_pair
function:
public fun create_pair<X, Y>(sender: &signer) acquires SwapInfo {
    // Implementation will go here
}
Here's what each part means:
public fun
: This function can be called by anyone
<X, Y>
: These are generic type parameters representing our two tokens
sender: &signer
: The user creating the pair must sign the transaction
acquires SwapInfo
: This function will access global state information
2. Initial Checks and Setup
Before creating a new pair, we need to perform some checks and setup:
assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
let sender_addr = signer::address_of(sender);
let swap_info = borrow_global_mut<SwapInfo>(DEFAULT_ADMIN);
let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
Let's break this down:
We first check if the pair already exists. If it does, we stop the process.
We get the address of the sender for later use.
We borrow the global SwapInfo to access shared state.
We create a special "resource signer" that allows the contract to manage resources.
3. Creating the LP Token Name
LP stands for "Liquidity Provider". We need to create a unique name for our LP token:
let lp_name: string::String = string::utf8(b"movement-");
let name_x = coin::symbol<X>();
let name_y = coin::symbol<Y>();
string::append(&mut lp_name, name_x);
string::append_utf8(&mut lp_name, b"-");
string::append(&mut lp_name, name_y);
string::append_utf8(&mut lp_name, b"-LP");
if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
    lp_name = string::utf8(b"movement LPs");
};
This code does the following:
Starts with "movement-"
Adds the symbols of both tokens
Ends with "-LP"
If the name is too long, it uses a generic "movement LPs" instead
4. Initializing the LP Token
Now we create the actual LP token:
let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
    &resource_signer,
    lp_name,
    string::utf8(b"Move-LP"),
    8,
    true
);
This function call does several things:
Creates a new token type
LPToken<X, Y>
Sets its name to our generated
lp_name
Sets its symbol to "Move-LP"
Sets 8 decimal places
Enables supply tracking
Returns capabilities for burning, freezing, and minting these tokens
5. Setting Up the Pool State
We need to initialize some data structures to keep track of our trading pair:
move_to<TokenPairReserve<X, Y>>(
    &resource_signer,
    TokenPairReserve {
        reserve_x: 0,
        reserve_y: 0,
        block_timestamp_last: 0
    }
);
move_to<TokenPairMetadata<X, Y>>(
    &resource_signer,
    TokenPairMetadata {
        creator: sender_addr,
        fee_amount: coin::zero<LPToken<X, Y>>(),
        k_last: 0,
        balance_x: coin::zero<X>(),
        balance_y: coin::zero<Y>(),
        mint_cap,
        burn_cap,
        freeze_cap,
    }
);
This initializes two important structures:
TokenPairReserve
: Keeps track of the current amounts of each token in the pool
TokenPairMetadata
: Stores various pieces of information about the pair, including who created it, accumulated fees, and token balances
6. Setting Up Events and Finalizing
Lastly, we set up event tracking and finalize the pair creation:
move_to<PairEventHolder<X, Y>>(
    &resource_signer,
    PairEventHolder {
        add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
        remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
        swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
    }
);
let token_x = type_info::type_name<X>();
let token_y = type_info::type_name<Y>();
event::emit_event<PairCreatedEvent>(
    &mut swap_info.pair_created,
    PairCreatedEvent {
        user: sender_addr,
        token_x,
        token_y
    }
);
register_lp<X, Y>(&resource_signer);
This final part:
Sets up event handlers for adding liquidity, removing liquidity, and swapping
Emits a "PairCreatedEvent" to notify listeners that a new pair has been created
Registers the ability to hold LP tokens
Conclusion
Congratulations! You've just learned about the intricate process of creating a trading pair in a DEX. This function sets up the foundation for users to provide liquidity and trade tokens. In the next part of this tutorial, we'll explore how to add liquidity to our newly created pair. Stay tuned!
			Key points covered:
Understanding the
create_pair
function and its parameters
Performing initial checks and setup for pair creation
Generating a unique name for the LP (Liquidity Provider) token
Initializing the LP token with specific attributes
Setting up pool state data structures
Configuring event tracking for liquidity and swap actions
Emitting a PairCreatedEvent to notify listeners
Registering the ability to hold LP tokens
Introduction to Creating Trading Pairs in a DEX
Welcome to this beginner-friendly tutorial on creating trading pairs in a Decentralized Exchange (DEX). We'll explore the
create_pair
function, which is the foundation of setting up liquidity pools for token trading. Don't worry if some terms are unfamiliar - we'll break everything down step-by-step!
1. Understanding the create_pair Function
Let's start by looking at the basic structure of our
create_pair
function:
public fun create_pair<X, Y>(sender: &signer) acquires SwapInfo {
    // Implementation will go here
}
Here's what each part means:
public fun
: This function can be called by anyone
<X, Y>
: These are generic type parameters representing our two tokens
sender: &signer
: The user creating the pair must sign the transaction
acquires SwapInfo
: This function will access global state information
2. Initial Checks and Setup
Before creating a new pair, we need to perform some checks and setup:
assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
let sender_addr = signer::address_of(sender);
let swap_info = borrow_global_mut<SwapInfo>(DEFAULT_ADMIN);
let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
Let's break this down:
We first check if the pair already exists. If it does, we stop the process.
We get the address of the sender for later use.
We borrow the global SwapInfo to access shared state.
We create a special "resource signer" that allows the contract to manage resources.
3. Creating the LP Token Name
LP stands for "Liquidity Provider". We need to create a unique name for our LP token:
let lp_name: string::String = string::utf8(b"movement-");
let name_x = coin::symbol<X>();
let name_y = coin::symbol<Y>();
string::append(&mut lp_name, name_x);
string::append_utf8(&mut lp_name, b"-");
string::append(&mut lp_name, name_y);
string::append_utf8(&mut lp_name, b"-LP");
if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
    lp_name = string::utf8(b"movement LPs");
};
This code does the following:
Starts with "movement-"
Adds the symbols of both tokens
Ends with "-LP"
If the name is too long, it uses a generic "movement LPs" instead
4. Initializing the LP Token
Now we create the actual LP token:
let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
    &resource_signer,
    lp_name,
    string::utf8(b"Move-LP"),
    8,
    true
);
This function call does several things:
Creates a new token type
LPToken<X, Y>
Sets its name to our generated
lp_name
Sets its symbol to "Move-LP"
Sets 8 decimal places
Enables supply tracking
Returns capabilities for burning, freezing, and minting these tokens
5. Setting Up the Pool State
We need to initialize some data structures to keep track of our trading pair:
move_to<TokenPairReserve<X, Y>>(
    &resource_signer,
    TokenPairReserve {
        reserve_x: 0,
        reserve_y: 0,
        block_timestamp_last: 0
    }
);
move_to<TokenPairMetadata<X, Y>>(
    &resource_signer,
    TokenPairMetadata {
        creator: sender_addr,
        fee_amount: coin::zero<LPToken<X, Y>>(),
        k_last: 0,
        balance_x: coin::zero<X>(),
        balance_y: coin::zero<Y>(),
        mint_cap,
        burn_cap,
        freeze_cap,
    }
);
This initializes two important structures:
TokenPairReserve
: Keeps track of the current amounts of each token in the pool
TokenPairMetadata
: Stores various pieces of information about the pair, including who created it, accumulated fees, and token balances
6. Setting Up Events and Finalizing
Lastly, we set up event tracking and finalize the pair creation:
move_to<PairEventHolder<X, Y>>(
    &resource_signer,
    PairEventHolder {
        add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
        remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
        swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
    }
);
let token_x = type_info::type_name<X>();
let token_y = type_info::type_name<Y>();
event::emit_event<PairCreatedEvent>(
    &mut swap_info.pair_created,
    PairCreatedEvent {
        user: sender_addr,
        token_x,
        token_y
    }
);
register_lp<X, Y>(&resource_signer);
This final part:
Sets up event handlers for adding liquidity, removing liquidity, and swapping
Emits a "PairCreatedEvent" to notify listeners that a new pair has been created
Registers the ability to hold LP tokens
Conclusion
Congratulations! You've just learned about the intricate process of creating a trading pair in a DEX. This function sets up the foundation for users to provide liquidity and trade tokens. In the next part of this tutorial, we'll explore how to add liquidity to our newly created pair. Stay tuned!
		Key points covered:
		Key points covered:
		Understanding the
create_pair
function and its parameters
Performing initial checks and setup for pair creation
Generating a unique name for the LP (Liquidity Provider) token
Initializing the LP token with specific attributes
Setting up pool state data structures
Configuring event tracking for liquidity and swap actions
Emitting a PairCreatedEvent to notify listeners
Registering the ability to hold LP tokens
		Understanding the
create_pair
function and its parameters
		Understanding the
		<code>create_pair</code>
		create_pair
		function and its parameters
		Performing initial checks and setup for pair creation
		Performing initial checks and setup for pair creation
		Generating a unique name for the LP (Liquidity Provider) token
		Generating a unique name for the LP (Liquidity Provider) token
		Initializing the LP token with specific attributes
		Initializing the LP token with specific attributes
		Setting up pool state data structures
		Setting up pool state data structures
		Configuring event tracking for liquidity and swap actions
		Configuring event tracking for liquidity and swap actions
		Emitting a PairCreatedEvent to notify listeners
		Emitting a PairCreatedEvent to notify listeners
		Registering the ability to hold LP tokens
		Registering the ability to hold LP tokens
	Introduction to Creating Trading Pairs in a DEX
	Introduction to Creating Trading Pairs in a DEX
	Welcome to this beginner-friendly tutorial on creating trading pairs in a Decentralized Exchange (DEX). We'll explore the
create_pair
function, which is the foundation of setting up liquidity pools for token trading. Don't worry if some terms are unfamiliar - we'll break everything down step-by-step!
	Welcome to this beginner-friendly tutorial on creating trading pairs in a Decentralized Exchange (DEX). We'll explore the
	<code>create_pair</code>
	create_pair
	function, which is the foundation of setting up liquidity pools for token trading. Don't worry if some terms are unfamiliar - we'll break everything down step-by-step!
	1. Understanding the create_pair Function
	1. Understanding the create_pair Function
	Let's start by looking at the basic structure of our
create_pair
function:
	Let's start by looking at the basic structure of our
	<code>create_pair</code>
	create_pair
	function:
	<code>public fun create_pair<X, Y>(sender: &signer) acquires SwapInfo {
    // Implementation will go here
}</code>
	<code>public fun create_pair<X, Y>(sender: &signer) acquires SwapInfo {
    // Implementation will go here
}</code>
	public fun create_pair<X, Y>(sender: &signer) acquires SwapInfo {
    // Implementation will go here
}
	Here's what each part means:
	Here's what each part means:
	public fun
: This function can be called by anyone
<X, Y>
: These are generic type parameters representing our two tokens
sender: &signer
: The user creating the pair must sign the transaction
acquires SwapInfo
: This function will access global state information
	public fun
: This function can be called by anyone
	<code>public fun</code>
	public fun
	: This function can be called by anyone
	<X, Y>
: These are generic type parameters representing our two tokens
	<code><X, Y></code>
	<X, Y>
	: These are generic type parameters representing our two tokens
	sender: &signer
: The user creating the pair must sign the transaction
	<code>sender: &signer</code>
	sender: &signer
	: The user creating the pair must sign the transaction
	acquires SwapInfo
: This function will access global state information
	<code>acquires SwapInfo</code>
	acquires SwapInfo
	: This function will access global state information
	2. Initial Checks and Setup
	2. Initial Checks and Setup
	Before creating a new pair, we need to perform some checks and setup:
	Before creating a new pair, we need to perform some checks and setup:
	<code>assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
let sender_addr = signer::address_of(sender);
let swap_info = borrow_global_mut<SwapInfo>(DEFAULT_ADMIN);
let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);</code>
	<code>assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
let sender_addr = signer::address_of(sender);
let swap_info = borrow_global_mut<SwapInfo>(DEFAULT_ADMIN);
let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);</code>
	assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
let sender_addr = signer::address_of(sender);
let swap_info = borrow_global_mut<SwapInfo>(DEFAULT_ADMIN);
let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
	Let's break this down:
	Let's break this down:
	We first check if the pair already exists. If it does, we stop the process.
We get the address of the sender for later use.
We borrow the global SwapInfo to access shared state.
We create a special "resource signer" that allows the contract to manage resources.
	We first check if the pair already exists. If it does, we stop the process.
	We first check if the pair already exists. If it does, we stop the process.
	We get the address of the sender for later use.
	We get the address of the sender for later use.
	We borrow the global SwapInfo to access shared state.
	We borrow the global SwapInfo to access shared state.
	We create a special "resource signer" that allows the contract to manage resources.
	We create a special "resource signer" that allows the contract to manage resources.
	3. Creating the LP Token Name
	3. Creating the LP Token Name
	LP stands for "Liquidity Provider". We need to create a unique name for our LP token:
	LP stands for "Liquidity Provider". We need to create a unique name for our LP token:
	<code>let lp_name: string::String = string::utf8(b"movement-");
let name_x = coin::symbol<X>();
let name_y = coin::symbol<Y>();
string::append(&mut lp_name, name_x);
string::append_utf8(&mut lp_name, b"-");
string::append(&mut lp_name, name_y);
string::append_utf8(&mut lp_name, b"-LP");
if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
    lp_name = string::utf8(b"movement LPs");
};</code>
	<code>let lp_name: string::String = string::utf8(b"movement-");
let name_x = coin::symbol<X>();
let name_y = coin::symbol<Y>();
string::append(&mut lp_name, name_x);
string::append_utf8(&mut lp_name, b"-");
string::append(&mut lp_name, name_y);
string::append_utf8(&mut lp_name, b"-LP");
if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
    lp_name = string::utf8(b"movement LPs");
};</code>
	let lp_name: string::String = string::utf8(b"movement-");
let name_x = coin::symbol<X>();
let name_y = coin::symbol<Y>();
string::append(&mut lp_name, name_x);
string::append_utf8(&mut lp_name, b"-");
string::append(&mut lp_name, name_y);
string::append_utf8(&mut lp_name, b"-LP");
if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
    lp_name = string::utf8(b"movement LPs");
};
	This code does the following:
	This code does the following:
	Starts with "movement-"
Adds the symbols of both tokens
Ends with "-LP"
If the name is too long, it uses a generic "movement LPs" instead
	Starts with "movement-"
	Starts with "movement-"
	Adds the symbols of both tokens
	Adds the symbols of both tokens
	Ends with "-LP"
	Ends with "-LP"
	If the name is too long, it uses a generic "movement LPs" instead
	If the name is too long, it uses a generic "movement LPs" instead
	4. Initializing the LP Token
	4. Initializing the LP Token
	Now we create the actual LP token:
	Now we create the actual LP token:
	<code>let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
    &resource_signer,
    lp_name,
    string::utf8(b"Move-LP"),
    8,
    true
);</code>
	<code>let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
    &resource_signer,
    lp_name,
    string::utf8(b"Move-LP"),
    8,
    true
);</code>
	let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
    &resource_signer,
    lp_name,
    string::utf8(b"Move-LP"),
    8,
    true
);
	This function call does several things:
	This function call does several things:
	Creates a new token type
LPToken<X, Y>
Sets its name to our generated
lp_name
Sets its symbol to "Move-LP"
Sets 8 decimal places
Enables supply tracking
Returns capabilities for burning, freezing, and minting these tokens
	Creates a new token type
LPToken<X, Y>
	Creates a new token type
	<code>LPToken<X, Y></code>
	LPToken<X, Y>
	Sets its name to our generated
lp_name
	Sets its name to our generated
	<code>lp_name</code>
	lp_name
	Sets its symbol to "Move-LP"
	Sets its symbol to "Move-LP"
	Sets 8 decimal places
	Sets 8 decimal places
	Enables supply tracking
	Enables supply tracking
	Returns capabilities for burning, freezing, and minting these tokens
	Returns capabilities for burning, freezing, and minting these tokens
	5. Setting Up the Pool State
	5. Setting Up the Pool State
	We need to initialize some data structures to keep track of our trading pair:
	We need to initialize some data structures to keep track of our trading pair:
	<code>move_to<TokenPairReserve<X, Y>>(
    &resource_signer,
    TokenPairReserve {
        reserve_x: 0,
        reserve_y: 0,
        block_timestamp_last: 0
    }
);
move_to<TokenPairMetadata<X, Y>>(
    &resource_signer,
    TokenPairMetadata {
        creator: sender_addr,
        fee_amount: coin::zero<LPToken<X, Y>>(),
        k_last: 0,
        balance_x: coin::zero<X>(),
        balance_y: coin::zero<Y>(),
        mint_cap,
        burn_cap,
        freeze_cap,
    }
);</code>
	<code>move_to<TokenPairReserve<X, Y>>(
    &resource_signer,
    TokenPairReserve {
        reserve_x: 0,
        reserve_y: 0,
        block_timestamp_last: 0
    }
);
move_to<TokenPairMetadata<X, Y>>(
    &resource_signer,
    TokenPairMetadata {
        creator: sender_addr,
        fee_amount: coin::zero<LPToken<X, Y>>(),
        k_last: 0,
        balance_x: coin::zero<X>(),
        balance_y: coin::zero<Y>(),
        mint_cap,
        burn_cap,
        freeze_cap,
    }
);</code>
	move_to<TokenPairReserve<X, Y>>(
    &resource_signer,
    TokenPairReserve {
        reserve_x: 0,
        reserve_y: 0,
        block_timestamp_last: 0
    }
);
move_to<TokenPairMetadata<X, Y>>(
    &resource_signer,
    TokenPairMetadata {
        creator: sender_addr,
        fee_amount: coin::zero<LPToken<X, Y>>(),
        k_last: 0,
        balance_x: coin::zero<X>(),
        balance_y: coin::zero<Y>(),
        mint_cap,
        burn_cap,
        freeze_cap,
    }
);
	This initializes two important structures:
	This initializes two important structures:
	TokenPairReserve
: Keeps track of the current amounts of each token in the pool
TokenPairMetadata
: Stores various pieces of information about the pair, including who created it, accumulated fees, and token balances
	TokenPairReserve
: Keeps track of the current amounts of each token in the pool
	<code>TokenPairReserve</code>
	TokenPairReserve
	: Keeps track of the current amounts of each token in the pool
	TokenPairMetadata
: Stores various pieces of information about the pair, including who created it, accumulated fees, and token balances
	<code>TokenPairMetadata</code>
	TokenPairMetadata
	: Stores various pieces of information about the pair, including who created it, accumulated fees, and token balances
	6. Setting Up Events and Finalizing
	6. Setting Up Events and Finalizing
	Lastly, we set up event tracking and finalize the pair creation:
	Lastly, we set up event tracking and finalize the pair creation:
	<code>move_to<PairEventHolder<X, Y>>(
    &resource_signer,
    PairEventHolder {
        add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
        remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
        swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
    }
);
let token_x = type_info::type_name<X>();
let token_y = type_info::type_name<Y>();
event::emit_event<PairCreatedEvent>(
    &mut swap_info.pair_created,
    PairCreatedEvent {
        user: sender_addr,
        token_x,
        token_y
    }
);
register_lp<X, Y>(&resource_signer);</code>
	<code>move_to<PairEventHolder<X, Y>>(
    &resource_signer,
    PairEventHolder {
        add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
        remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
        swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
    }
);
let token_x = type_info::type_name<X>();
let token_y = type_info::type_name<Y>();
event::emit_event<PairCreatedEvent>(
    &mut swap_info.pair_created,
    PairCreatedEvent {
        user: sender_addr,
        token_x,
        token_y
    }
);
register_lp<X, Y>(&resource_signer);</code>
	move_to<PairEventHolder<X, Y>>(
    &resource_signer,
    PairEventHolder {
        add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
        remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
        swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
    }
);
let token_x = type_info::type_name<X>();
let token_y = type_info::type_name<Y>();
event::emit_event<PairCreatedEvent>(
    &mut swap_info.pair_created,
    PairCreatedEvent {
        user: sender_addr,
        token_x,
        token_y
    }
);
register_lp<X, Y>(&resource_signer);
	This final part:
	This final part:
	Sets up event handlers for adding liquidity, removing liquidity, and swapping
Emits a "PairCreatedEvent" to notify listeners that a new pair has been created
Registers the ability to hold LP tokens
	Sets up event handlers for adding liquidity, removing liquidity, and swapping
	Sets up event handlers for adding liquidity, removing liquidity, and swapping
	Emits a "PairCreatedEvent" to notify listeners that a new pair has been created
	Emits a "PairCreatedEvent" to notify listeners that a new pair has been created
	Registers the ability to hold LP tokens
	Registers the ability to hold LP tokens
	Conclusion
	Conclusion
	Congratulations! You've just learned about the intricate process of creating a trading pair in a DEX. This function sets up the foundation for users to provide liquidity and trade tokens. In the next part of this tutorial, we'll explore how to add liquidity to our newly created pair. Stay tuned!
	Congratulations! You've just learned about the intricate process of creating a trading pair in a DEX. This function sets up the foundation for users to provide liquidity and trade tokens. In the next part of this tutorial, we'll explore how to add liquidity to our newly created pair. Stay tuned!

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/02-swap/04-adding-liquidity-in-a-dex
Adding Liquidity in a DEX
Adding Liquidity in a DEX
On This Page
Summary
Introduction to Adding Liquidity in a DEX
1. Understanding the Main Entry Point: add_liquidity
1.1. Input Parameters Explained
1.2. Understanding Coin Operations
1.3. Processing Return Values
1.4. Managing Token Stores
2. Deep Dive into Direct Liquidity Addition
2.1. Calculating Optimal Amounts
2.2. Depositing Tokens into the Pool
3. Understanding the LP Token Minting Process
3.1. Initial Liquidity Calculation
3.2. Subsequent Liquidity Calculation
4. Event Emission for Transparency
5. Crucial Safety Considerations
Summary
Adding liquidity in a DEX involves users providing token pairs to create trading pools
The process is managed through the
add_liquidity
function, which handles token withdrawal, deposit, and LP token minting
Optimal amounts are calculated to maintain the pool's price ratio and prevent manipulation
LP tokens are minted proportionally to the liquidity provided, with special considerations for initial liquidity
Safety measures include slippage protection, minimum liquidity requirements, and atomic state updates
Events are emitted for transparency and off-chain tracking of pool activities
The process ensures fair distribution of LP tokens and maintains the constant product formula
Introduction to Adding Liquidity in a DEX
Adding liquidity is a fundamental operation in any Decentralized Exchange (DEX). When users provide token pairs to create trading pools, they receive Liquidity Provider (LP) tokens in return. This process is crucial for maintaining the DEX's functionality and liquidity. Let's dive into the detailed implementation of the
add_liquidity
function and its components, breaking it down for beginners.
1. Understanding the Main Entry Point: add_liquidity
The
add_liquidity
function is the primary way users interact with the liquidity pool. Let's examine its structure and purpose:
public fun add_liquidity<X, Y>(
    sender: &signer,
    amount_x: u64,
    amount_y: u64
): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
    let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = 
    add_liquidity_direct(
        coin::withdraw<X>(sender, amount_x), 
        coin::withdraw<Y>(sender, amount_y)
    );
    
    let sender_addr = signer::address_of(sender);
    let lp_amount = coin::value(&coin_lp);
    assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    
    check_or_register_coin_store<LPToken<X, Y>>(sender);
    coin::deposit(sender_addr, coin_lp);
    coin::deposit(sender_addr, coin_left_x);
    coin::deposit(sender_addr, coin_left_y);
    
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<AddLiquidityEvent<X, Y>>(
        &mut pair_event_holder.add_liquidity,
        AddLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x: a_x,
            amount_y: a_y,
            liquidity: lp_amount,
            fee_amount: (fee_amount as u64),
        }
    );
    (a_x, a_y, lp_amount
}
1.1. Input Parameters Explained
sender: &signer
: This represents the account that's adding liquidity. In Move, a
signer
is a special type that proves ownership of an account.
amount_x: u64
: The amount of token X the user wants to add to the pool.
u64
means it's an unsigned 64-bit integer.
amount_y: u64
: The amount of token Y the user wants to add to the pool.
Returns:
(u64, u64, u64)
: This function returns three values:
The actual amount of token X used
The actual amount of token Y used
The number of LP tokens received
1.2. Understanding Coin Operations
The function starts by withdrawing tokens from the sender's account:
coin::withdraw<X>(sender, amount_x),
coin::withdraw<Y>(sender, amount_y)
These operations move tokens from the user's account to the contract's control.
The
coin::withdraw
function automatically checks if the user has sufficient balance.
If the balance is insufficient, the operation will fail, preventing any further execution.
1.3. Processing Return Values
After adding liquidity, the function checks if LP tokens were successfully minted:
let lp_amount = coin::value(&coin_lp);
assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
This verifies that a non-zero amount of LP tokens were minted.
If no LP tokens were minted (lp_amount = 0), the function will abort with an error.
This check ensures that users always receive LP tokens when adding liquidity, preventing potential loss of funds.
1.4. Managing Token Stores
Before depositing LP tokens, the function ensures the user can receive them:
check_or_register_coin_store<LPToken<X, Y>>(sender);
Let's look at the helper function implementation:
public fun check_or_register_coin_store<X>(sender: &signer) {
    if (!coin::is_account_registered<X>(signer::address_of(sender))) {
        coin::register<X>(sender);
    };
}
This function checks if the sender's account is registered to hold the LP token.
If not registered, it automatically registers the account to receive the token.
This prevents failures when trying to deposit LP tokens to an unregistered account.
2. Deep Dive into Direct Liquidity Addition
The core logic of adding liquidity is handled by the
add_liquidity_direct
function. Let's break it down:
fun add_liquidity_direct<X, Y>(
    x: coin::Coin<X>,
    y: coin::Coin<Y>,
): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>)
    acquires TokenPairReserve, TokenPairMetadata {
    let amount_x = coin::value(&x);
    let amount_y = coin::value(&y);
    let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
    
    // Calculate optimal amounts
    let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
        (amount_x, amount_y)
    } else {
        calculate_optimal_amounts(amount_x, amount_y, reserve_x, reserve_y)
    };
    assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
    assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
    let left_x = coin::extract(&mut x, amount_x - a_x);
    let left_y = coin::extract(&mut y, amount_y - a_y);
    
    deposit_x<X, Y>(x);
    deposit_y<X, Y>(y);
    
    let (lp, fee_amount) = mint<X, Y>();
    
    (a_x, a_y, lp, fee_amount, left_x, left_y)
}
2.1. Calculating Optimal Amounts
The function handles two scenarios: initial liquidity and subsequent additions.
For initial liquidity (when the pool is empty):
if (reserve_x == 0 && reserve_y == 0) {
    (amount_x, amount_y)
}
When the pool is empty, all provided tokens are used.
This sets the initial price ratio for the pool.
For subsequent additions:
let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
if (amount_y_optimal <= amount_y) {
    (amount_x, amount_y_optimal)
} else {
    let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
    assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
    (amount_x_optimal, amount_y)
}
The
quote
function calculates the optimal amount to maintain the current price ratio:
public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
This calculation ensures the constant product formula: (x + Δx)/(y + Δy) = x/y
It prevents price manipulation by maintaining the current pool ratio.
The function uses u128 (128-bit integers) for intermediate calculations to prevent overflow.
2.2. Depositing Tokens into the Pool
After calculating optimal amounts, the tokens are deposited into the pool:
fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_x, amount);
}
fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_y, amount);
}
These functions update the pool's balances by merging the new tokens with existing reserves.
The
borrow_global_mut
function allows modifying global storage.
Using separate functions for X and Y tokens ensures type safety and prevents mixing up token types.
3. Understanding the LP Token Minting Process
After depositing tokens, the contract mints LP tokens for the liquidity provider:
fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), 
                                 coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    
    let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
    let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
    
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    let total_supply = total_lp_supply<X, Y>();
    
    let liquidity = calculate_liquidity_amount(
        amount_x, 
        amount_y, 
        total_supply, 
        reserves
    );
    
    let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
    update<X, Y>(balance_x, balance_y, reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    
    (lp, fee_amount)
}
3.1. Initial Liquidity Calculation
For the first liquidity provider, LP tokens are calculated as follows:
if (total_supply == 0u128) {
    let sqrt = math128::sqrt(amount_x * amount_y);
    assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
    let l = sqrt - MINIMUM_LIQUIDITY;
    mint_lp_to<X, Y>(DEFAULT_ADMIN, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
    l
}
The geometric mean (square root of the product) of deposits is used to determine initial LP tokens.
A small amount (MINIMUM_LIQUIDITY) is locked forever to prevent the pool from being drained completely.
This approach helps in setting a fair initial price and prevents exploitation by the first liquidity provider.
3.2. Subsequent Liquidity Calculation
For subsequent liquidity additions, LP tokens are calculated proportionally:
let liquidity = math128::min(
    amount_x * total_supply / (reserves.reserve_x as u128),
    amount_y * total_supply / (reserves.reserve_y as u128)
);
assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
This calculation ensures fair distribution of LP tokens based on the proportion of liquidity added.
Using the minimum of the two ratios prevents dilution and maintains fairness.
The assert statement ensures that some LP tokens are always minted, preventing zero-value operations.
4. Event Emission for Transparency
The contract emits an event after successfully adding liquidity:
struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
    user: address,
    amount_x: u64,
    amount_y: u64,
    liquidity: u64,
    fee_amount: u64
}
This event records all relevant details of the liquidity addition.
It includes the user's address, amounts of both tokens used, LP tokens received, and any fees paid.
Emitting events allows for off-chain tracking and analysis of pool activities.
5. Crucial Safety Considerations
Slippage Protection:
The contract calculates optimal amounts to maintain the asset ratio.
Any unused tokens are returned to the user, preventing unexpected losses.
Minimum Requirements:
The contract enforces a non-zero liquidity check to prevent dust amounts.
A minimum LP token amount is required to prevent exploitation.
State Updates:
All operations are performed atomically to ensure consistency.
The constant product (K value) is maintained throughout the process.
**Error Handling:**The contract uses clear error codes for different failure scenarios:
const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 0x004;
const ERROR_INSUFFICIENT_AMOUNT: u64 = 0x006;
const ERROR_INVALID_AMOUNT: u64 = 0x008;
These error codes help in identifying and debugging issues quickly.
Each error corresponds to a specific failure case, improving error handling and user feedback.
This detailed breakdown of the
add_liquidity
function and its components provides a comprehensive understanding of how liquidity is added to a DEX. Next, we'll explore the
remove_liquidity
function to complete our understanding of liquidity management in a DEX
On This Page
Summary
Introduction to Adding Liquidity in a DEX
1. Understanding the Main Entry Point: add_liquidity
1.1. Input Parameters Explained
1.2. Understanding Coin Operations
1.3. Processing Return Values
1.4. Managing Token Stores
2. Deep Dive into Direct Liquidity Addition
2.1. Calculating Optimal Amounts
2.2. Depositing Tokens into the Pool
3. Understanding the LP Token Minting Process
3.1. Initial Liquidity Calculation
3.2. Subsequent Liquidity Calculation
4. Event Emission for Transparency
5. Crucial Safety Considerations
On This Page
Summary
Introduction to Adding Liquidity in a DEX
1. Understanding the Main Entry Point: add_liquidity
1.1. Input Parameters Explained
1.2. Understanding Coin Operations
1.3. Processing Return Values
1.4. Managing Token Stores
2. Deep Dive into Direct Liquidity Addition
2.1. Calculating Optimal Amounts
2.2. Depositing Tokens into the Pool
3. Understanding the LP Token Minting Process
3.1. Initial Liquidity Calculation
3.2. Subsequent Liquidity Calculation
4. Event Emission for Transparency
5. Crucial Safety Considerations
			On This Page
			On This Page
			Summary
Introduction to Adding Liquidity in a DEX
1. Understanding the Main Entry Point: add_liquidity
1.1. Input Parameters Explained
1.2. Understanding Coin Operations
1.3. Processing Return Values
1.4. Managing Token Stores
2. Deep Dive into Direct Liquidity Addition
2.1. Calculating Optimal Amounts
2.2. Depositing Tokens into the Pool
3. Understanding the LP Token Minting Process
3.1. Initial Liquidity Calculation
3.2. Subsequent Liquidity Calculation
4. Event Emission for Transparency
5. Crucial Safety Considerations
			Summary
			Summary
			Summary
			Summary
			Introduction to Adding Liquidity in a DEX
			Introduction to Adding Liquidity in a DEX
			Introduction to Adding Liquidity in a DEX
			Introduction to Adding Liquidity in a DEX
			1. Understanding the Main Entry Point: add_liquidity
1.1. Input Parameters Explained
1.2. Understanding Coin Operations
1.3. Processing Return Values
1.4. Managing Token Stores
			1. Understanding the Main Entry Point: add_liquidity
			1. Understanding the Main Entry Point: add_liquidity
			1. Understanding the Main Entry Point: add_liquidity
			1.1. Input Parameters Explained
1.2. Understanding Coin Operations
1.3. Processing Return Values
1.4. Managing Token Stores
			1.1. Input Parameters Explained
			1.1. Input Parameters Explained
			1.1. Input Parameters Explained
			1.1. Input Parameters Explained
			1.2. Understanding Coin Operations
			1.2. Understanding Coin Operations
			1.2. Understanding Coin Operations
			1.2. Understanding Coin Operations
			1.3. Processing Return Values
			1.3. Processing Return Values
			1.3. Processing Return Values
			1.3. Processing Return Values
			1.4. Managing Token Stores
			1.4. Managing Token Stores
			1.4. Managing Token Stores
			1.4. Managing Token Stores
			2. Deep Dive into Direct Liquidity Addition
2.1. Calculating Optimal Amounts
2.2. Depositing Tokens into the Pool
			2. Deep Dive into Direct Liquidity Addition
			2. Deep Dive into Direct Liquidity Addition
			2. Deep Dive into Direct Liquidity Addition
			2.1. Calculating Optimal Amounts
2.2. Depositing Tokens into the Pool
			2.1. Calculating Optimal Amounts
			2.1. Calculating Optimal Amounts
			2.1. Calculating Optimal Amounts
			2.1. Calculating Optimal Amounts
			2.2. Depositing Tokens into the Pool
			2.2. Depositing Tokens into the Pool
			2.2. Depositing Tokens into the Pool
			2.2. Depositing Tokens into the Pool
			3. Understanding the LP Token Minting Process
3.1. Initial Liquidity Calculation
3.2. Subsequent Liquidity Calculation
			3. Understanding the LP Token Minting Process
			3. Understanding the LP Token Minting Process
			3. Understanding the LP Token Minting Process
			3.1. Initial Liquidity Calculation
3.2. Subsequent Liquidity Calculation
			3.1. Initial Liquidity Calculation
			3.1. Initial Liquidity Calculation
			3.1. Initial Liquidity Calculation
			3.1. Initial Liquidity Calculation
			3.2. Subsequent Liquidity Calculation
			3.2. Subsequent Liquidity Calculation
			3.2. Subsequent Liquidity Calculation
			3.2. Subsequent Liquidity Calculation
			4. Event Emission for Transparency
			4. Event Emission for Transparency
			4. Event Emission for Transparency
			4. Event Emission for Transparency
			5. Crucial Safety Considerations
			5. Crucial Safety Considerations
			5. Crucial Safety Considerations
			5. Crucial Safety Considerations
			Summary
Adding liquidity in a DEX involves users providing token pairs to create trading pools
The process is managed through the
add_liquidity
function, which handles token withdrawal, deposit, and LP token minting
Optimal amounts are calculated to maintain the pool's price ratio and prevent manipulation
LP tokens are minted proportionally to the liquidity provided, with special considerations for initial liquidity
Safety measures include slippage protection, minimum liquidity requirements, and atomic state updates
Events are emitted for transparency and off-chain tracking of pool activities
The process ensures fair distribution of LP tokens and maintains the constant product formula
Introduction to Adding Liquidity in a DEX
Adding liquidity is a fundamental operation in any Decentralized Exchange (DEX). When users provide token pairs to create trading pools, they receive Liquidity Provider (LP) tokens in return. This process is crucial for maintaining the DEX's functionality and liquidity. Let's dive into the detailed implementation of the
add_liquidity
function and its components, breaking it down for beginners.
1. Understanding the Main Entry Point: add_liquidity
The
add_liquidity
function is the primary way users interact with the liquidity pool. Let's examine its structure and purpose:
public fun add_liquidity<X, Y>(
    sender: &signer,
    amount_x: u64,
    amount_y: u64
): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
    let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = 
    add_liquidity_direct(
        coin::withdraw<X>(sender, amount_x), 
        coin::withdraw<Y>(sender, amount_y)
    );
    
    let sender_addr = signer::address_of(sender);
    let lp_amount = coin::value(&coin_lp);
    assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    
    check_or_register_coin_store<LPToken<X, Y>>(sender);
    coin::deposit(sender_addr, coin_lp);
    coin::deposit(sender_addr, coin_left_x);
    coin::deposit(sender_addr, coin_left_y);
    
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<AddLiquidityEvent<X, Y>>(
        &mut pair_event_holder.add_liquidity,
        AddLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x: a_x,
            amount_y: a_y,
            liquidity: lp_amount,
            fee_amount: (fee_amount as u64),
        }
    );
    (a_x, a_y, lp_amount
}
1.1. Input Parameters Explained
sender: &signer
: This represents the account that's adding liquidity. In Move, a
signer
is a special type that proves ownership of an account.
amount_x: u64
: The amount of token X the user wants to add to the pool.
u64
means it's an unsigned 64-bit integer.
amount_y: u64
: The amount of token Y the user wants to add to the pool.
Returns:
(u64, u64, u64)
: This function returns three values:
The actual amount of token X used
The actual amount of token Y used
The number of LP tokens received
1.2. Understanding Coin Operations
The function starts by withdrawing tokens from the sender's account:
coin::withdraw<X>(sender, amount_x),
coin::withdraw<Y>(sender, amount_y)
These operations move tokens from the user's account to the contract's control.
The
coin::withdraw
function automatically checks if the user has sufficient balance.
If the balance is insufficient, the operation will fail, preventing any further execution.
1.3. Processing Return Values
After adding liquidity, the function checks if LP tokens were successfully minted:
let lp_amount = coin::value(&coin_lp);
assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
This verifies that a non-zero amount of LP tokens were minted.
If no LP tokens were minted (lp_amount = 0), the function will abort with an error.
This check ensures that users always receive LP tokens when adding liquidity, preventing potential loss of funds.
1.4. Managing Token Stores
Before depositing LP tokens, the function ensures the user can receive them:
check_or_register_coin_store<LPToken<X, Y>>(sender);
Let's look at the helper function implementation:
public fun check_or_register_coin_store<X>(sender: &signer) {
    if (!coin::is_account_registered<X>(signer::address_of(sender))) {
        coin::register<X>(sender);
    };
}
This function checks if the sender's account is registered to hold the LP token.
If not registered, it automatically registers the account to receive the token.
This prevents failures when trying to deposit LP tokens to an unregistered account.
2. Deep Dive into Direct Liquidity Addition
The core logic of adding liquidity is handled by the
add_liquidity_direct
function. Let's break it down:
fun add_liquidity_direct<X, Y>(
    x: coin::Coin<X>,
    y: coin::Coin<Y>,
): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>)
    acquires TokenPairReserve, TokenPairMetadata {
    let amount_x = coin::value(&x);
    let amount_y = coin::value(&y);
    let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
    
    // Calculate optimal amounts
    let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
        (amount_x, amount_y)
    } else {
        calculate_optimal_amounts(amount_x, amount_y, reserve_x, reserve_y)
    };
    assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
    assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
    let left_x = coin::extract(&mut x, amount_x - a_x);
    let left_y = coin::extract(&mut y, amount_y - a_y);
    
    deposit_x<X, Y>(x);
    deposit_y<X, Y>(y);
    
    let (lp, fee_amount) = mint<X, Y>();
    
    (a_x, a_y, lp, fee_amount, left_x, left_y)
}
2.1. Calculating Optimal Amounts
The function handles two scenarios: initial liquidity and subsequent additions.
For initial liquidity (when the pool is empty):
if (reserve_x == 0 && reserve_y == 0) {
    (amount_x, amount_y)
}
When the pool is empty, all provided tokens are used.
This sets the initial price ratio for the pool.
For subsequent additions:
let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
if (amount_y_optimal <= amount_y) {
    (amount_x, amount_y_optimal)
} else {
    let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
    assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
    (amount_x_optimal, amount_y)
}
The
quote
function calculates the optimal amount to maintain the current price ratio:
public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
This calculation ensures the constant product formula: (x + Δx)/(y + Δy) = x/y
It prevents price manipulation by maintaining the current pool ratio.
The function uses u128 (128-bit integers) for intermediate calculations to prevent overflow.
2.2. Depositing Tokens into the Pool
After calculating optimal amounts, the tokens are deposited into the pool:
fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_x, amount);
}
fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_y, amount);
}
These functions update the pool's balances by merging the new tokens with existing reserves.
The
borrow_global_mut
function allows modifying global storage.
Using separate functions for X and Y tokens ensures type safety and prevents mixing up token types.
3. Understanding the LP Token Minting Process
After depositing tokens, the contract mints LP tokens for the liquidity provider:
fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), 
                                 coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    
    let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
    let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
    
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    let total_supply = total_lp_supply<X, Y>();
    
    let liquidity = calculate_liquidity_amount(
        amount_x, 
        amount_y, 
        total_supply, 
        reserves
    );
    
    let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
    update<X, Y>(balance_x, balance_y, reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    
    (lp, fee_amount)
}
3.1. Initial Liquidity Calculation
For the first liquidity provider, LP tokens are calculated as follows:
if (total_supply == 0u128) {
    let sqrt = math128::sqrt(amount_x * amount_y);
    assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
    let l = sqrt - MINIMUM_LIQUIDITY;
    mint_lp_to<X, Y>(DEFAULT_ADMIN, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
    l
}
The geometric mean (square root of the product) of deposits is used to determine initial LP tokens.
A small amount (MINIMUM_LIQUIDITY) is locked forever to prevent the pool from being drained completely.
This approach helps in setting a fair initial price and prevents exploitation by the first liquidity provider.
3.2. Subsequent Liquidity Calculation
For subsequent liquidity additions, LP tokens are calculated proportionally:
let liquidity = math128::min(
    amount_x * total_supply / (reserves.reserve_x as u128),
    amount_y * total_supply / (reserves.reserve_y as u128)
);
assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
This calculation ensures fair distribution of LP tokens based on the proportion of liquidity added.
Using the minimum of the two ratios prevents dilution and maintains fairness.
The assert statement ensures that some LP tokens are always minted, preventing zero-value operations.
4. Event Emission for Transparency
The contract emits an event after successfully adding liquidity:
struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
    user: address,
    amount_x: u64,
    amount_y: u64,
    liquidity: u64,
    fee_amount: u64
}
This event records all relevant details of the liquidity addition.
It includes the user's address, amounts of both tokens used, LP tokens received, and any fees paid.
Emitting events allows for off-chain tracking and analysis of pool activities.
5. Crucial Safety Considerations
Slippage Protection:
The contract calculates optimal amounts to maintain the asset ratio.
Any unused tokens are returned to the user, preventing unexpected losses.
Minimum Requirements:
The contract enforces a non-zero liquidity check to prevent dust amounts.
A minimum LP token amount is required to prevent exploitation.
State Updates:
All operations are performed atomically to ensure consistency.
The constant product (K value) is maintained throughout the process.
**Error Handling:**The contract uses clear error codes for different failure scenarios:
const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 0x004;
const ERROR_INSUFFICIENT_AMOUNT: u64 = 0x006;
const ERROR_INVALID_AMOUNT: u64 = 0x008;
These error codes help in identifying and debugging issues quickly.
Each error corresponds to a specific failure case, improving error handling and user feedback.
This detailed breakdown of the
add_liquidity
function and its components provides a comprehensive understanding of how liquidity is added to a DEX. Next, we'll explore the
remove_liquidity
function to complete our understanding of liquidity management in a DEX
			Summary
Adding liquidity in a DEX involves users providing token pairs to create trading pools
The process is managed through the
add_liquidity
function, which handles token withdrawal, deposit, and LP token minting
Optimal amounts are calculated to maintain the pool's price ratio and prevent manipulation
LP tokens are minted proportionally to the liquidity provided, with special considerations for initial liquidity
Safety measures include slippage protection, minimum liquidity requirements, and atomic state updates
Events are emitted for transparency and off-chain tracking of pool activities
The process ensures fair distribution of LP tokens and maintains the constant product formula
Introduction to Adding Liquidity in a DEX
Adding liquidity is a fundamental operation in any Decentralized Exchange (DEX). When users provide token pairs to create trading pools, they receive Liquidity Provider (LP) tokens in return. This process is crucial for maintaining the DEX's functionality and liquidity. Let's dive into the detailed implementation of the
add_liquidity
function and its components, breaking it down for beginners.
1. Understanding the Main Entry Point: add_liquidity
The
add_liquidity
function is the primary way users interact with the liquidity pool. Let's examine its structure and purpose:
public fun add_liquidity<X, Y>(
    sender: &signer,
    amount_x: u64,
    amount_y: u64
): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
    let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = 
    add_liquidity_direct(
        coin::withdraw<X>(sender, amount_x), 
        coin::withdraw<Y>(sender, amount_y)
    );
    
    let sender_addr = signer::address_of(sender);
    let lp_amount = coin::value(&coin_lp);
    assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    
    check_or_register_coin_store<LPToken<X, Y>>(sender);
    coin::deposit(sender_addr, coin_lp);
    coin::deposit(sender_addr, coin_left_x);
    coin::deposit(sender_addr, coin_left_y);
    
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<AddLiquidityEvent<X, Y>>(
        &mut pair_event_holder.add_liquidity,
        AddLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x: a_x,
            amount_y: a_y,
            liquidity: lp_amount,
            fee_amount: (fee_amount as u64),
        }
    );
    (a_x, a_y, lp_amount
}
1.1. Input Parameters Explained
sender: &signer
: This represents the account that's adding liquidity. In Move, a
signer
is a special type that proves ownership of an account.
amount_x: u64
: The amount of token X the user wants to add to the pool.
u64
means it's an unsigned 64-bit integer.
amount_y: u64
: The amount of token Y the user wants to add to the pool.
Returns:
(u64, u64, u64)
: This function returns three values:
The actual amount of token X used
The actual amount of token Y used
The number of LP tokens received
1.2. Understanding Coin Operations
The function starts by withdrawing tokens from the sender's account:
coin::withdraw<X>(sender, amount_x),
coin::withdraw<Y>(sender, amount_y)
These operations move tokens from the user's account to the contract's control.
The
coin::withdraw
function automatically checks if the user has sufficient balance.
If the balance is insufficient, the operation will fail, preventing any further execution.
1.3. Processing Return Values
After adding liquidity, the function checks if LP tokens were successfully minted:
let lp_amount = coin::value(&coin_lp);
assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
This verifies that a non-zero amount of LP tokens were minted.
If no LP tokens were minted (lp_amount = 0), the function will abort with an error.
This check ensures that users always receive LP tokens when adding liquidity, preventing potential loss of funds.
1.4. Managing Token Stores
Before depositing LP tokens, the function ensures the user can receive them:
check_or_register_coin_store<LPToken<X, Y>>(sender);
Let's look at the helper function implementation:
public fun check_or_register_coin_store<X>(sender: &signer) {
    if (!coin::is_account_registered<X>(signer::address_of(sender))) {
        coin::register<X>(sender);
    };
}
This function checks if the sender's account is registered to hold the LP token.
If not registered, it automatically registers the account to receive the token.
This prevents failures when trying to deposit LP tokens to an unregistered account.
2. Deep Dive into Direct Liquidity Addition
The core logic of adding liquidity is handled by the
add_liquidity_direct
function. Let's break it down:
fun add_liquidity_direct<X, Y>(
    x: coin::Coin<X>,
    y: coin::Coin<Y>,
): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>)
    acquires TokenPairReserve, TokenPairMetadata {
    let amount_x = coin::value(&x);
    let amount_y = coin::value(&y);
    let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
    
    // Calculate optimal amounts
    let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
        (amount_x, amount_y)
    } else {
        calculate_optimal_amounts(amount_x, amount_y, reserve_x, reserve_y)
    };
    assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
    assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
    let left_x = coin::extract(&mut x, amount_x - a_x);
    let left_y = coin::extract(&mut y, amount_y - a_y);
    
    deposit_x<X, Y>(x);
    deposit_y<X, Y>(y);
    
    let (lp, fee_amount) = mint<X, Y>();
    
    (a_x, a_y, lp, fee_amount, left_x, left_y)
}
2.1. Calculating Optimal Amounts
The function handles two scenarios: initial liquidity and subsequent additions.
For initial liquidity (when the pool is empty):
if (reserve_x == 0 && reserve_y == 0) {
    (amount_x, amount_y)
}
When the pool is empty, all provided tokens are used.
This sets the initial price ratio for the pool.
For subsequent additions:
let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
if (amount_y_optimal <= amount_y) {
    (amount_x, amount_y_optimal)
} else {
    let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
    assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
    (amount_x_optimal, amount_y)
}
The
quote
function calculates the optimal amount to maintain the current price ratio:
public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
This calculation ensures the constant product formula: (x + Δx)/(y + Δy) = x/y
It prevents price manipulation by maintaining the current pool ratio.
The function uses u128 (128-bit integers) for intermediate calculations to prevent overflow.
2.2. Depositing Tokens into the Pool
After calculating optimal amounts, the tokens are deposited into the pool:
fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_x, amount);
}
fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_y, amount);
}
These functions update the pool's balances by merging the new tokens with existing reserves.
The
borrow_global_mut
function allows modifying global storage.
Using separate functions for X and Y tokens ensures type safety and prevents mixing up token types.
3. Understanding the LP Token Minting Process
After depositing tokens, the contract mints LP tokens for the liquidity provider:
fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), 
                                 coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    
    let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
    let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
    
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    let total_supply = total_lp_supply<X, Y>();
    
    let liquidity = calculate_liquidity_amount(
        amount_x, 
        amount_y, 
        total_supply, 
        reserves
    );
    
    let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
    update<X, Y>(balance_x, balance_y, reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    
    (lp, fee_amount)
}
3.1. Initial Liquidity Calculation
For the first liquidity provider, LP tokens are calculated as follows:
if (total_supply == 0u128) {
    let sqrt = math128::sqrt(amount_x * amount_y);
    assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
    let l = sqrt - MINIMUM_LIQUIDITY;
    mint_lp_to<X, Y>(DEFAULT_ADMIN, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
    l
}
The geometric mean (square root of the product) of deposits is used to determine initial LP tokens.
A small amount (MINIMUM_LIQUIDITY) is locked forever to prevent the pool from being drained completely.
This approach helps in setting a fair initial price and prevents exploitation by the first liquidity provider.
3.2. Subsequent Liquidity Calculation
For subsequent liquidity additions, LP tokens are calculated proportionally:
let liquidity = math128::min(
    amount_x * total_supply / (reserves.reserve_x as u128),
    amount_y * total_supply / (reserves.reserve_y as u128)
);
assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
This calculation ensures fair distribution of LP tokens based on the proportion of liquidity added.
Using the minimum of the two ratios prevents dilution and maintains fairness.
The assert statement ensures that some LP tokens are always minted, preventing zero-value operations.
4. Event Emission for Transparency
The contract emits an event after successfully adding liquidity:
struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
    user: address,
    amount_x: u64,
    amount_y: u64,
    liquidity: u64,
    fee_amount: u64
}
This event records all relevant details of the liquidity addition.
It includes the user's address, amounts of both tokens used, LP tokens received, and any fees paid.
Emitting events allows for off-chain tracking and analysis of pool activities.
5. Crucial Safety Considerations
Slippage Protection:
The contract calculates optimal amounts to maintain the asset ratio.
Any unused tokens are returned to the user, preventing unexpected losses.
Minimum Requirements:
The contract enforces a non-zero liquidity check to prevent dust amounts.
A minimum LP token amount is required to prevent exploitation.
State Updates:
All operations are performed atomically to ensure consistency.
The constant product (K value) is maintained throughout the process.
**Error Handling:**The contract uses clear error codes for different failure scenarios:
const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 0x004;
const ERROR_INSUFFICIENT_AMOUNT: u64 = 0x006;
const ERROR_INVALID_AMOUNT: u64 = 0x008;
These error codes help in identifying and debugging issues quickly.
Each error corresponds to a specific failure case, improving error handling and user feedback.
This detailed breakdown of the
add_liquidity
function and its components provides a comprehensive understanding of how liquidity is added to a DEX. Next, we'll explore the
remove_liquidity
function to complete our understanding of liquidity management in a DEX
			Summary
Adding liquidity in a DEX involves users providing token pairs to create trading pools
The process is managed through the
add_liquidity
function, which handles token withdrawal, deposit, and LP token minting
Optimal amounts are calculated to maintain the pool's price ratio and prevent manipulation
LP tokens are minted proportionally to the liquidity provided, with special considerations for initial liquidity
Safety measures include slippage protection, minimum liquidity requirements, and atomic state updates
Events are emitted for transparency and off-chain tracking of pool activities
The process ensures fair distribution of LP tokens and maintains the constant product formula
Introduction to Adding Liquidity in a DEX
Adding liquidity is a fundamental operation in any Decentralized Exchange (DEX). When users provide token pairs to create trading pools, they receive Liquidity Provider (LP) tokens in return. This process is crucial for maintaining the DEX's functionality and liquidity. Let's dive into the detailed implementation of the
add_liquidity
function and its components, breaking it down for beginners.
1. Understanding the Main Entry Point: add_liquidity
The
add_liquidity
function is the primary way users interact with the liquidity pool. Let's examine its structure and purpose:
public fun add_liquidity<X, Y>(
    sender: &signer,
    amount_x: u64,
    amount_y: u64
): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
    let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = 
    add_liquidity_direct(
        coin::withdraw<X>(sender, amount_x), 
        coin::withdraw<Y>(sender, amount_y)
    );
    
    let sender_addr = signer::address_of(sender);
    let lp_amount = coin::value(&coin_lp);
    assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    
    check_or_register_coin_store<LPToken<X, Y>>(sender);
    coin::deposit(sender_addr, coin_lp);
    coin::deposit(sender_addr, coin_left_x);
    coin::deposit(sender_addr, coin_left_y);
    
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<AddLiquidityEvent<X, Y>>(
        &mut pair_event_holder.add_liquidity,
        AddLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x: a_x,
            amount_y: a_y,
            liquidity: lp_amount,
            fee_amount: (fee_amount as u64),
        }
    );
    (a_x, a_y, lp_amount
}
1.1. Input Parameters Explained
sender: &signer
: This represents the account that's adding liquidity. In Move, a
signer
is a special type that proves ownership of an account.
amount_x: u64
: The amount of token X the user wants to add to the pool.
u64
means it's an unsigned 64-bit integer.
amount_y: u64
: The amount of token Y the user wants to add to the pool.
Returns:
(u64, u64, u64)
: This function returns three values:
The actual amount of token X used
The actual amount of token Y used
The number of LP tokens received
1.2. Understanding Coin Operations
The function starts by withdrawing tokens from the sender's account:
coin::withdraw<X>(sender, amount_x),
coin::withdraw<Y>(sender, amount_y)
These operations move tokens from the user's account to the contract's control.
The
coin::withdraw
function automatically checks if the user has sufficient balance.
If the balance is insufficient, the operation will fail, preventing any further execution.
1.3. Processing Return Values
After adding liquidity, the function checks if LP tokens were successfully minted:
let lp_amount = coin::value(&coin_lp);
assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
This verifies that a non-zero amount of LP tokens were minted.
If no LP tokens were minted (lp_amount = 0), the function will abort with an error.
This check ensures that users always receive LP tokens when adding liquidity, preventing potential loss of funds.
1.4. Managing Token Stores
Before depositing LP tokens, the function ensures the user can receive them:
check_or_register_coin_store<LPToken<X, Y>>(sender);
Let's look at the helper function implementation:
public fun check_or_register_coin_store<X>(sender: &signer) {
    if (!coin::is_account_registered<X>(signer::address_of(sender))) {
        coin::register<X>(sender);
    };
}
This function checks if the sender's account is registered to hold the LP token.
If not registered, it automatically registers the account to receive the token.
This prevents failures when trying to deposit LP tokens to an unregistered account.
2. Deep Dive into Direct Liquidity Addition
The core logic of adding liquidity is handled by the
add_liquidity_direct
function. Let's break it down:
fun add_liquidity_direct<X, Y>(
    x: coin::Coin<X>,
    y: coin::Coin<Y>,
): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>)
    acquires TokenPairReserve, TokenPairMetadata {
    let amount_x = coin::value(&x);
    let amount_y = coin::value(&y);
    let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
    
    // Calculate optimal amounts
    let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
        (amount_x, amount_y)
    } else {
        calculate_optimal_amounts(amount_x, amount_y, reserve_x, reserve_y)
    };
    assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
    assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
    let left_x = coin::extract(&mut x, amount_x - a_x);
    let left_y = coin::extract(&mut y, amount_y - a_y);
    
    deposit_x<X, Y>(x);
    deposit_y<X, Y>(y);
    
    let (lp, fee_amount) = mint<X, Y>();
    
    (a_x, a_y, lp, fee_amount, left_x, left_y)
}
2.1. Calculating Optimal Amounts
The function handles two scenarios: initial liquidity and subsequent additions.
For initial liquidity (when the pool is empty):
if (reserve_x == 0 && reserve_y == 0) {
    (amount_x, amount_y)
}
When the pool is empty, all provided tokens are used.
This sets the initial price ratio for the pool.
For subsequent additions:
let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
if (amount_y_optimal <= amount_y) {
    (amount_x, amount_y_optimal)
} else {
    let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
    assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
    (amount_x_optimal, amount_y)
}
The
quote
function calculates the optimal amount to maintain the current price ratio:
public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
This calculation ensures the constant product formula: (x + Δx)/(y + Δy) = x/y
It prevents price manipulation by maintaining the current pool ratio.
The function uses u128 (128-bit integers) for intermediate calculations to prevent overflow.
2.2. Depositing Tokens into the Pool
After calculating optimal amounts, the tokens are deposited into the pool:
fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_x, amount);
}
fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_y, amount);
}
These functions update the pool's balances by merging the new tokens with existing reserves.
The
borrow_global_mut
function allows modifying global storage.
Using separate functions for X and Y tokens ensures type safety and prevents mixing up token types.
3. Understanding the LP Token Minting Process
After depositing tokens, the contract mints LP tokens for the liquidity provider:
fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), 
                                 coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    
    let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
    let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
    
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    let total_supply = total_lp_supply<X, Y>();
    
    let liquidity = calculate_liquidity_amount(
        amount_x, 
        amount_y, 
        total_supply, 
        reserves
    );
    
    let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
    update<X, Y>(balance_x, balance_y, reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    
    (lp, fee_amount)
}
3.1. Initial Liquidity Calculation
For the first liquidity provider, LP tokens are calculated as follows:
if (total_supply == 0u128) {
    let sqrt = math128::sqrt(amount_x * amount_y);
    assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
    let l = sqrt - MINIMUM_LIQUIDITY;
    mint_lp_to<X, Y>(DEFAULT_ADMIN, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
    l
}
The geometric mean (square root of the product) of deposits is used to determine initial LP tokens.
A small amount (MINIMUM_LIQUIDITY) is locked forever to prevent the pool from being drained completely.
This approach helps in setting a fair initial price and prevents exploitation by the first liquidity provider.
3.2. Subsequent Liquidity Calculation
For subsequent liquidity additions, LP tokens are calculated proportionally:
let liquidity = math128::min(
    amount_x * total_supply / (reserves.reserve_x as u128),
    amount_y * total_supply / (reserves.reserve_y as u128)
);
assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
This calculation ensures fair distribution of LP tokens based on the proportion of liquidity added.
Using the minimum of the two ratios prevents dilution and maintains fairness.
The assert statement ensures that some LP tokens are always minted, preventing zero-value operations.
4. Event Emission for Transparency
The contract emits an event after successfully adding liquidity:
struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
    user: address,
    amount_x: u64,
    amount_y: u64,
    liquidity: u64,
    fee_amount: u64
}
This event records all relevant details of the liquidity addition.
It includes the user's address, amounts of both tokens used, LP tokens received, and any fees paid.
Emitting events allows for off-chain tracking and analysis of pool activities.
5. Crucial Safety Considerations
Slippage Protection:
The contract calculates optimal amounts to maintain the asset ratio.
Any unused tokens are returned to the user, preventing unexpected losses.
Minimum Requirements:
The contract enforces a non-zero liquidity check to prevent dust amounts.
A minimum LP token amount is required to prevent exploitation.
State Updates:
All operations are performed atomically to ensure consistency.
The constant product (K value) is maintained throughout the process.
**Error Handling:**The contract uses clear error codes for different failure scenarios:
const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 0x004;
const ERROR_INSUFFICIENT_AMOUNT: u64 = 0x006;
const ERROR_INVALID_AMOUNT: u64 = 0x008;
These error codes help in identifying and debugging issues quickly.
Each error corresponds to a specific failure case, improving error handling and user feedback.
This detailed breakdown of the
add_liquidity
function and its components provides a comprehensive understanding of how liquidity is added to a DEX. Next, we'll explore the
remove_liquidity
function to complete our understanding of liquidity management in a DEX
	Summary
	Summary
	Adding liquidity in a DEX involves users providing token pairs to create trading pools
The process is managed through the
add_liquidity
function, which handles token withdrawal, deposit, and LP token minting
Optimal amounts are calculated to maintain the pool's price ratio and prevent manipulation
LP tokens are minted proportionally to the liquidity provided, with special considerations for initial liquidity
Safety measures include slippage protection, minimum liquidity requirements, and atomic state updates
Events are emitted for transparency and off-chain tracking of pool activities
The process ensures fair distribution of LP tokens and maintains the constant product formula
	Adding liquidity in a DEX involves users providing token pairs to create trading pools
	Adding liquidity in a DEX involves users providing token pairs to create trading pools
	The process is managed through the
add_liquidity
function, which handles token withdrawal, deposit, and LP token minting
	The process is managed through the
	<code>add_liquidity</code>
	add_liquidity
	function, which handles token withdrawal, deposit, and LP token minting
	Optimal amounts are calculated to maintain the pool's price ratio and prevent manipulation
	Optimal amounts are calculated to maintain the pool's price ratio and prevent manipulation
	LP tokens are minted proportionally to the liquidity provided, with special considerations for initial liquidity
	LP tokens are minted proportionally to the liquidity provided, with special considerations for initial liquidity
	Safety measures include slippage protection, minimum liquidity requirements, and atomic state updates
	Safety measures include slippage protection, minimum liquidity requirements, and atomic state updates
	Events are emitted for transparency and off-chain tracking of pool activities
	Events are emitted for transparency and off-chain tracking of pool activities
	The process ensures fair distribution of LP tokens and maintains the constant product formula
	The process ensures fair distribution of LP tokens and maintains the constant product formula
	Introduction to Adding Liquidity in a DEX
	Introduction to Adding Liquidity in a DEX
	Adding liquidity is a fundamental operation in any Decentralized Exchange (DEX). When users provide token pairs to create trading pools, they receive Liquidity Provider (LP) tokens in return. This process is crucial for maintaining the DEX's functionality and liquidity. Let's dive into the detailed implementation of the
add_liquidity
function and its components, breaking it down for beginners.
	Adding liquidity is a fundamental operation in any Decentralized Exchange (DEX). When users provide token pairs to create trading pools, they receive Liquidity Provider (LP) tokens in return. This process is crucial for maintaining the DEX's functionality and liquidity. Let's dive into the detailed implementation of the
	<code>add_liquidity</code>
	add_liquidity
	function and its components, breaking it down for beginners.
	1. Understanding the Main Entry Point: add_liquidity
	1. Understanding the Main Entry Point: add_liquidity
	The
add_liquidity
function is the primary way users interact with the liquidity pool. Let's examine its structure and purpose:
	The
	<code>add_liquidity</code>
	add_liquidity
	function is the primary way users interact with the liquidity pool. Let's examine its structure and purpose:
	<code>public fun add_liquidity<X, Y>(
    sender: &signer,
    amount_x: u64,
    amount_y: u64
): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
    let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = 
    add_liquidity_direct(
        coin::withdraw<X>(sender, amount_x), 
        coin::withdraw<Y>(sender, amount_y)
    );
    
    let sender_addr = signer::address_of(sender);
    let lp_amount = coin::value(&coin_lp);
    assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    
    check_or_register_coin_store<LPToken<X, Y>>(sender);
    coin::deposit(sender_addr, coin_lp);
    coin::deposit(sender_addr, coin_left_x);
    coin::deposit(sender_addr, coin_left_y);
    
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<AddLiquidityEvent<X, Y>>(
        &mut pair_event_holder.add_liquidity,
        AddLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x: a_x,
            amount_y: a_y,
            liquidity: lp_amount,
            fee_amount: (fee_amount as u64),
        }
    );
    (a_x, a_y, lp_amount
}</code>
	<code>public fun add_liquidity<X, Y>(
    sender: &signer,
    amount_x: u64,
    amount_y: u64
): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
    let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = 
    add_liquidity_direct(
        coin::withdraw<X>(sender, amount_x), 
        coin::withdraw<Y>(sender, amount_y)
    );
    
    let sender_addr = signer::address_of(sender);
    let lp_amount = coin::value(&coin_lp);
    assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    
    check_or_register_coin_store<LPToken<X, Y>>(sender);
    coin::deposit(sender_addr, coin_lp);
    coin::deposit(sender_addr, coin_left_x);
    coin::deposit(sender_addr, coin_left_y);
    
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<AddLiquidityEvent<X, Y>>(
        &mut pair_event_holder.add_liquidity,
        AddLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x: a_x,
            amount_y: a_y,
            liquidity: lp_amount,
            fee_amount: (fee_amount as u64),
        }
    );
    (a_x, a_y, lp_amount
}</code>
	public fun add_liquidity<X, Y>(
    sender: &signer,
    amount_x: u64,
    amount_y: u64
): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
    let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = 
    add_liquidity_direct(
        coin::withdraw<X>(sender, amount_x), 
        coin::withdraw<Y>(sender, amount_y)
    );
    
    let sender_addr = signer::address_of(sender);
    let lp_amount = coin::value(&coin_lp);
    assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    
    check_or_register_coin_store<LPToken<X, Y>>(sender);
    coin::deposit(sender_addr, coin_lp);
    coin::deposit(sender_addr, coin_left_x);
    coin::deposit(sender_addr, coin_left_y);
    
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<AddLiquidityEvent<X, Y>>(
        &mut pair_event_holder.add_liquidity,
        AddLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x: a_x,
            amount_y: a_y,
            liquidity: lp_amount,
            fee_amount: (fee_amount as u64),
        }
    );
    (a_x, a_y, lp_amount
}
		1.1. Input Parameters Explained
		1.1. Input Parameters Explained
		sender: &signer
: This represents the account that's adding liquidity. In Move, a
signer
is a special type that proves ownership of an account.
amount_x: u64
: The amount of token X the user wants to add to the pool.
u64
means it's an unsigned 64-bit integer.
amount_y: u64
: The amount of token Y the user wants to add to the pool.
Returns:
(u64, u64, u64)
: This function returns three values:
The actual amount of token X used
The actual amount of token Y used
The number of LP tokens received
		sender: &signer
: This represents the account that's adding liquidity. In Move, a
signer
is a special type that proves ownership of an account.
		<code>sender: &signer</code>
		sender: &signer
		: This represents the account that's adding liquidity. In Move, a
		<code>signer</code>
		signer
		is a special type that proves ownership of an account.
		amount_x: u64
: The amount of token X the user wants to add to the pool.
u64
means it's an unsigned 64-bit integer.
		<code>amount_x: u64</code>
		amount_x: u64
		: The amount of token X the user wants to add to the pool.
		<code>u64</code>
		u64
		means it's an unsigned 64-bit integer.
		amount_y: u64
: The amount of token Y the user wants to add to the pool.
		<code>amount_y: u64</code>
		amount_y: u64
		: The amount of token Y the user wants to add to the pool.
		Returns:
(u64, u64, u64)
: This function returns three values:
The actual amount of token X used
The actual amount of token Y used
The number of LP tokens received
		Returns:
		<code>(u64, u64, u64)</code>
		(u64, u64, u64)
		: This function returns three values:
		The actual amount of token X used
The actual amount of token Y used
The number of LP tokens received
		The actual amount of token X used
		The actual amount of token X used
		The actual amount of token Y used
		The actual amount of token Y used
		The number of LP tokens received
		The number of LP tokens received
		1.2. Understanding Coin Operations
		1.2. Understanding Coin Operations
		The function starts by withdrawing tokens from the sender's account:
		The function starts by withdrawing tokens from the sender's account:
		<code>coin::withdraw<X>(sender, amount_x),
coin::withdraw<Y>(sender, amount_y)</code>
		<code>coin::withdraw<X>(sender, amount_x),
coin::withdraw<Y>(sender, amount_y)</code>
		coin::withdraw<X>(sender, amount_x),
coin::withdraw<Y>(sender, amount_y)
		These operations move tokens from the user's account to the contract's control.
The
coin::withdraw
function automatically checks if the user has sufficient balance.
If the balance is insufficient, the operation will fail, preventing any further execution.
		These operations move tokens from the user's account to the contract's control.
		These operations move tokens from the user's account to the contract's control.
		The
coin::withdraw
function automatically checks if the user has sufficient balance.
		The
		<code>coin::withdraw</code>
		coin::withdraw
		function automatically checks if the user has sufficient balance.
		If the balance is insufficient, the operation will fail, preventing any further execution.
		If the balance is insufficient, the operation will fail, preventing any further execution.
		1.3. Processing Return Values
		1.3. Processing Return Values
		After adding liquidity, the function checks if LP tokens were successfully minted:
		After adding liquidity, the function checks if LP tokens were successfully minted:
		<code>let lp_amount = coin::value(&coin_lp);
assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);</code>
		<code>let lp_amount = coin::value(&coin_lp);
assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);</code>
		let lp_amount = coin::value(&coin_lp);
assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
		This verifies that a non-zero amount of LP tokens were minted.
If no LP tokens were minted (lp_amount = 0), the function will abort with an error.
This check ensures that users always receive LP tokens when adding liquidity, preventing potential loss of funds.
		This verifies that a non-zero amount of LP tokens were minted.
		This verifies that a non-zero amount of LP tokens were minted.
		If no LP tokens were minted (lp_amount = 0), the function will abort with an error.
		If no LP tokens were minted (lp_amount = 0), the function will abort with an error.
		This check ensures that users always receive LP tokens when adding liquidity, preventing potential loss of funds.
		This check ensures that users always receive LP tokens when adding liquidity, preventing potential loss of funds.
		1.4. Managing Token Stores
		1.4. Managing Token Stores
		Before depositing LP tokens, the function ensures the user can receive them:
		Before depositing LP tokens, the function ensures the user can receive them:
		<code>check_or_register_coin_store<LPToken<X, Y>>(sender);</code>
		<code>check_or_register_coin_store<LPToken<X, Y>>(sender);</code>
		check_or_register_coin_store<LPToken<X, Y>>(sender);
		Let's look at the helper function implementation:
		Let's look at the helper function implementation:
		<code>public fun check_or_register_coin_store<X>(sender: &signer) {
    if (!coin::is_account_registered<X>(signer::address_of(sender))) {
        coin::register<X>(sender);
    };
}</code>
		<code>public fun check_or_register_coin_store<X>(sender: &signer) {
    if (!coin::is_account_registered<X>(signer::address_of(sender))) {
        coin::register<X>(sender);
    };
}</code>
		public fun check_or_register_coin_store<X>(sender: &signer) {
    if (!coin::is_account_registered<X>(signer::address_of(sender))) {
        coin::register<X>(sender);
    };
}
		This function checks if the sender's account is registered to hold the LP token.
If not registered, it automatically registers the account to receive the token.
This prevents failures when trying to deposit LP tokens to an unregistered account.
		This function checks if the sender's account is registered to hold the LP token.
		This function checks if the sender's account is registered to hold the LP token.
		If not registered, it automatically registers the account to receive the token.
		If not registered, it automatically registers the account to receive the token.
		This prevents failures when trying to deposit LP tokens to an unregistered account.
		This prevents failures when trying to deposit LP tokens to an unregistered account.
	2. Deep Dive into Direct Liquidity Addition
	2. Deep Dive into Direct Liquidity Addition
	The core logic of adding liquidity is handled by the
add_liquidity_direct
function. Let's break it down:
	The core logic of adding liquidity is handled by the
	<code>add_liquidity_direct</code>
	add_liquidity_direct
	function. Let's break it down:
	<code>fun add_liquidity_direct<X, Y>(
    x: coin::Coin<X>,
    y: coin::Coin<Y>,
): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>)
    acquires TokenPairReserve, TokenPairMetadata {
    let amount_x = coin::value(&x);
    let amount_y = coin::value(&y);
    let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
    
    // Calculate optimal amounts
    let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
        (amount_x, amount_y)
    } else {
        calculate_optimal_amounts(amount_x, amount_y, reserve_x, reserve_y)
    };
    assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
    assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
    let left_x = coin::extract(&mut x, amount_x - a_x);
    let left_y = coin::extract(&mut y, amount_y - a_y);
    
    deposit_x<X, Y>(x);
    deposit_y<X, Y>(y);
    
    let (lp, fee_amount) = mint<X, Y>();
    
    (a_x, a_y, lp, fee_amount, left_x, left_y)
}</code>
	<code>fun add_liquidity_direct<X, Y>(
    x: coin::Coin<X>,
    y: coin::Coin<Y>,
): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>)
    acquires TokenPairReserve, TokenPairMetadata {
    let amount_x = coin::value(&x);
    let amount_y = coin::value(&y);
    let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
    
    // Calculate optimal amounts
    let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
        (amount_x, amount_y)
    } else {
        calculate_optimal_amounts(amount_x, amount_y, reserve_x, reserve_y)
    };
    assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
    assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
    let left_x = coin::extract(&mut x, amount_x - a_x);
    let left_y = coin::extract(&mut y, amount_y - a_y);
    
    deposit_x<X, Y>(x);
    deposit_y<X, Y>(y);
    
    let (lp, fee_amount) = mint<X, Y>();
    
    (a_x, a_y, lp, fee_amount, left_x, left_y)
}</code>
	fun add_liquidity_direct<X, Y>(
    x: coin::Coin<X>,
    y: coin::Coin<Y>,
): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>)
    acquires TokenPairReserve, TokenPairMetadata {
    let amount_x = coin::value(&x);
    let amount_y = coin::value(&y);
    let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
    
    // Calculate optimal amounts
    let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
        (amount_x, amount_y)
    } else {
        calculate_optimal_amounts(amount_x, amount_y, reserve_x, reserve_y)
    };
    assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
    assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
    let left_x = coin::extract(&mut x, amount_x - a_x);
    let left_y = coin::extract(&mut y, amount_y - a_y);
    
    deposit_x<X, Y>(x);
    deposit_y<X, Y>(y);
    
    let (lp, fee_amount) = mint<X, Y>();
    
    (a_x, a_y, lp, fee_amount, left_x, left_y)
}
		2.1. Calculating Optimal Amounts
		2.1. Calculating Optimal Amounts
		The function handles two scenarios: initial liquidity and subsequent additions.
		The function handles two scenarios: initial liquidity and subsequent additions.
		For initial liquidity (when the pool is empty):
		For initial liquidity (when the pool is empty):
		<code>if (reserve_x == 0 && reserve_y == 0) {
    (amount_x, amount_y)
}</code>
		<code>if (reserve_x == 0 && reserve_y == 0) {
    (amount_x, amount_y)
}</code>
		if (reserve_x == 0 && reserve_y == 0) {
    (amount_x, amount_y)
}
		When the pool is empty, all provided tokens are used.
This sets the initial price ratio for the pool.
		When the pool is empty, all provided tokens are used.
		When the pool is empty, all provided tokens are used.
		This sets the initial price ratio for the pool.
		This sets the initial price ratio for the pool.
		For subsequent additions:
		For subsequent additions:
		<code>let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
if (amount_y_optimal <= amount_y) {
    (amount_x, amount_y_optimal)
} else {
    let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
    assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
    (amount_x_optimal, amount_y)
}</code>
		<code>let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
if (amount_y_optimal <= amount_y) {
    (amount_x, amount_y_optimal)
} else {
    let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
    assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
    (amount_x_optimal, amount_y)
}</code>
		let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
if (amount_y_optimal <= amount_y) {
    (amount_x, amount_y_optimal)
} else {
    let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
    assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
    (amount_x_optimal, amount_y)
}
		The
quote
function calculates the optimal amount to maintain the current price ratio:
		The
		<code>quote</code>
		quote
		function calculates the optimal amount to maintain the current price ratio:
		<code>public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}</code>
		<code>public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}</code>
		public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
    assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
    assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
		This calculation ensures the constant product formula: (x + Δx)/(y + Δy) = x/y
It prevents price manipulation by maintaining the current pool ratio.
The function uses u128 (128-bit integers) for intermediate calculations to prevent overflow.
		This calculation ensures the constant product formula: (x + Δx)/(y + Δy) = x/y
		This calculation ensures the constant product formula: (x + Δx)/(y + Δy) = x/y
		It prevents price manipulation by maintaining the current pool ratio.
		It prevents price manipulation by maintaining the current pool ratio.
		The function uses u128 (128-bit integers) for intermediate calculations to prevent overflow.
		The function uses u128 (128-bit integers) for intermediate calculations to prevent overflow.
		2.2. Depositing Tokens into the Pool
		2.2. Depositing Tokens into the Pool
		After calculating optimal amounts, the tokens are deposited into the pool:
		After calculating optimal amounts, the tokens are deposited into the pool:
		<code>fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_x, amount);
}
fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_y, amount);
}</code>
		<code>fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_x, amount);
}
fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_y, amount);
}</code>
		fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_x, amount);
}
fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    coin::merge(&mut metadata.balance_y, amount);
}
		These functions update the pool's balances by merging the new tokens with existing reserves.
The
borrow_global_mut
function allows modifying global storage.
Using separate functions for X and Y tokens ensures type safety and prevents mixing up token types.
		These functions update the pool's balances by merging the new tokens with existing reserves.
		These functions update the pool's balances by merging the new tokens with existing reserves.
		The
borrow_global_mut
function allows modifying global storage.
		The
		<code>borrow_global_mut</code>
		borrow_global_mut
		function allows modifying global storage.
		Using separate functions for X and Y tokens ensures type safety and prevents mixing up token types.
		Using separate functions for X and Y tokens ensures type safety and prevents mixing up token types.
	3. Understanding the LP Token Minting Process
	3. Understanding the LP Token Minting Process
	After depositing tokens, the contract mints LP tokens for the liquidity provider:
	After depositing tokens, the contract mints LP tokens for the liquidity provider:
	<code>fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), 
                                 coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    
    let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
    let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
    
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    let total_supply = total_lp_supply<X, Y>();
    
    let liquidity = calculate_liquidity_amount(
        amount_x, 
        amount_y, 
        total_supply, 
        reserves
    );
    
    let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
    update<X, Y>(balance_x, balance_y, reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    
    (lp, fee_amount)
}</code>
	<code>fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), 
                                 coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    
    let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
    let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
    
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    let total_supply = total_lp_supply<X, Y>();
    
    let liquidity = calculate_liquidity_amount(
        amount_x, 
        amount_y, 
        total_supply, 
        reserves
    );
    
    let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
    update<X, Y>(balance_x, balance_y, reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    
    (lp, fee_amount)
}</code>
	fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), 
                                 coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    
    let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
    let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
    
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    let total_supply = total_lp_supply<X, Y>();
    
    let liquidity = calculate_liquidity_amount(
        amount_x, 
        amount_y, 
        total_supply, 
        reserves
    );
    
    let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
    update<X, Y>(balance_x, balance_y, reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    
    (lp, fee_amount)
}
		3.1. Initial Liquidity Calculation
		3.1. Initial Liquidity Calculation
		For the first liquidity provider, LP tokens are calculated as follows:
		For the first liquidity provider, LP tokens are calculated as follows:
		<code>if (total_supply == 0u128) {
    let sqrt = math128::sqrt(amount_x * amount_y);
    assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
    let l = sqrt - MINIMUM_LIQUIDITY;
    mint_lp_to<X, Y>(DEFAULT_ADMIN, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
    l
}</code>
		<code>if (total_supply == 0u128) {
    let sqrt = math128::sqrt(amount_x * amount_y);
    assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
    let l = sqrt - MINIMUM_LIQUIDITY;
    mint_lp_to<X, Y>(DEFAULT_ADMIN, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
    l
}</code>
		if (total_supply == 0u128) {
    let sqrt = math128::sqrt(amount_x * amount_y);
    assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
    let l = sqrt - MINIMUM_LIQUIDITY;
    mint_lp_to<X, Y>(DEFAULT_ADMIN, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
    l
}
		The geometric mean (square root of the product) of deposits is used to determine initial LP tokens.
A small amount (MINIMUM_LIQUIDITY) is locked forever to prevent the pool from being drained completely.
This approach helps in setting a fair initial price and prevents exploitation by the first liquidity provider.
		The geometric mean (square root of the product) of deposits is used to determine initial LP tokens.
		The geometric mean (square root of the product) of deposits is used to determine initial LP tokens.
		A small amount (MINIMUM_LIQUIDITY) is locked forever to prevent the pool from being drained completely.
		A small amount (MINIMUM_LIQUIDITY) is locked forever to prevent the pool from being drained completely.
		This approach helps in setting a fair initial price and prevents exploitation by the first liquidity provider.
		This approach helps in setting a fair initial price and prevents exploitation by the first liquidity provider.
		3.2. Subsequent Liquidity Calculation
		3.2. Subsequent Liquidity Calculation
		For subsequent liquidity additions, LP tokens are calculated proportionally:
		For subsequent liquidity additions, LP tokens are calculated proportionally:
		<code>let liquidity = math128::min(
    amount_x * total_supply / (reserves.reserve_x as u128),
    amount_y * total_supply / (reserves.reserve_y as u128)
);
assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);</code>
		<code>let liquidity = math128::min(
    amount_x * total_supply / (reserves.reserve_x as u128),
    amount_y * total_supply / (reserves.reserve_y as u128)
);
assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);</code>
		let liquidity = math128::min(
    amount_x * total_supply / (reserves.reserve_x as u128),
    amount_y * total_supply / (reserves.reserve_y as u128)
);
assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
		This calculation ensures fair distribution of LP tokens based on the proportion of liquidity added.
Using the minimum of the two ratios prevents dilution and maintains fairness.
The assert statement ensures that some LP tokens are always minted, preventing zero-value operations.
		This calculation ensures fair distribution of LP tokens based on the proportion of liquidity added.
		This calculation ensures fair distribution of LP tokens based on the proportion of liquidity added.
		Using the minimum of the two ratios prevents dilution and maintains fairness.
		Using the minimum of the two ratios prevents dilution and maintains fairness.
		The assert statement ensures that some LP tokens are always minted, preventing zero-value operations.
		The assert statement ensures that some LP tokens are always minted, preventing zero-value operations.
	4. Event Emission for Transparency
	4. Event Emission for Transparency
	The contract emits an event after successfully adding liquidity:
	The contract emits an event after successfully adding liquidity:
	<code>struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
    user: address,
    amount_x: u64,
    amount_y: u64,
    liquidity: u64,
    fee_amount: u64
}</code>
	<code>struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
    user: address,
    amount_x: u64,
    amount_y: u64,
    liquidity: u64,
    fee_amount: u64
}</code>
	struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
    user: address,
    amount_x: u64,
    amount_y: u64,
    liquidity: u64,
    fee_amount: u64
}
	This event records all relevant details of the liquidity addition.
It includes the user's address, amounts of both tokens used, LP tokens received, and any fees paid.
Emitting events allows for off-chain tracking and analysis of pool activities.
	This event records all relevant details of the liquidity addition.
	This event records all relevant details of the liquidity addition.
	It includes the user's address, amounts of both tokens used, LP tokens received, and any fees paid.
	It includes the user's address, amounts of both tokens used, LP tokens received, and any fees paid.
	Emitting events allows for off-chain tracking and analysis of pool activities.
	Emitting events allows for off-chain tracking and analysis of pool activities.
	5. Crucial Safety Considerations
	5. Crucial Safety Considerations
	Slippage Protection:
The contract calculates optimal amounts to maintain the asset ratio.
Any unused tokens are returned to the user, preventing unexpected losses.
Minimum Requirements:
The contract enforces a non-zero liquidity check to prevent dust amounts.
A minimum LP token amount is required to prevent exploitation.
State Updates:
All operations are performed atomically to ensure consistency.
The constant product (K value) is maintained throughout the process.
**Error Handling:**The contract uses clear error codes for different failure scenarios:
const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 0x004;
const ERROR_INSUFFICIENT_AMOUNT: u64 = 0x006;
const ERROR_INVALID_AMOUNT: u64 = 0x008;
These error codes help in identifying and debugging issues quickly.
Each error corresponds to a specific failure case, improving error handling and user feedback.
	Slippage Protection:
The contract calculates optimal amounts to maintain the asset ratio.
Any unused tokens are returned to the user, preventing unexpected losses.
	Slippage Protection:
	Slippage Protection:
	Slippage Protection:
	The contract calculates optimal amounts to maintain the asset ratio.
Any unused tokens are returned to the user, preventing unexpected losses.
	The contract calculates optimal amounts to maintain the asset ratio.
	The contract calculates optimal amounts to maintain the asset ratio.
	Any unused tokens are returned to the user, preventing unexpected losses.
	Any unused tokens are returned to the user, preventing unexpected losses.
	Minimum Requirements:
The contract enforces a non-zero liquidity check to prevent dust amounts.
A minimum LP token amount is required to prevent exploitation.
	Minimum Requirements:
	Minimum Requirements:
	Minimum Requirements:
	The contract enforces a non-zero liquidity check to prevent dust amounts.
A minimum LP token amount is required to prevent exploitation.
	The contract enforces a non-zero liquidity check to prevent dust amounts.
	The contract enforces a non-zero liquidity check to prevent dust amounts.
	A minimum LP token amount is required to prevent exploitation.
	A minimum LP token amount is required to prevent exploitation.
	State Updates:
All operations are performed atomically to ensure consistency.
The constant product (K value) is maintained throughout the process.
	State Updates:
	State Updates:
	State Updates:
	All operations are performed atomically to ensure consistency.
The constant product (K value) is maintained throughout the process.
	All operations are performed atomically to ensure consistency.
	All operations are performed atomically to ensure consistency.
	The constant product (K value) is maintained throughout the process.
	The constant product (K value) is maintained throughout the process.
	**Error Handling:**The contract uses clear error codes for different failure scenarios:
const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 0x004;
const ERROR_INSUFFICIENT_AMOUNT: u64 = 0x006;
const ERROR_INVALID_AMOUNT: u64 = 0x008;
These error codes help in identifying and debugging issues quickly.
Each error corresponds to a specific failure case, improving error handling and user feedback.
	**Error Handling:**The contract uses clear error codes for different failure scenarios:
	**Error Handling:**The contract uses clear error codes for different failure scenarios:
	<code>const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 0x004;
const ERROR_INSUFFICIENT_AMOUNT: u64 = 0x006;
const ERROR_INVALID_AMOUNT: u64 = 0x008;</code>
	<code>const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 0x004;
const ERROR_INSUFFICIENT_AMOUNT: u64 = 0x006;
const ERROR_INVALID_AMOUNT: u64 = 0x008;</code>
	const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 0x004;
const ERROR_INSUFFICIENT_AMOUNT: u64 = 0x006;
const ERROR_INVALID_AMOUNT: u64 = 0x008;
	These error codes help in identifying and debugging issues quickly.
Each error corresponds to a specific failure case, improving error handling and user feedback.
	These error codes help in identifying and debugging issues quickly.
	These error codes help in identifying and debugging issues quickly.
	Each error corresponds to a specific failure case, improving error handling and user feedback.
	Each error corresponds to a specific failure case, improving error handling and user feedback.
	This detailed breakdown of the
add_liquidity
function and its components provides a comprehensive understanding of how liquidity is added to a DEX. Next, we'll explore the
remove_liquidity
function to complete our understanding of liquidity management in a DEX
	This detailed breakdown of the
	<code>add_liquidity</code>
	add_liquidity
	function and its components provides a comprehensive understanding of how liquidity is added to a DEX. Next, we'll explore the
	<code>remove_liquidity</code>
	remove_liquidity
	function to complete our understanding of liquidity management in a DEX

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/02-swap/05-removing-liquidity
Removing Liquidity
Removing Liquidity
On This Page
Key points:
Introduction
1. Public Interface: The Entry Point
Function Parameters:
Return Values:
Key Steps in the Implementation:
2. Direct Removal Implementation
Purpose:
3. Core Burn Implementation
Initial Setup:
Metadata Access:
Balance Retrieval:
Fee Processing:
Fee Calculation Formula:
Understanding the Fee Calculation:
Amount Calculations:
Understanding the Amount Calculations:
Validation and Execution:
Token Extraction:
State Updates:
Key points:
Allows Liquidity Providers (LPs) to withdraw tokens from the pool
Involves burning LP tokens to receive proportional amounts of underlying tokens
Requires careful calculations to ensure fair distribution of assets
Includes processing of accrued fees before token extraction
Updates pool reserves and k-value after removal
Implements safety checks to prevent errors and maintain pool integrity
Uses a public interface for user interaction and internal functions for core logic
Crucial for maintaining flexibility and attractiveness of liquidity provision in DEXs
Introduction
Liquidity removal is a fundamental operation in a DEX that allows Liquidity Providers (LPs) to withdraw their tokens from the pool. When an LP decides to exit their position, they need to burn their LP tokens and receive a proportional amount of both token types from the pool. This process is crucial for maintaining the flexibility and attractiveness of providing liquidity in a DEX.
1. Public Interface: The Entry Point
Let's break down the public function that initiates the liquidity removal process:
/// Remove liquidity from a pool
/// Returns (amount_x_received, amount_y_received)
/// Requirements:
/// - Must have sufficient LP tokens to burn
/// - Must receive minimum amounts of tokens
public fun remove_liquidity<X, Y>(
    sender: &signer,
    liquidity: u64,
): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
    let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
    let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
    let amount_x = coin::value(&coins_x);
    let amount_y = coin::value(&coins_y);
    check_or_register_coin_store<X>(sender);
    check_or_register_coin_store<Y>(sender);
    let sender_addr = signer::address_of(sender);
    coin::deposit<X>(sender_addr, coins_x);
    coin::deposit<Y>(sender_addr, coins_y);
    // event
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<RemoveLiquidityEvent<X, Y>>(
        &mut pair_event_holder.remove_liquidity,
        RemoveLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x,
            amount_y,
            liquidity,
            fee_amount: (fee_amount as u64)
        }
    );
    (amount_x, amount_y)
}
This function is the main entry point for liquidity removal. Let's examine its components:
Function Parameters:
sender: &signer
- This is a reference to the user's account that's initiating the liquidity removal. It's used for several important operations:
Verifying that the user owns the LP tokens they're trying to burn
Withdrawing the LP tokens from the user's account
Depositing the underlying tokens back into the user's account after the removal process
liquidity: u64
- This parameter represents the amount of LP tokens the user wants to burn. It's important to note that:
The amount must be greater than 0 to perform a valid operation
It cannot exceed the user's current LP token balance
This value determines how many underlying tokens the user will receive back
Return Values:
The function returns a tuple
(u64, u64)
, which represents:
amount_x
: The amount of token X the user receives
amount_y
: The amount of token Y the user receives
These amounts are calculated proportionally based on the ratio of LP tokens burned to the total supply of LP tokens.
Key Steps in the Implementation:
Withdrawing LP Tokens:
let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
This line withdraws the specified amount of LP tokens from the user's account. It uses generics (
LPToken<X, Y>
) to ensure it's withdrawing the correct LP token for the specific token pair. If the user doesn't have enough LP tokens, this operation will fail automatically.
Core Liquidity Removal:
let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
This function call performs the actual liquidity removal. It takes the LP tokens and returns the underlying tokens (X and Y) along with any accrued fees. This step ensures that the entire operation is atomic, meaning it either completes fully or not at all.
Safety Checks:
check_or_register_coin_store<X>(sender);
check_or_register_coin_store<Y>(sender);
These lines perform crucial safety checks:
They ensure that the user's account is set up to receive both token types
If the user doesn't have a "coin store" for either token, it's automatically created
This prevents potential issues where the removal succeeds but the tokens can't be deposited
Depositing Tokens and Emitting Events:
The function then deposits the received tokens into the user's account and emits an event to record the liquidity removal operation. This ensures transparency and allows for easy tracking of DEX activities.
2. Direct Removal Implementation
/// Remove liquidity to token types.
fun remove_liquidity_direct<X, Y>(
    liquidity: coin::Coin<LPToken<X, Y>>,
): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    burn<X, Y>(liquidity)
}
Purpose:
This function serves as an important abstraction layer in our liquidity removal process. Let's break it down for beginners:
Separates concerns:
Public interface (remove_liquidity): This is what users interact with. It handles user-specific operations like withdrawing LP tokens from their account.
Direct function (remove_liquidity_direct): This manages the core logic of liquidity removal. It's an intermediate step that helps organize our code.
Burn function: This handles the detailed implementation of actually burning LP tokens and calculating token amounts to return.
3. Core Burn Implementation
/// Burns LP tokens to withdraw liquidity
/// Returns withdrawn tokens proportional to LP tokens burned
/// Requirements:
/// - Must receive minimum amounts of both tokens
fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    let liquidity = coin::value(&lp_tokens);
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    // Need to add fee amount which have not been minted.
    let total_lp_supply = total_lp_supply<X, Y>();
    let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
    coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
    let w_x = extract_x((amount_x as u64), metadata);
    let w_y = extract_y((amount_y as u64), metadata);
    update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    (w_x, w_y, fee_amount)
}
Initial Setup:
Let's break down the initial setup of our liquidity removal function. This part is crucial as it sets the stage for all subsequent operations.
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let (balance_x, balance_y) = (
    coin::value(&metadata.balance_x),
    coin::value(&metadata.balance_y)
);
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
let liquidity = coin::value(&lp_tokens);
Metadata Access:
The first line retrieves the metadata for our token pair. This is a critical step because the metadata contains essential information about our liquidity pool.
borrow_global_mut
: This function is used to get a mutable reference to the pool metadata. 'Mutable' means we can change this data if needed.
The metadata is stored at the
DEFAULT_ADMIN
address. This is a common pattern in Move to have a central storage location for important data.
The metadata contains crucial information like the current balances of both tokens, the total supply of LP tokens, and other pool-specific data.
Balance Retrieval:
Next, we retrieve the current balances of both tokens in the pool. This is necessary to calculate how much of each token the user should receive when removing liquidity.
We use
coin::value
to safely read the balance of each token in the pool.
This function returns the numerical value of the coin, which we can use in our calculations.
Getting accurate balances is crucial for maintaining the correct proportions when removing liquidity.
Fee Processing:
Before we calculate the amounts of tokens to return to the user, we need to process any accrued fees. This is an important step in maintaining the economic model of the DEX.
let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
This line calls a function to calculate and mint the fees. Let's break down how this works:
Fee Calculation Formula:
let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
let root_k_last = math128::sqrt(metadata.k_last);
if root_k > root_k_last {
    let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
    let denominator = root_k_last * 17u128 + root_k * 8u128;
    let liquidity = numerator / denominator;
    fee = liquidity as u64;
};
}
This might look complicated, but let's break it down step by step:
Understanding the Fee Calculation:
Calculating root_k:
We calculate the square root of the product of current reserves (reserve_x * reserve_y)
This represents the current "size" of the pool
Retrieving root_k_last:
This is the square root of the last recorded k value
It represents the pool size from the last operation
Comparing root_k and root_k_last:
If root_k > root_k_last, it means the pool has grown
This growth is what we use to calculate fees
Fee calculation:
We use a complex formula to ensure fair fee distribution
The numerator considers total supply and pool growth
The denominator includes factors to balance the fee
The result is a fair amount of new LP tokens to mint as fees
This fee calculation ensures that the protocol can sustain itself while providing fair returns to liquidity providers.
Amount Calculations:
let total_lp_supply = total_lp_supply<X, Y>();
let amount_x = ((balance_x as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
let amount_y = ((balance_y as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
Understanding the Amount Calculations:
Now that we've processed fees, we need to calculate how many tokens the user will receive when removing liquidity. The formula is straightforward but crucial:
amount_token = (current_balance * lp_amount_to_burn) / total_lp_supply
Let's break this down:
Proportion calculation:
We calculate based on the user's share of LP tokens
This ensures fairness - you get back proportional to what you put in
It automatically includes any fees or gains the pool has accumulated
Precision handling:
We cast to u128 (a larger integer type) for the calculation
This prevents potential overflow errors with large numbers
It also maintains accuracy in the division operation
Here's a simple example to illustrate:
If:
- Pool has 1000 X, 2000 Y
- Total LP supply is 1000
- User burns 100 LP tokens (10%)
Then:
- amount_x = 1000 * 100 / 1000 = 100 X
- amount_y = 2000 * 100 / 1000 = 200 Y
In this example, the user would receive 100 X tokens and 200 Y tokens for their 10% share of the pool.
Validation and Execution:
assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
After calculating the amounts, we perform some crucial steps:
Safety Checks:
We ensure that both amount_x and amount_y are greater than zero
This prevents "dust" withdrawals that could potentially harm the pool
If either amount is zero, we throw an error
LP Token Burning:
We use the burn capability to destroy the LP tokens
This reduces the total supply of LP tokens
It's an irreversible operation, ensuring the integrity of the pool
Token Extraction:
let w_x = extract_x((amount_x as u64), metadata);
let w_y = extract_y((amount_y as u64), metadata);
Now we actually extract the tokens to return to the user:
Safety check:
assert!(coin::value&lt;X&gt;(&metadata.balance_x) > amount,
       ERROR_INSUFFICIENT_AMOUNT);
This verifies that the pool has enough tokens to fulfill the withdrawal
It prevents potential underflow errors
It's a double-check to ensure our previous calculations were correct
Actual extraction:
coin::extract(&mut metadata.balance_x, amount)
This removes the calculated amount of tokens from the pool
It creates a new Coin object with these tokens
This Coin object will be returned to the user
State Updates:
update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
Finally, we need to update the state of our pool:
Reserve updates:
We update the current reserves with the new balances
This typically includes recording a timestamp for the update
It's crucial for maintaining an accurate state of the pool
K value update:
We calculate the new k value (product of reserves)
This is stored for the next operation
It's used in future fee calculations to detect pool growth
By following these steps, we ensure that liquidity removal is handled accurately, fairly, and safely in our DEX. Each step plays a crucial role in maintaining the integrity and efficiency of the system.
On This Page
Key points:
Introduction
1. Public Interface: The Entry Point
Function Parameters:
Return Values:
Key Steps in the Implementation:
2. Direct Removal Implementation
Purpose:
3. Core Burn Implementation
Initial Setup:
Metadata Access:
Balance Retrieval:
Fee Processing:
Fee Calculation Formula:
Understanding the Fee Calculation:
Amount Calculations:
Understanding the Amount Calculations:
Validation and Execution:
Token Extraction:
State Updates:
On This Page
Key points:
Introduction
1. Public Interface: The Entry Point
Function Parameters:
Return Values:
Key Steps in the Implementation:
2. Direct Removal Implementation
Purpose:
3. Core Burn Implementation
Initial Setup:
Metadata Access:
Balance Retrieval:
Fee Processing:
Fee Calculation Formula:
Understanding the Fee Calculation:
Amount Calculations:
Understanding the Amount Calculations:
Validation and Execution:
Token Extraction:
State Updates:
			On This Page
			On This Page
			Key points:
Introduction
1. Public Interface: The Entry Point
Function Parameters:
Return Values:
Key Steps in the Implementation:
2. Direct Removal Implementation
Purpose:
3. Core Burn Implementation
Initial Setup:
Metadata Access:
Balance Retrieval:
Fee Processing:
Fee Calculation Formula:
Understanding the Fee Calculation:
Amount Calculations:
Understanding the Amount Calculations:
Validation and Execution:
Token Extraction:
State Updates:
			Key points:
			Key points:
			Key points:
			Key points:
			Introduction
			Introduction
			Introduction
			Introduction
			1. Public Interface: The Entry Point
Function Parameters:
Return Values:
Key Steps in the Implementation:
			1. Public Interface: The Entry Point
			1. Public Interface: The Entry Point
			1. Public Interface: The Entry Point
			Function Parameters:
Return Values:
Key Steps in the Implementation:
			Function Parameters:
			Function Parameters:
			Function Parameters:
			Function Parameters:
			Return Values:
			Return Values:
			Return Values:
			Return Values:
			Key Steps in the Implementation:
			Key Steps in the Implementation:
			Key Steps in the Implementation:
			Key Steps in the Implementation:
			2. Direct Removal Implementation
Purpose:
			2. Direct Removal Implementation
			2. Direct Removal Implementation
			2. Direct Removal Implementation
			Purpose:
			Purpose:
			Purpose:
			Purpose:
			Purpose:
			3. Core Burn Implementation
Initial Setup:
Metadata Access:
Balance Retrieval:
Fee Processing:
Fee Calculation Formula:
Understanding the Fee Calculation:
Amount Calculations:
Understanding the Amount Calculations:
Validation and Execution:
Token Extraction:
State Updates:
			3. Core Burn Implementation
			3. Core Burn Implementation
			3. Core Burn Implementation
			Initial Setup:
Metadata Access:
Balance Retrieval:
Fee Processing:
Fee Calculation Formula:
Understanding the Fee Calculation:
Amount Calculations:
Understanding the Amount Calculations:
Validation and Execution:
Token Extraction:
State Updates:
			Initial Setup:
			Initial Setup:
			Initial Setup:
			Initial Setup:
			Metadata Access:
			Metadata Access:
			Metadata Access:
			Metadata Access:
			Balance Retrieval:
			Balance Retrieval:
			Balance Retrieval:
			Balance Retrieval:
			Fee Processing:
			Fee Processing:
			Fee Processing:
			Fee Processing:
			Fee Calculation Formula:
			Fee Calculation Formula:
			Fee Calculation Formula:
			Fee Calculation Formula:
			Understanding the Fee Calculation:
			Understanding the Fee Calculation:
			Understanding the Fee Calculation:
			Understanding the Fee Calculation:
			Amount Calculations:
			Amount Calculations:
			Amount Calculations:
			Amount Calculations:
			Understanding the Amount Calculations:
			Understanding the Amount Calculations:
			Understanding the Amount Calculations:
			Understanding the Amount Calculations:
			Validation and Execution:
			Validation and Execution:
			Validation and Execution:
			Validation and Execution:
			Token Extraction:
			Token Extraction:
			Token Extraction:
			Token Extraction:
			State Updates:
			State Updates:
			State Updates:
			State Updates:
			Key points:
Allows Liquidity Providers (LPs) to withdraw tokens from the pool
Involves burning LP tokens to receive proportional amounts of underlying tokens
Requires careful calculations to ensure fair distribution of assets
Includes processing of accrued fees before token extraction
Updates pool reserves and k-value after removal
Implements safety checks to prevent errors and maintain pool integrity
Uses a public interface for user interaction and internal functions for core logic
Crucial for maintaining flexibility and attractiveness of liquidity provision in DEXs
Introduction
Liquidity removal is a fundamental operation in a DEX that allows Liquidity Providers (LPs) to withdraw their tokens from the pool. When an LP decides to exit their position, they need to burn their LP tokens and receive a proportional amount of both token types from the pool. This process is crucial for maintaining the flexibility and attractiveness of providing liquidity in a DEX.
1. Public Interface: The Entry Point
Let's break down the public function that initiates the liquidity removal process:
/// Remove liquidity from a pool
/// Returns (amount_x_received, amount_y_received)
/// Requirements:
/// - Must have sufficient LP tokens to burn
/// - Must receive minimum amounts of tokens
public fun remove_liquidity<X, Y>(
    sender: &signer,
    liquidity: u64,
): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
    let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
    let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
    let amount_x = coin::value(&coins_x);
    let amount_y = coin::value(&coins_y);
    check_or_register_coin_store<X>(sender);
    check_or_register_coin_store<Y>(sender);
    let sender_addr = signer::address_of(sender);
    coin::deposit<X>(sender_addr, coins_x);
    coin::deposit<Y>(sender_addr, coins_y);
    // event
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<RemoveLiquidityEvent<X, Y>>(
        &mut pair_event_holder.remove_liquidity,
        RemoveLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x,
            amount_y,
            liquidity,
            fee_amount: (fee_amount as u64)
        }
    );
    (amount_x, amount_y)
}
This function is the main entry point for liquidity removal. Let's examine its components:
Function Parameters:
sender: &signer
- This is a reference to the user's account that's initiating the liquidity removal. It's used for several important operations:
Verifying that the user owns the LP tokens they're trying to burn
Withdrawing the LP tokens from the user's account
Depositing the underlying tokens back into the user's account after the removal process
liquidity: u64
- This parameter represents the amount of LP tokens the user wants to burn. It's important to note that:
The amount must be greater than 0 to perform a valid operation
It cannot exceed the user's current LP token balance
This value determines how many underlying tokens the user will receive back
Return Values:
The function returns a tuple
(u64, u64)
, which represents:
amount_x
: The amount of token X the user receives
amount_y
: The amount of token Y the user receives
These amounts are calculated proportionally based on the ratio of LP tokens burned to the total supply of LP tokens.
Key Steps in the Implementation:
Withdrawing LP Tokens:
let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
This line withdraws the specified amount of LP tokens from the user's account. It uses generics (
LPToken<X, Y>
) to ensure it's withdrawing the correct LP token for the specific token pair. If the user doesn't have enough LP tokens, this operation will fail automatically.
Core Liquidity Removal:
let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
This function call performs the actual liquidity removal. It takes the LP tokens and returns the underlying tokens (X and Y) along with any accrued fees. This step ensures that the entire operation is atomic, meaning it either completes fully or not at all.
Safety Checks:
check_or_register_coin_store<X>(sender);
check_or_register_coin_store<Y>(sender);
These lines perform crucial safety checks:
They ensure that the user's account is set up to receive both token types
If the user doesn't have a "coin store" for either token, it's automatically created
This prevents potential issues where the removal succeeds but the tokens can't be deposited
Depositing Tokens and Emitting Events:
The function then deposits the received tokens into the user's account and emits an event to record the liquidity removal operation. This ensures transparency and allows for easy tracking of DEX activities.
2. Direct Removal Implementation
/// Remove liquidity to token types.
fun remove_liquidity_direct<X, Y>(
    liquidity: coin::Coin<LPToken<X, Y>>,
): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    burn<X, Y>(liquidity)
}
Purpose:
This function serves as an important abstraction layer in our liquidity removal process. Let's break it down for beginners:
Separates concerns:
Public interface (remove_liquidity): This is what users interact with. It handles user-specific operations like withdrawing LP tokens from their account.
Direct function (remove_liquidity_direct): This manages the core logic of liquidity removal. It's an intermediate step that helps organize our code.
Burn function: This handles the detailed implementation of actually burning LP tokens and calculating token amounts to return.
3. Core Burn Implementation
/// Burns LP tokens to withdraw liquidity
/// Returns withdrawn tokens proportional to LP tokens burned
/// Requirements:
/// - Must receive minimum amounts of both tokens
fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    let liquidity = coin::value(&lp_tokens);
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    // Need to add fee amount which have not been minted.
    let total_lp_supply = total_lp_supply<X, Y>();
    let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
    coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
    let w_x = extract_x((amount_x as u64), metadata);
    let w_y = extract_y((amount_y as u64), metadata);
    update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    (w_x, w_y, fee_amount)
}
Initial Setup:
Let's break down the initial setup of our liquidity removal function. This part is crucial as it sets the stage for all subsequent operations.
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let (balance_x, balance_y) = (
    coin::value(&metadata.balance_x),
    coin::value(&metadata.balance_y)
);
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
let liquidity = coin::value(&lp_tokens);
Metadata Access:
The first line retrieves the metadata for our token pair. This is a critical step because the metadata contains essential information about our liquidity pool.
borrow_global_mut
: This function is used to get a mutable reference to the pool metadata. 'Mutable' means we can change this data if needed.
The metadata is stored at the
DEFAULT_ADMIN
address. This is a common pattern in Move to have a central storage location for important data.
The metadata contains crucial information like the current balances of both tokens, the total supply of LP tokens, and other pool-specific data.
Balance Retrieval:
Next, we retrieve the current balances of both tokens in the pool. This is necessary to calculate how much of each token the user should receive when removing liquidity.
We use
coin::value
to safely read the balance of each token in the pool.
This function returns the numerical value of the coin, which we can use in our calculations.
Getting accurate balances is crucial for maintaining the correct proportions when removing liquidity.
Fee Processing:
Before we calculate the amounts of tokens to return to the user, we need to process any accrued fees. This is an important step in maintaining the economic model of the DEX.
let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
This line calls a function to calculate and mint the fees. Let's break down how this works:
Fee Calculation Formula:
let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
let root_k_last = math128::sqrt(metadata.k_last);
if root_k > root_k_last {
    let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
    let denominator = root_k_last * 17u128 + root_k * 8u128;
    let liquidity = numerator / denominator;
    fee = liquidity as u64;
};
}
This might look complicated, but let's break it down step by step:
Understanding the Fee Calculation:
Calculating root_k:
We calculate the square root of the product of current reserves (reserve_x * reserve_y)
This represents the current "size" of the pool
Retrieving root_k_last:
This is the square root of the last recorded k value
It represents the pool size from the last operation
Comparing root_k and root_k_last:
If root_k > root_k_last, it means the pool has grown
This growth is what we use to calculate fees
Fee calculation:
We use a complex formula to ensure fair fee distribution
The numerator considers total supply and pool growth
The denominator includes factors to balance the fee
The result is a fair amount of new LP tokens to mint as fees
This fee calculation ensures that the protocol can sustain itself while providing fair returns to liquidity providers.
Amount Calculations:
let total_lp_supply = total_lp_supply<X, Y>();
let amount_x = ((balance_x as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
let amount_y = ((balance_y as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
Understanding the Amount Calculations:
Now that we've processed fees, we need to calculate how many tokens the user will receive when removing liquidity. The formula is straightforward but crucial:
amount_token = (current_balance * lp_amount_to_burn) / total_lp_supply
Let's break this down:
Proportion calculation:
We calculate based on the user's share of LP tokens
This ensures fairness - you get back proportional to what you put in
It automatically includes any fees or gains the pool has accumulated
Precision handling:
We cast to u128 (a larger integer type) for the calculation
This prevents potential overflow errors with large numbers
It also maintains accuracy in the division operation
Here's a simple example to illustrate:
If:
- Pool has 1000 X, 2000 Y
- Total LP supply is 1000
- User burns 100 LP tokens (10%)
Then:
- amount_x = 1000 * 100 / 1000 = 100 X
- amount_y = 2000 * 100 / 1000 = 200 Y
In this example, the user would receive 100 X tokens and 200 Y tokens for their 10% share of the pool.
Validation and Execution:
assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
After calculating the amounts, we perform some crucial steps:
Safety Checks:
We ensure that both amount_x and amount_y are greater than zero
This prevents "dust" withdrawals that could potentially harm the pool
If either amount is zero, we throw an error
LP Token Burning:
We use the burn capability to destroy the LP tokens
This reduces the total supply of LP tokens
It's an irreversible operation, ensuring the integrity of the pool
Token Extraction:
let w_x = extract_x((amount_x as u64), metadata);
let w_y = extract_y((amount_y as u64), metadata);
Now we actually extract the tokens to return to the user:
Safety check:
assert!(coin::value&lt;X&gt;(&metadata.balance_x) > amount,
       ERROR_INSUFFICIENT_AMOUNT);
This verifies that the pool has enough tokens to fulfill the withdrawal
It prevents potential underflow errors
It's a double-check to ensure our previous calculations were correct
Actual extraction:
coin::extract(&mut metadata.balance_x, amount)
This removes the calculated amount of tokens from the pool
It creates a new Coin object with these tokens
This Coin object will be returned to the user
State Updates:
update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
Finally, we need to update the state of our pool:
Reserve updates:
We update the current reserves with the new balances
This typically includes recording a timestamp for the update
It's crucial for maintaining an accurate state of the pool
K value update:
We calculate the new k value (product of reserves)
This is stored for the next operation
It's used in future fee calculations to detect pool growth
By following these steps, we ensure that liquidity removal is handled accurately, fairly, and safely in our DEX. Each step plays a crucial role in maintaining the integrity and efficiency of the system.
			Key points:
Allows Liquidity Providers (LPs) to withdraw tokens from the pool
Involves burning LP tokens to receive proportional amounts of underlying tokens
Requires careful calculations to ensure fair distribution of assets
Includes processing of accrued fees before token extraction
Updates pool reserves and k-value after removal
Implements safety checks to prevent errors and maintain pool integrity
Uses a public interface for user interaction and internal functions for core logic
Crucial for maintaining flexibility and attractiveness of liquidity provision in DEXs
Introduction
Liquidity removal is a fundamental operation in a DEX that allows Liquidity Providers (LPs) to withdraw their tokens from the pool. When an LP decides to exit their position, they need to burn their LP tokens and receive a proportional amount of both token types from the pool. This process is crucial for maintaining the flexibility and attractiveness of providing liquidity in a DEX.
1. Public Interface: The Entry Point
Let's break down the public function that initiates the liquidity removal process:
/// Remove liquidity from a pool
/// Returns (amount_x_received, amount_y_received)
/// Requirements:
/// - Must have sufficient LP tokens to burn
/// - Must receive minimum amounts of tokens
public fun remove_liquidity<X, Y>(
    sender: &signer,
    liquidity: u64,
): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
    let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
    let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
    let amount_x = coin::value(&coins_x);
    let amount_y = coin::value(&coins_y);
    check_or_register_coin_store<X>(sender);
    check_or_register_coin_store<Y>(sender);
    let sender_addr = signer::address_of(sender);
    coin::deposit<X>(sender_addr, coins_x);
    coin::deposit<Y>(sender_addr, coins_y);
    // event
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<RemoveLiquidityEvent<X, Y>>(
        &mut pair_event_holder.remove_liquidity,
        RemoveLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x,
            amount_y,
            liquidity,
            fee_amount: (fee_amount as u64)
        }
    );
    (amount_x, amount_y)
}
This function is the main entry point for liquidity removal. Let's examine its components:
Function Parameters:
sender: &signer
- This is a reference to the user's account that's initiating the liquidity removal. It's used for several important operations:
Verifying that the user owns the LP tokens they're trying to burn
Withdrawing the LP tokens from the user's account
Depositing the underlying tokens back into the user's account after the removal process
liquidity: u64
- This parameter represents the amount of LP tokens the user wants to burn. It's important to note that:
The amount must be greater than 0 to perform a valid operation
It cannot exceed the user's current LP token balance
This value determines how many underlying tokens the user will receive back
Return Values:
The function returns a tuple
(u64, u64)
, which represents:
amount_x
: The amount of token X the user receives
amount_y
: The amount of token Y the user receives
These amounts are calculated proportionally based on the ratio of LP tokens burned to the total supply of LP tokens.
Key Steps in the Implementation:
Withdrawing LP Tokens:
let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
This line withdraws the specified amount of LP tokens from the user's account. It uses generics (
LPToken<X, Y>
) to ensure it's withdrawing the correct LP token for the specific token pair. If the user doesn't have enough LP tokens, this operation will fail automatically.
Core Liquidity Removal:
let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
This function call performs the actual liquidity removal. It takes the LP tokens and returns the underlying tokens (X and Y) along with any accrued fees. This step ensures that the entire operation is atomic, meaning it either completes fully or not at all.
Safety Checks:
check_or_register_coin_store<X>(sender);
check_or_register_coin_store<Y>(sender);
These lines perform crucial safety checks:
They ensure that the user's account is set up to receive both token types
If the user doesn't have a "coin store" for either token, it's automatically created
This prevents potential issues where the removal succeeds but the tokens can't be deposited
Depositing Tokens and Emitting Events:
The function then deposits the received tokens into the user's account and emits an event to record the liquidity removal operation. This ensures transparency and allows for easy tracking of DEX activities.
2. Direct Removal Implementation
/// Remove liquidity to token types.
fun remove_liquidity_direct<X, Y>(
    liquidity: coin::Coin<LPToken<X, Y>>,
): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    burn<X, Y>(liquidity)
}
Purpose:
This function serves as an important abstraction layer in our liquidity removal process. Let's break it down for beginners:
Separates concerns:
Public interface (remove_liquidity): This is what users interact with. It handles user-specific operations like withdrawing LP tokens from their account.
Direct function (remove_liquidity_direct): This manages the core logic of liquidity removal. It's an intermediate step that helps organize our code.
Burn function: This handles the detailed implementation of actually burning LP tokens and calculating token amounts to return.
3. Core Burn Implementation
/// Burns LP tokens to withdraw liquidity
/// Returns withdrawn tokens proportional to LP tokens burned
/// Requirements:
/// - Must receive minimum amounts of both tokens
fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    let liquidity = coin::value(&lp_tokens);
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    // Need to add fee amount which have not been minted.
    let total_lp_supply = total_lp_supply<X, Y>();
    let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
    coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
    let w_x = extract_x((amount_x as u64), metadata);
    let w_y = extract_y((amount_y as u64), metadata);
    update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    (w_x, w_y, fee_amount)
}
Initial Setup:
Let's break down the initial setup of our liquidity removal function. This part is crucial as it sets the stage for all subsequent operations.
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let (balance_x, balance_y) = (
    coin::value(&metadata.balance_x),
    coin::value(&metadata.balance_y)
);
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
let liquidity = coin::value(&lp_tokens);
Metadata Access:
The first line retrieves the metadata for our token pair. This is a critical step because the metadata contains essential information about our liquidity pool.
borrow_global_mut
: This function is used to get a mutable reference to the pool metadata. 'Mutable' means we can change this data if needed.
The metadata is stored at the
DEFAULT_ADMIN
address. This is a common pattern in Move to have a central storage location for important data.
The metadata contains crucial information like the current balances of both tokens, the total supply of LP tokens, and other pool-specific data.
Balance Retrieval:
Next, we retrieve the current balances of both tokens in the pool. This is necessary to calculate how much of each token the user should receive when removing liquidity.
We use
coin::value
to safely read the balance of each token in the pool.
This function returns the numerical value of the coin, which we can use in our calculations.
Getting accurate balances is crucial for maintaining the correct proportions when removing liquidity.
Fee Processing:
Before we calculate the amounts of tokens to return to the user, we need to process any accrued fees. This is an important step in maintaining the economic model of the DEX.
let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
This line calls a function to calculate and mint the fees. Let's break down how this works:
Fee Calculation Formula:
let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
let root_k_last = math128::sqrt(metadata.k_last);
if root_k > root_k_last {
    let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
    let denominator = root_k_last * 17u128 + root_k * 8u128;
    let liquidity = numerator / denominator;
    fee = liquidity as u64;
};
}
This might look complicated, but let's break it down step by step:
Understanding the Fee Calculation:
Calculating root_k:
We calculate the square root of the product of current reserves (reserve_x * reserve_y)
This represents the current "size" of the pool
Retrieving root_k_last:
This is the square root of the last recorded k value
It represents the pool size from the last operation
Comparing root_k and root_k_last:
If root_k > root_k_last, it means the pool has grown
This growth is what we use to calculate fees
Fee calculation:
We use a complex formula to ensure fair fee distribution
The numerator considers total supply and pool growth
The denominator includes factors to balance the fee
The result is a fair amount of new LP tokens to mint as fees
This fee calculation ensures that the protocol can sustain itself while providing fair returns to liquidity providers.
Amount Calculations:
let total_lp_supply = total_lp_supply<X, Y>();
let amount_x = ((balance_x as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
let amount_y = ((balance_y as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
Understanding the Amount Calculations:
Now that we've processed fees, we need to calculate how many tokens the user will receive when removing liquidity. The formula is straightforward but crucial:
amount_token = (current_balance * lp_amount_to_burn) / total_lp_supply
Let's break this down:
Proportion calculation:
We calculate based on the user's share of LP tokens
This ensures fairness - you get back proportional to what you put in
It automatically includes any fees or gains the pool has accumulated
Precision handling:
We cast to u128 (a larger integer type) for the calculation
This prevents potential overflow errors with large numbers
It also maintains accuracy in the division operation
Here's a simple example to illustrate:
If:
- Pool has 1000 X, 2000 Y
- Total LP supply is 1000
- User burns 100 LP tokens (10%)
Then:
- amount_x = 1000 * 100 / 1000 = 100 X
- amount_y = 2000 * 100 / 1000 = 200 Y
In this example, the user would receive 100 X tokens and 200 Y tokens for their 10% share of the pool.
Validation and Execution:
assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
After calculating the amounts, we perform some crucial steps:
Safety Checks:
We ensure that both amount_x and amount_y are greater than zero
This prevents "dust" withdrawals that could potentially harm the pool
If either amount is zero, we throw an error
LP Token Burning:
We use the burn capability to destroy the LP tokens
This reduces the total supply of LP tokens
It's an irreversible operation, ensuring the integrity of the pool
Token Extraction:
let w_x = extract_x((amount_x as u64), metadata);
let w_y = extract_y((amount_y as u64), metadata);
Now we actually extract the tokens to return to the user:
Safety check:
assert!(coin::value&lt;X&gt;(&metadata.balance_x) > amount,
       ERROR_INSUFFICIENT_AMOUNT);
This verifies that the pool has enough tokens to fulfill the withdrawal
It prevents potential underflow errors
It's a double-check to ensure our previous calculations were correct
Actual extraction:
coin::extract(&mut metadata.balance_x, amount)
This removes the calculated amount of tokens from the pool
It creates a new Coin object with these tokens
This Coin object will be returned to the user
State Updates:
update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
Finally, we need to update the state of our pool:
Reserve updates:
We update the current reserves with the new balances
This typically includes recording a timestamp for the update
It's crucial for maintaining an accurate state of the pool
K value update:
We calculate the new k value (product of reserves)
This is stored for the next operation
It's used in future fee calculations to detect pool growth
By following these steps, we ensure that liquidity removal is handled accurately, fairly, and safely in our DEX. Each step plays a crucial role in maintaining the integrity and efficiency of the system.
			Key points:
Allows Liquidity Providers (LPs) to withdraw tokens from the pool
Involves burning LP tokens to receive proportional amounts of underlying tokens
Requires careful calculations to ensure fair distribution of assets
Includes processing of accrued fees before token extraction
Updates pool reserves and k-value after removal
Implements safety checks to prevent errors and maintain pool integrity
Uses a public interface for user interaction and internal functions for core logic
Crucial for maintaining flexibility and attractiveness of liquidity provision in DEXs
Introduction
Liquidity removal is a fundamental operation in a DEX that allows Liquidity Providers (LPs) to withdraw their tokens from the pool. When an LP decides to exit their position, they need to burn their LP tokens and receive a proportional amount of both token types from the pool. This process is crucial for maintaining the flexibility and attractiveness of providing liquidity in a DEX.
1. Public Interface: The Entry Point
Let's break down the public function that initiates the liquidity removal process:
/// Remove liquidity from a pool
/// Returns (amount_x_received, amount_y_received)
/// Requirements:
/// - Must have sufficient LP tokens to burn
/// - Must receive minimum amounts of tokens
public fun remove_liquidity<X, Y>(
    sender: &signer,
    liquidity: u64,
): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
    let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
    let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
    let amount_x = coin::value(&coins_x);
    let amount_y = coin::value(&coins_y);
    check_or_register_coin_store<X>(sender);
    check_or_register_coin_store<Y>(sender);
    let sender_addr = signer::address_of(sender);
    coin::deposit<X>(sender_addr, coins_x);
    coin::deposit<Y>(sender_addr, coins_y);
    // event
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<RemoveLiquidityEvent<X, Y>>(
        &mut pair_event_holder.remove_liquidity,
        RemoveLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x,
            amount_y,
            liquidity,
            fee_amount: (fee_amount as u64)
        }
    );
    (amount_x, amount_y)
}
This function is the main entry point for liquidity removal. Let's examine its components:
Function Parameters:
sender: &signer
- This is a reference to the user's account that's initiating the liquidity removal. It's used for several important operations:
Verifying that the user owns the LP tokens they're trying to burn
Withdrawing the LP tokens from the user's account
Depositing the underlying tokens back into the user's account after the removal process
liquidity: u64
- This parameter represents the amount of LP tokens the user wants to burn. It's important to note that:
The amount must be greater than 0 to perform a valid operation
It cannot exceed the user's current LP token balance
This value determines how many underlying tokens the user will receive back
Return Values:
The function returns a tuple
(u64, u64)
, which represents:
amount_x
: The amount of token X the user receives
amount_y
: The amount of token Y the user receives
These amounts are calculated proportionally based on the ratio of LP tokens burned to the total supply of LP tokens.
Key Steps in the Implementation:
Withdrawing LP Tokens:
let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
This line withdraws the specified amount of LP tokens from the user's account. It uses generics (
LPToken<X, Y>
) to ensure it's withdrawing the correct LP token for the specific token pair. If the user doesn't have enough LP tokens, this operation will fail automatically.
Core Liquidity Removal:
let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
This function call performs the actual liquidity removal. It takes the LP tokens and returns the underlying tokens (X and Y) along with any accrued fees. This step ensures that the entire operation is atomic, meaning it either completes fully or not at all.
Safety Checks:
check_or_register_coin_store<X>(sender);
check_or_register_coin_store<Y>(sender);
These lines perform crucial safety checks:
They ensure that the user's account is set up to receive both token types
If the user doesn't have a "coin store" for either token, it's automatically created
This prevents potential issues where the removal succeeds but the tokens can't be deposited
Depositing Tokens and Emitting Events:
The function then deposits the received tokens into the user's account and emits an event to record the liquidity removal operation. This ensures transparency and allows for easy tracking of DEX activities.
2. Direct Removal Implementation
/// Remove liquidity to token types.
fun remove_liquidity_direct<X, Y>(
    liquidity: coin::Coin<LPToken<X, Y>>,
): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    burn<X, Y>(liquidity)
}
Purpose:
This function serves as an important abstraction layer in our liquidity removal process. Let's break it down for beginners:
Separates concerns:
Public interface (remove_liquidity): This is what users interact with. It handles user-specific operations like withdrawing LP tokens from their account.
Direct function (remove_liquidity_direct): This manages the core logic of liquidity removal. It's an intermediate step that helps organize our code.
Burn function: This handles the detailed implementation of actually burning LP tokens and calculating token amounts to return.
3. Core Burn Implementation
/// Burns LP tokens to withdraw liquidity
/// Returns withdrawn tokens proportional to LP tokens burned
/// Requirements:
/// - Must receive minimum amounts of both tokens
fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    let liquidity = coin::value(&lp_tokens);
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    // Need to add fee amount which have not been minted.
    let total_lp_supply = total_lp_supply<X, Y>();
    let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
    coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
    let w_x = extract_x((amount_x as u64), metadata);
    let w_y = extract_y((amount_y as u64), metadata);
    update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    (w_x, w_y, fee_amount)
}
Initial Setup:
Let's break down the initial setup of our liquidity removal function. This part is crucial as it sets the stage for all subsequent operations.
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let (balance_x, balance_y) = (
    coin::value(&metadata.balance_x),
    coin::value(&metadata.balance_y)
);
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
let liquidity = coin::value(&lp_tokens);
Metadata Access:
The first line retrieves the metadata for our token pair. This is a critical step because the metadata contains essential information about our liquidity pool.
borrow_global_mut
: This function is used to get a mutable reference to the pool metadata. 'Mutable' means we can change this data if needed.
The metadata is stored at the
DEFAULT_ADMIN
address. This is a common pattern in Move to have a central storage location for important data.
The metadata contains crucial information like the current balances of both tokens, the total supply of LP tokens, and other pool-specific data.
Balance Retrieval:
Next, we retrieve the current balances of both tokens in the pool. This is necessary to calculate how much of each token the user should receive when removing liquidity.
We use
coin::value
to safely read the balance of each token in the pool.
This function returns the numerical value of the coin, which we can use in our calculations.
Getting accurate balances is crucial for maintaining the correct proportions when removing liquidity.
Fee Processing:
Before we calculate the amounts of tokens to return to the user, we need to process any accrued fees. This is an important step in maintaining the economic model of the DEX.
let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
This line calls a function to calculate and mint the fees. Let's break down how this works:
Fee Calculation Formula:
let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
let root_k_last = math128::sqrt(metadata.k_last);
if root_k > root_k_last {
    let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
    let denominator = root_k_last * 17u128 + root_k * 8u128;
    let liquidity = numerator / denominator;
    fee = liquidity as u64;
};
}
This might look complicated, but let's break it down step by step:
Understanding the Fee Calculation:
Calculating root_k:
We calculate the square root of the product of current reserves (reserve_x * reserve_y)
This represents the current "size" of the pool
Retrieving root_k_last:
This is the square root of the last recorded k value
It represents the pool size from the last operation
Comparing root_k and root_k_last:
If root_k > root_k_last, it means the pool has grown
This growth is what we use to calculate fees
Fee calculation:
We use a complex formula to ensure fair fee distribution
The numerator considers total supply and pool growth
The denominator includes factors to balance the fee
The result is a fair amount of new LP tokens to mint as fees
This fee calculation ensures that the protocol can sustain itself while providing fair returns to liquidity providers.
Amount Calculations:
let total_lp_supply = total_lp_supply<X, Y>();
let amount_x = ((balance_x as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
let amount_y = ((balance_y as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
Understanding the Amount Calculations:
Now that we've processed fees, we need to calculate how many tokens the user will receive when removing liquidity. The formula is straightforward but crucial:
amount_token = (current_balance * lp_amount_to_burn) / total_lp_supply
Let's break this down:
Proportion calculation:
We calculate based on the user's share of LP tokens
This ensures fairness - you get back proportional to what you put in
It automatically includes any fees or gains the pool has accumulated
Precision handling:
We cast to u128 (a larger integer type) for the calculation
This prevents potential overflow errors with large numbers
It also maintains accuracy in the division operation
Here's a simple example to illustrate:
If:
- Pool has 1000 X, 2000 Y
- Total LP supply is 1000
- User burns 100 LP tokens (10%)
Then:
- amount_x = 1000 * 100 / 1000 = 100 X
- amount_y = 2000 * 100 / 1000 = 200 Y
In this example, the user would receive 100 X tokens and 200 Y tokens for their 10% share of the pool.
Validation and Execution:
assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
After calculating the amounts, we perform some crucial steps:
Safety Checks:
We ensure that both amount_x and amount_y are greater than zero
This prevents "dust" withdrawals that could potentially harm the pool
If either amount is zero, we throw an error
LP Token Burning:
We use the burn capability to destroy the LP tokens
This reduces the total supply of LP tokens
It's an irreversible operation, ensuring the integrity of the pool
Token Extraction:
let w_x = extract_x((amount_x as u64), metadata);
let w_y = extract_y((amount_y as u64), metadata);
Now we actually extract the tokens to return to the user:
Safety check:
assert!(coin::value&lt;X&gt;(&metadata.balance_x) > amount,
       ERROR_INSUFFICIENT_AMOUNT);
This verifies that the pool has enough tokens to fulfill the withdrawal
It prevents potential underflow errors
It's a double-check to ensure our previous calculations were correct
Actual extraction:
coin::extract(&mut metadata.balance_x, amount)
This removes the calculated amount of tokens from the pool
It creates a new Coin object with these tokens
This Coin object will be returned to the user
State Updates:
update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
Finally, we need to update the state of our pool:
Reserve updates:
We update the current reserves with the new balances
This typically includes recording a timestamp for the update
It's crucial for maintaining an accurate state of the pool
K value update:
We calculate the new k value (product of reserves)
This is stored for the next operation
It's used in future fee calculations to detect pool growth
By following these steps, we ensure that liquidity removal is handled accurately, fairly, and safely in our DEX. Each step plays a crucial role in maintaining the integrity and efficiency of the system.
		Key points:
		Key points:
		Allows Liquidity Providers (LPs) to withdraw tokens from the pool
Involves burning LP tokens to receive proportional amounts of underlying tokens
Requires careful calculations to ensure fair distribution of assets
Includes processing of accrued fees before token extraction
Updates pool reserves and k-value after removal
Implements safety checks to prevent errors and maintain pool integrity
Uses a public interface for user interaction and internal functions for core logic
Crucial for maintaining flexibility and attractiveness of liquidity provision in DEXs
		Allows Liquidity Providers (LPs) to withdraw tokens from the pool
		Allows Liquidity Providers (LPs) to withdraw tokens from the pool
		Involves burning LP tokens to receive proportional amounts of underlying tokens
		Involves burning LP tokens to receive proportional amounts of underlying tokens
		Requires careful calculations to ensure fair distribution of assets
		Requires careful calculations to ensure fair distribution of assets
		Includes processing of accrued fees before token extraction
		Includes processing of accrued fees before token extraction
		Updates pool reserves and k-value after removal
		Updates pool reserves and k-value after removal
		Implements safety checks to prevent errors and maintain pool integrity
		Implements safety checks to prevent errors and maintain pool integrity
		Uses a public interface for user interaction and internal functions for core logic
		Uses a public interface for user interaction and internal functions for core logic
		Crucial for maintaining flexibility and attractiveness of liquidity provision in DEXs
		Crucial for maintaining flexibility and attractiveness of liquidity provision in DEXs
	Introduction
	Introduction
	Liquidity removal is a fundamental operation in a DEX that allows Liquidity Providers (LPs) to withdraw their tokens from the pool. When an LP decides to exit their position, they need to burn their LP tokens and receive a proportional amount of both token types from the pool. This process is crucial for maintaining the flexibility and attractiveness of providing liquidity in a DEX.
	Liquidity removal is a fundamental operation in a DEX that allows Liquidity Providers (LPs) to withdraw their tokens from the pool. When an LP decides to exit their position, they need to burn their LP tokens and receive a proportional amount of both token types from the pool. This process is crucial for maintaining the flexibility and attractiveness of providing liquidity in a DEX.
	1. Public Interface: The Entry Point
	1. Public Interface: The Entry Point
	Let's break down the public function that initiates the liquidity removal process:
	Let's break down the public function that initiates the liquidity removal process:
	<code>/// Remove liquidity from a pool
/// Returns (amount_x_received, amount_y_received)
/// Requirements:
/// - Must have sufficient LP tokens to burn
/// - Must receive minimum amounts of tokens
public fun remove_liquidity<X, Y>(
    sender: &signer,
    liquidity: u64,
): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
    let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
    let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
    let amount_x = coin::value(&coins_x);
    let amount_y = coin::value(&coins_y);
    check_or_register_coin_store<X>(sender);
    check_or_register_coin_store<Y>(sender);
    let sender_addr = signer::address_of(sender);
    coin::deposit<X>(sender_addr, coins_x);
    coin::deposit<Y>(sender_addr, coins_y);
    // event
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<RemoveLiquidityEvent<X, Y>>(
        &mut pair_event_holder.remove_liquidity,
        RemoveLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x,
            amount_y,
            liquidity,
            fee_amount: (fee_amount as u64)
        }
    );
    (amount_x, amount_y)
}</code>
	<code>/// Remove liquidity from a pool
/// Returns (amount_x_received, amount_y_received)
/// Requirements:
/// - Must have sufficient LP tokens to burn
/// - Must receive minimum amounts of tokens
public fun remove_liquidity<X, Y>(
    sender: &signer,
    liquidity: u64,
): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
    let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
    let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
    let amount_x = coin::value(&coins_x);
    let amount_y = coin::value(&coins_y);
    check_or_register_coin_store<X>(sender);
    check_or_register_coin_store<Y>(sender);
    let sender_addr = signer::address_of(sender);
    coin::deposit<X>(sender_addr, coins_x);
    coin::deposit<Y>(sender_addr, coins_y);
    // event
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<RemoveLiquidityEvent<X, Y>>(
        &mut pair_event_holder.remove_liquidity,
        RemoveLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x,
            amount_y,
            liquidity,
            fee_amount: (fee_amount as u64)
        }
    );
    (amount_x, amount_y)
}</code>
	/// Remove liquidity from a pool
/// Returns (amount_x_received, amount_y_received)
/// Requirements:
/// - Must have sufficient LP tokens to burn
/// - Must receive minimum amounts of tokens
public fun remove_liquidity<X, Y>(
    sender: &signer,
    liquidity: u64,
): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
    let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
    let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
    let amount_x = coin::value(&coins_x);
    let amount_y = coin::value(&coins_y);
    check_or_register_coin_store<X>(sender);
    check_or_register_coin_store<Y>(sender);
    let sender_addr = signer::address_of(sender);
    coin::deposit<X>(sender_addr, coins_x);
    coin::deposit<Y>(sender_addr, coins_y);
    // event
    let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
    event::emit_event<RemoveLiquidityEvent<X, Y>>(
        &mut pair_event_holder.remove_liquidity,
        RemoveLiquidityEvent<X, Y> {
            user: sender_addr,
            amount_x,
            amount_y,
            liquidity,
            fee_amount: (fee_amount as u64)
        }
    );
    (amount_x, amount_y)
}
	This function is the main entry point for liquidity removal. Let's examine its components:
	This function is the main entry point for liquidity removal. Let's examine its components:
		Function Parameters:
		Function Parameters:
		sender: &signer
- This is a reference to the user's account that's initiating the liquidity removal. It's used for several important operations:
Verifying that the user owns the LP tokens they're trying to burn
Withdrawing the LP tokens from the user's account
Depositing the underlying tokens back into the user's account after the removal process
liquidity: u64
- This parameter represents the amount of LP tokens the user wants to burn. It's important to note that:
The amount must be greater than 0 to perform a valid operation
It cannot exceed the user's current LP token balance
This value determines how many underlying tokens the user will receive back
		sender: &signer
- This is a reference to the user's account that's initiating the liquidity removal. It's used for several important operations:
Verifying that the user owns the LP tokens they're trying to burn
Withdrawing the LP tokens from the user's account
Depositing the underlying tokens back into the user's account after the removal process
		sender: &signer
		sender: &signer
		- This is a reference to the user's account that's initiating the liquidity removal. It's used for several important operations:
		Verifying that the user owns the LP tokens they're trying to burn
Withdrawing the LP tokens from the user's account
Depositing the underlying tokens back into the user's account after the removal process
		Verifying that the user owns the LP tokens they're trying to burn
		Verifying that the user owns the LP tokens they're trying to burn
		Withdrawing the LP tokens from the user's account
		Withdrawing the LP tokens from the user's account
		Depositing the underlying tokens back into the user's account after the removal process
		Depositing the underlying tokens back into the user's account after the removal process
		liquidity: u64
- This parameter represents the amount of LP tokens the user wants to burn. It's important to note that:
The amount must be greater than 0 to perform a valid operation
It cannot exceed the user's current LP token balance
This value determines how many underlying tokens the user will receive back
		liquidity: u64
		liquidity: u64
		- This parameter represents the amount of LP tokens the user wants to burn. It's important to note that:
		The amount must be greater than 0 to perform a valid operation
It cannot exceed the user's current LP token balance
This value determines how many underlying tokens the user will receive back
		The amount must be greater than 0 to perform a valid operation
		The amount must be greater than 0 to perform a valid operation
		It cannot exceed the user's current LP token balance
		It cannot exceed the user's current LP token balance
		This value determines how many underlying tokens the user will receive back
		This value determines how many underlying tokens the user will receive back
		Return Values:
		Return Values:
		The function returns a tuple
(u64, u64)
, which represents:
		The function returns a tuple
		<code>(u64, u64)</code>
		(u64, u64)
		, which represents:
		amount_x
: The amount of token X the user receives
amount_y
: The amount of token Y the user receives
		amount_x
: The amount of token X the user receives
		<code>amount_x</code>
		amount_x
		: The amount of token X the user receives
		amount_y
: The amount of token Y the user receives
		<code>amount_y</code>
		amount_y
		: The amount of token Y the user receives
		These amounts are calculated proportionally based on the ratio of LP tokens burned to the total supply of LP tokens.
		These amounts are calculated proportionally based on the ratio of LP tokens burned to the total supply of LP tokens.
		Key Steps in the Implementation:
		Key Steps in the Implementation:
		Withdrawing LP Tokens:
		Withdrawing LP Tokens:
		Withdrawing LP Tokens:
		<code>let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);</code>
		<code>let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);</code>
		let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
		This line withdraws the specified amount of LP tokens from the user's account. It uses generics (
LPToken<X, Y>
) to ensure it's withdrawing the correct LP token for the specific token pair. If the user doesn't have enough LP tokens, this operation will fail automatically.
		This line withdraws the specified amount of LP tokens from the user's account. It uses generics (
		<code>LPToken<X, Y></code>
		LPToken<X, Y>
		) to ensure it's withdrawing the correct LP token for the specific token pair. If the user doesn't have enough LP tokens, this operation will fail automatically.
		Core Liquidity Removal:
		Core Liquidity Removal:
		Core Liquidity Removal:
		<code>let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);</code>
		<code>let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);</code>
		let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
		This function call performs the actual liquidity removal. It takes the LP tokens and returns the underlying tokens (X and Y) along with any accrued fees. This step ensures that the entire operation is atomic, meaning it either completes fully or not at all.
		This function call performs the actual liquidity removal. It takes the LP tokens and returns the underlying tokens (X and Y) along with any accrued fees. This step ensures that the entire operation is atomic, meaning it either completes fully or not at all.
		Safety Checks:
		Safety Checks:
		Safety Checks:
		<code>check_or_register_coin_store<X>(sender);
check_or_register_coin_store<Y>(sender);</code>
		<code>check_or_register_coin_store<X>(sender);
check_or_register_coin_store<Y>(sender);</code>
		check_or_register_coin_store<X>(sender);
check_or_register_coin_store<Y>(sender);
		These lines perform crucial safety checks:
		These lines perform crucial safety checks:
		They ensure that the user's account is set up to receive both token types
If the user doesn't have a "coin store" for either token, it's automatically created
This prevents potential issues where the removal succeeds but the tokens can't be deposited
		They ensure that the user's account is set up to receive both token types
		They ensure that the user's account is set up to receive both token types
		If the user doesn't have a "coin store" for either token, it's automatically created
		If the user doesn't have a "coin store" for either token, it's automatically created
		This prevents potential issues where the removal succeeds but the tokens can't be deposited
		This prevents potential issues where the removal succeeds but the tokens can't be deposited
		Depositing Tokens and Emitting Events:
		Depositing Tokens and Emitting Events:
		Depositing Tokens and Emitting Events:
		The function then deposits the received tokens into the user's account and emits an event to record the liquidity removal operation. This ensures transparency and allows for easy tracking of DEX activities.
		The function then deposits the received tokens into the user's account and emits an event to record the liquidity removal operation. This ensures transparency and allows for easy tracking of DEX activities.
	2. Direct Removal Implementation
	2. Direct Removal Implementation
	<code>/// Remove liquidity to token types.
fun remove_liquidity_direct<X, Y>(
    liquidity: coin::Coin<LPToken<X, Y>>,
): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    burn<X, Y>(liquidity)
}</code>
	<code>/// Remove liquidity to token types.
fun remove_liquidity_direct<X, Y>(
    liquidity: coin::Coin<LPToken<X, Y>>,
): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    burn<X, Y>(liquidity)
}</code>
	/// Remove liquidity to token types.
fun remove_liquidity_direct<X, Y>(
    liquidity: coin::Coin<LPToken<X, Y>>,
): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    burn<X, Y>(liquidity)
}
		Purpose:
		Purpose:
		This function serves as an important abstraction layer in our liquidity removal process. Let's break it down for beginners:
		This function serves as an important abstraction layer in our liquidity removal process. Let's break it down for beginners:
		Separates concerns:
Public interface (remove_liquidity): This is what users interact with. It handles user-specific operations like withdrawing LP tokens from their account.
Direct function (remove_liquidity_direct): This manages the core logic of liquidity removal. It's an intermediate step that helps organize our code.
Burn function: This handles the detailed implementation of actually burning LP tokens and calculating token amounts to return.
		Separates concerns:
Public interface (remove_liquidity): This is what users interact with. It handles user-specific operations like withdrawing LP tokens from their account.
Direct function (remove_liquidity_direct): This manages the core logic of liquidity removal. It's an intermediate step that helps organize our code.
Burn function: This handles the detailed implementation of actually burning LP tokens and calculating token amounts to return.
		Separates concerns:
		Public interface (remove_liquidity): This is what users interact with. It handles user-specific operations like withdrawing LP tokens from their account.
Direct function (remove_liquidity_direct): This manages the core logic of liquidity removal. It's an intermediate step that helps organize our code.
Burn function: This handles the detailed implementation of actually burning LP tokens and calculating token amounts to return.
		Public interface (remove_liquidity): This is what users interact with. It handles user-specific operations like withdrawing LP tokens from their account.
		Public interface (remove_liquidity): This is what users interact with. It handles user-specific operations like withdrawing LP tokens from their account.
		Direct function (remove_liquidity_direct): This manages the core logic of liquidity removal. It's an intermediate step that helps organize our code.
		Direct function (remove_liquidity_direct): This manages the core logic of liquidity removal. It's an intermediate step that helps organize our code.
		Burn function: This handles the detailed implementation of actually burning LP tokens and calculating token amounts to return.
		Burn function: This handles the detailed implementation of actually burning LP tokens and calculating token amounts to return.
	3. Core Burn Implementation
	3. Core Burn Implementation
	<code>/// Burns LP tokens to withdraw liquidity
/// Returns withdrawn tokens proportional to LP tokens burned
/// Requirements:
/// - Must receive minimum amounts of both tokens
fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    let liquidity = coin::value(&lp_tokens);
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    // Need to add fee amount which have not been minted.
    let total_lp_supply = total_lp_supply<X, Y>();
    let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
    coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
    let w_x = extract_x((amount_x as u64), metadata);
    let w_y = extract_y((amount_y as u64), metadata);
    update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    (w_x, w_y, fee_amount)
}</code>
	<code>/// Burns LP tokens to withdraw liquidity
/// Returns withdrawn tokens proportional to LP tokens burned
/// Requirements:
/// - Must receive minimum amounts of both tokens
fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    let liquidity = coin::value(&lp_tokens);
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    // Need to add fee amount which have not been minted.
    let total_lp_supply = total_lp_supply<X, Y>();
    let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
    coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
    let w_x = extract_x((amount_x as u64), metadata);
    let w_y = extract_y((amount_y as u64), metadata);
    update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    (w_x, w_y, fee_amount)
}</code>
	/// Burns LP tokens to withdraw liquidity
/// Returns withdrawn tokens proportional to LP tokens burned
/// Requirements:
/// - Must receive minimum amounts of both tokens
fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
    let liquidity = coin::value(&lp_tokens);
    let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
    // Need to add fee amount which have not been minted.
    let total_lp_supply = total_lp_supply<X, Y>();
    let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
    assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
    coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
    let w_x = extract_x((amount_x as u64), metadata);
    let w_y = extract_y((amount_y as u64), metadata);
    update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
    metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
    (w_x, w_y, fee_amount)
}
		Initial Setup:
		Initial Setup:
		Let's break down the initial setup of our liquidity removal function. This part is crucial as it sets the stage for all subsequent operations.
		Let's break down the initial setup of our liquidity removal function. This part is crucial as it sets the stage for all subsequent operations.
		<code>let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let (balance_x, balance_y) = (
    coin::value(&metadata.balance_x),
    coin::value(&metadata.balance_y)
);
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
let liquidity = coin::value(&lp_tokens);</code>
		<code>let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let (balance_x, balance_y) = (
    coin::value(&metadata.balance_x),
    coin::value(&metadata.balance_y)
);
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
let liquidity = coin::value(&lp_tokens);</code>
		let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let (balance_x, balance_y) = (
    coin::value(&metadata.balance_x),
    coin::value(&metadata.balance_y)
);
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
let liquidity = coin::value(&lp_tokens);
		Metadata Access:
		Metadata Access:
		The first line retrieves the metadata for our token pair. This is a critical step because the metadata contains essential information about our liquidity pool.
		The first line retrieves the metadata for our token pair. This is a critical step because the metadata contains essential information about our liquidity pool.
		borrow_global_mut
: This function is used to get a mutable reference to the pool metadata. 'Mutable' means we can change this data if needed.
The metadata is stored at the
DEFAULT_ADMIN
address. This is a common pattern in Move to have a central storage location for important data.
The metadata contains crucial information like the current balances of both tokens, the total supply of LP tokens, and other pool-specific data.
		borrow_global_mut
: This function is used to get a mutable reference to the pool metadata. 'Mutable' means we can change this data if needed.
		<code>borrow_global_mut</code>
		borrow_global_mut
		: This function is used to get a mutable reference to the pool metadata. 'Mutable' means we can change this data if needed.
		The metadata is stored at the
DEFAULT_ADMIN
address. This is a common pattern in Move to have a central storage location for important data.
		The metadata is stored at the
		<code>DEFAULT_ADMIN</code>
		DEFAULT_ADMIN
		address. This is a common pattern in Move to have a central storage location for important data.
		The metadata contains crucial information like the current balances of both tokens, the total supply of LP tokens, and other pool-specific data.
		The metadata contains crucial information like the current balances of both tokens, the total supply of LP tokens, and other pool-specific data.
		Balance Retrieval:
		Balance Retrieval:
		Next, we retrieve the current balances of both tokens in the pool. This is necessary to calculate how much of each token the user should receive when removing liquidity.
		Next, we retrieve the current balances of both tokens in the pool. This is necessary to calculate how much of each token the user should receive when removing liquidity.
		We use
coin::value
to safely read the balance of each token in the pool.
This function returns the numerical value of the coin, which we can use in our calculations.
Getting accurate balances is crucial for maintaining the correct proportions when removing liquidity.
		We use
coin::value
to safely read the balance of each token in the pool.
		We use
		<code>coin::value</code>
		coin::value
		to safely read the balance of each token in the pool.
		This function returns the numerical value of the coin, which we can use in our calculations.
		This function returns the numerical value of the coin, which we can use in our calculations.
		Getting accurate balances is crucial for maintaining the correct proportions when removing liquidity.
		Getting accurate balances is crucial for maintaining the correct proportions when removing liquidity.
		Fee Processing:
		Fee Processing:
		Before we calculate the amounts of tokens to return to the user, we need to process any accrued fees. This is an important step in maintaining the economic model of the DEX.
		Before we calculate the amounts of tokens to return to the user, we need to process any accrued fees. This is an important step in maintaining the economic model of the DEX.
		<code>let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);</code>
		<code>let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);</code>
		let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
		This line calls a function to calculate and mint the fees. Let's break down how this works:
		This line calls a function to calculate and mint the fees. Let's break down how this works:
		Fee Calculation Formula:
		Fee Calculation Formula:
		<code>let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
let root_k_last = math128::sqrt(metadata.k_last);
if root_k > root_k_last {
    let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
    let denominator = root_k_last * 17u128 + root_k * 8u128;
    let liquidity = numerator / denominator;
    fee = liquidity as u64;
};
}</code>
		<code>let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
let root_k_last = math128::sqrt(metadata.k_last);
if root_k > root_k_last {
    let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
    let denominator = root_k_last * 17u128 + root_k * 8u128;
    let liquidity = numerator / denominator;
    fee = liquidity as u64;
};
}</code>
		let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
let root_k_last = math128::sqrt(metadata.k_last);
if root_k > root_k_last {
    let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
    let denominator = root_k_last * 17u128 + root_k * 8u128;
    let liquidity = numerator / denominator;
    fee = liquidity as u64;
};
}
		This might look complicated, but let's break it down step by step:
		This might look complicated, but let's break it down step by step:
		Understanding the Fee Calculation:
		Understanding the Fee Calculation:
		Calculating root_k:
We calculate the square root of the product of current reserves (reserve_x * reserve_y)
This represents the current "size" of the pool
Retrieving root_k_last:
This is the square root of the last recorded k value
It represents the pool size from the last operation
Comparing root_k and root_k_last:
If root_k > root_k_last, it means the pool has grown
This growth is what we use to calculate fees
Fee calculation:
We use a complex formula to ensure fair fee distribution
The numerator considers total supply and pool growth
The denominator includes factors to balance the fee
The result is a fair amount of new LP tokens to mint as fees
		Calculating root_k:
We calculate the square root of the product of current reserves (reserve_x * reserve_y)
This represents the current "size" of the pool
		Calculating root_k:
		We calculate the square root of the product of current reserves (reserve_x * reserve_y)
This represents the current "size" of the pool
		We calculate the square root of the product of current reserves (reserve_x * reserve_y)
		We calculate the square root of the product of current reserves (reserve_x * reserve_y)
		This represents the current "size" of the pool
		This represents the current "size" of the pool
		Retrieving root_k_last:
This is the square root of the last recorded k value
It represents the pool size from the last operation
		Retrieving root_k_last:
		This is the square root of the last recorded k value
It represents the pool size from the last operation
		This is the square root of the last recorded k value
		This is the square root of the last recorded k value
		It represents the pool size from the last operation
		It represents the pool size from the last operation
		Comparing root_k and root_k_last:
If root_k > root_k_last, it means the pool has grown
This growth is what we use to calculate fees
		Comparing root_k and root_k_last:
		If root_k > root_k_last, it means the pool has grown
This growth is what we use to calculate fees
		If root_k > root_k_last, it means the pool has grown
		If root_k > root_k_last, it means the pool has grown
		This growth is what we use to calculate fees
		This growth is what we use to calculate fees
		Fee calculation:
We use a complex formula to ensure fair fee distribution
The numerator considers total supply and pool growth
The denominator includes factors to balance the fee
The result is a fair amount of new LP tokens to mint as fees
		Fee calculation:
		We use a complex formula to ensure fair fee distribution
The numerator considers total supply and pool growth
The denominator includes factors to balance the fee
The result is a fair amount of new LP tokens to mint as fees
		We use a complex formula to ensure fair fee distribution
		We use a complex formula to ensure fair fee distribution
		The numerator considers total supply and pool growth
		The numerator considers total supply and pool growth
		The denominator includes factors to balance the fee
		The denominator includes factors to balance the fee
		The result is a fair amount of new LP tokens to mint as fees
		The result is a fair amount of new LP tokens to mint as fees
		This fee calculation ensures that the protocol can sustain itself while providing fair returns to liquidity providers.
		This fee calculation ensures that the protocol can sustain itself while providing fair returns to liquidity providers.
		Amount Calculations:
		Amount Calculations:
		<code>let total_lp_supply = total_lp_supply<X, Y>();
let amount_x = ((balance_x as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
let amount_y = ((balance_y as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);</code>
		<code>let total_lp_supply = total_lp_supply<X, Y>();
let amount_x = ((balance_x as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
let amount_y = ((balance_y as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);</code>
		let total_lp_supply = total_lp_supply<X, Y>();
let amount_x = ((balance_x as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
let amount_y = ((balance_y as u128) * (liquidity as u128) /
               (total_lp_supply as u128) as u64);
		Understanding the Amount Calculations:
		Understanding the Amount Calculations:
		Now that we've processed fees, we need to calculate how many tokens the user will receive when removing liquidity. The formula is straightforward but crucial:
		Now that we've processed fees, we need to calculate how many tokens the user will receive when removing liquidity. The formula is straightforward but crucial:
		<code>amount_token = (current_balance * lp_amount_to_burn) / total_lp_supply</code>
		<code>amount_token = (current_balance * lp_amount_to_burn) / total_lp_supply</code>
		amount_token = (current_balance * lp_amount_to_burn) / total_lp_supply
		Let's break this down:
		Let's break this down:
		Proportion calculation:
We calculate based on the user's share of LP tokens
This ensures fairness - you get back proportional to what you put in
It automatically includes any fees or gains the pool has accumulated
Precision handling:
We cast to u128 (a larger integer type) for the calculation
This prevents potential overflow errors with large numbers
It also maintains accuracy in the division operation
		Proportion calculation:
We calculate based on the user's share of LP tokens
This ensures fairness - you get back proportional to what you put in
It automatically includes any fees or gains the pool has accumulated
		Proportion calculation:
		We calculate based on the user's share of LP tokens
This ensures fairness - you get back proportional to what you put in
It automatically includes any fees or gains the pool has accumulated
		We calculate based on the user's share of LP tokens
		We calculate based on the user's share of LP tokens
		This ensures fairness - you get back proportional to what you put in
		This ensures fairness - you get back proportional to what you put in
		It automatically includes any fees or gains the pool has accumulated
		It automatically includes any fees or gains the pool has accumulated
		Precision handling:
We cast to u128 (a larger integer type) for the calculation
This prevents potential overflow errors with large numbers
It also maintains accuracy in the division operation
		Precision handling:
		We cast to u128 (a larger integer type) for the calculation
This prevents potential overflow errors with large numbers
It also maintains accuracy in the division operation
		We cast to u128 (a larger integer type) for the calculation
		We cast to u128 (a larger integer type) for the calculation
		This prevents potential overflow errors with large numbers
		This prevents potential overflow errors with large numbers
		It also maintains accuracy in the division operation
		It also maintains accuracy in the division operation
		Here's a simple example to illustrate:
		Here's a simple example to illustrate:
		<code>If:
- Pool has 1000 X, 2000 Y
- Total LP supply is 1000
- User burns 100 LP tokens (10%)
Then:
- amount_x = 1000 * 100 / 1000 = 100 X
- amount_y = 2000 * 100 / 1000 = 200 Y</code>
		<code>If:
- Pool has 1000 X, 2000 Y
- Total LP supply is 1000
- User burns 100 LP tokens (10%)
Then:
- amount_x = 1000 * 100 / 1000 = 100 X
- amount_y = 2000 * 100 / 1000 = 200 Y</code>
		If:
- Pool has 1000 X, 2000 Y
- Total LP supply is 1000
- User burns 100 LP tokens (10%)
Then:
- amount_x = 1000 * 100 / 1000 = 100 X
- amount_y = 2000 * 100 / 1000 = 200 Y
		In this example, the user would receive 100 X tokens and 200 Y tokens for their 10% share of the pool.
		In this example, the user would receive 100 X tokens and 200 Y tokens for their 10% share of the pool.
		Validation and Execution:
		Validation and Execution:
		<code>assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);</code>
		<code>assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);</code>
		assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
		After calculating the amounts, we perform some crucial steps:
		After calculating the amounts, we perform some crucial steps:
		Safety Checks:
We ensure that both amount_x and amount_y are greater than zero
This prevents "dust" withdrawals that could potentially harm the pool
If either amount is zero, we throw an error
LP Token Burning:
We use the burn capability to destroy the LP tokens
This reduces the total supply of LP tokens
It's an irreversible operation, ensuring the integrity of the pool
		Safety Checks:
We ensure that both amount_x and amount_y are greater than zero
This prevents "dust" withdrawals that could potentially harm the pool
If either amount is zero, we throw an error
		Safety Checks:
		We ensure that both amount_x and amount_y are greater than zero
This prevents "dust" withdrawals that could potentially harm the pool
If either amount is zero, we throw an error
		We ensure that both amount_x and amount_y are greater than zero
		We ensure that both amount_x and amount_y are greater than zero
		This prevents "dust" withdrawals that could potentially harm the pool
		This prevents "dust" withdrawals that could potentially harm the pool
		If either amount is zero, we throw an error
		If either amount is zero, we throw an error
		LP Token Burning:
We use the burn capability to destroy the LP tokens
This reduces the total supply of LP tokens
It's an irreversible operation, ensuring the integrity of the pool
		LP Token Burning:
		We use the burn capability to destroy the LP tokens
This reduces the total supply of LP tokens
It's an irreversible operation, ensuring the integrity of the pool
		We use the burn capability to destroy the LP tokens
		We use the burn capability to destroy the LP tokens
		This reduces the total supply of LP tokens
		This reduces the total supply of LP tokens
		It's an irreversible operation, ensuring the integrity of the pool
		It's an irreversible operation, ensuring the integrity of the pool
		Token Extraction:
		Token Extraction:
		<code>let w_x = extract_x((amount_x as u64), metadata);
let w_y = extract_y((amount_y as u64), metadata);</code>
		<code>let w_x = extract_x((amount_x as u64), metadata);
let w_y = extract_y((amount_y as u64), metadata);</code>
		let w_x = extract_x((amount_x as u64), metadata);
let w_y = extract_y((amount_y as u64), metadata);
		Now we actually extract the tokens to return to the user:
		Now we actually extract the tokens to return to the user:
		Safety check:
assert!(coin::value&lt;X&gt;(&metadata.balance_x) > amount,
       ERROR_INSUFFICIENT_AMOUNT);
This verifies that the pool has enough tokens to fulfill the withdrawal
It prevents potential underflow errors
It's a double-check to ensure our previous calculations were correct
Actual extraction:
coin::extract(&mut metadata.balance_x, amount)
This removes the calculated amount of tokens from the pool
It creates a new Coin object with these tokens
This Coin object will be returned to the user
		Safety check:
assert!(coin::value&lt;X&gt;(&metadata.balance_x) > amount,
       ERROR_INSUFFICIENT_AMOUNT);
This verifies that the pool has enough tokens to fulfill the withdrawal
It prevents potential underflow errors
It's a double-check to ensure our previous calculations were correct
		Safety check:
		Safety check:
		<code>assert!(coin::value&lt;X&gt;(&metadata.balance_x) > amount,
       ERROR_INSUFFICIENT_AMOUNT);</code>
		<code>assert!(coin::value&lt;X&gt;(&metadata.balance_x) > amount,
       ERROR_INSUFFICIENT_AMOUNT);</code>
		assert!(coin::value&lt;X&gt;(&metadata.balance_x) > amount,
       ERROR_INSUFFICIENT_AMOUNT);
		This verifies that the pool has enough tokens to fulfill the withdrawal
It prevents potential underflow errors
It's a double-check to ensure our previous calculations were correct
		This verifies that the pool has enough tokens to fulfill the withdrawal
		This verifies that the pool has enough tokens to fulfill the withdrawal
		It prevents potential underflow errors
		It prevents potential underflow errors
		It's a double-check to ensure our previous calculations were correct
		It's a double-check to ensure our previous calculations were correct
		Actual extraction:
coin::extract(&mut metadata.balance_x, amount)
This removes the calculated amount of tokens from the pool
It creates a new Coin object with these tokens
This Coin object will be returned to the user
		Actual extraction:
		Actual extraction:
		<code>coin::extract(&mut metadata.balance_x, amount)</code>
		<code>coin::extract(&mut metadata.balance_x, amount)</code>
		coin::extract(&mut metadata.balance_x, amount)
		This removes the calculated amount of tokens from the pool
It creates a new Coin object with these tokens
This Coin object will be returned to the user
		This removes the calculated amount of tokens from the pool
		This removes the calculated amount of tokens from the pool
		It creates a new Coin object with these tokens
		It creates a new Coin object with these tokens
		This Coin object will be returned to the user
		This Coin object will be returned to the user
		State Updates:
		State Updates:
		<code>update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);</code>
		<code>update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);</code>
		update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
		Finally, we need to update the state of our pool:
		Finally, we need to update the state of our pool:
		Reserve updates:
We update the current reserves with the new balances
This typically includes recording a timestamp for the update
It's crucial for maintaining an accurate state of the pool
K value update:
We calculate the new k value (product of reserves)
This is stored for the next operation
It's used in future fee calculations to detect pool growth
		Reserve updates:
We update the current reserves with the new balances
This typically includes recording a timestamp for the update
It's crucial for maintaining an accurate state of the pool
		Reserve updates:
		We update the current reserves with the new balances
This typically includes recording a timestamp for the update
It's crucial for maintaining an accurate state of the pool
		We update the current reserves with the new balances
		We update the current reserves with the new balances
		This typically includes recording a timestamp for the update
		This typically includes recording a timestamp for the update
		It's crucial for maintaining an accurate state of the pool
		It's crucial for maintaining an accurate state of the pool
		K value update:
We calculate the new k value (product of reserves)
This is stored for the next operation
It's used in future fee calculations to detect pool growth
		K value update:
		We calculate the new k value (product of reserves)
This is stored for the next operation
It's used in future fee calculations to detect pool growth
		We calculate the new k value (product of reserves)
		We calculate the new k value (product of reserves)
		This is stored for the next operation
		This is stored for the next operation
		It's used in future fee calculations to detect pool growth
		It's used in future fee calculations to detect pool growth
		By following these steps, we ensure that liquidity removal is handled accurately, fairly, and safely in our DEX. Each step plays a crucial role in maintaining the integrity and efficiency of the system.
		By following these steps, we ensure that liquidity removal is handled accurately, fairly, and safely in our DEX. Each step plays a crucial role in maintaining the integrity and efficiency of the system.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/02-swap/06-swapping-token
Swapping Token
Swapping Token
On This Page
Key Points:
Introduction
1. Public Interface: swap_exact_x_to_y
Function Name and Generics
Parameter Analysis:
Return Value
Acquire Clause
Implementation Details:
Step 1: Withdraw Tokens
Step 2: Execute Swap
Step 3: Prepare Deposit
Step 4: Complete Transfer
2. Direct Swap Implementation
Core Logic:
Step 1: Get Input Amount
Step 2: Deposit to Pool
Step 3: Get Reserves
Step 4: Calculate Output
AMM Formula Details:
Execute Swap:
3. Core Swap Implementation
Initial Validation
Token Handling
K Value Protection
Price Impact Check
Final Verification
Key Points:
This document provides a comprehensive explanation of token swapping in decentralized exchanges, focusing on the implementation of the swap_exact_x_to_y function. Key points covered include:
The public interface and parameters of the swap function
Step-by-step breakdown of the swap implementation
Detailed explanation of the AMM (Automated Market Maker) formula
Core swap logic including liquidity checks and token handling
K value protection and price impact considerations
Final verification to ensure the constant product formula is maintained
This guide is essential for developers looking to understand or implement token swapping mechanisms in DeFi applications.
Introduction
Swapping is a fundamental feature of decentralized exchanges (DEXs), allowing users to trade one token for another. In this tutorial, we'll dive deep into the implementation of a common swap type: swap_exact_x_to_y. This function enables users to exchange a specific amount of token X for token Y, with the output amount determined by an Automated Market Maker (AMM) formula.
1. Public Interface: swap_exact_x_to_y
public fun swap_exact_x_to_y<X, Y>(
    sender: &signer,
    amount_in: u64,
    to: address
): u64 acquires TokenPairReserve, TokenPairMetadata
Let's break down this function signature to understand what each part means:
Function Name and Generics
swap_exact_x_to_y
: This name clearly indicates the function's purpose - swapping an exact amount of token X for token Y.
<X, Y>
: These are generic type parameters. They allow the function to work with any two token types, making it flexible and reusable.
Parameter Analysis:
sender: &signer
This is a reference to the signer object, representing the user initiating the swap.
The signer is crucial for several reasons:
It allows the function to withdraw tokens from the user's account.
It's used to verify that the user has the necessary permissions.
It enables the function to register coin stores if they don't exist yet.
amount_in: u64
This parameter specifies the exact amount of token X the user wants to swap.
It must be greater than 0 to perform a valid swap.
This amount is used in calculations to determine how much of token Y the user will receive.
The size of amount_in affects the price impact of the swap on the liquidity pool.
to: address
This is the address that will receive the output token Y.
Interestingly, this can be different from the sender's address.
This flexibility allows for direct transfers to other addresses.
It's particularly useful when interacting with more complex smart contracts or routers.
Return Value
The function returns a u64, which represents the amount of token Y that was output from the swap. This allows the caller to know exactly how many tokens were received.
Acquire Clause
The
acquires TokenPairReserve, TokenPairMetadata
clause indicates that this function will access global storage to read or modify these resources. This is important for managing the liquidity pool and swap calculations.
Implementation Details:
Now, let's walk through the implementation step-by-step:
Step 1: Withdraw Tokens
let coins = coin::withdraw<X>(sender, amount_in);
This line does several important things:
It calls the withdraw function from the coin module, specifying token X as the type.
It takes tokens directly from the sender's account.
The exact amount_in is withdrawn.
If the sender doesn't have enough balance, this operation will fail.
The result is a new Coin object containing the withdrawn tokens.
Step 2: Execute Swap
let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
This line is where the actual swap logic happens:
It calls an internal function swap_exact_x_to_y_direct.
The coins object (containing token X) is passed to this function.
The function returns two Coin objects: coins_x_out and coins_y_out.
coins_x_out will typically be empty (zero value) in this case.
coins_y_out contains the tokens that resulted from the swap.
Step 3: Prepare Deposit
let amount_out = coin::value(&coins_y_out);
check_or_register_coin_store<Y>(sender);
These lines prepare for the final transfer:
The value of coins_y_out is extracted. This is how many tokens of Y were swapped for.
The check_or_register_coin_store function ensures that the recipient can receive token Y.
If the recipient doesn't have a coin store for token Y, one is automatically created.
Step 4: Complete Transfer
coin::destroy_zero(coins_x_out);
coin::deposit(to, coins_y_out);
The final steps of the swap:
coins_x_out is destroyed. This should be empty, as all X tokens were swapped.
The resulting Y tokens (coins_y_out) are deposited to the specified 'to' address.
The function implicitly returns amount_out, telling the caller how many Y tokens were received.
2. Direct Swap Implementation
Now, let's dive deeper into the core of our swap function:
swap_exact_x_to_y_direct
. This function is where the magic happens - it's responsible for executing the actual token swap.
public fun swap_exact_x_to_y_direct<X, Y>(
    coins_in: coin::Coin<X>
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata
Let's break down this function signature:
It's a public function, meaning it can be called from outside the
module.It
uses generic typesand, allowing it to work with any pair of
tokens.It
takes a Coin as input (the tokens we're swapping).It returns two Coin objects: Coin(any leftover input) and Coin(the swapped tokens).
The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
Core Logic:
Now, let's walk through the function step-by-step:
Step 1: Get Input Amount
let amount_in = coin::value<X>(&coins_in);
This line retrieves the exact amount of tokens X that the user is swapping. It's crucial because:
It tells us how many tokens we're working with.
We need this value for our swap calculations later.
It's a read-only operation, so it doesn't modify the coins_in object.
Step 2: Deposit to Pool
deposit_x<X, Y>(coins_in);
This step is where we actually add the input tokens to the liquidity pool:
The deposit_x function (not shown here) handles the mechanics of adding tokens to the pool.
After this step, the pool's balance of token X has increased by amount_in.
This is a critical step because it's where the user's tokens are actually transferred to the pool.
Step 3: Get Reserves
let (rin, rout, _) = token_reserves<X, Y>();
Here, we're fetching the current state of the liquidity pool:
rin represents the reserve of the input token (X in this case).
rout represents the reserve of the output token (Y in this case).
The underscore (_) suggests there's a third value returned that we're not using here.
These reserve values are crucial for calculating the swap output.
Step 4: Calculate Output
let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
This is where we determine how many Y tokens the user will receive:
We use a utility function get_amount_out to perform the calculation.
It takes into account the input amount and the current reserves of both tokens.
The calculation ensures that the pool maintains its balance according to the AMM formula.
AMM Formula Details:
Let's take a closer look at the get_amount_out function:
// In swap_utils
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 997u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 1000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
This function is the heart of our AMM. Let's break it down:
First, we have two assert statements:
They ensure that we have a valid input amount and that there's sufficient liquidity in the pool.
If these conditions aren't met, the function will abort with an error.
Next, we calculate the input amount with the fee applied:
We multiply the input by 997, which is equivalent to applying a 0.3% fee (3/1000).
This fee goes to the liquidity providers as an incentive.
The core of the calculation is based on the constant product formula:
This formula ensures that the product of the two token reserves remains constant before and after the swap.
It's designed to provide a fair price and maintain pool stability.
Finally, we return the calculated output amount:
We cast the result back to u64, which may involve some rounding.
This is the amount of Y tokens the user will receive.
Let's look at a concrete example to better understand this calculation:
Given:
- amount_in = 100
- reserve_in = 1000
- reserve_out = 2000
Calculation:
1. amount_in_with_fee = 100 * 997 = 99,700
2. numerator = 99,700 * 2000 = 199,400,000
3. denominator = 1000 * 1000 + 99,700 = 1,099,700
4. amount_out = 199,400,000 / 1,099,700 ≈ 181
In this example, if a user wants to swap 100 of token X, they would receive approximately 181 of token Y.
Execute Swap:
After calculating the output amount, we execute the actual swap:
let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
This line calls an internal swap function:
We pass 0 for the X output because we're swapping all of X for Y.
We pass our calculated amount_out for the Y output.
The function returns two Coin objects, representing the results of the swap.
Finally, we have a safety check:
assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
This assertion ensures that:
We've swapped all of the input X tokens.
There are no leftover X tokens from the swap.
If this condition isn't met, it indicates an error in our calculations or swap execution.
3. Core Swap Implementation
Now, let's dive deep into the core swap implementation. This is where the actual token exchange happens, and it's crucial to understand each step for anyone new to DeFi development.
fun swap&lt;X, Y&gt;(
    amount_x_out: u64,
    amount_y_out: u64
): (coin::Coin&lt;X&gt;, coin::Coin&lt;Y&gt;) acquires TokenPairReserve, TokenPairMetadata
This function is the heart of our swap mechanism. Let's break it down:
It's generic over two types, X and Y, representing our token pair.
It takes two parameters: amount_x_out and amount_y_out, which are the amounts of tokens X and Y to be swapped out.
It returns two Coin objects, representing the swapped tokens.
The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
Initial Validation
assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
This line is our first safety check:
It ensures that we're actually swapping something. At least one of the output amounts must be greater than zero.
If both outputs are zero, it would mean we're not swapping anything, which doesn't make sense in a swap operation.
The assert! macro will cause the transaction to revert if this condition isn't met, protecting against empty or invalid swaps.
let reserves = borrow_global_mut<<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
assert!(
    amount_x_out < reserves.reserve_x &&
    amount_y_out < reserves.reserve_y,
    ERROR_INSUFFICIENT_LIQUIDITY
);
This block performs a crucial liquidity check:
We first borrow the global TokenPairReserve resource, which holds the current reserves of both tokens.
Then, we check if the requested output amounts are less than the available reserves for each token.
This prevents a swap from draining the entire liquidity pool, which could destabilize the market.
If there's not enough liquidity, the transaction will revert with an
ERROR_INSUFFICIENT_LIQUIDITY
error.
Token Handling
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let coins_x_out = coin::zero<X>();
let coins_y_out = coin::zero<Y>();
if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
This section handles the actual token extraction:
We start by borrowing the TokenPairMetadata, which contains additional information about the token pair.
We initialize two empty Coin objects, one for each token type.
Then, we check if we need to extract any of token X or Y (remember, one of them might be zero in a single-sided swap).
If we need to extract tokens, we use the extract_x or extract_y functions (not shown here) to take tokens from the pool.
The extracted tokens are then merged into our initially empty Coin objects.
K Value Protection
let (balance_x, balance_y) = token_balances<X, Y>();
let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
    balance_x - (reserves.reserve_x - amount_x_out)
} else { 0 };
let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
    balance_y - (reserves.reserve_y - amount_y_out)
} else { 0 };
This part is crucial for maintaining the constant product formula (x * y = k):
We first get the current balances of both tokens in the pool.
Then, we calculate the actual amounts of tokens that were input into the swap.
This calculation accounts for the possibility of a bidirectional swap, where both tokens might be both input and output.
If the current balance is higher than what it should be after output (reserves minus output), we know some tokens were input.
This step is essential for accurately updating the pool state after the swap.
Price Impact Check
let prec = (PRECISION as u128);
let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
This section prepares for the final K value check:
We use a precision factor (PRECISION) to avoid dealing with fractional numbers.
We calculate adjusted balances by subtracting a portion of the input amounts. This accounts for the swap fee (0.25% in this case, as 25/10000 = 0.0025).
We also adjust the reserves using the same precision factor.
These adjustments allow us to perform accurate comparisons in the next step.
Final Verification
let compare_result = if (balance_x_adjusted > 0 && reserve_x_adjusted > 0 &&
    MAX_U128 / balance_x_adjusted > balance_y_adjusted &&
    MAX_U128 / reserve_x_adjusted > reserve_y_adjusted) {
    balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
} else {
    let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
    let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
    p >= k
};
assert!(compare_result, ERROR_K);
This final check ensures that the constant product formula is maintained:
We first check if we can safely multiply the adjusted balances without overflow.
If it's safe, we directly compare the product of adjusted balances with the product of adjusted reserves.
If there's a risk of overflow, we use larger u256 integers to perform the comparison.
The key here is that the new product (p) should be greater than or equal to the old product (k).
If this condition isn't met, it means the swap would adversely affect the pool's balance, and the transaction is reverted.
Next, we'll explore the implementation of other swap types: swap_x_to_exact_y, swap_exact_y_to_x, and swap_y_to_exact_x.
On This Page
Key Points:
Introduction
1. Public Interface: swap_exact_x_to_y
Function Name and Generics
Parameter Analysis:
Return Value
Acquire Clause
Implementation Details:
Step 1: Withdraw Tokens
Step 2: Execute Swap
Step 3: Prepare Deposit
Step 4: Complete Transfer
2. Direct Swap Implementation
Core Logic:
Step 1: Get Input Amount
Step 2: Deposit to Pool
Step 3: Get Reserves
Step 4: Calculate Output
AMM Formula Details:
Execute Swap:
3. Core Swap Implementation
Initial Validation
Token Handling
K Value Protection
Price Impact Check
Final Verification
On This Page
Key Points:
Introduction
1. Public Interface: swap_exact_x_to_y
Function Name and Generics
Parameter Analysis:
Return Value
Acquire Clause
Implementation Details:
Step 1: Withdraw Tokens
Step 2: Execute Swap
Step 3: Prepare Deposit
Step 4: Complete Transfer
2. Direct Swap Implementation
Core Logic:
Step 1: Get Input Amount
Step 2: Deposit to Pool
Step 3: Get Reserves
Step 4: Calculate Output
AMM Formula Details:
Execute Swap:
3. Core Swap Implementation
Initial Validation
Token Handling
K Value Protection
Price Impact Check
Final Verification
			On This Page
			On This Page
			Key Points:
Introduction
1. Public Interface: swap_exact_x_to_y
Function Name and Generics
Parameter Analysis:
Return Value
Acquire Clause
Implementation Details:
Step 1: Withdraw Tokens
Step 2: Execute Swap
Step 3: Prepare Deposit
Step 4: Complete Transfer
2. Direct Swap Implementation
Core Logic:
Step 1: Get Input Amount
Step 2: Deposit to Pool
Step 3: Get Reserves
Step 4: Calculate Output
AMM Formula Details:
Execute Swap:
3. Core Swap Implementation
Initial Validation
Token Handling
K Value Protection
Price Impact Check
Final Verification
			Key Points:
			Key Points:
			Key Points:
			Key Points:
			Introduction
			Introduction
			Introduction
			Introduction
			1. Public Interface: swap_exact_x_to_y
Function Name and Generics
Parameter Analysis:
Return Value
Acquire Clause
Implementation Details:
Step 1: Withdraw Tokens
Step 2: Execute Swap
Step 3: Prepare Deposit
Step 4: Complete Transfer
			1. Public Interface: swap_exact_x_to_y
			1. Public Interface: swap_exact_x_to_y
			1. Public Interface: swap_exact_x_to_y
			Function Name and Generics
Parameter Analysis:
Return Value
Acquire Clause
Implementation Details:
Step 1: Withdraw Tokens
Step 2: Execute Swap
Step 3: Prepare Deposit
Step 4: Complete Transfer
			Function Name and Generics
			Function Name and Generics
			Function Name and Generics
			Function Name and Generics
			Parameter Analysis:
			Parameter Analysis:
			Parameter Analysis:
			Parameter Analysis:
			Return Value
			Return Value
			Return Value
			Return Value
			Acquire Clause
			Acquire Clause
			Acquire Clause
			Acquire Clause
			Implementation Details:
			Implementation Details:
			Implementation Details:
			Implementation Details:
			Step 1: Withdraw Tokens
			Step 1: Withdraw Tokens
			Step 1: Withdraw Tokens
			Step 1: Withdraw Tokens
			Step 2: Execute Swap
			Step 2: Execute Swap
			Step 2: Execute Swap
			Step 2: Execute Swap
			Step 3: Prepare Deposit
			Step 3: Prepare Deposit
			Step 3: Prepare Deposit
			Step 3: Prepare Deposit
			Step 4: Complete Transfer
			Step 4: Complete Transfer
			Step 4: Complete Transfer
			Step 4: Complete Transfer
			2. Direct Swap Implementation
Core Logic:
Step 1: Get Input Amount
Step 2: Deposit to Pool
Step 3: Get Reserves
Step 4: Calculate Output
AMM Formula Details:
Execute Swap:
			2. Direct Swap Implementation
			2. Direct Swap Implementation
			2. Direct Swap Implementation
			Core Logic:
Step 1: Get Input Amount
Step 2: Deposit to Pool
Step 3: Get Reserves
Step 4: Calculate Output
AMM Formula Details:
Execute Swap:
			Core Logic:
			Core Logic:
			Core Logic:
			Core Logic:
			Step 1: Get Input Amount
			Step 1: Get Input Amount
			Step 1: Get Input Amount
			Step 1: Get Input Amount
			Step 2: Deposit to Pool
			Step 2: Deposit to Pool
			Step 2: Deposit to Pool
			Step 2: Deposit to Pool
			Step 3: Get Reserves
			Step 3: Get Reserves
			Step 3: Get Reserves
			Step 3: Get Reserves
			Step 4: Calculate Output
			Step 4: Calculate Output
			Step 4: Calculate Output
			Step 4: Calculate Output
			AMM Formula Details:
			AMM Formula Details:
			AMM Formula Details:
			AMM Formula Details:
			Execute Swap:
			Execute Swap:
			Execute Swap:
			Execute Swap:
			3. Core Swap Implementation
Initial Validation
Token Handling
K Value Protection
Price Impact Check
Final Verification
			3. Core Swap Implementation
			3. Core Swap Implementation
			3. Core Swap Implementation
			Initial Validation
Token Handling
K Value Protection
Price Impact Check
Final Verification
			Initial Validation
			Initial Validation
			Initial Validation
			Initial Validation
			Token Handling
			Token Handling
			Token Handling
			Token Handling
			K Value Protection
			K Value Protection
			K Value Protection
			K Value Protection
			Price Impact Check
			Price Impact Check
			Price Impact Check
			Price Impact Check
			Final Verification
			Final Verification
			Final Verification
			Final Verification
			Key Points:
This document provides a comprehensive explanation of token swapping in decentralized exchanges, focusing on the implementation of the swap_exact_x_to_y function. Key points covered include:
The public interface and parameters of the swap function
Step-by-step breakdown of the swap implementation
Detailed explanation of the AMM (Automated Market Maker) formula
Core swap logic including liquidity checks and token handling
K value protection and price impact considerations
Final verification to ensure the constant product formula is maintained
This guide is essential for developers looking to understand or implement token swapping mechanisms in DeFi applications.
Introduction
Swapping is a fundamental feature of decentralized exchanges (DEXs), allowing users to trade one token for another. In this tutorial, we'll dive deep into the implementation of a common swap type: swap_exact_x_to_y. This function enables users to exchange a specific amount of token X for token Y, with the output amount determined by an Automated Market Maker (AMM) formula.
1. Public Interface: swap_exact_x_to_y
public fun swap_exact_x_to_y<X, Y>(
    sender: &signer,
    amount_in: u64,
    to: address
): u64 acquires TokenPairReserve, TokenPairMetadata
Let's break down this function signature to understand what each part means:
Function Name and Generics
swap_exact_x_to_y
: This name clearly indicates the function's purpose - swapping an exact amount of token X for token Y.
<X, Y>
: These are generic type parameters. They allow the function to work with any two token types, making it flexible and reusable.
Parameter Analysis:
sender: &signer
This is a reference to the signer object, representing the user initiating the swap.
The signer is crucial for several reasons:
It allows the function to withdraw tokens from the user's account.
It's used to verify that the user has the necessary permissions.
It enables the function to register coin stores if they don't exist yet.
amount_in: u64
This parameter specifies the exact amount of token X the user wants to swap.
It must be greater than 0 to perform a valid swap.
This amount is used in calculations to determine how much of token Y the user will receive.
The size of amount_in affects the price impact of the swap on the liquidity pool.
to: address
This is the address that will receive the output token Y.
Interestingly, this can be different from the sender's address.
This flexibility allows for direct transfers to other addresses.
It's particularly useful when interacting with more complex smart contracts or routers.
Return Value
The function returns a u64, which represents the amount of token Y that was output from the swap. This allows the caller to know exactly how many tokens were received.
Acquire Clause
The
acquires TokenPairReserve, TokenPairMetadata
clause indicates that this function will access global storage to read or modify these resources. This is important for managing the liquidity pool and swap calculations.
Implementation Details:
Now, let's walk through the implementation step-by-step:
Step 1: Withdraw Tokens
let coins = coin::withdraw<X>(sender, amount_in);
This line does several important things:
It calls the withdraw function from the coin module, specifying token X as the type.
It takes tokens directly from the sender's account.
The exact amount_in is withdrawn.
If the sender doesn't have enough balance, this operation will fail.
The result is a new Coin object containing the withdrawn tokens.
Step 2: Execute Swap
let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
This line is where the actual swap logic happens:
It calls an internal function swap_exact_x_to_y_direct.
The coins object (containing token X) is passed to this function.
The function returns two Coin objects: coins_x_out and coins_y_out.
coins_x_out will typically be empty (zero value) in this case.
coins_y_out contains the tokens that resulted from the swap.
Step 3: Prepare Deposit
let amount_out = coin::value(&coins_y_out);
check_or_register_coin_store<Y>(sender);
These lines prepare for the final transfer:
The value of coins_y_out is extracted. This is how many tokens of Y were swapped for.
The check_or_register_coin_store function ensures that the recipient can receive token Y.
If the recipient doesn't have a coin store for token Y, one is automatically created.
Step 4: Complete Transfer
coin::destroy_zero(coins_x_out);
coin::deposit(to, coins_y_out);
The final steps of the swap:
coins_x_out is destroyed. This should be empty, as all X tokens were swapped.
The resulting Y tokens (coins_y_out) are deposited to the specified 'to' address.
The function implicitly returns amount_out, telling the caller how many Y tokens were received.
2. Direct Swap Implementation
Now, let's dive deeper into the core of our swap function:
swap_exact_x_to_y_direct
. This function is where the magic happens - it's responsible for executing the actual token swap.
public fun swap_exact_x_to_y_direct<X, Y>(
    coins_in: coin::Coin<X>
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata
Let's break down this function signature:
It's a public function, meaning it can be called from outside the
module.It
uses generic typesand, allowing it to work with any pair of
tokens.It
takes a Coin as input (the tokens we're swapping).It returns two Coin objects: Coin(any leftover input) and Coin(the swapped tokens).
The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
Core Logic:
Now, let's walk through the function step-by-step:
Step 1: Get Input Amount
let amount_in = coin::value<X>(&coins_in);
This line retrieves the exact amount of tokens X that the user is swapping. It's crucial because:
It tells us how many tokens we're working with.
We need this value for our swap calculations later.
It's a read-only operation, so it doesn't modify the coins_in object.
Step 2: Deposit to Pool
deposit_x<X, Y>(coins_in);
This step is where we actually add the input tokens to the liquidity pool:
The deposit_x function (not shown here) handles the mechanics of adding tokens to the pool.
After this step, the pool's balance of token X has increased by amount_in.
This is a critical step because it's where the user's tokens are actually transferred to the pool.
Step 3: Get Reserves
let (rin, rout, _) = token_reserves<X, Y>();
Here, we're fetching the current state of the liquidity pool:
rin represents the reserve of the input token (X in this case).
rout represents the reserve of the output token (Y in this case).
The underscore (_) suggests there's a third value returned that we're not using here.
These reserve values are crucial for calculating the swap output.
Step 4: Calculate Output
let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
This is where we determine how many Y tokens the user will receive:
We use a utility function get_amount_out to perform the calculation.
It takes into account the input amount and the current reserves of both tokens.
The calculation ensures that the pool maintains its balance according to the AMM formula.
AMM Formula Details:
Let's take a closer look at the get_amount_out function:
// In swap_utils
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 997u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 1000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
This function is the heart of our AMM. Let's break it down:
First, we have two assert statements:
They ensure that we have a valid input amount and that there's sufficient liquidity in the pool.
If these conditions aren't met, the function will abort with an error.
Next, we calculate the input amount with the fee applied:
We multiply the input by 997, which is equivalent to applying a 0.3% fee (3/1000).
This fee goes to the liquidity providers as an incentive.
The core of the calculation is based on the constant product formula:
This formula ensures that the product of the two token reserves remains constant before and after the swap.
It's designed to provide a fair price and maintain pool stability.
Finally, we return the calculated output amount:
We cast the result back to u64, which may involve some rounding.
This is the amount of Y tokens the user will receive.
Let's look at a concrete example to better understand this calculation:
Given:
- amount_in = 100
- reserve_in = 1000
- reserve_out = 2000
Calculation:
1. amount_in_with_fee = 100 * 997 = 99,700
2. numerator = 99,700 * 2000 = 199,400,000
3. denominator = 1000 * 1000 + 99,700 = 1,099,700
4. amount_out = 199,400,000 / 1,099,700 ≈ 181
In this example, if a user wants to swap 100 of token X, they would receive approximately 181 of token Y.
Execute Swap:
After calculating the output amount, we execute the actual swap:
let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
This line calls an internal swap function:
We pass 0 for the X output because we're swapping all of X for Y.
We pass our calculated amount_out for the Y output.
The function returns two Coin objects, representing the results of the swap.
Finally, we have a safety check:
assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
This assertion ensures that:
We've swapped all of the input X tokens.
There are no leftover X tokens from the swap.
If this condition isn't met, it indicates an error in our calculations or swap execution.
3. Core Swap Implementation
Now, let's dive deep into the core swap implementation. This is where the actual token exchange happens, and it's crucial to understand each step for anyone new to DeFi development.
fun swap&lt;X, Y&gt;(
    amount_x_out: u64,
    amount_y_out: u64
): (coin::Coin&lt;X&gt;, coin::Coin&lt;Y&gt;) acquires TokenPairReserve, TokenPairMetadata
This function is the heart of our swap mechanism. Let's break it down:
It's generic over two types, X and Y, representing our token pair.
It takes two parameters: amount_x_out and amount_y_out, which are the amounts of tokens X and Y to be swapped out.
It returns two Coin objects, representing the swapped tokens.
The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
Initial Validation
assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
This line is our first safety check:
It ensures that we're actually swapping something. At least one of the output amounts must be greater than zero.
If both outputs are zero, it would mean we're not swapping anything, which doesn't make sense in a swap operation.
The assert! macro will cause the transaction to revert if this condition isn't met, protecting against empty or invalid swaps.
let reserves = borrow_global_mut<<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
assert!(
    amount_x_out < reserves.reserve_x &&
    amount_y_out < reserves.reserve_y,
    ERROR_INSUFFICIENT_LIQUIDITY
);
This block performs a crucial liquidity check:
We first borrow the global TokenPairReserve resource, which holds the current reserves of both tokens.
Then, we check if the requested output amounts are less than the available reserves for each token.
This prevents a swap from draining the entire liquidity pool, which could destabilize the market.
If there's not enough liquidity, the transaction will revert with an
ERROR_INSUFFICIENT_LIQUIDITY
error.
Token Handling
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let coins_x_out = coin::zero<X>();
let coins_y_out = coin::zero<Y>();
if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
This section handles the actual token extraction:
We start by borrowing the TokenPairMetadata, which contains additional information about the token pair.
We initialize two empty Coin objects, one for each token type.
Then, we check if we need to extract any of token X or Y (remember, one of them might be zero in a single-sided swap).
If we need to extract tokens, we use the extract_x or extract_y functions (not shown here) to take tokens from the pool.
The extracted tokens are then merged into our initially empty Coin objects.
K Value Protection
let (balance_x, balance_y) = token_balances<X, Y>();
let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
    balance_x - (reserves.reserve_x - amount_x_out)
} else { 0 };
let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
    balance_y - (reserves.reserve_y - amount_y_out)
} else { 0 };
This part is crucial for maintaining the constant product formula (x * y = k):
We first get the current balances of both tokens in the pool.
Then, we calculate the actual amounts of tokens that were input into the swap.
This calculation accounts for the possibility of a bidirectional swap, where both tokens might be both input and output.
If the current balance is higher than what it should be after output (reserves minus output), we know some tokens were input.
This step is essential for accurately updating the pool state after the swap.
Price Impact Check
let prec = (PRECISION as u128);
let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
This section prepares for the final K value check:
We use a precision factor (PRECISION) to avoid dealing with fractional numbers.
We calculate adjusted balances by subtracting a portion of the input amounts. This accounts for the swap fee (0.25% in this case, as 25/10000 = 0.0025).
We also adjust the reserves using the same precision factor.
These adjustments allow us to perform accurate comparisons in the next step.
Final Verification
let compare_result = if (balance_x_adjusted > 0 && reserve_x_adjusted > 0 &&
    MAX_U128 / balance_x_adjusted > balance_y_adjusted &&
    MAX_U128 / reserve_x_adjusted > reserve_y_adjusted) {
    balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
} else {
    let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
    let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
    p >= k
};
assert!(compare_result, ERROR_K);
This final check ensures that the constant product formula is maintained:
We first check if we can safely multiply the adjusted balances without overflow.
If it's safe, we directly compare the product of adjusted balances with the product of adjusted reserves.
If there's a risk of overflow, we use larger u256 integers to perform the comparison.
The key here is that the new product (p) should be greater than or equal to the old product (k).
If this condition isn't met, it means the swap would adversely affect the pool's balance, and the transaction is reverted.
Next, we'll explore the implementation of other swap types: swap_x_to_exact_y, swap_exact_y_to_x, and swap_y_to_exact_x.
			Key Points:
This document provides a comprehensive explanation of token swapping in decentralized exchanges, focusing on the implementation of the swap_exact_x_to_y function. Key points covered include:
The public interface and parameters of the swap function
Step-by-step breakdown of the swap implementation
Detailed explanation of the AMM (Automated Market Maker) formula
Core swap logic including liquidity checks and token handling
K value protection and price impact considerations
Final verification to ensure the constant product formula is maintained
This guide is essential for developers looking to understand or implement token swapping mechanisms in DeFi applications.
Introduction
Swapping is a fundamental feature of decentralized exchanges (DEXs), allowing users to trade one token for another. In this tutorial, we'll dive deep into the implementation of a common swap type: swap_exact_x_to_y. This function enables users to exchange a specific amount of token X for token Y, with the output amount determined by an Automated Market Maker (AMM) formula.
1. Public Interface: swap_exact_x_to_y
public fun swap_exact_x_to_y<X, Y>(
    sender: &signer,
    amount_in: u64,
    to: address
): u64 acquires TokenPairReserve, TokenPairMetadata
Let's break down this function signature to understand what each part means:
Function Name and Generics
swap_exact_x_to_y
: This name clearly indicates the function's purpose - swapping an exact amount of token X for token Y.
<X, Y>
: These are generic type parameters. They allow the function to work with any two token types, making it flexible and reusable.
Parameter Analysis:
sender: &signer
This is a reference to the signer object, representing the user initiating the swap.
The signer is crucial for several reasons:
It allows the function to withdraw tokens from the user's account.
It's used to verify that the user has the necessary permissions.
It enables the function to register coin stores if they don't exist yet.
amount_in: u64
This parameter specifies the exact amount of token X the user wants to swap.
It must be greater than 0 to perform a valid swap.
This amount is used in calculations to determine how much of token Y the user will receive.
The size of amount_in affects the price impact of the swap on the liquidity pool.
to: address
This is the address that will receive the output token Y.
Interestingly, this can be different from the sender's address.
This flexibility allows for direct transfers to other addresses.
It's particularly useful when interacting with more complex smart contracts or routers.
Return Value
The function returns a u64, which represents the amount of token Y that was output from the swap. This allows the caller to know exactly how many tokens were received.
Acquire Clause
The
acquires TokenPairReserve, TokenPairMetadata
clause indicates that this function will access global storage to read or modify these resources. This is important for managing the liquidity pool and swap calculations.
Implementation Details:
Now, let's walk through the implementation step-by-step:
Step 1: Withdraw Tokens
let coins = coin::withdraw<X>(sender, amount_in);
This line does several important things:
It calls the withdraw function from the coin module, specifying token X as the type.
It takes tokens directly from the sender's account.
The exact amount_in is withdrawn.
If the sender doesn't have enough balance, this operation will fail.
The result is a new Coin object containing the withdrawn tokens.
Step 2: Execute Swap
let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
This line is where the actual swap logic happens:
It calls an internal function swap_exact_x_to_y_direct.
The coins object (containing token X) is passed to this function.
The function returns two Coin objects: coins_x_out and coins_y_out.
coins_x_out will typically be empty (zero value) in this case.
coins_y_out contains the tokens that resulted from the swap.
Step 3: Prepare Deposit
let amount_out = coin::value(&coins_y_out);
check_or_register_coin_store<Y>(sender);
These lines prepare for the final transfer:
The value of coins_y_out is extracted. This is how many tokens of Y were swapped for.
The check_or_register_coin_store function ensures that the recipient can receive token Y.
If the recipient doesn't have a coin store for token Y, one is automatically created.
Step 4: Complete Transfer
coin::destroy_zero(coins_x_out);
coin::deposit(to, coins_y_out);
The final steps of the swap:
coins_x_out is destroyed. This should be empty, as all X tokens were swapped.
The resulting Y tokens (coins_y_out) are deposited to the specified 'to' address.
The function implicitly returns amount_out, telling the caller how many Y tokens were received.
2. Direct Swap Implementation
Now, let's dive deeper into the core of our swap function:
swap_exact_x_to_y_direct
. This function is where the magic happens - it's responsible for executing the actual token swap.
public fun swap_exact_x_to_y_direct<X, Y>(
    coins_in: coin::Coin<X>
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata
Let's break down this function signature:
It's a public function, meaning it can be called from outside the
module.It
uses generic typesand, allowing it to work with any pair of
tokens.It
takes a Coin as input (the tokens we're swapping).It returns two Coin objects: Coin(any leftover input) and Coin(the swapped tokens).
The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
Core Logic:
Now, let's walk through the function step-by-step:
Step 1: Get Input Amount
let amount_in = coin::value<X>(&coins_in);
This line retrieves the exact amount of tokens X that the user is swapping. It's crucial because:
It tells us how many tokens we're working with.
We need this value for our swap calculations later.
It's a read-only operation, so it doesn't modify the coins_in object.
Step 2: Deposit to Pool
deposit_x<X, Y>(coins_in);
This step is where we actually add the input tokens to the liquidity pool:
The deposit_x function (not shown here) handles the mechanics of adding tokens to the pool.
After this step, the pool's balance of token X has increased by amount_in.
This is a critical step because it's where the user's tokens are actually transferred to the pool.
Step 3: Get Reserves
let (rin, rout, _) = token_reserves<X, Y>();
Here, we're fetching the current state of the liquidity pool:
rin represents the reserve of the input token (X in this case).
rout represents the reserve of the output token (Y in this case).
The underscore (_) suggests there's a third value returned that we're not using here.
These reserve values are crucial for calculating the swap output.
Step 4: Calculate Output
let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
This is where we determine how many Y tokens the user will receive:
We use a utility function get_amount_out to perform the calculation.
It takes into account the input amount and the current reserves of both tokens.
The calculation ensures that the pool maintains its balance according to the AMM formula.
AMM Formula Details:
Let's take a closer look at the get_amount_out function:
// In swap_utils
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 997u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 1000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
This function is the heart of our AMM. Let's break it down:
First, we have two assert statements:
They ensure that we have a valid input amount and that there's sufficient liquidity in the pool.
If these conditions aren't met, the function will abort with an error.
Next, we calculate the input amount with the fee applied:
We multiply the input by 997, which is equivalent to applying a 0.3% fee (3/1000).
This fee goes to the liquidity providers as an incentive.
The core of the calculation is based on the constant product formula:
This formula ensures that the product of the two token reserves remains constant before and after the swap.
It's designed to provide a fair price and maintain pool stability.
Finally, we return the calculated output amount:
We cast the result back to u64, which may involve some rounding.
This is the amount of Y tokens the user will receive.
Let's look at a concrete example to better understand this calculation:
Given:
- amount_in = 100
- reserve_in = 1000
- reserve_out = 2000
Calculation:
1. amount_in_with_fee = 100 * 997 = 99,700
2. numerator = 99,700 * 2000 = 199,400,000
3. denominator = 1000 * 1000 + 99,700 = 1,099,700
4. amount_out = 199,400,000 / 1,099,700 ≈ 181
In this example, if a user wants to swap 100 of token X, they would receive approximately 181 of token Y.
Execute Swap:
After calculating the output amount, we execute the actual swap:
let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
This line calls an internal swap function:
We pass 0 for the X output because we're swapping all of X for Y.
We pass our calculated amount_out for the Y output.
The function returns two Coin objects, representing the results of the swap.
Finally, we have a safety check:
assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
This assertion ensures that:
We've swapped all of the input X tokens.
There are no leftover X tokens from the swap.
If this condition isn't met, it indicates an error in our calculations or swap execution.
3. Core Swap Implementation
Now, let's dive deep into the core swap implementation. This is where the actual token exchange happens, and it's crucial to understand each step for anyone new to DeFi development.
fun swap&lt;X, Y&gt;(
    amount_x_out: u64,
    amount_y_out: u64
): (coin::Coin&lt;X&gt;, coin::Coin&lt;Y&gt;) acquires TokenPairReserve, TokenPairMetadata
This function is the heart of our swap mechanism. Let's break it down:
It's generic over two types, X and Y, representing our token pair.
It takes two parameters: amount_x_out and amount_y_out, which are the amounts of tokens X and Y to be swapped out.
It returns two Coin objects, representing the swapped tokens.
The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
Initial Validation
assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
This line is our first safety check:
It ensures that we're actually swapping something. At least one of the output amounts must be greater than zero.
If both outputs are zero, it would mean we're not swapping anything, which doesn't make sense in a swap operation.
The assert! macro will cause the transaction to revert if this condition isn't met, protecting against empty or invalid swaps.
let reserves = borrow_global_mut<<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
assert!(
    amount_x_out < reserves.reserve_x &&
    amount_y_out < reserves.reserve_y,
    ERROR_INSUFFICIENT_LIQUIDITY
);
This block performs a crucial liquidity check:
We first borrow the global TokenPairReserve resource, which holds the current reserves of both tokens.
Then, we check if the requested output amounts are less than the available reserves for each token.
This prevents a swap from draining the entire liquidity pool, which could destabilize the market.
If there's not enough liquidity, the transaction will revert with an
ERROR_INSUFFICIENT_LIQUIDITY
error.
Token Handling
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let coins_x_out = coin::zero<X>();
let coins_y_out = coin::zero<Y>();
if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
This section handles the actual token extraction:
We start by borrowing the TokenPairMetadata, which contains additional information about the token pair.
We initialize two empty Coin objects, one for each token type.
Then, we check if we need to extract any of token X or Y (remember, one of them might be zero in a single-sided swap).
If we need to extract tokens, we use the extract_x or extract_y functions (not shown here) to take tokens from the pool.
The extracted tokens are then merged into our initially empty Coin objects.
K Value Protection
let (balance_x, balance_y) = token_balances<X, Y>();
let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
    balance_x - (reserves.reserve_x - amount_x_out)
} else { 0 };
let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
    balance_y - (reserves.reserve_y - amount_y_out)
} else { 0 };
This part is crucial for maintaining the constant product formula (x * y = k):
We first get the current balances of both tokens in the pool.
Then, we calculate the actual amounts of tokens that were input into the swap.
This calculation accounts for the possibility of a bidirectional swap, where both tokens might be both input and output.
If the current balance is higher than what it should be after output (reserves minus output), we know some tokens were input.
This step is essential for accurately updating the pool state after the swap.
Price Impact Check
let prec = (PRECISION as u128);
let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
This section prepares for the final K value check:
We use a precision factor (PRECISION) to avoid dealing with fractional numbers.
We calculate adjusted balances by subtracting a portion of the input amounts. This accounts for the swap fee (0.25% in this case, as 25/10000 = 0.0025).
We also adjust the reserves using the same precision factor.
These adjustments allow us to perform accurate comparisons in the next step.
Final Verification
let compare_result = if (balance_x_adjusted > 0 && reserve_x_adjusted > 0 &&
    MAX_U128 / balance_x_adjusted > balance_y_adjusted &&
    MAX_U128 / reserve_x_adjusted > reserve_y_adjusted) {
    balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
} else {
    let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
    let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
    p >= k
};
assert!(compare_result, ERROR_K);
This final check ensures that the constant product formula is maintained:
We first check if we can safely multiply the adjusted balances without overflow.
If it's safe, we directly compare the product of adjusted balances with the product of adjusted reserves.
If there's a risk of overflow, we use larger u256 integers to perform the comparison.
The key here is that the new product (p) should be greater than or equal to the old product (k).
If this condition isn't met, it means the swap would adversely affect the pool's balance, and the transaction is reverted.
Next, we'll explore the implementation of other swap types: swap_x_to_exact_y, swap_exact_y_to_x, and swap_y_to_exact_x.
			Key Points:
This document provides a comprehensive explanation of token swapping in decentralized exchanges, focusing on the implementation of the swap_exact_x_to_y function. Key points covered include:
The public interface and parameters of the swap function
Step-by-step breakdown of the swap implementation
Detailed explanation of the AMM (Automated Market Maker) formula
Core swap logic including liquidity checks and token handling
K value protection and price impact considerations
Final verification to ensure the constant product formula is maintained
This guide is essential for developers looking to understand or implement token swapping mechanisms in DeFi applications.
Introduction
Swapping is a fundamental feature of decentralized exchanges (DEXs), allowing users to trade one token for another. In this tutorial, we'll dive deep into the implementation of a common swap type: swap_exact_x_to_y. This function enables users to exchange a specific amount of token X for token Y, with the output amount determined by an Automated Market Maker (AMM) formula.
1. Public Interface: swap_exact_x_to_y
public fun swap_exact_x_to_y<X, Y>(
    sender: &signer,
    amount_in: u64,
    to: address
): u64 acquires TokenPairReserve, TokenPairMetadata
Let's break down this function signature to understand what each part means:
Function Name and Generics
swap_exact_x_to_y
: This name clearly indicates the function's purpose - swapping an exact amount of token X for token Y.
<X, Y>
: These are generic type parameters. They allow the function to work with any two token types, making it flexible and reusable.
Parameter Analysis:
sender: &signer
This is a reference to the signer object, representing the user initiating the swap.
The signer is crucial for several reasons:
It allows the function to withdraw tokens from the user's account.
It's used to verify that the user has the necessary permissions.
It enables the function to register coin stores if they don't exist yet.
amount_in: u64
This parameter specifies the exact amount of token X the user wants to swap.
It must be greater than 0 to perform a valid swap.
This amount is used in calculations to determine how much of token Y the user will receive.
The size of amount_in affects the price impact of the swap on the liquidity pool.
to: address
This is the address that will receive the output token Y.
Interestingly, this can be different from the sender's address.
This flexibility allows for direct transfers to other addresses.
It's particularly useful when interacting with more complex smart contracts or routers.
Return Value
The function returns a u64, which represents the amount of token Y that was output from the swap. This allows the caller to know exactly how many tokens were received.
Acquire Clause
The
acquires TokenPairReserve, TokenPairMetadata
clause indicates that this function will access global storage to read or modify these resources. This is important for managing the liquidity pool and swap calculations.
Implementation Details:
Now, let's walk through the implementation step-by-step:
Step 1: Withdraw Tokens
let coins = coin::withdraw<X>(sender, amount_in);
This line does several important things:
It calls the withdraw function from the coin module, specifying token X as the type.
It takes tokens directly from the sender's account.
The exact amount_in is withdrawn.
If the sender doesn't have enough balance, this operation will fail.
The result is a new Coin object containing the withdrawn tokens.
Step 2: Execute Swap
let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
This line is where the actual swap logic happens:
It calls an internal function swap_exact_x_to_y_direct.
The coins object (containing token X) is passed to this function.
The function returns two Coin objects: coins_x_out and coins_y_out.
coins_x_out will typically be empty (zero value) in this case.
coins_y_out contains the tokens that resulted from the swap.
Step 3: Prepare Deposit
let amount_out = coin::value(&coins_y_out);
check_or_register_coin_store<Y>(sender);
These lines prepare for the final transfer:
The value of coins_y_out is extracted. This is how many tokens of Y were swapped for.
The check_or_register_coin_store function ensures that the recipient can receive token Y.
If the recipient doesn't have a coin store for token Y, one is automatically created.
Step 4: Complete Transfer
coin::destroy_zero(coins_x_out);
coin::deposit(to, coins_y_out);
The final steps of the swap:
coins_x_out is destroyed. This should be empty, as all X tokens were swapped.
The resulting Y tokens (coins_y_out) are deposited to the specified 'to' address.
The function implicitly returns amount_out, telling the caller how many Y tokens were received.
2. Direct Swap Implementation
Now, let's dive deeper into the core of our swap function:
swap_exact_x_to_y_direct
. This function is where the magic happens - it's responsible for executing the actual token swap.
public fun swap_exact_x_to_y_direct<X, Y>(
    coins_in: coin::Coin<X>
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata
Let's break down this function signature:
It's a public function, meaning it can be called from outside the
module.It
uses generic typesand, allowing it to work with any pair of
tokens.It
takes a Coin as input (the tokens we're swapping).It returns two Coin objects: Coin(any leftover input) and Coin(the swapped tokens).
The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
Core Logic:
Now, let's walk through the function step-by-step:
Step 1: Get Input Amount
let amount_in = coin::value<X>(&coins_in);
This line retrieves the exact amount of tokens X that the user is swapping. It's crucial because:
It tells us how many tokens we're working with.
We need this value for our swap calculations later.
It's a read-only operation, so it doesn't modify the coins_in object.
Step 2: Deposit to Pool
deposit_x<X, Y>(coins_in);
This step is where we actually add the input tokens to the liquidity pool:
The deposit_x function (not shown here) handles the mechanics of adding tokens to the pool.
After this step, the pool's balance of token X has increased by amount_in.
This is a critical step because it's where the user's tokens are actually transferred to the pool.
Step 3: Get Reserves
let (rin, rout, _) = token_reserves<X, Y>();
Here, we're fetching the current state of the liquidity pool:
rin represents the reserve of the input token (X in this case).
rout represents the reserve of the output token (Y in this case).
The underscore (_) suggests there's a third value returned that we're not using here.
These reserve values are crucial for calculating the swap output.
Step 4: Calculate Output
let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
This is where we determine how many Y tokens the user will receive:
We use a utility function get_amount_out to perform the calculation.
It takes into account the input amount and the current reserves of both tokens.
The calculation ensures that the pool maintains its balance according to the AMM formula.
AMM Formula Details:
Let's take a closer look at the get_amount_out function:
// In swap_utils
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 997u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 1000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
This function is the heart of our AMM. Let's break it down:
First, we have two assert statements:
They ensure that we have a valid input amount and that there's sufficient liquidity in the pool.
If these conditions aren't met, the function will abort with an error.
Next, we calculate the input amount with the fee applied:
We multiply the input by 997, which is equivalent to applying a 0.3% fee (3/1000).
This fee goes to the liquidity providers as an incentive.
The core of the calculation is based on the constant product formula:
This formula ensures that the product of the two token reserves remains constant before and after the swap.
It's designed to provide a fair price and maintain pool stability.
Finally, we return the calculated output amount:
We cast the result back to u64, which may involve some rounding.
This is the amount of Y tokens the user will receive.
Let's look at a concrete example to better understand this calculation:
Given:
- amount_in = 100
- reserve_in = 1000
- reserve_out = 2000
Calculation:
1. amount_in_with_fee = 100 * 997 = 99,700
2. numerator = 99,700 * 2000 = 199,400,000
3. denominator = 1000 * 1000 + 99,700 = 1,099,700
4. amount_out = 199,400,000 / 1,099,700 ≈ 181
In this example, if a user wants to swap 100 of token X, they would receive approximately 181 of token Y.
Execute Swap:
After calculating the output amount, we execute the actual swap:
let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
This line calls an internal swap function:
We pass 0 for the X output because we're swapping all of X for Y.
We pass our calculated amount_out for the Y output.
The function returns two Coin objects, representing the results of the swap.
Finally, we have a safety check:
assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
This assertion ensures that:
We've swapped all of the input X tokens.
There are no leftover X tokens from the swap.
If this condition isn't met, it indicates an error in our calculations or swap execution.
3. Core Swap Implementation
Now, let's dive deep into the core swap implementation. This is where the actual token exchange happens, and it's crucial to understand each step for anyone new to DeFi development.
fun swap&lt;X, Y&gt;(
    amount_x_out: u64,
    amount_y_out: u64
): (coin::Coin&lt;X&gt;, coin::Coin&lt;Y&gt;) acquires TokenPairReserve, TokenPairMetadata
This function is the heart of our swap mechanism. Let's break it down:
It's generic over two types, X and Y, representing our token pair.
It takes two parameters: amount_x_out and amount_y_out, which are the amounts of tokens X and Y to be swapped out.
It returns two Coin objects, representing the swapped tokens.
The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
Initial Validation
assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
This line is our first safety check:
It ensures that we're actually swapping something. At least one of the output amounts must be greater than zero.
If both outputs are zero, it would mean we're not swapping anything, which doesn't make sense in a swap operation.
The assert! macro will cause the transaction to revert if this condition isn't met, protecting against empty or invalid swaps.
let reserves = borrow_global_mut<<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
assert!(
    amount_x_out < reserves.reserve_x &&
    amount_y_out < reserves.reserve_y,
    ERROR_INSUFFICIENT_LIQUIDITY
);
This block performs a crucial liquidity check:
We first borrow the global TokenPairReserve resource, which holds the current reserves of both tokens.
Then, we check if the requested output amounts are less than the available reserves for each token.
This prevents a swap from draining the entire liquidity pool, which could destabilize the market.
If there's not enough liquidity, the transaction will revert with an
ERROR_INSUFFICIENT_LIQUIDITY
error.
Token Handling
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let coins_x_out = coin::zero<X>();
let coins_y_out = coin::zero<Y>();
if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
This section handles the actual token extraction:
We start by borrowing the TokenPairMetadata, which contains additional information about the token pair.
We initialize two empty Coin objects, one for each token type.
Then, we check if we need to extract any of token X or Y (remember, one of them might be zero in a single-sided swap).
If we need to extract tokens, we use the extract_x or extract_y functions (not shown here) to take tokens from the pool.
The extracted tokens are then merged into our initially empty Coin objects.
K Value Protection
let (balance_x, balance_y) = token_balances<X, Y>();
let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
    balance_x - (reserves.reserve_x - amount_x_out)
} else { 0 };
let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
    balance_y - (reserves.reserve_y - amount_y_out)
} else { 0 };
This part is crucial for maintaining the constant product formula (x * y = k):
We first get the current balances of both tokens in the pool.
Then, we calculate the actual amounts of tokens that were input into the swap.
This calculation accounts for the possibility of a bidirectional swap, where both tokens might be both input and output.
If the current balance is higher than what it should be after output (reserves minus output), we know some tokens were input.
This step is essential for accurately updating the pool state after the swap.
Price Impact Check
let prec = (PRECISION as u128);
let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
This section prepares for the final K value check:
We use a precision factor (PRECISION) to avoid dealing with fractional numbers.
We calculate adjusted balances by subtracting a portion of the input amounts. This accounts for the swap fee (0.25% in this case, as 25/10000 = 0.0025).
We also adjust the reserves using the same precision factor.
These adjustments allow us to perform accurate comparisons in the next step.
Final Verification
let compare_result = if (balance_x_adjusted > 0 && reserve_x_adjusted > 0 &&
    MAX_U128 / balance_x_adjusted > balance_y_adjusted &&
    MAX_U128 / reserve_x_adjusted > reserve_y_adjusted) {
    balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
} else {
    let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
    let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
    p >= k
};
assert!(compare_result, ERROR_K);
This final check ensures that the constant product formula is maintained:
We first check if we can safely multiply the adjusted balances without overflow.
If it's safe, we directly compare the product of adjusted balances with the product of adjusted reserves.
If there's a risk of overflow, we use larger u256 integers to perform the comparison.
The key here is that the new product (p) should be greater than or equal to the old product (k).
If this condition isn't met, it means the swap would adversely affect the pool's balance, and the transaction is reverted.
Next, we'll explore the implementation of other swap types: swap_x_to_exact_y, swap_exact_y_to_x, and swap_y_to_exact_x.
		Key Points:
		Key Points:
		This document provides a comprehensive explanation of token swapping in decentralized exchanges, focusing on the implementation of the swap_exact_x_to_y function. Key points covered include:
		This document provides a comprehensive explanation of token swapping in decentralized exchanges, focusing on the implementation of the swap_exact_x_to_y function. Key points covered include:
		The public interface and parameters of the swap function
Step-by-step breakdown of the swap implementation
Detailed explanation of the AMM (Automated Market Maker) formula
Core swap logic including liquidity checks and token handling
K value protection and price impact considerations
Final verification to ensure the constant product formula is maintained
		The public interface and parameters of the swap function
		The public interface and parameters of the swap function
		Step-by-step breakdown of the swap implementation
		Step-by-step breakdown of the swap implementation
		Detailed explanation of the AMM (Automated Market Maker) formula
		Detailed explanation of the AMM (Automated Market Maker) formula
		Core swap logic including liquidity checks and token handling
		Core swap logic including liquidity checks and token handling
		K value protection and price impact considerations
		K value protection and price impact considerations
		Final verification to ensure the constant product formula is maintained
		Final verification to ensure the constant product formula is maintained
		This guide is essential for developers looking to understand or implement token swapping mechanisms in DeFi applications.
		This guide is essential for developers looking to understand or implement token swapping mechanisms in DeFi applications.
	Introduction
	Introduction
	Swapping is a fundamental feature of decentralized exchanges (DEXs), allowing users to trade one token for another. In this tutorial, we'll dive deep into the implementation of a common swap type: swap_exact_x_to_y. This function enables users to exchange a specific amount of token X for token Y, with the output amount determined by an Automated Market Maker (AMM) formula.
	Swapping is a fundamental feature of decentralized exchanges (DEXs), allowing users to trade one token for another. In this tutorial, we'll dive deep into the implementation of a common swap type: swap_exact_x_to_y. This function enables users to exchange a specific amount of token X for token Y, with the output amount determined by an Automated Market Maker (AMM) formula.
	1. Public Interface: swap_exact_x_to_y
	1. Public Interface: swap_exact_x_to_y
	<code>public fun swap_exact_x_to_y<X, Y>(
    sender: &signer,
    amount_in: u64,
    to: address
): u64 acquires TokenPairReserve, TokenPairMetadata</code>
	<code>public fun swap_exact_x_to_y<X, Y>(
    sender: &signer,
    amount_in: u64,
    to: address
): u64 acquires TokenPairReserve, TokenPairMetadata</code>
	public fun swap_exact_x_to_y<X, Y>(
    sender: &signer,
    amount_in: u64,
    to: address
): u64 acquires TokenPairReserve, TokenPairMetadata
	Let's break down this function signature to understand what each part means:
	Let's break down this function signature to understand what each part means:
		Function Name and Generics
		Function Name and Generics
		swap_exact_x_to_y
: This name clearly indicates the function's purpose - swapping an exact amount of token X for token Y.
<X, Y>
: These are generic type parameters. They allow the function to work with any two token types, making it flexible and reusable.
		swap_exact_x_to_y
: This name clearly indicates the function's purpose - swapping an exact amount of token X for token Y.
		swap_exact_x_to_y
		swap_exact_x_to_y
		: This name clearly indicates the function's purpose - swapping an exact amount of token X for token Y.
		<X, Y>
: These are generic type parameters. They allow the function to work with any two token types, making it flexible and reusable.
		<X, Y>
		<X, Y>
		: These are generic type parameters. They allow the function to work with any two token types, making it flexible and reusable.
		Parameter Analysis:
		Parameter Analysis:
		sender: &signer
This is a reference to the signer object, representing the user initiating the swap.
The signer is crucial for several reasons:
It allows the function to withdraw tokens from the user's account.
It's used to verify that the user has the necessary permissions.
It enables the function to register coin stores if they don't exist yet.
amount_in: u64
This parameter specifies the exact amount of token X the user wants to swap.
It must be greater than 0 to perform a valid swap.
This amount is used in calculations to determine how much of token Y the user will receive.
The size of amount_in affects the price impact of the swap on the liquidity pool.
to: address
This is the address that will receive the output token Y.
Interestingly, this can be different from the sender's address.
This flexibility allows for direct transfers to other addresses.
It's particularly useful when interacting with more complex smart contracts or routers.
		sender: &signer
This is a reference to the signer object, representing the user initiating the swap.
The signer is crucial for several reasons:
It allows the function to withdraw tokens from the user's account.
It's used to verify that the user has the necessary permissions.
It enables the function to register coin stores if they don't exist yet.
		sender: &signer
		sender: &signer
		This is a reference to the signer object, representing the user initiating the swap.
The signer is crucial for several reasons:
It allows the function to withdraw tokens from the user's account.
It's used to verify that the user has the necessary permissions.
It enables the function to register coin stores if they don't exist yet.
		This is a reference to the signer object, representing the user initiating the swap.
		This is a reference to the signer object, representing the user initiating the swap.
		The signer is crucial for several reasons:
It allows the function to withdraw tokens from the user's account.
It's used to verify that the user has the necessary permissions.
It enables the function to register coin stores if they don't exist yet.
		The signer is crucial for several reasons:
		It allows the function to withdraw tokens from the user's account.
It's used to verify that the user has the necessary permissions.
It enables the function to register coin stores if they don't exist yet.
		It allows the function to withdraw tokens from the user's account.
		It allows the function to withdraw tokens from the user's account.
		It's used to verify that the user has the necessary permissions.
		It's used to verify that the user has the necessary permissions.
		It enables the function to register coin stores if they don't exist yet.
		It enables the function to register coin stores if they don't exist yet.
		amount_in: u64
This parameter specifies the exact amount of token X the user wants to swap.
It must be greater than 0 to perform a valid swap.
This amount is used in calculations to determine how much of token Y the user will receive.
The size of amount_in affects the price impact of the swap on the liquidity pool.
		amount_in: u64
		amount_in: u64
		This parameter specifies the exact amount of token X the user wants to swap.
It must be greater than 0 to perform a valid swap.
This amount is used in calculations to determine how much of token Y the user will receive.
The size of amount_in affects the price impact of the swap on the liquidity pool.
		This parameter specifies the exact amount of token X the user wants to swap.
		This parameter specifies the exact amount of token X the user wants to swap.
		It must be greater than 0 to perform a valid swap.
		It must be greater than 0 to perform a valid swap.
		This amount is used in calculations to determine how much of token Y the user will receive.
		This amount is used in calculations to determine how much of token Y the user will receive.
		The size of amount_in affects the price impact of the swap on the liquidity pool.
		The size of amount_in affects the price impact of the swap on the liquidity pool.
		to: address
This is the address that will receive the output token Y.
Interestingly, this can be different from the sender's address.
This flexibility allows for direct transfers to other addresses.
It's particularly useful when interacting with more complex smart contracts or routers.
		to: address
		to: address
		This is the address that will receive the output token Y.
Interestingly, this can be different from the sender's address.
This flexibility allows for direct transfers to other addresses.
It's particularly useful when interacting with more complex smart contracts or routers.
		This is the address that will receive the output token Y.
		This is the address that will receive the output token Y.
		Interestingly, this can be different from the sender's address.
		Interestingly, this can be different from the sender's address.
		This flexibility allows for direct transfers to other addresses.
		This flexibility allows for direct transfers to other addresses.
		It's particularly useful when interacting with more complex smart contracts or routers.
		It's particularly useful when interacting with more complex smart contracts or routers.
		Return Value
		Return Value
		The function returns a u64, which represents the amount of token Y that was output from the swap. This allows the caller to know exactly how many tokens were received.
		The function returns a u64, which represents the amount of token Y that was output from the swap. This allows the caller to know exactly how many tokens were received.
		Acquire Clause
		Acquire Clause
		The
acquires TokenPairReserve, TokenPairMetadata
clause indicates that this function will access global storage to read or modify these resources. This is important for managing the liquidity pool and swap calculations.
		The
		acquires TokenPairReserve, TokenPairMetadata
		acquires TokenPairReserve, TokenPairMetadata
		clause indicates that this function will access global storage to read or modify these resources. This is important for managing the liquidity pool and swap calculations.
		Implementation Details:
		Implementation Details:
		Now, let's walk through the implementation step-by-step:
		Now, let's walk through the implementation step-by-step:
		Step 1: Withdraw Tokens
		Step 1: Withdraw Tokens
		<code>let coins = coin::withdraw<X>(sender, amount_in);</code>
		<code>let coins = coin::withdraw<X>(sender, amount_in);</code>
		let coins = coin::withdraw<X>(sender, amount_in);
		This line does several important things:
		This line does several important things:
		It calls the withdraw function from the coin module, specifying token X as the type.
It takes tokens directly from the sender's account.
The exact amount_in is withdrawn.
If the sender doesn't have enough balance, this operation will fail.
The result is a new Coin object containing the withdrawn tokens.
		It calls the withdraw function from the coin module, specifying token X as the type.
		It calls the withdraw function from the coin module, specifying token X as the type.
		It takes tokens directly from the sender's account.
		It takes tokens directly from the sender's account.
		The exact amount_in is withdrawn.
		The exact amount_in is withdrawn.
		If the sender doesn't have enough balance, this operation will fail.
		If the sender doesn't have enough balance, this operation will fail.
		The result is a new Coin object containing the withdrawn tokens.
		The result is a new Coin object containing the withdrawn tokens.
		Step 2: Execute Swap
		Step 2: Execute Swap
		<code>let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);</code>
		<code>let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);</code>
		let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
		This line is where the actual swap logic happens:
		This line is where the actual swap logic happens:
		It calls an internal function swap_exact_x_to_y_direct.
The coins object (containing token X) is passed to this function.
The function returns two Coin objects: coins_x_out and coins_y_out.
coins_x_out will typically be empty (zero value) in this case.
coins_y_out contains the tokens that resulted from the swap.
		It calls an internal function swap_exact_x_to_y_direct.
		It calls an internal function swap_exact_x_to_y_direct.
		The coins object (containing token X) is passed to this function.
		The coins object (containing token X) is passed to this function.
		The function returns two Coin objects: coins_x_out and coins_y_out.
		The function returns two Coin objects: coins_x_out and coins_y_out.
		coins_x_out will typically be empty (zero value) in this case.
		coins_x_out will typically be empty (zero value) in this case.
		coins_y_out contains the tokens that resulted from the swap.
		coins_y_out contains the tokens that resulted from the swap.
		Step 3: Prepare Deposit
		Step 3: Prepare Deposit
		<code>let amount_out = coin::value(&coins_y_out);
check_or_register_coin_store<Y>(sender);</code>
		<code>let amount_out = coin::value(&coins_y_out);
check_or_register_coin_store<Y>(sender);</code>
		let amount_out = coin::value(&coins_y_out);
check_or_register_coin_store<Y>(sender);
		These lines prepare for the final transfer:
		These lines prepare for the final transfer:
		The value of coins_y_out is extracted. This is how many tokens of Y were swapped for.
The check_or_register_coin_store function ensures that the recipient can receive token Y.
If the recipient doesn't have a coin store for token Y, one is automatically created.
		The value of coins_y_out is extracted. This is how many tokens of Y were swapped for.
		The value of coins_y_out is extracted. This is how many tokens of Y were swapped for.
		The check_or_register_coin_store function ensures that the recipient can receive token Y.
		The check_or_register_coin_store function ensures that the recipient can receive token Y.
		If the recipient doesn't have a coin store for token Y, one is automatically created.
		If the recipient doesn't have a coin store for token Y, one is automatically created.
		Step 4: Complete Transfer
		Step 4: Complete Transfer
		<code>coin::destroy_zero(coins_x_out);
coin::deposit(to, coins_y_out);</code>
		<code>coin::destroy_zero(coins_x_out);
coin::deposit(to, coins_y_out);</code>
		coin::destroy_zero(coins_x_out);
coin::deposit(to, coins_y_out);
		The final steps of the swap:
		The final steps of the swap:
		coins_x_out is destroyed. This should be empty, as all X tokens were swapped.
The resulting Y tokens (coins_y_out) are deposited to the specified 'to' address.
The function implicitly returns amount_out, telling the caller how many Y tokens were received.
		coins_x_out is destroyed. This should be empty, as all X tokens were swapped.
		coins_x_out is destroyed. This should be empty, as all X tokens were swapped.
		The resulting Y tokens (coins_y_out) are deposited to the specified 'to' address.
		The resulting Y tokens (coins_y_out) are deposited to the specified 'to' address.
		The function implicitly returns amount_out, telling the caller how many Y tokens were received.
		The function implicitly returns amount_out, telling the caller how many Y tokens were received.
	2. Direct Swap Implementation
	2. Direct Swap Implementation
	Now, let's dive deeper into the core of our swap function:
swap_exact_x_to_y_direct
. This function is where the magic happens - it's responsible for executing the actual token swap.
	Now, let's dive deeper into the core of our swap function:
	<code>swap_exact_x_to_y_direct</code>
	swap_exact_x_to_y_direct
	. This function is where the magic happens - it's responsible for executing the actual token swap.
	<code>public fun swap_exact_x_to_y_direct<X, Y>(
    coins_in: coin::Coin<X>
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata</code>
	<code>public fun swap_exact_x_to_y_direct<X, Y>(
    coins_in: coin::Coin<X>
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata</code>
	public fun swap_exact_x_to_y_direct<X, Y>(
    coins_in: coin::Coin<X>
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata
	Let's break down this function signature:
	Let's break down this function signature:
	It's a public function, meaning it can be called from outside the
module.It
uses generic typesand, allowing it to work with any pair of
tokens.It
takes a Coin as input (the tokens we're swapping).It returns two Coin objects: Coin(any leftover input) and Coin(the swapped tokens).
The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
	It's a public function, meaning it can be called from outside the
module.It
uses generic typesand, allowing it to work with any pair of
tokens.It
takes a Coin as input (the tokens we're swapping).It returns two Coin objects: Coin(any leftover input) and Coin(the swapped tokens).
	It's a public function, meaning it can be called from outside the
	module.It
	module.It
	uses generic typesand, allowing it to work with any pair of
	tokens.It
	tokens.It
	takes a Coin as input (the tokens we're swapping).It returns two Coin objects: Coin(any leftover input) and Coin(the swapped tokens).
	The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
	The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
		Core Logic:
		Core Logic:
		Now, let's walk through the function step-by-step:
		Now, let's walk through the function step-by-step:
		Step 1: Get Input Amount
		Step 1: Get Input Amount
		<code>let amount_in = coin::value<X>(&coins_in);</code>
		<code>let amount_in = coin::value<X>(&coins_in);</code>
		let amount_in = coin::value<X>(&coins_in);
		This line retrieves the exact amount of tokens X that the user is swapping. It's crucial because:
		This line retrieves the exact amount of tokens X that the user is swapping. It's crucial because:
		It tells us how many tokens we're working with.
We need this value for our swap calculations later.
It's a read-only operation, so it doesn't modify the coins_in object.
		It tells us how many tokens we're working with.
		It tells us how many tokens we're working with.
		We need this value for our swap calculations later.
		We need this value for our swap calculations later.
		It's a read-only operation, so it doesn't modify the coins_in object.
		It's a read-only operation, so it doesn't modify the coins_in object.
		Step 2: Deposit to Pool
		Step 2: Deposit to Pool
		<code>deposit_x<X, Y>(coins_in);</code>
		<code>deposit_x<X, Y>(coins_in);</code>
		deposit_x<X, Y>(coins_in);
		This step is where we actually add the input tokens to the liquidity pool:
		This step is where we actually add the input tokens to the liquidity pool:
		The deposit_x function (not shown here) handles the mechanics of adding tokens to the pool.
After this step, the pool's balance of token X has increased by amount_in.
This is a critical step because it's where the user's tokens are actually transferred to the pool.
		The deposit_x function (not shown here) handles the mechanics of adding tokens to the pool.
		The deposit_x function (not shown here) handles the mechanics of adding tokens to the pool.
		After this step, the pool's balance of token X has increased by amount_in.
		After this step, the pool's balance of token X has increased by amount_in.
		This is a critical step because it's where the user's tokens are actually transferred to the pool.
		This is a critical step because it's where the user's tokens are actually transferred to the pool.
		Step 3: Get Reserves
		Step 3: Get Reserves
		<code>let (rin, rout, _) = token_reserves<X, Y>();</code>
		<code>let (rin, rout, _) = token_reserves<X, Y>();</code>
		let (rin, rout, _) = token_reserves<X, Y>();
		Here, we're fetching the current state of the liquidity pool:
		Here, we're fetching the current state of the liquidity pool:
		rin represents the reserve of the input token (X in this case).
rout represents the reserve of the output token (Y in this case).
The underscore (_) suggests there's a third value returned that we're not using here.
These reserve values are crucial for calculating the swap output.
		rin represents the reserve of the input token (X in this case).
		rin represents the reserve of the input token (X in this case).
		rout represents the reserve of the output token (Y in this case).
		rout represents the reserve of the output token (Y in this case).
		The underscore (_) suggests there's a third value returned that we're not using here.
		The underscore (_) suggests there's a third value returned that we're not using here.
		These reserve values are crucial for calculating the swap output.
		These reserve values are crucial for calculating the swap output.
		Step 4: Calculate Output
		Step 4: Calculate Output
		<code>let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);</code>
		<code>let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);</code>
		let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
		This is where we determine how many Y tokens the user will receive:
		This is where we determine how many Y tokens the user will receive:
		We use a utility function get_amount_out to perform the calculation.
It takes into account the input amount and the current reserves of both tokens.
The calculation ensures that the pool maintains its balance according to the AMM formula.
		We use a utility function get_amount_out to perform the calculation.
		We use a utility function get_amount_out to perform the calculation.
		It takes into account the input amount and the current reserves of both tokens.
		It takes into account the input amount and the current reserves of both tokens.
		The calculation ensures that the pool maintains its balance according to the AMM formula.
		The calculation ensures that the pool maintains its balance according to the AMM formula.
		AMM Formula Details:
		AMM Formula Details:
		Let's take a closer look at the get_amount_out function:
		Let's take a closer look at the get_amount_out function:
		<code>// In swap_utils
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 997u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 1000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}</code>
		<code>// In swap_utils
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 997u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 1000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}</code>
		// In swap_utils
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
    assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    let amount_in_with_fee = (amount_in as u128) * 997u128;
    let numerator = amount_in_with_fee * (reserve_out as u128);
    let denominator = (reserve_in as u128) * 1000u128 + amount_in_with_fee;
    ((numerator / denominator) as u64)
}
		This function is the heart of our AMM. Let's break it down:
		This function is the heart of our AMM. Let's break it down:
		First, we have two assert statements:
They ensure that we have a valid input amount and that there's sufficient liquidity in the pool.
If these conditions aren't met, the function will abort with an error.
Next, we calculate the input amount with the fee applied:
We multiply the input by 997, which is equivalent to applying a 0.3% fee (3/1000).
This fee goes to the liquidity providers as an incentive.
The core of the calculation is based on the constant product formula:
This formula ensures that the product of the two token reserves remains constant before and after the swap.
It's designed to provide a fair price and maintain pool stability.
Finally, we return the calculated output amount:
We cast the result back to u64, which may involve some rounding.
This is the amount of Y tokens the user will receive.
		First, we have two assert statements:
They ensure that we have a valid input amount and that there's sufficient liquidity in the pool.
If these conditions aren't met, the function will abort with an error.
		First, we have two assert statements:
		They ensure that we have a valid input amount and that there's sufficient liquidity in the pool.
If these conditions aren't met, the function will abort with an error.
		They ensure that we have a valid input amount and that there's sufficient liquidity in the pool.
		They ensure that we have a valid input amount and that there's sufficient liquidity in the pool.
		If these conditions aren't met, the function will abort with an error.
		If these conditions aren't met, the function will abort with an error.
		Next, we calculate the input amount with the fee applied:
We multiply the input by 997, which is equivalent to applying a 0.3% fee (3/1000).
This fee goes to the liquidity providers as an incentive.
		Next, we calculate the input amount with the fee applied:
		We multiply the input by 997, which is equivalent to applying a 0.3% fee (3/1000).
This fee goes to the liquidity providers as an incentive.
		We multiply the input by 997, which is equivalent to applying a 0.3% fee (3/1000).
		We multiply the input by 997, which is equivalent to applying a 0.3% fee (3/1000).
		This fee goes to the liquidity providers as an incentive.
		This fee goes to the liquidity providers as an incentive.
		The core of the calculation is based on the constant product formula:
This formula ensures that the product of the two token reserves remains constant before and after the swap.
It's designed to provide a fair price and maintain pool stability.
		The core of the calculation is based on the constant product formula:
		This formula ensures that the product of the two token reserves remains constant before and after the swap.
It's designed to provide a fair price and maintain pool stability.
		This formula ensures that the product of the two token reserves remains constant before and after the swap.
		This formula ensures that the product of the two token reserves remains constant before and after the swap.
		It's designed to provide a fair price and maintain pool stability.
		It's designed to provide a fair price and maintain pool stability.
		Finally, we return the calculated output amount:
We cast the result back to u64, which may involve some rounding.
This is the amount of Y tokens the user will receive.
		Finally, we return the calculated output amount:
		We cast the result back to u64, which may involve some rounding.
This is the amount of Y tokens the user will receive.
		We cast the result back to u64, which may involve some rounding.
		We cast the result back to u64, which may involve some rounding.
		This is the amount of Y tokens the user will receive.
		This is the amount of Y tokens the user will receive.
		Let's look at a concrete example to better understand this calculation:
		Let's look at a concrete example to better understand this calculation:
		<code>Given:
- amount_in = 100
- reserve_in = 1000
- reserve_out = 2000
Calculation:
1. amount_in_with_fee = 100 * 997 = 99,700
2. numerator = 99,700 * 2000 = 199,400,000
3. denominator = 1000 * 1000 + 99,700 = 1,099,700
4. amount_out = 199,400,000 / 1,099,700 ≈ 181</code>
		<code>Given:
- amount_in = 100
- reserve_in = 1000
- reserve_out = 2000
Calculation:
1. amount_in_with_fee = 100 * 997 = 99,700
2. numerator = 99,700 * 2000 = 199,400,000
3. denominator = 1000 * 1000 + 99,700 = 1,099,700
4. amount_out = 199,400,000 / 1,099,700 ≈ 181</code>
		Given:
- amount_in = 100
- reserve_in = 1000
- reserve_out = 2000
Calculation:
1. amount_in_with_fee = 100 * 997 = 99,700
2. numerator = 99,700 * 2000 = 199,400,000
3. denominator = 1000 * 1000 + 99,700 = 1,099,700
4. amount_out = 199,400,000 / 1,099,700 ≈ 181
		In this example, if a user wants to swap 100 of token X, they would receive approximately 181 of token Y.
		In this example, if a user wants to swap 100 of token X, they would receive approximately 181 of token Y.
		Execute Swap:
		Execute Swap:
		After calculating the output amount, we execute the actual swap:
		After calculating the output amount, we execute the actual swap:
		<code>let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);</code>
		<code>let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);</code>
		let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
		This line calls an internal swap function:
		This line calls an internal swap function:
		We pass 0 for the X output because we're swapping all of X for Y.
We pass our calculated amount_out for the Y output.
The function returns two Coin objects, representing the results of the swap.
		We pass 0 for the X output because we're swapping all of X for Y.
		We pass 0 for the X output because we're swapping all of X for Y.
		We pass our calculated amount_out for the Y output.
		We pass our calculated amount_out for the Y output.
		The function returns two Coin objects, representing the results of the swap.
		The function returns two Coin objects, representing the results of the swap.
		Finally, we have a safety check:
		Finally, we have a safety check:
		<code>assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);</code>
		<code>assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);</code>
		assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
		This assertion ensures that:
		This assertion ensures that:
		We've swapped all of the input X tokens.
There are no leftover X tokens from the swap.
If this condition isn't met, it indicates an error in our calculations or swap execution.
		We've swapped all of the input X tokens.
		We've swapped all of the input X tokens.
		There are no leftover X tokens from the swap.
		There are no leftover X tokens from the swap.
		If this condition isn't met, it indicates an error in our calculations or swap execution.
		If this condition isn't met, it indicates an error in our calculations or swap execution.
	3. Core Swap Implementation
	3. Core Swap Implementation
	Now, let's dive deep into the core swap implementation. This is where the actual token exchange happens, and it's crucial to understand each step for anyone new to DeFi development.
	Now, let's dive deep into the core swap implementation. This is where the actual token exchange happens, and it's crucial to understand each step for anyone new to DeFi development.
	<code>fun swap&lt;X, Y&gt;(
    amount_x_out: u64,
    amount_y_out: u64
): (coin::Coin&lt;X&gt;, coin::Coin&lt;Y&gt;) acquires TokenPairReserve, TokenPairMetadata</code>
	<code>fun swap&lt;X, Y&gt;(
    amount_x_out: u64,
    amount_y_out: u64
): (coin::Coin&lt;X&gt;, coin::Coin&lt;Y&gt;) acquires TokenPairReserve, TokenPairMetadata</code>
	fun swap&lt;X, Y&gt;(
    amount_x_out: u64,
    amount_y_out: u64
): (coin::Coin&lt;X&gt;, coin::Coin&lt;Y&gt;) acquires TokenPairReserve, TokenPairMetadata
	This function is the heart of our swap mechanism. Let's break it down:
	This function is the heart of our swap mechanism. Let's break it down:
	It's generic over two types, X and Y, representing our token pair.
It takes two parameters: amount_x_out and amount_y_out, which are the amounts of tokens X and Y to be swapped out.
It returns two Coin objects, representing the swapped tokens.
The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
	It's generic over two types, X and Y, representing our token pair.
	It's generic over two types, X and Y, representing our token pair.
	It takes two parameters: amount_x_out and amount_y_out, which are the amounts of tokens X and Y to be swapped out.
	It takes two parameters: amount_x_out and amount_y_out, which are the amounts of tokens X and Y to be swapped out.
	It returns two Coin objects, representing the swapped tokens.
	It returns two Coin objects, representing the swapped tokens.
	The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
	The 'acquires' keyword indicates it will access global storage for TokenPairReserve and TokenPairMetadata.
		Initial Validation
		Initial Validation
		<code>assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);</code>
		<code>assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);</code>
		assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
		This line is our first safety check:
		This line is our first safety check:
		It ensures that we're actually swapping something. At least one of the output amounts must be greater than zero.
If both outputs are zero, it would mean we're not swapping anything, which doesn't make sense in a swap operation.
The assert! macro will cause the transaction to revert if this condition isn't met, protecting against empty or invalid swaps.
		It ensures that we're actually swapping something. At least one of the output amounts must be greater than zero.
		It ensures that we're actually swapping something. At least one of the output amounts must be greater than zero.
		If both outputs are zero, it would mean we're not swapping anything, which doesn't make sense in a swap operation.
		If both outputs are zero, it would mean we're not swapping anything, which doesn't make sense in a swap operation.
		The assert! macro will cause the transaction to revert if this condition isn't met, protecting against empty or invalid swaps.
		The assert! macro will cause the transaction to revert if this condition isn't met, protecting against empty or invalid swaps.
		<code>let reserves = borrow_global_mut<<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
assert!(
    amount_x_out < reserves.reserve_x &&
    amount_y_out < reserves.reserve_y,
    ERROR_INSUFFICIENT_LIQUIDITY
);</code>
		<code>let reserves = borrow_global_mut<<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
assert!(
    amount_x_out < reserves.reserve_x &&
    amount_y_out < reserves.reserve_y,
    ERROR_INSUFFICIENT_LIQUIDITY
);</code>
		let reserves = borrow_global_mut<<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
assert!(
    amount_x_out < reserves.reserve_x &&
    amount_y_out < reserves.reserve_y,
    ERROR_INSUFFICIENT_LIQUIDITY
);
		This block performs a crucial liquidity check:
		This block performs a crucial liquidity check:
		We first borrow the global TokenPairReserve resource, which holds the current reserves of both tokens.
Then, we check if the requested output amounts are less than the available reserves for each token.
This prevents a swap from draining the entire liquidity pool, which could destabilize the market.
If there's not enough liquidity, the transaction will revert with an
ERROR_INSUFFICIENT_LIQUIDITY
error.
		We first borrow the global TokenPairReserve resource, which holds the current reserves of both tokens.
		We first borrow the global TokenPairReserve resource, which holds the current reserves of both tokens.
		Then, we check if the requested output amounts are less than the available reserves for each token.
		Then, we check if the requested output amounts are less than the available reserves for each token.
		This prevents a swap from draining the entire liquidity pool, which could destabilize the market.
		This prevents a swap from draining the entire liquidity pool, which could destabilize the market.
		If there's not enough liquidity, the transaction will revert with an
ERROR_INSUFFICIENT_LIQUIDITY
error.
		If there's not enough liquidity, the transaction will revert with an
		<code>ERROR_INSUFFICIENT_LIQUIDITY</code>
		ERROR_INSUFFICIENT_LIQUIDITY
		error.
		Token Handling
		Token Handling
		<code>let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let coins_x_out = coin::zero<X>();
let coins_y_out = coin::zero<Y>();
if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));</code>
		<code>let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let coins_x_out = coin::zero<X>();
let coins_y_out = coin::zero<Y>();
if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));</code>
		let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let coins_x_out = coin::zero<X>();
let coins_y_out = coin::zero<Y>();
if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
		This section handles the actual token extraction:
		This section handles the actual token extraction:
		We start by borrowing the TokenPairMetadata, which contains additional information about the token pair.
We initialize two empty Coin objects, one for each token type.
Then, we check if we need to extract any of token X or Y (remember, one of them might be zero in a single-sided swap).
If we need to extract tokens, we use the extract_x or extract_y functions (not shown here) to take tokens from the pool.
The extracted tokens are then merged into our initially empty Coin objects.
		We start by borrowing the TokenPairMetadata, which contains additional information about the token pair.
		We start by borrowing the TokenPairMetadata, which contains additional information about the token pair.
		We initialize two empty Coin objects, one for each token type.
		We initialize two empty Coin objects, one for each token type.
		Then, we check if we need to extract any of token X or Y (remember, one of them might be zero in a single-sided swap).
		Then, we check if we need to extract any of token X or Y (remember, one of them might be zero in a single-sided swap).
		If we need to extract tokens, we use the extract_x or extract_y functions (not shown here) to take tokens from the pool.
		If we need to extract tokens, we use the extract_x or extract_y functions (not shown here) to take tokens from the pool.
		The extracted tokens are then merged into our initially empty Coin objects.
		The extracted tokens are then merged into our initially empty Coin objects.
		K Value Protection
		K Value Protection
		<code>let (balance_x, balance_y) = token_balances<X, Y>();
let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
    balance_x - (reserves.reserve_x - amount_x_out)
} else { 0 };
let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
    balance_y - (reserves.reserve_y - amount_y_out)
} else { 0 };</code>
		<code>let (balance_x, balance_y) = token_balances<X, Y>();
let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
    balance_x - (reserves.reserve_x - amount_x_out)
} else { 0 };
let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
    balance_y - (reserves.reserve_y - amount_y_out)
} else { 0 };</code>
		let (balance_x, balance_y) = token_balances<X, Y>();
let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
    balance_x - (reserves.reserve_x - amount_x_out)
} else { 0 };
let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
    balance_y - (reserves.reserve_y - amount_y_out)
} else { 0 };
		This part is crucial for maintaining the constant product formula (x * y = k):
		This part is crucial for maintaining the constant product formula (x * y = k):
		We first get the current balances of both tokens in the pool.
Then, we calculate the actual amounts of tokens that were input into the swap.
This calculation accounts for the possibility of a bidirectional swap, where both tokens might be both input and output.
If the current balance is higher than what it should be after output (reserves minus output), we know some tokens were input.
This step is essential for accurately updating the pool state after the swap.
		We first get the current balances of both tokens in the pool.
		We first get the current balances of both tokens in the pool.
		Then, we calculate the actual amounts of tokens that were input into the swap.
		Then, we calculate the actual amounts of tokens that were input into the swap.
		This calculation accounts for the possibility of a bidirectional swap, where both tokens might be both input and output.
		This calculation accounts for the possibility of a bidirectional swap, where both tokens might be both input and output.
		If the current balance is higher than what it should be after output (reserves minus output), we know some tokens were input.
		If the current balance is higher than what it should be after output (reserves minus output), we know some tokens were input.
		This step is essential for accurately updating the pool state after the swap.
		This step is essential for accurately updating the pool state after the swap.
		Price Impact Check
		Price Impact Check
		<code>let prec = (PRECISION as u128);
let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;</code>
		<code>let prec = (PRECISION as u128);
let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;</code>
		let prec = (PRECISION as u128);
let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
		This section prepares for the final K value check:
		This section prepares for the final K value check:
		We use a precision factor (PRECISION) to avoid dealing with fractional numbers.
We calculate adjusted balances by subtracting a portion of the input amounts. This accounts for the swap fee (0.25% in this case, as 25/10000 = 0.0025).
We also adjust the reserves using the same precision factor.
These adjustments allow us to perform accurate comparisons in the next step.
		We use a precision factor (PRECISION) to avoid dealing with fractional numbers.
		We use a precision factor (PRECISION) to avoid dealing with fractional numbers.
		We calculate adjusted balances by subtracting a portion of the input amounts. This accounts for the swap fee (0.25% in this case, as 25/10000 = 0.0025).
		We calculate adjusted balances by subtracting a portion of the input amounts. This accounts for the swap fee (0.25% in this case, as 25/10000 = 0.0025).
		We also adjust the reserves using the same precision factor.
		We also adjust the reserves using the same precision factor.
		These adjustments allow us to perform accurate comparisons in the next step.
		These adjustments allow us to perform accurate comparisons in the next step.
		Final Verification
		Final Verification
		<code>let compare_result = if (balance_x_adjusted > 0 && reserve_x_adjusted > 0 &&
    MAX_U128 / balance_x_adjusted > balance_y_adjusted &&
    MAX_U128 / reserve_x_adjusted > reserve_y_adjusted) {
    balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
} else {
    let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
    let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
    p >= k
};
assert!(compare_result, ERROR_K);</code>
		<code>let compare_result = if (balance_x_adjusted > 0 && reserve_x_adjusted > 0 &&
    MAX_U128 / balance_x_adjusted > balance_y_adjusted &&
    MAX_U128 / reserve_x_adjusted > reserve_y_adjusted) {
    balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
} else {
    let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
    let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
    p >= k
};
assert!(compare_result, ERROR_K);</code>
		let compare_result = if (balance_x_adjusted > 0 && reserve_x_adjusted > 0 &&
    MAX_U128 / balance_x_adjusted > balance_y_adjusted &&
    MAX_U128 / reserve_x_adjusted > reserve_y_adjusted) {
    balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
} else {
    let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
    let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
    p >= k
};
assert!(compare_result, ERROR_K);
		This final check ensures that the constant product formula is maintained:
		This final check ensures that the constant product formula is maintained:
		We first check if we can safely multiply the adjusted balances without overflow.
If it's safe, we directly compare the product of adjusted balances with the product of adjusted reserves.
If there's a risk of overflow, we use larger u256 integers to perform the comparison.
The key here is that the new product (p) should be greater than or equal to the old product (k).
If this condition isn't met, it means the swap would adversely affect the pool's balance, and the transaction is reverted.
		We first check if we can safely multiply the adjusted balances without overflow.
		We first check if we can safely multiply the adjusted balances without overflow.
		If it's safe, we directly compare the product of adjusted balances with the product of adjusted reserves.
		If it's safe, we directly compare the product of adjusted balances with the product of adjusted reserves.
		If there's a risk of overflow, we use larger u256 integers to perform the comparison.
		If there's a risk of overflow, we use larger u256 integers to perform the comparison.
		The key here is that the new product (p) should be greater than or equal to the old product (k).
		The key here is that the new product (p) should be greater than or equal to the old product (k).
		If this condition isn't met, it means the swap would adversely affect the pool's balance, and the transaction is reverted.
		If this condition isn't met, it means the swap would adversely affect the pool's balance, and the transaction is reverted.
		Next, we'll explore the implementation of other swap types: swap_x_to_exact_y, swap_exact_y_to_x, and swap_y_to_exact_x.
		Next, we'll explore the implementation of other swap types: swap_x_to_exact_y, swap_exact_y_to_x, and swap_y_to_exact_x.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/02-swap/07-dex-full-code
DEX Full Code
DEX Full Code
module movement::swap {
    use std::signer;
    use std::option;
    use std::string;
    use aptos_std::type_info;
    use aptos_std::event;
    use aptos_std::math128;
    use aptos_framework::coin;
    use aptos_framework::timestamp;
    use aptos_framework::account;
    use aptos_framework::resource_account;
    use movement::swap_utils;
    const ZERO_ACCOUNT: address = @0x0;
    const DEFAULT_ADMIN: address = @movement;
    const RESOURCE_ACCOUNT: address = @movement;
    const DEV: address = @dev;
    const MINIMUM_LIQUIDITY: u128 = 1000;
    const MAX_COIN_NAME_LENGTH: u64 = 32;
    // List of errors
    const ERROR_ONLY_ADMIN: u64 = 0;
    const ERROR_ALREADY_INITIALIZED: u64 = 1;
    const ERROR_NOT_CREATOR: u64 = 2;
    const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 4;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 6;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 7;
    const ERROR_INVALID_AMOUNT: u64 = 8;
    const ERROR_TOKENS_NOT_SORTED: u64 = 9;
    const ERROR_INSUFFICIENT_LIQUIDITY_BURNED: u64 = 10;
    const ERROR_INSUFFICIENT_OUTPUT_AMOUNT: u64 = 13;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 14;
    const ERROR_K: u64 = 15;
    const ERROR_X_NOT_REGISTERED: u64 = 16;
    const ERROR_Y_NOT_REGISTERED: u64 = 16;
    const ERROR_NOT_ADMIN: u64 = 17;
    const ERROR_NOT_FEE_TO: u64 = 18;
    const ERROR_NOT_EQUAL_EXACT_AMOUNT: u64 = 19;
    const ERROR_NOT_RESOURCE_ACCOUNT: u64 = 20;
    const ERROR_NO_FEE_WITHDRAW: u64 = 21;
    const PRECISION: u64 = 10000;
    /// Max `u128` value.
    const MAX_U128: u128 = 340282366920938463463374607431768211455;
    /// The LP Token type
    struct LPToken<phantom X, phantom Y> has key {}
    /// Stores the metadata required for the token pairs
    struct TokenPairMetadata<phantom X, phantom Y> has key {
        /// The admin of the token pair
        creator: address,
        /// fee amount , record fee amount which is not withdrawed
        fee_amount: coin::Coin<LPToken<X, Y>>,
        /// It's reserve_x * reserve_y, as of immediately after the most recent liquidity event
        k_last: u128,
        /// T0 token balance
        balance_x: coin::Coin<X>,
        /// T1 token balance
        balance_y: coin::Coin<Y>,
        /// Mint capacity of LP Token
        mint_cap: coin::MintCapability<LPToken<X, Y>>,
        /// Burn capacity of LP Token
        burn_cap: coin::BurnCapability<LPToken<X, Y>>,
        /// Freeze capacity of LP Token
        freeze_cap: coin::FreezeCapability<LPToken<X, Y>>,
    }
    /// Stores the reservation info required for the token pairs
    struct TokenPairReserve<phantom X, phantom Y> has key {
        reserve_x: u64,
        reserve_y: u64,
        block_timestamp_last: u64
    }
    struct SwapInfo has key {
        signer_cap: account::SignerCapability,
        fee_to: address,
        admin: address,
        pair_created: event::EventHandle<PairCreatedEvent>
    }
    struct PairCreatedEvent has drop, store {
        user: address,
        token_x: string::String,
        token_y: string::String
    }
    struct PairEventHolder<phantom X, phantom Y> has key {
        add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
        remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
        swap: event::EventHandle<SwapEvent<X, Y>>
    }
    struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x: u64,
        amount_y: u64,
        liquidity: u64,
        fee_amount: u64
    }
    struct RemoveLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        liquidity: u64,
        amount_x: u64,
        amount_y: u64,
        fee_amount: u64
    }
    struct SwapEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    }
    /*
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     Please use swap_util::sort_token_type<X,Y>()
     before using any function
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    */
    fun init_module(sender: &signer) {
        let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEV);
        let resource_signer = account::create_signer_with_capability(&signer_cap);
        move_to(&resource_signer, SwapInfo {
            signer_cap,
            fee_to: ZERO_ACCOUNT,
            admin: DEFAULT_ADMIN,
            pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
        });
    }
    /// Create the specified coin pair
    public(friend) fun create_pair<X, Y>(
        sender: &signer,
    ) acquires SwapInfo {
        assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
        let lp_name: string::String = string::utf8(b"movement-");
        let name_x = coin::symbol<X>();
        let name_y = coin::symbol<Y>();
        string::append(&mut lp_name, name_x);
        string::append_utf8(&mut lp_name, b"-");
        string::append(&mut lp_name, name_y);
        string::append_utf8(&mut lp_name, b"-LP");
        if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
            lp_name = string::utf8(b"movement LPs");
        };
        // now we init the LP token
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
            &resource_signer,
            lp_name,
            string::utf8(b"Cake-LP"),
            8,
            true
        );
        move_to<TokenPairReserve<X, Y>>(
            &resource_signer,
            TokenPairReserve {
                reserve_x: 0,
                reserve_y: 0,
                block_timestamp_last: 0
            }
        );
        move_to<TokenPairMetadata<X, Y>>(
            &resource_signer,
            TokenPairMetadata {
                creator: sender_addr,
                fee_amount: coin::zero<LPToken<X, Y>>(),
                k_last: 0,
                balance_x: coin::zero<X>(),
                balance_y: coin::zero<Y>(),
                mint_cap,
                burn_cap,
                freeze_cap,
            }
        );
        move_to<PairEventHolder<X, Y>>(
            &resource_signer,
            PairEventHolder {
                add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
                remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
                swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
            }
        );
        // pair created event
        let token_x = type_info::type_name<X>();
        let token_y = type_info::type_name<Y>();
        event::emit_event<PairCreatedEvent>(
            &mut swap_info.pair_created,
            PairCreatedEvent {
                user: sender_addr,
                token_x,
                token_y
            }
        );
        // create LP CoinStore , which is needed as a lock for minimum_liquidity
        register_lp<X, Y>(&resource_signer);
    }
    public fun register_lp<X, Y>(sender: &signer) {
        coin::register<LPToken<X, Y>>(sender);
    }
    public fun is_pair_created<X, Y>(): bool {
        exists<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT)
    }
    /// Obtain the LP token balance of `addr`.
    /// This method can only be used to check other users' balance.
    public fun lp_balance<X, Y>(addr: address): u64 {
        coin::balance<LPToken<X, Y>>(addr)
    }
    /// Get the total supply of LP Tokens
    public fun total_lp_supply<X, Y>(): u128 {
        option::get_with_default(
            &coin::supply<LPToken<X, Y>>(),
            0u128
        )
    }
    /// Get the current reserves of T0 and T1 with the latest updated timestamp
    public fun token_reserves<X, Y>(): (u64, u64, u64) acquires TokenPairReserve {
        let reserve = borrow_global<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        (
            reserve.reserve_x,
            reserve.reserve_y,
            reserve.block_timestamp_last
        )
    }
    /// The amount of balance currently in pools of the liquidity pair
    public fun token_balances<X, Y>(): (u64, u64) acquires TokenPairMetadata {
        let meta =
            borrow_global<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        (
            coin::value(&meta.balance_x),
            coin::value(&meta.balance_y)
        )
    }
    public fun check_or_register_coin_store<X>(sender: &signer) {
        if (!coin::is_account_registered<X>(signer::address_of(sender))) {
            coin::register<X>(sender);
        };
    }
    public fun admin(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.admin
    }
    public fun fee_to(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.fee_to
    }
    // ===================== Update functions ======================
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    public(friend) fun add_liquidity<X, Y>(
        sender: &signer,
        amount_x: u64,
        amount_y: u64
    ): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
        let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = add_liquidity_direct(coin::withdraw<X>(sender, amount_x), coin::withdraw<Y>(sender, amount_y));
        let sender_addr = signer::address_of(sender);
        let lp_amount = coin::value(&coin_lp);
        assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        check_or_register_coin_store<LPToken<X, Y>>(sender);
        coin::deposit(sender_addr, coin_lp);
        coin::deposit(sender_addr, coin_left_x);
        coin::deposit(sender_addr, coin_left_y);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<AddLiquidityEvent<X, Y>>(
            &mut pair_event_holder.add_liquidity,
            AddLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x: a_x,
                amount_y: a_y,
                liquidity: lp_amount,
                fee_amount: (fee_amount as u64),
            }
        );
        (a_x, a_y, lp_amount)
    }
    public(friend) fun add_swap_event<X, Y>(
        sender: &signer,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let sender_addr = signer::address_of(sender);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    public(friend) fun add_swap_event_with_address<X, Y>(
        sender_addr: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    fun add_liquidity_direct<X, Y>(
        x: coin::Coin<X>,
        y: coin::Coin<Y>,
    ): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_x = coin::value(&x);
        let amount_y = coin::value(&y);
        let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
        let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
            (amount_x, amount_y)
        } else {
            let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
            if (amount_y_optimal <= amount_y) {
                (amount_x, amount_y_optimal)
            } else {
                let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
                assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
                (amount_x_optimal, amount_y)
            }
        };
        assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
        assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
        let left_x = coin::extract(&mut x, amount_x - a_x);
        let left_y = coin::extract(&mut y, amount_y - a_y);
        deposit_x<X, Y>(x);
        deposit_y<X, Y>(y);
        let (lp, fee_amount) = mint<X, Y>();
        (a_x, a_y, lp, fee_amount, left_x, left_y)
    }
    /// Remove liquidity to token types.
    public(friend) fun remove_liquidity<X, Y>(
        sender: &signer,
        liquidity: u64,
    ): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
        let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
        let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
        let amount_x = coin::value(&coins_x);
        let amount_y = coin::value(&coins_y);
        check_or_register_coin_store<X>(sender);
        check_or_register_coin_store<Y>(sender);
        let sender_addr = signer::address_of(sender);
        coin::deposit<X>(sender_addr, coins_x);
        coin::deposit<Y>(sender_addr, coins_y);
        // event
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<RemoveLiquidityEvent<X, Y>>(
            &mut pair_event_holder.remove_liquidity,
            RemoveLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x,
                amount_y,
                liquidity,
                fee_amount: (fee_amount as u64)
            }
        );
        (amount_x, amount_y)
    }
    /// Remove liquidity to token types.
    fun remove_liquidity_direct<X, Y>(
        liquidity: coin::Coin<LPToken<X, Y>>,
    ): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        burn<X, Y>(liquidity)
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
        let amount_out = coin::value(&coins_y_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_out
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y_direct<X, Y>(
        coins_in: coin::Coin<X>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<X>(&coins_in);
        deposit_x<X, Y>(coins_in);
        let (rin, rout, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    public(friend) fun swap_x_to_exact_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_x_to_exact_y_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_in
    }
    public(friend) fun swap_x_to_exact_y_direct<X, Y>(
        coins_in: coin::Coin<X>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_x<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_y_to_x_direct<X, Y>(coins);
        let amount_out = coin::value<X>(&coins_x_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_out
    }
    public(friend) fun swap_y_to_exact_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_y_to_exact_x_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_in
    }
    public(friend) fun swap_y_to_exact_x_direct<X, Y>(
        coins_in: coin::Coin<Y>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_y<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x_direct<X, Y>(
        coins_in: coin::Coin<Y>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<Y>(&coins_in);
        deposit_y<X, Y>(coins_in);
        let (rout, rin, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    fun swap<X, Y>(
        amount_x_out: u64,
        amount_y_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        assert!(amount_x_out < reserves.reserve_x && amount_y_out < reserves.reserve_y, ERROR_INSUFFICIENT_LIQUIDITY);
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let coins_x_out = coin::zero<X>();
        let coins_y_out = coin::zero<Y>();
        if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
        if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
        let (balance_x, balance_y) = token_balances<X, Y>();
        let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
            balance_x - (reserves.reserve_x - amount_x_out)
        } else { 0 };
        let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
            balance_y - (reserves.reserve_y - amount_y_out)
        } else { 0 };
        assert!(amount_x_in > 0 || amount_y_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        let prec = (PRECISION as u128);
        let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
        let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
        let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
        let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
        // No need to use u256 when balance_x_adjusted * balance_y_adjusted and reserve_x_adjusted * reserve_y_adjusted are less than MAX_U128.
        let compare_result = if(balance_x_adjusted > 0 && reserve_x_adjusted > 0 && MAX_U128 / balance_x_adjusted > balance_y_adjusted && MAX_U128 / reserve_x_adjusted > reserve_y_adjusted){
            balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
        }else{
            let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
            let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
            p >= k
        };
        assert!(compare_result, ERROR_K);
        update(balance_x, balance_y, reserves);
        (coins_x_out, coins_y_out)
    }
    /// Mint LP Token.
    /// This low-level function should be called from a contract which performs important safety checks
    fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
        let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_supply = total_lp_supply<X, Y>();
        let liquidity = if (total_supply == 0u128) {
            let sqrt = math128::sqrt(amount_x * amount_y);
            assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            let l = sqrt - MINIMUM_LIQUIDITY;
            // permanently lock the first MINIMUM_LIQUIDITY tokens
            mint_lp_to<X, Y>(RESOURCE_ACCOUNT, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
            l
        } else {
            let liquidity = math128::min(amount_x * total_supply / (reserves.reserve_x as u128), amount_y * total_supply / (reserves.reserve_y as u128));
            assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            liquidity
        };
        let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
        update<X, Y>(balance_x, balance_y, reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (lp, fee_amount)
    }
    fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let liquidity = coin::value(&lp_tokens);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_lp_supply = total_lp_supply<X, Y>();
        let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
        coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
        let w_x = extract_x((amount_x as u64), metadata);
        let w_y = extract_y((amount_y as u64), metadata);
        update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (w_x, w_y, fee_amount)
    }
    fun update<X, Y>(balance_x: u64, balance_y: u64, reserve: &mut TokenPairReserve<X, Y>) {
        let block_timestamp = timestamp::now_seconds();
        reserve.reserve_x = balance_x;
        reserve.reserve_y = balance_y;
        reserve.block_timestamp_last = block_timestamp;
    }
    /// Mint LP Tokens to account
    fun mint_lp_to<X, Y>(
        to: address,
        amount: u64,
        mint_cap: &coin::MintCapability<LPToken<X, Y>>
    ) {
        let coins = coin::mint<LPToken<X, Y>>(amount, mint_cap);
        coin::deposit(to, coins);
    }
    /// Mint LP Tokens to account
    fun mint_lp<X, Y>(amount: u64, mint_cap: &coin::MintCapability<LPToken<X, Y>>): coin::Coin<LPToken<X, Y>> {
        coin::mint<LPToken<X, Y>>(amount, mint_cap)
    }
    fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_x, amount);
    }
    fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_y, amount);
    }
    /// Extract `amount` from this contract
    fun extract_x<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<X> {
        assert!(coin::value<X>(&metadata.balance_x) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_x, amount)
    }
    /// Extract `amount` from this contract
    fun extract_y<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<Y> {
        assert!(coin::value<Y>(&metadata.balance_y) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_y, amount)
    }
    fun mint_fee<X, Y>(reserve_x: u64, reserve_y: u64, metadata: &mut TokenPairMetadata<X, Y>): u64 {
        let fee = 0u64;
        if (metadata.k_last != 0) {
            let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
            let root_k_last = math128::sqrt(metadata.k_last);
            if (root_k > root_k_last) {
                let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
                let denominator = root_k_last * 17u128 + (root_k * 8u128);
                let liquidity = numerator / denominator;
                fee = (liquidity as u64);
                // record fee amount in metadata, in case of fee_to with register.
                if (fee > 0) {
                    let coin = mint_lp(fee, &metadata.mint_cap);
                    coin::merge(&mut metadata.fee_amount, coin);
                }
            };
        };
        fee
    }
    public entry fun set_admin(sender: &signer, new_admin: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.admin = new_admin;
    }
    public entry fun set_fee_to(sender: &signer, new_fee_to: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.fee_to = new_fee_to;
    }
}
module movement::swap_utils {
    use std::string;
    use aptos_std::type_info;
    const EQUAL: u8 = 0;
    const SMALLER: u8 = 1;
    const GREATER: u8 = 2;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 0;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 1;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 2;
    const ERROR_INSUFFICIENT_OUTPOT_AMOUNT: u64 = 3;
    const ERROR_SAME_COIN: u64 = 4;
    public fun get_amount_out(
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let amount_in_with_fee = (amount_in as u128) * 9975u128;
        let numerator = amount_in_with_fee * (reserve_out as u128);
        let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
        ((numerator / denominator) as u64)
    }
    public fun get_amount_in(
        amount_out: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_out > 0, ERROR_INSUFFICIENT_OUTPOT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let numerator = (reserve_in as u128) * (amount_out as u128) * 10000u128;
        let denominator = ((reserve_out as u128) - (amount_out as u128)) * 9975u128;
        (((numerator / denominator) as u64) + 1u64)
    }
    public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
        assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
        assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
    }
    public fun get_token_info<T>(): vector<u8> {
        let type_name = type_info::type_name<T>();
        *string::bytes(&type_name)
    }
}
module movement::swap {
    use std::signer;
    use std::option;
    use std::string;
    use aptos_std::type_info;
    use aptos_std::event;
    use aptos_std::math128;
    use aptos_framework::coin;
    use aptos_framework::timestamp;
    use aptos_framework::account;
    use aptos_framework::resource_account;
    use movement::swap_utils;
    const ZERO_ACCOUNT: address = @0x0;
    const DEFAULT_ADMIN: address = @movement;
    const RESOURCE_ACCOUNT: address = @movement;
    const DEV: address = @dev;
    const MINIMUM_LIQUIDITY: u128 = 1000;
    const MAX_COIN_NAME_LENGTH: u64 = 32;
    // List of errors
    const ERROR_ONLY_ADMIN: u64 = 0;
    const ERROR_ALREADY_INITIALIZED: u64 = 1;
    const ERROR_NOT_CREATOR: u64 = 2;
    const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 4;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 6;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 7;
    const ERROR_INVALID_AMOUNT: u64 = 8;
    const ERROR_TOKENS_NOT_SORTED: u64 = 9;
    const ERROR_INSUFFICIENT_LIQUIDITY_BURNED: u64 = 10;
    const ERROR_INSUFFICIENT_OUTPUT_AMOUNT: u64 = 13;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 14;
    const ERROR_K: u64 = 15;
    const ERROR_X_NOT_REGISTERED: u64 = 16;
    const ERROR_Y_NOT_REGISTERED: u64 = 16;
    const ERROR_NOT_ADMIN: u64 = 17;
    const ERROR_NOT_FEE_TO: u64 = 18;
    const ERROR_NOT_EQUAL_EXACT_AMOUNT: u64 = 19;
    const ERROR_NOT_RESOURCE_ACCOUNT: u64 = 20;
    const ERROR_NO_FEE_WITHDRAW: u64 = 21;
    const PRECISION: u64 = 10000;
    /// Max `u128` value.
    const MAX_U128: u128 = 340282366920938463463374607431768211455;
    /// The LP Token type
    struct LPToken<phantom X, phantom Y> has key {}
    /// Stores the metadata required for the token pairs
    struct TokenPairMetadata<phantom X, phantom Y> has key {
        /// The admin of the token pair
        creator: address,
        /// fee amount , record fee amount which is not withdrawed
        fee_amount: coin::Coin<LPToken<X, Y>>,
        /// It's reserve_x * reserve_y, as of immediately after the most recent liquidity event
        k_last: u128,
        /// T0 token balance
        balance_x: coin::Coin<X>,
        /// T1 token balance
        balance_y: coin::Coin<Y>,
        /// Mint capacity of LP Token
        mint_cap: coin::MintCapability<LPToken<X, Y>>,
        /// Burn capacity of LP Token
        burn_cap: coin::BurnCapability<LPToken<X, Y>>,
        /// Freeze capacity of LP Token
        freeze_cap: coin::FreezeCapability<LPToken<X, Y>>,
    }
    /// Stores the reservation info required for the token pairs
    struct TokenPairReserve<phantom X, phantom Y> has key {
        reserve_x: u64,
        reserve_y: u64,
        block_timestamp_last: u64
    }
    struct SwapInfo has key {
        signer_cap: account::SignerCapability,
        fee_to: address,
        admin: address,
        pair_created: event::EventHandle<PairCreatedEvent>
    }
    struct PairCreatedEvent has drop, store {
        user: address,
        token_x: string::String,
        token_y: string::String
    }
    struct PairEventHolder<phantom X, phantom Y> has key {
        add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
        remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
        swap: event::EventHandle<SwapEvent<X, Y>>
    }
    struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x: u64,
        amount_y: u64,
        liquidity: u64,
        fee_amount: u64
    }
    struct RemoveLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        liquidity: u64,
        amount_x: u64,
        amount_y: u64,
        fee_amount: u64
    }
    struct SwapEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    }
    /*
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     Please use swap_util::sort_token_type<X,Y>()
     before using any function
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    */
    fun init_module(sender: &signer) {
        let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEV);
        let resource_signer = account::create_signer_with_capability(&signer_cap);
        move_to(&resource_signer, SwapInfo {
            signer_cap,
            fee_to: ZERO_ACCOUNT,
            admin: DEFAULT_ADMIN,
            pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
        });
    }
    /// Create the specified coin pair
    public(friend) fun create_pair<X, Y>(
        sender: &signer,
    ) acquires SwapInfo {
        assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
        let lp_name: string::String = string::utf8(b"movement-");
        let name_x = coin::symbol<X>();
        let name_y = coin::symbol<Y>();
        string::append(&mut lp_name, name_x);
        string::append_utf8(&mut lp_name, b"-");
        string::append(&mut lp_name, name_y);
        string::append_utf8(&mut lp_name, b"-LP");
        if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
            lp_name = string::utf8(b"movement LPs");
        };
        // now we init the LP token
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
            &resource_signer,
            lp_name,
            string::utf8(b"Cake-LP"),
            8,
            true
        );
        move_to<TokenPairReserve<X, Y>>(
            &resource_signer,
            TokenPairReserve {
                reserve_x: 0,
                reserve_y: 0,
                block_timestamp_last: 0
            }
        );
        move_to<TokenPairMetadata<X, Y>>(
            &resource_signer,
            TokenPairMetadata {
                creator: sender_addr,
                fee_amount: coin::zero<LPToken<X, Y>>(),
                k_last: 0,
                balance_x: coin::zero<X>(),
                balance_y: coin::zero<Y>(),
                mint_cap,
                burn_cap,
                freeze_cap,
            }
        );
        move_to<PairEventHolder<X, Y>>(
            &resource_signer,
            PairEventHolder {
                add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
                remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
                swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
            }
        );
        // pair created event
        let token_x = type_info::type_name<X>();
        let token_y = type_info::type_name<Y>();
        event::emit_event<PairCreatedEvent>(
            &mut swap_info.pair_created,
            PairCreatedEvent {
                user: sender_addr,
                token_x,
                token_y
            }
        );
        // create LP CoinStore , which is needed as a lock for minimum_liquidity
        register_lp<X, Y>(&resource_signer);
    }
    public fun register_lp<X, Y>(sender: &signer) {
        coin::register<LPToken<X, Y>>(sender);
    }
    public fun is_pair_created<X, Y>(): bool {
        exists<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT)
    }
    /// Obtain the LP token balance of `addr`.
    /// This method can only be used to check other users' balance.
    public fun lp_balance<X, Y>(addr: address): u64 {
        coin::balance<LPToken<X, Y>>(addr)
    }
    /// Get the total supply of LP Tokens
    public fun total_lp_supply<X, Y>(): u128 {
        option::get_with_default(
            &coin::supply<LPToken<X, Y>>(),
            0u128
        )
    }
    /// Get the current reserves of T0 and T1 with the latest updated timestamp
    public fun token_reserves<X, Y>(): (u64, u64, u64) acquires TokenPairReserve {
        let reserve = borrow_global<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        (
            reserve.reserve_x,
            reserve.reserve_y,
            reserve.block_timestamp_last
        )
    }
    /// The amount of balance currently in pools of the liquidity pair
    public fun token_balances<X, Y>(): (u64, u64) acquires TokenPairMetadata {
        let meta =
            borrow_global<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        (
            coin::value(&meta.balance_x),
            coin::value(&meta.balance_y)
        )
    }
    public fun check_or_register_coin_store<X>(sender: &signer) {
        if (!coin::is_account_registered<X>(signer::address_of(sender))) {
            coin::register<X>(sender);
        };
    }
    public fun admin(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.admin
    }
    public fun fee_to(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.fee_to
    }
    // ===================== Update functions ======================
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    public(friend) fun add_liquidity<X, Y>(
        sender: &signer,
        amount_x: u64,
        amount_y: u64
    ): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
        let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = add_liquidity_direct(coin::withdraw<X>(sender, amount_x), coin::withdraw<Y>(sender, amount_y));
        let sender_addr = signer::address_of(sender);
        let lp_amount = coin::value(&coin_lp);
        assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        check_or_register_coin_store<LPToken<X, Y>>(sender);
        coin::deposit(sender_addr, coin_lp);
        coin::deposit(sender_addr, coin_left_x);
        coin::deposit(sender_addr, coin_left_y);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<AddLiquidityEvent<X, Y>>(
            &mut pair_event_holder.add_liquidity,
            AddLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x: a_x,
                amount_y: a_y,
                liquidity: lp_amount,
                fee_amount: (fee_amount as u64),
            }
        );
        (a_x, a_y, lp_amount)
    }
    public(friend) fun add_swap_event<X, Y>(
        sender: &signer,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let sender_addr = signer::address_of(sender);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    public(friend) fun add_swap_event_with_address<X, Y>(
        sender_addr: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    fun add_liquidity_direct<X, Y>(
        x: coin::Coin<X>,
        y: coin::Coin<Y>,
    ): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_x = coin::value(&x);
        let amount_y = coin::value(&y);
        let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
        let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
            (amount_x, amount_y)
        } else {
            let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
            if (amount_y_optimal <= amount_y) {
                (amount_x, amount_y_optimal)
            } else {
                let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
                assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
                (amount_x_optimal, amount_y)
            }
        };
        assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
        assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
        let left_x = coin::extract(&mut x, amount_x - a_x);
        let left_y = coin::extract(&mut y, amount_y - a_y);
        deposit_x<X, Y>(x);
        deposit_y<X, Y>(y);
        let (lp, fee_amount) = mint<X, Y>();
        (a_x, a_y, lp, fee_amount, left_x, left_y)
    }
    /// Remove liquidity to token types.
    public(friend) fun remove_liquidity<X, Y>(
        sender: &signer,
        liquidity: u64,
    ): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
        let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
        let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
        let amount_x = coin::value(&coins_x);
        let amount_y = coin::value(&coins_y);
        check_or_register_coin_store<X>(sender);
        check_or_register_coin_store<Y>(sender);
        let sender_addr = signer::address_of(sender);
        coin::deposit<X>(sender_addr, coins_x);
        coin::deposit<Y>(sender_addr, coins_y);
        // event
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<RemoveLiquidityEvent<X, Y>>(
            &mut pair_event_holder.remove_liquidity,
            RemoveLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x,
                amount_y,
                liquidity,
                fee_amount: (fee_amount as u64)
            }
        );
        (amount_x, amount_y)
    }
    /// Remove liquidity to token types.
    fun remove_liquidity_direct<X, Y>(
        liquidity: coin::Coin<LPToken<X, Y>>,
    ): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        burn<X, Y>(liquidity)
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
        let amount_out = coin::value(&coins_y_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_out
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y_direct<X, Y>(
        coins_in: coin::Coin<X>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<X>(&coins_in);
        deposit_x<X, Y>(coins_in);
        let (rin, rout, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    public(friend) fun swap_x_to_exact_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_x_to_exact_y_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_in
    }
    public(friend) fun swap_x_to_exact_y_direct<X, Y>(
        coins_in: coin::Coin<X>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_x<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_y_to_x_direct<X, Y>(coins);
        let amount_out = coin::value<X>(&coins_x_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_out
    }
    public(friend) fun swap_y_to_exact_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_y_to_exact_x_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_in
    }
    public(friend) fun swap_y_to_exact_x_direct<X, Y>(
        coins_in: coin::Coin<Y>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_y<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x_direct<X, Y>(
        coins_in: coin::Coin<Y>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<Y>(&coins_in);
        deposit_y<X, Y>(coins_in);
        let (rout, rin, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    fun swap<X, Y>(
        amount_x_out: u64,
        amount_y_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        assert!(amount_x_out < reserves.reserve_x && amount_y_out < reserves.reserve_y, ERROR_INSUFFICIENT_LIQUIDITY);
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let coins_x_out = coin::zero<X>();
        let coins_y_out = coin::zero<Y>();
        if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
        if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
        let (balance_x, balance_y) = token_balances<X, Y>();
        let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
            balance_x - (reserves.reserve_x - amount_x_out)
        } else { 0 };
        let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
            balance_y - (reserves.reserve_y - amount_y_out)
        } else { 0 };
        assert!(amount_x_in > 0 || amount_y_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        let prec = (PRECISION as u128);
        let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
        let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
        let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
        let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
        // No need to use u256 when balance_x_adjusted * balance_y_adjusted and reserve_x_adjusted * reserve_y_adjusted are less than MAX_U128.
        let compare_result = if(balance_x_adjusted > 0 && reserve_x_adjusted > 0 && MAX_U128 / balance_x_adjusted > balance_y_adjusted && MAX_U128 / reserve_x_adjusted > reserve_y_adjusted){
            balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
        }else{
            let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
            let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
            p >= k
        };
        assert!(compare_result, ERROR_K);
        update(balance_x, balance_y, reserves);
        (coins_x_out, coins_y_out)
    }
    /// Mint LP Token.
    /// This low-level function should be called from a contract which performs important safety checks
    fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
        let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_supply = total_lp_supply<X, Y>();
        let liquidity = if (total_supply == 0u128) {
            let sqrt = math128::sqrt(amount_x * amount_y);
            assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            let l = sqrt - MINIMUM_LIQUIDITY;
            // permanently lock the first MINIMUM_LIQUIDITY tokens
            mint_lp_to<X, Y>(RESOURCE_ACCOUNT, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
            l
        } else {
            let liquidity = math128::min(amount_x * total_supply / (reserves.reserve_x as u128), amount_y * total_supply / (reserves.reserve_y as u128));
            assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            liquidity
        };
        let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
        update<X, Y>(balance_x, balance_y, reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (lp, fee_amount)
    }
    fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let liquidity = coin::value(&lp_tokens);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_lp_supply = total_lp_supply<X, Y>();
        let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
        coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
        let w_x = extract_x((amount_x as u64), metadata);
        let w_y = extract_y((amount_y as u64), metadata);
        update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (w_x, w_y, fee_amount)
    }
    fun update<X, Y>(balance_x: u64, balance_y: u64, reserve: &mut TokenPairReserve<X, Y>) {
        let block_timestamp = timestamp::now_seconds();
        reserve.reserve_x = balance_x;
        reserve.reserve_y = balance_y;
        reserve.block_timestamp_last = block_timestamp;
    }
    /// Mint LP Tokens to account
    fun mint_lp_to<X, Y>(
        to: address,
        amount: u64,
        mint_cap: &coin::MintCapability<LPToken<X, Y>>
    ) {
        let coins = coin::mint<LPToken<X, Y>>(amount, mint_cap);
        coin::deposit(to, coins);
    }
    /// Mint LP Tokens to account
    fun mint_lp<X, Y>(amount: u64, mint_cap: &coin::MintCapability<LPToken<X, Y>>): coin::Coin<LPToken<X, Y>> {
        coin::mint<LPToken<X, Y>>(amount, mint_cap)
    }
    fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_x, amount);
    }
    fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_y, amount);
    }
    /// Extract `amount` from this contract
    fun extract_x<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<X> {
        assert!(coin::value<X>(&metadata.balance_x) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_x, amount)
    }
    /// Extract `amount` from this contract
    fun extract_y<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<Y> {
        assert!(coin::value<Y>(&metadata.balance_y) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_y, amount)
    }
    fun mint_fee<X, Y>(reserve_x: u64, reserve_y: u64, metadata: &mut TokenPairMetadata<X, Y>): u64 {
        let fee = 0u64;
        if (metadata.k_last != 0) {
            let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
            let root_k_last = math128::sqrt(metadata.k_last);
            if (root_k > root_k_last) {
                let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
                let denominator = root_k_last * 17u128 + (root_k * 8u128);
                let liquidity = numerator / denominator;
                fee = (liquidity as u64);
                // record fee amount in metadata, in case of fee_to with register.
                if (fee > 0) {
                    let coin = mint_lp(fee, &metadata.mint_cap);
                    coin::merge(&mut metadata.fee_amount, coin);
                }
            };
        };
        fee
    }
    public entry fun set_admin(sender: &signer, new_admin: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.admin = new_admin;
    }
    public entry fun set_fee_to(sender: &signer, new_fee_to: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.fee_to = new_fee_to;
    }
}
module movement::swap_utils {
    use std::string;
    use aptos_std::type_info;
    const EQUAL: u8 = 0;
    const SMALLER: u8 = 1;
    const GREATER: u8 = 2;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 0;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 1;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 2;
    const ERROR_INSUFFICIENT_OUTPOT_AMOUNT: u64 = 3;
    const ERROR_SAME_COIN: u64 = 4;
    public fun get_amount_out(
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let amount_in_with_fee = (amount_in as u128) * 9975u128;
        let numerator = amount_in_with_fee * (reserve_out as u128);
        let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
        ((numerator / denominator) as u64)
    }
    public fun get_amount_in(
        amount_out: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_out > 0, ERROR_INSUFFICIENT_OUTPOT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let numerator = (reserve_in as u128) * (amount_out as u128) * 10000u128;
        let denominator = ((reserve_out as u128) - (amount_out as u128)) * 9975u128;
        (((numerator / denominator) as u64) + 1u64)
    }
    public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
        assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
        assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
    }
    public fun get_token_info<T>(): vector<u8> {
        let type_name = type_info::type_name<T>();
        *string::bytes(&type_name)
    }
}
module movement::swap {
    use std::signer;
    use std::option;
    use std::string;
    use aptos_std::type_info;
    use aptos_std::event;
    use aptos_std::math128;
    use aptos_framework::coin;
    use aptos_framework::timestamp;
    use aptos_framework::account;
    use aptos_framework::resource_account;
    use movement::swap_utils;
    const ZERO_ACCOUNT: address = @0x0;
    const DEFAULT_ADMIN: address = @movement;
    const RESOURCE_ACCOUNT: address = @movement;
    const DEV: address = @dev;
    const MINIMUM_LIQUIDITY: u128 = 1000;
    const MAX_COIN_NAME_LENGTH: u64 = 32;
    // List of errors
    const ERROR_ONLY_ADMIN: u64 = 0;
    const ERROR_ALREADY_INITIALIZED: u64 = 1;
    const ERROR_NOT_CREATOR: u64 = 2;
    const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 4;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 6;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 7;
    const ERROR_INVALID_AMOUNT: u64 = 8;
    const ERROR_TOKENS_NOT_SORTED: u64 = 9;
    const ERROR_INSUFFICIENT_LIQUIDITY_BURNED: u64 = 10;
    const ERROR_INSUFFICIENT_OUTPUT_AMOUNT: u64 = 13;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 14;
    const ERROR_K: u64 = 15;
    const ERROR_X_NOT_REGISTERED: u64 = 16;
    const ERROR_Y_NOT_REGISTERED: u64 = 16;
    const ERROR_NOT_ADMIN: u64 = 17;
    const ERROR_NOT_FEE_TO: u64 = 18;
    const ERROR_NOT_EQUAL_EXACT_AMOUNT: u64 = 19;
    const ERROR_NOT_RESOURCE_ACCOUNT: u64 = 20;
    const ERROR_NO_FEE_WITHDRAW: u64 = 21;
    const PRECISION: u64 = 10000;
    /// Max `u128` value.
    const MAX_U128: u128 = 340282366920938463463374607431768211455;
    /// The LP Token type
    struct LPToken<phantom X, phantom Y> has key {}
    /// Stores the metadata required for the token pairs
    struct TokenPairMetadata<phantom X, phantom Y> has key {
        /// The admin of the token pair
        creator: address,
        /// fee amount , record fee amount which is not withdrawed
        fee_amount: coin::Coin<LPToken<X, Y>>,
        /// It's reserve_x * reserve_y, as of immediately after the most recent liquidity event
        k_last: u128,
        /// T0 token balance
        balance_x: coin::Coin<X>,
        /// T1 token balance
        balance_y: coin::Coin<Y>,
        /// Mint capacity of LP Token
        mint_cap: coin::MintCapability<LPToken<X, Y>>,
        /// Burn capacity of LP Token
        burn_cap: coin::BurnCapability<LPToken<X, Y>>,
        /// Freeze capacity of LP Token
        freeze_cap: coin::FreezeCapability<LPToken<X, Y>>,
    }
    /// Stores the reservation info required for the token pairs
    struct TokenPairReserve<phantom X, phantom Y> has key {
        reserve_x: u64,
        reserve_y: u64,
        block_timestamp_last: u64
    }
    struct SwapInfo has key {
        signer_cap: account::SignerCapability,
        fee_to: address,
        admin: address,
        pair_created: event::EventHandle<PairCreatedEvent>
    }
    struct PairCreatedEvent has drop, store {
        user: address,
        token_x: string::String,
        token_y: string::String
    }
    struct PairEventHolder<phantom X, phantom Y> has key {
        add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
        remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
        swap: event::EventHandle<SwapEvent<X, Y>>
    }
    struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x: u64,
        amount_y: u64,
        liquidity: u64,
        fee_amount: u64
    }
    struct RemoveLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        liquidity: u64,
        amount_x: u64,
        amount_y: u64,
        fee_amount: u64
    }
    struct SwapEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    }
    /*
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     Please use swap_util::sort_token_type<X,Y>()
     before using any function
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    */
    fun init_module(sender: &signer) {
        let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEV);
        let resource_signer = account::create_signer_with_capability(&signer_cap);
        move_to(&resource_signer, SwapInfo {
            signer_cap,
            fee_to: ZERO_ACCOUNT,
            admin: DEFAULT_ADMIN,
            pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
        });
    }
    /// Create the specified coin pair
    public(friend) fun create_pair<X, Y>(
        sender: &signer,
    ) acquires SwapInfo {
        assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
        let lp_name: string::String = string::utf8(b"movement-");
        let name_x = coin::symbol<X>();
        let name_y = coin::symbol<Y>();
        string::append(&mut lp_name, name_x);
        string::append_utf8(&mut lp_name, b"-");
        string::append(&mut lp_name, name_y);
        string::append_utf8(&mut lp_name, b"-LP");
        if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
            lp_name = string::utf8(b"movement LPs");
        };
        // now we init the LP token
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
            &resource_signer,
            lp_name,
            string::utf8(b"Cake-LP"),
            8,
            true
        );
        move_to<TokenPairReserve<X, Y>>(
            &resource_signer,
            TokenPairReserve {
                reserve_x: 0,
                reserve_y: 0,
                block_timestamp_last: 0
            }
        );
        move_to<TokenPairMetadata<X, Y>>(
            &resource_signer,
            TokenPairMetadata {
                creator: sender_addr,
                fee_amount: coin::zero<LPToken<X, Y>>(),
                k_last: 0,
                balance_x: coin::zero<X>(),
                balance_y: coin::zero<Y>(),
                mint_cap,
                burn_cap,
                freeze_cap,
            }
        );
        move_to<PairEventHolder<X, Y>>(
            &resource_signer,
            PairEventHolder {
                add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
                remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
                swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
            }
        );
        // pair created event
        let token_x = type_info::type_name<X>();
        let token_y = type_info::type_name<Y>();
        event::emit_event<PairCreatedEvent>(
            &mut swap_info.pair_created,
            PairCreatedEvent {
                user: sender_addr,
                token_x,
                token_y
            }
        );
        // create LP CoinStore , which is needed as a lock for minimum_liquidity
        register_lp<X, Y>(&resource_signer);
    }
    public fun register_lp<X, Y>(sender: &signer) {
        coin::register<LPToken<X, Y>>(sender);
    }
    public fun is_pair_created<X, Y>(): bool {
        exists<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT)
    }
    /// Obtain the LP token balance of `addr`.
    /// This method can only be used to check other users' balance.
    public fun lp_balance<X, Y>(addr: address): u64 {
        coin::balance<LPToken<X, Y>>(addr)
    }
    /// Get the total supply of LP Tokens
    public fun total_lp_supply<X, Y>(): u128 {
        option::get_with_default(
            &coin::supply<LPToken<X, Y>>(),
            0u128
        )
    }
    /// Get the current reserves of T0 and T1 with the latest updated timestamp
    public fun token_reserves<X, Y>(): (u64, u64, u64) acquires TokenPairReserve {
        let reserve = borrow_global<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        (
            reserve.reserve_x,
            reserve.reserve_y,
            reserve.block_timestamp_last
        )
    }
    /// The amount of balance currently in pools of the liquidity pair
    public fun token_balances<X, Y>(): (u64, u64) acquires TokenPairMetadata {
        let meta =
            borrow_global<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        (
            coin::value(&meta.balance_x),
            coin::value(&meta.balance_y)
        )
    }
    public fun check_or_register_coin_store<X>(sender: &signer) {
        if (!coin::is_account_registered<X>(signer::address_of(sender))) {
            coin::register<X>(sender);
        };
    }
    public fun admin(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.admin
    }
    public fun fee_to(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.fee_to
    }
    // ===================== Update functions ======================
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    public(friend) fun add_liquidity<X, Y>(
        sender: &signer,
        amount_x: u64,
        amount_y: u64
    ): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
        let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = add_liquidity_direct(coin::withdraw<X>(sender, amount_x), coin::withdraw<Y>(sender, amount_y));
        let sender_addr = signer::address_of(sender);
        let lp_amount = coin::value(&coin_lp);
        assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        check_or_register_coin_store<LPToken<X, Y>>(sender);
        coin::deposit(sender_addr, coin_lp);
        coin::deposit(sender_addr, coin_left_x);
        coin::deposit(sender_addr, coin_left_y);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<AddLiquidityEvent<X, Y>>(
            &mut pair_event_holder.add_liquidity,
            AddLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x: a_x,
                amount_y: a_y,
                liquidity: lp_amount,
                fee_amount: (fee_amount as u64),
            }
        );
        (a_x, a_y, lp_amount)
    }
    public(friend) fun add_swap_event<X, Y>(
        sender: &signer,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let sender_addr = signer::address_of(sender);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    public(friend) fun add_swap_event_with_address<X, Y>(
        sender_addr: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    fun add_liquidity_direct<X, Y>(
        x: coin::Coin<X>,
        y: coin::Coin<Y>,
    ): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_x = coin::value(&x);
        let amount_y = coin::value(&y);
        let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
        let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
            (amount_x, amount_y)
        } else {
            let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
            if (amount_y_optimal <= amount_y) {
                (amount_x, amount_y_optimal)
            } else {
                let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
                assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
                (amount_x_optimal, amount_y)
            }
        };
        assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
        assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
        let left_x = coin::extract(&mut x, amount_x - a_x);
        let left_y = coin::extract(&mut y, amount_y - a_y);
        deposit_x<X, Y>(x);
        deposit_y<X, Y>(y);
        let (lp, fee_amount) = mint<X, Y>();
        (a_x, a_y, lp, fee_amount, left_x, left_y)
    }
    /// Remove liquidity to token types.
    public(friend) fun remove_liquidity<X, Y>(
        sender: &signer,
        liquidity: u64,
    ): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
        let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
        let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
        let amount_x = coin::value(&coins_x);
        let amount_y = coin::value(&coins_y);
        check_or_register_coin_store<X>(sender);
        check_or_register_coin_store<Y>(sender);
        let sender_addr = signer::address_of(sender);
        coin::deposit<X>(sender_addr, coins_x);
        coin::deposit<Y>(sender_addr, coins_y);
        // event
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<RemoveLiquidityEvent<X, Y>>(
            &mut pair_event_holder.remove_liquidity,
            RemoveLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x,
                amount_y,
                liquidity,
                fee_amount: (fee_amount as u64)
            }
        );
        (amount_x, amount_y)
    }
    /// Remove liquidity to token types.
    fun remove_liquidity_direct<X, Y>(
        liquidity: coin::Coin<LPToken<X, Y>>,
    ): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        burn<X, Y>(liquidity)
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
        let amount_out = coin::value(&coins_y_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_out
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y_direct<X, Y>(
        coins_in: coin::Coin<X>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<X>(&coins_in);
        deposit_x<X, Y>(coins_in);
        let (rin, rout, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    public(friend) fun swap_x_to_exact_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_x_to_exact_y_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_in
    }
    public(friend) fun swap_x_to_exact_y_direct<X, Y>(
        coins_in: coin::Coin<X>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_x<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_y_to_x_direct<X, Y>(coins);
        let amount_out = coin::value<X>(&coins_x_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_out
    }
    public(friend) fun swap_y_to_exact_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_y_to_exact_x_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_in
    }
    public(friend) fun swap_y_to_exact_x_direct<X, Y>(
        coins_in: coin::Coin<Y>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_y<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x_direct<X, Y>(
        coins_in: coin::Coin<Y>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<Y>(&coins_in);
        deposit_y<X, Y>(coins_in);
        let (rout, rin, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    fun swap<X, Y>(
        amount_x_out: u64,
        amount_y_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        assert!(amount_x_out < reserves.reserve_x && amount_y_out < reserves.reserve_y, ERROR_INSUFFICIENT_LIQUIDITY);
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let coins_x_out = coin::zero<X>();
        let coins_y_out = coin::zero<Y>();
        if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
        if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
        let (balance_x, balance_y) = token_balances<X, Y>();
        let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
            balance_x - (reserves.reserve_x - amount_x_out)
        } else { 0 };
        let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
            balance_y - (reserves.reserve_y - amount_y_out)
        } else { 0 };
        assert!(amount_x_in > 0 || amount_y_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        let prec = (PRECISION as u128);
        let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
        let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
        let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
        let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
        // No need to use u256 when balance_x_adjusted * balance_y_adjusted and reserve_x_adjusted * reserve_y_adjusted are less than MAX_U128.
        let compare_result = if(balance_x_adjusted > 0 && reserve_x_adjusted > 0 && MAX_U128 / balance_x_adjusted > balance_y_adjusted && MAX_U128 / reserve_x_adjusted > reserve_y_adjusted){
            balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
        }else{
            let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
            let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
            p >= k
        };
        assert!(compare_result, ERROR_K);
        update(balance_x, balance_y, reserves);
        (coins_x_out, coins_y_out)
    }
    /// Mint LP Token.
    /// This low-level function should be called from a contract which performs important safety checks
    fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
        let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_supply = total_lp_supply<X, Y>();
        let liquidity = if (total_supply == 0u128) {
            let sqrt = math128::sqrt(amount_x * amount_y);
            assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            let l = sqrt - MINIMUM_LIQUIDITY;
            // permanently lock the first MINIMUM_LIQUIDITY tokens
            mint_lp_to<X, Y>(RESOURCE_ACCOUNT, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
            l
        } else {
            let liquidity = math128::min(amount_x * total_supply / (reserves.reserve_x as u128), amount_y * total_supply / (reserves.reserve_y as u128));
            assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            liquidity
        };
        let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
        update<X, Y>(balance_x, balance_y, reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (lp, fee_amount)
    }
    fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let liquidity = coin::value(&lp_tokens);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_lp_supply = total_lp_supply<X, Y>();
        let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
        coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
        let w_x = extract_x((amount_x as u64), metadata);
        let w_y = extract_y((amount_y as u64), metadata);
        update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (w_x, w_y, fee_amount)
    }
    fun update<X, Y>(balance_x: u64, balance_y: u64, reserve: &mut TokenPairReserve<X, Y>) {
        let block_timestamp = timestamp::now_seconds();
        reserve.reserve_x = balance_x;
        reserve.reserve_y = balance_y;
        reserve.block_timestamp_last = block_timestamp;
    }
    /// Mint LP Tokens to account
    fun mint_lp_to<X, Y>(
        to: address,
        amount: u64,
        mint_cap: &coin::MintCapability<LPToken<X, Y>>
    ) {
        let coins = coin::mint<LPToken<X, Y>>(amount, mint_cap);
        coin::deposit(to, coins);
    }
    /// Mint LP Tokens to account
    fun mint_lp<X, Y>(amount: u64, mint_cap: &coin::MintCapability<LPToken<X, Y>>): coin::Coin<LPToken<X, Y>> {
        coin::mint<LPToken<X, Y>>(amount, mint_cap)
    }
    fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_x, amount);
    }
    fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_y, amount);
    }
    /// Extract `amount` from this contract
    fun extract_x<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<X> {
        assert!(coin::value<X>(&metadata.balance_x) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_x, amount)
    }
    /// Extract `amount` from this contract
    fun extract_y<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<Y> {
        assert!(coin::value<Y>(&metadata.balance_y) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_y, amount)
    }
    fun mint_fee<X, Y>(reserve_x: u64, reserve_y: u64, metadata: &mut TokenPairMetadata<X, Y>): u64 {
        let fee = 0u64;
        if (metadata.k_last != 0) {
            let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
            let root_k_last = math128::sqrt(metadata.k_last);
            if (root_k > root_k_last) {
                let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
                let denominator = root_k_last * 17u128 + (root_k * 8u128);
                let liquidity = numerator / denominator;
                fee = (liquidity as u64);
                // record fee amount in metadata, in case of fee_to with register.
                if (fee > 0) {
                    let coin = mint_lp(fee, &metadata.mint_cap);
                    coin::merge(&mut metadata.fee_amount, coin);
                }
            };
        };
        fee
    }
    public entry fun set_admin(sender: &signer, new_admin: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.admin = new_admin;
    }
    public entry fun set_fee_to(sender: &signer, new_fee_to: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.fee_to = new_fee_to;
    }
}
module movement::swap_utils {
    use std::string;
    use aptos_std::type_info;
    const EQUAL: u8 = 0;
    const SMALLER: u8 = 1;
    const GREATER: u8 = 2;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 0;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 1;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 2;
    const ERROR_INSUFFICIENT_OUTPOT_AMOUNT: u64 = 3;
    const ERROR_SAME_COIN: u64 = 4;
    public fun get_amount_out(
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let amount_in_with_fee = (amount_in as u128) * 9975u128;
        let numerator = amount_in_with_fee * (reserve_out as u128);
        let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
        ((numerator / denominator) as u64)
    }
    public fun get_amount_in(
        amount_out: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_out > 0, ERROR_INSUFFICIENT_OUTPOT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let numerator = (reserve_in as u128) * (amount_out as u128) * 10000u128;
        let denominator = ((reserve_out as u128) - (amount_out as u128)) * 9975u128;
        (((numerator / denominator) as u64) + 1u64)
    }
    public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
        assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
        assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
    }
    public fun get_token_info<T>(): vector<u8> {
        let type_name = type_info::type_name<T>();
        *string::bytes(&type_name)
    }
}
module movement::swap {
    use std::signer;
    use std::option;
    use std::string;
    use aptos_std::type_info;
    use aptos_std::event;
    use aptos_std::math128;
    use aptos_framework::coin;
    use aptos_framework::timestamp;
    use aptos_framework::account;
    use aptos_framework::resource_account;
    use movement::swap_utils;
    const ZERO_ACCOUNT: address = @0x0;
    const DEFAULT_ADMIN: address = @movement;
    const RESOURCE_ACCOUNT: address = @movement;
    const DEV: address = @dev;
    const MINIMUM_LIQUIDITY: u128 = 1000;
    const MAX_COIN_NAME_LENGTH: u64 = 32;
    // List of errors
    const ERROR_ONLY_ADMIN: u64 = 0;
    const ERROR_ALREADY_INITIALIZED: u64 = 1;
    const ERROR_NOT_CREATOR: u64 = 2;
    const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 4;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 6;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 7;
    const ERROR_INVALID_AMOUNT: u64 = 8;
    const ERROR_TOKENS_NOT_SORTED: u64 = 9;
    const ERROR_INSUFFICIENT_LIQUIDITY_BURNED: u64 = 10;
    const ERROR_INSUFFICIENT_OUTPUT_AMOUNT: u64 = 13;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 14;
    const ERROR_K: u64 = 15;
    const ERROR_X_NOT_REGISTERED: u64 = 16;
    const ERROR_Y_NOT_REGISTERED: u64 = 16;
    const ERROR_NOT_ADMIN: u64 = 17;
    const ERROR_NOT_FEE_TO: u64 = 18;
    const ERROR_NOT_EQUAL_EXACT_AMOUNT: u64 = 19;
    const ERROR_NOT_RESOURCE_ACCOUNT: u64 = 20;
    const ERROR_NO_FEE_WITHDRAW: u64 = 21;
    const PRECISION: u64 = 10000;
    /// Max `u128` value.
    const MAX_U128: u128 = 340282366920938463463374607431768211455;
    /// The LP Token type
    struct LPToken<phantom X, phantom Y> has key {}
    /// Stores the metadata required for the token pairs
    struct TokenPairMetadata<phantom X, phantom Y> has key {
        /// The admin of the token pair
        creator: address,
        /// fee amount , record fee amount which is not withdrawed
        fee_amount: coin::Coin<LPToken<X, Y>>,
        /// It's reserve_x * reserve_y, as of immediately after the most recent liquidity event
        k_last: u128,
        /// T0 token balance
        balance_x: coin::Coin<X>,
        /// T1 token balance
        balance_y: coin::Coin<Y>,
        /// Mint capacity of LP Token
        mint_cap: coin::MintCapability<LPToken<X, Y>>,
        /// Burn capacity of LP Token
        burn_cap: coin::BurnCapability<LPToken<X, Y>>,
        /// Freeze capacity of LP Token
        freeze_cap: coin::FreezeCapability<LPToken<X, Y>>,
    }
    /// Stores the reservation info required for the token pairs
    struct TokenPairReserve<phantom X, phantom Y> has key {
        reserve_x: u64,
        reserve_y: u64,
        block_timestamp_last: u64
    }
    struct SwapInfo has key {
        signer_cap: account::SignerCapability,
        fee_to: address,
        admin: address,
        pair_created: event::EventHandle<PairCreatedEvent>
    }
    struct PairCreatedEvent has drop, store {
        user: address,
        token_x: string::String,
        token_y: string::String
    }
    struct PairEventHolder<phantom X, phantom Y> has key {
        add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
        remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
        swap: event::EventHandle<SwapEvent<X, Y>>
    }
    struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x: u64,
        amount_y: u64,
        liquidity: u64,
        fee_amount: u64
    }
    struct RemoveLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        liquidity: u64,
        amount_x: u64,
        amount_y: u64,
        fee_amount: u64
    }
    struct SwapEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    }
    /*
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     Please use swap_util::sort_token_type<X,Y>()
     before using any function
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    */
    fun init_module(sender: &signer) {
        let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEV);
        let resource_signer = account::create_signer_with_capability(&signer_cap);
        move_to(&resource_signer, SwapInfo {
            signer_cap,
            fee_to: ZERO_ACCOUNT,
            admin: DEFAULT_ADMIN,
            pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
        });
    }
    /// Create the specified coin pair
    public(friend) fun create_pair<X, Y>(
        sender: &signer,
    ) acquires SwapInfo {
        assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
        let lp_name: string::String = string::utf8(b"movement-");
        let name_x = coin::symbol<X>();
        let name_y = coin::symbol<Y>();
        string::append(&mut lp_name, name_x);
        string::append_utf8(&mut lp_name, b"-");
        string::append(&mut lp_name, name_y);
        string::append_utf8(&mut lp_name, b"-LP");
        if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
            lp_name = string::utf8(b"movement LPs");
        };
        // now we init the LP token
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
            &resource_signer,
            lp_name,
            string::utf8(b"Cake-LP"),
            8,
            true
        );
        move_to<TokenPairReserve<X, Y>>(
            &resource_signer,
            TokenPairReserve {
                reserve_x: 0,
                reserve_y: 0,
                block_timestamp_last: 0
            }
        );
        move_to<TokenPairMetadata<X, Y>>(
            &resource_signer,
            TokenPairMetadata {
                creator: sender_addr,
                fee_amount: coin::zero<LPToken<X, Y>>(),
                k_last: 0,
                balance_x: coin::zero<X>(),
                balance_y: coin::zero<Y>(),
                mint_cap,
                burn_cap,
                freeze_cap,
            }
        );
        move_to<PairEventHolder<X, Y>>(
            &resource_signer,
            PairEventHolder {
                add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
                remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
                swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
            }
        );
        // pair created event
        let token_x = type_info::type_name<X>();
        let token_y = type_info::type_name<Y>();
        event::emit_event<PairCreatedEvent>(
            &mut swap_info.pair_created,
            PairCreatedEvent {
                user: sender_addr,
                token_x,
                token_y
            }
        );
        // create LP CoinStore , which is needed as a lock for minimum_liquidity
        register_lp<X, Y>(&resource_signer);
    }
    public fun register_lp<X, Y>(sender: &signer) {
        coin::register<LPToken<X, Y>>(sender);
    }
    public fun is_pair_created<X, Y>(): bool {
        exists<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT)
    }
    /// Obtain the LP token balance of `addr`.
    /// This method can only be used to check other users' balance.
    public fun lp_balance<X, Y>(addr: address): u64 {
        coin::balance<LPToken<X, Y>>(addr)
    }
    /// Get the total supply of LP Tokens
    public fun total_lp_supply<X, Y>(): u128 {
        option::get_with_default(
            &coin::supply<LPToken<X, Y>>(),
            0u128
        )
    }
    /// Get the current reserves of T0 and T1 with the latest updated timestamp
    public fun token_reserves<X, Y>(): (u64, u64, u64) acquires TokenPairReserve {
        let reserve = borrow_global<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        (
            reserve.reserve_x,
            reserve.reserve_y,
            reserve.block_timestamp_last
        )
    }
    /// The amount of balance currently in pools of the liquidity pair
    public fun token_balances<X, Y>(): (u64, u64) acquires TokenPairMetadata {
        let meta =
            borrow_global<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        (
            coin::value(&meta.balance_x),
            coin::value(&meta.balance_y)
        )
    }
    public fun check_or_register_coin_store<X>(sender: &signer) {
        if (!coin::is_account_registered<X>(signer::address_of(sender))) {
            coin::register<X>(sender);
        };
    }
    public fun admin(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.admin
    }
    public fun fee_to(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.fee_to
    }
    // ===================== Update functions ======================
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    public(friend) fun add_liquidity<X, Y>(
        sender: &signer,
        amount_x: u64,
        amount_y: u64
    ): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
        let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = add_liquidity_direct(coin::withdraw<X>(sender, amount_x), coin::withdraw<Y>(sender, amount_y));
        let sender_addr = signer::address_of(sender);
        let lp_amount = coin::value(&coin_lp);
        assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        check_or_register_coin_store<LPToken<X, Y>>(sender);
        coin::deposit(sender_addr, coin_lp);
        coin::deposit(sender_addr, coin_left_x);
        coin::deposit(sender_addr, coin_left_y);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<AddLiquidityEvent<X, Y>>(
            &mut pair_event_holder.add_liquidity,
            AddLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x: a_x,
                amount_y: a_y,
                liquidity: lp_amount,
                fee_amount: (fee_amount as u64),
            }
        );
        (a_x, a_y, lp_amount)
    }
    public(friend) fun add_swap_event<X, Y>(
        sender: &signer,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let sender_addr = signer::address_of(sender);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    public(friend) fun add_swap_event_with_address<X, Y>(
        sender_addr: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    fun add_liquidity_direct<X, Y>(
        x: coin::Coin<X>,
        y: coin::Coin<Y>,
    ): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_x = coin::value(&x);
        let amount_y = coin::value(&y);
        let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
        let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
            (amount_x, amount_y)
        } else {
            let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
            if (amount_y_optimal <= amount_y) {
                (amount_x, amount_y_optimal)
            } else {
                let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
                assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
                (amount_x_optimal, amount_y)
            }
        };
        assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
        assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
        let left_x = coin::extract(&mut x, amount_x - a_x);
        let left_y = coin::extract(&mut y, amount_y - a_y);
        deposit_x<X, Y>(x);
        deposit_y<X, Y>(y);
        let (lp, fee_amount) = mint<X, Y>();
        (a_x, a_y, lp, fee_amount, left_x, left_y)
    }
    /// Remove liquidity to token types.
    public(friend) fun remove_liquidity<X, Y>(
        sender: &signer,
        liquidity: u64,
    ): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
        let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
        let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
        let amount_x = coin::value(&coins_x);
        let amount_y = coin::value(&coins_y);
        check_or_register_coin_store<X>(sender);
        check_or_register_coin_store<Y>(sender);
        let sender_addr = signer::address_of(sender);
        coin::deposit<X>(sender_addr, coins_x);
        coin::deposit<Y>(sender_addr, coins_y);
        // event
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<RemoveLiquidityEvent<X, Y>>(
            &mut pair_event_holder.remove_liquidity,
            RemoveLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x,
                amount_y,
                liquidity,
                fee_amount: (fee_amount as u64)
            }
        );
        (amount_x, amount_y)
    }
    /// Remove liquidity to token types.
    fun remove_liquidity_direct<X, Y>(
        liquidity: coin::Coin<LPToken<X, Y>>,
    ): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        burn<X, Y>(liquidity)
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
        let amount_out = coin::value(&coins_y_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_out
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y_direct<X, Y>(
        coins_in: coin::Coin<X>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<X>(&coins_in);
        deposit_x<X, Y>(coins_in);
        let (rin, rout, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    public(friend) fun swap_x_to_exact_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_x_to_exact_y_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_in
    }
    public(friend) fun swap_x_to_exact_y_direct<X, Y>(
        coins_in: coin::Coin<X>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_x<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_y_to_x_direct<X, Y>(coins);
        let amount_out = coin::value<X>(&coins_x_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_out
    }
    public(friend) fun swap_y_to_exact_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_y_to_exact_x_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_in
    }
    public(friend) fun swap_y_to_exact_x_direct<X, Y>(
        coins_in: coin::Coin<Y>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_y<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x_direct<X, Y>(
        coins_in: coin::Coin<Y>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<Y>(&coins_in);
        deposit_y<X, Y>(coins_in);
        let (rout, rin, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    fun swap<X, Y>(
        amount_x_out: u64,
        amount_y_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        assert!(amount_x_out < reserves.reserve_x && amount_y_out < reserves.reserve_y, ERROR_INSUFFICIENT_LIQUIDITY);
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let coins_x_out = coin::zero<X>();
        let coins_y_out = coin::zero<Y>();
        if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
        if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
        let (balance_x, balance_y) = token_balances<X, Y>();
        let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
            balance_x - (reserves.reserve_x - amount_x_out)
        } else { 0 };
        let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
            balance_y - (reserves.reserve_y - amount_y_out)
        } else { 0 };
        assert!(amount_x_in > 0 || amount_y_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        let prec = (PRECISION as u128);
        let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
        let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
        let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
        let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
        // No need to use u256 when balance_x_adjusted * balance_y_adjusted and reserve_x_adjusted * reserve_y_adjusted are less than MAX_U128.
        let compare_result = if(balance_x_adjusted > 0 && reserve_x_adjusted > 0 && MAX_U128 / balance_x_adjusted > balance_y_adjusted && MAX_U128 / reserve_x_adjusted > reserve_y_adjusted){
            balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
        }else{
            let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
            let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
            p >= k
        };
        assert!(compare_result, ERROR_K);
        update(balance_x, balance_y, reserves);
        (coins_x_out, coins_y_out)
    }
    /// Mint LP Token.
    /// This low-level function should be called from a contract which performs important safety checks
    fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
        let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_supply = total_lp_supply<X, Y>();
        let liquidity = if (total_supply == 0u128) {
            let sqrt = math128::sqrt(amount_x * amount_y);
            assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            let l = sqrt - MINIMUM_LIQUIDITY;
            // permanently lock the first MINIMUM_LIQUIDITY tokens
            mint_lp_to<X, Y>(RESOURCE_ACCOUNT, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
            l
        } else {
            let liquidity = math128::min(amount_x * total_supply / (reserves.reserve_x as u128), amount_y * total_supply / (reserves.reserve_y as u128));
            assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            liquidity
        };
        let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
        update<X, Y>(balance_x, balance_y, reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (lp, fee_amount)
    }
    fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let liquidity = coin::value(&lp_tokens);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_lp_supply = total_lp_supply<X, Y>();
        let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
        coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
        let w_x = extract_x((amount_x as u64), metadata);
        let w_y = extract_y((amount_y as u64), metadata);
        update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (w_x, w_y, fee_amount)
    }
    fun update<X, Y>(balance_x: u64, balance_y: u64, reserve: &mut TokenPairReserve<X, Y>) {
        let block_timestamp = timestamp::now_seconds();
        reserve.reserve_x = balance_x;
        reserve.reserve_y = balance_y;
        reserve.block_timestamp_last = block_timestamp;
    }
    /// Mint LP Tokens to account
    fun mint_lp_to<X, Y>(
        to: address,
        amount: u64,
        mint_cap: &coin::MintCapability<LPToken<X, Y>>
    ) {
        let coins = coin::mint<LPToken<X, Y>>(amount, mint_cap);
        coin::deposit(to, coins);
    }
    /// Mint LP Tokens to account
    fun mint_lp<X, Y>(amount: u64, mint_cap: &coin::MintCapability<LPToken<X, Y>>): coin::Coin<LPToken<X, Y>> {
        coin::mint<LPToken<X, Y>>(amount, mint_cap)
    }
    fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_x, amount);
    }
    fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_y, amount);
    }
    /// Extract `amount` from this contract
    fun extract_x<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<X> {
        assert!(coin::value<X>(&metadata.balance_x) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_x, amount)
    }
    /// Extract `amount` from this contract
    fun extract_y<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<Y> {
        assert!(coin::value<Y>(&metadata.balance_y) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_y, amount)
    }
    fun mint_fee<X, Y>(reserve_x: u64, reserve_y: u64, metadata: &mut TokenPairMetadata<X, Y>): u64 {
        let fee = 0u64;
        if (metadata.k_last != 0) {
            let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
            let root_k_last = math128::sqrt(metadata.k_last);
            if (root_k > root_k_last) {
                let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
                let denominator = root_k_last * 17u128 + (root_k * 8u128);
                let liquidity = numerator / denominator;
                fee = (liquidity as u64);
                // record fee amount in metadata, in case of fee_to with register.
                if (fee > 0) {
                    let coin = mint_lp(fee, &metadata.mint_cap);
                    coin::merge(&mut metadata.fee_amount, coin);
                }
            };
        };
        fee
    }
    public entry fun set_admin(sender: &signer, new_admin: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.admin = new_admin;
    }
    public entry fun set_fee_to(sender: &signer, new_fee_to: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.fee_to = new_fee_to;
    }
}
module movement::swap_utils {
    use std::string;
    use aptos_std::type_info;
    const EQUAL: u8 = 0;
    const SMALLER: u8 = 1;
    const GREATER: u8 = 2;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 0;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 1;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 2;
    const ERROR_INSUFFICIENT_OUTPOT_AMOUNT: u64 = 3;
    const ERROR_SAME_COIN: u64 = 4;
    public fun get_amount_out(
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let amount_in_with_fee = (amount_in as u128) * 9975u128;
        let numerator = amount_in_with_fee * (reserve_out as u128);
        let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
        ((numerator / denominator) as u64)
    }
    public fun get_amount_in(
        amount_out: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_out > 0, ERROR_INSUFFICIENT_OUTPOT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let numerator = (reserve_in as u128) * (amount_out as u128) * 10000u128;
        let denominator = ((reserve_out as u128) - (amount_out as u128)) * 9975u128;
        (((numerator / denominator) as u64) + 1u64)
    }
    public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
        assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
        assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
    }
    public fun get_token_info<T>(): vector<u8> {
        let type_name = type_info::type_name<T>();
        *string::bytes(&type_name)
    }
}
<code>module movement::swap {
    use std::signer;
    use std::option;
    use std::string;
    use aptos_std::type_info;
    use aptos_std::event;
    use aptos_std::math128;
    use aptos_framework::coin;
    use aptos_framework::timestamp;
    use aptos_framework::account;
    use aptos_framework::resource_account;
    use movement::swap_utils;
    const ZERO_ACCOUNT: address = @0x0;
    const DEFAULT_ADMIN: address = @movement;
    const RESOURCE_ACCOUNT: address = @movement;
    const DEV: address = @dev;
    const MINIMUM_LIQUIDITY: u128 = 1000;
    const MAX_COIN_NAME_LENGTH: u64 = 32;
    // List of errors
    const ERROR_ONLY_ADMIN: u64 = 0;
    const ERROR_ALREADY_INITIALIZED: u64 = 1;
    const ERROR_NOT_CREATOR: u64 = 2;
    const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 4;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 6;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 7;
    const ERROR_INVALID_AMOUNT: u64 = 8;
    const ERROR_TOKENS_NOT_SORTED: u64 = 9;
    const ERROR_INSUFFICIENT_LIQUIDITY_BURNED: u64 = 10;
    const ERROR_INSUFFICIENT_OUTPUT_AMOUNT: u64 = 13;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 14;
    const ERROR_K: u64 = 15;
    const ERROR_X_NOT_REGISTERED: u64 = 16;
    const ERROR_Y_NOT_REGISTERED: u64 = 16;
    const ERROR_NOT_ADMIN: u64 = 17;
    const ERROR_NOT_FEE_TO: u64 = 18;
    const ERROR_NOT_EQUAL_EXACT_AMOUNT: u64 = 19;
    const ERROR_NOT_RESOURCE_ACCOUNT: u64 = 20;
    const ERROR_NO_FEE_WITHDRAW: u64 = 21;
    const PRECISION: u64 = 10000;
    /// Max `u128` value.
    const MAX_U128: u128 = 340282366920938463463374607431768211455;
    /// The LP Token type
    struct LPToken<phantom X, phantom Y> has key {}
    /// Stores the metadata required for the token pairs
    struct TokenPairMetadata<phantom X, phantom Y> has key {
        /// The admin of the token pair
        creator: address,
        /// fee amount , record fee amount which is not withdrawed
        fee_amount: coin::Coin<LPToken<X, Y>>,
        /// It's reserve_x * reserve_y, as of immediately after the most recent liquidity event
        k_last: u128,
        /// T0 token balance
        balance_x: coin::Coin<X>,
        /// T1 token balance
        balance_y: coin::Coin<Y>,
        /// Mint capacity of LP Token
        mint_cap: coin::MintCapability<LPToken<X, Y>>,
        /// Burn capacity of LP Token
        burn_cap: coin::BurnCapability<LPToken<X, Y>>,
        /// Freeze capacity of LP Token
        freeze_cap: coin::FreezeCapability<LPToken<X, Y>>,
    }
    /// Stores the reservation info required for the token pairs
    struct TokenPairReserve<phantom X, phantom Y> has key {
        reserve_x: u64,
        reserve_y: u64,
        block_timestamp_last: u64
    }
    struct SwapInfo has key {
        signer_cap: account::SignerCapability,
        fee_to: address,
        admin: address,
        pair_created: event::EventHandle<PairCreatedEvent>
    }
    struct PairCreatedEvent has drop, store {
        user: address,
        token_x: string::String,
        token_y: string::String
    }
    struct PairEventHolder<phantom X, phantom Y> has key {
        add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
        remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
        swap: event::EventHandle<SwapEvent<X, Y>>
    }
    struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x: u64,
        amount_y: u64,
        liquidity: u64,
        fee_amount: u64
    }
    struct RemoveLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        liquidity: u64,
        amount_x: u64,
        amount_y: u64,
        fee_amount: u64
    }
    struct SwapEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    }
    /*
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     Please use swap_util::sort_token_type<X,Y>()
     before using any function
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    */
    fun init_module(sender: &signer) {
        let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEV);
        let resource_signer = account::create_signer_with_capability(&signer_cap);
        move_to(&resource_signer, SwapInfo {
            signer_cap,
            fee_to: ZERO_ACCOUNT,
            admin: DEFAULT_ADMIN,
            pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
        });
    }
    /// Create the specified coin pair
    public(friend) fun create_pair<X, Y>(
        sender: &signer,
    ) acquires SwapInfo {
        assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
        let lp_name: string::String = string::utf8(b"movement-");
        let name_x = coin::symbol<X>();
        let name_y = coin::symbol<Y>();
        string::append(&mut lp_name, name_x);
        string::append_utf8(&mut lp_name, b"-");
        string::append(&mut lp_name, name_y);
        string::append_utf8(&mut lp_name, b"-LP");
        if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
            lp_name = string::utf8(b"movement LPs");
        };
        // now we init the LP token
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
            &resource_signer,
            lp_name,
            string::utf8(b"Cake-LP"),
            8,
            true
        );
        move_to<TokenPairReserve<X, Y>>(
            &resource_signer,
            TokenPairReserve {
                reserve_x: 0,
                reserve_y: 0,
                block_timestamp_last: 0
            }
        );
        move_to<TokenPairMetadata<X, Y>>(
            &resource_signer,
            TokenPairMetadata {
                creator: sender_addr,
                fee_amount: coin::zero<LPToken<X, Y>>(),
                k_last: 0,
                balance_x: coin::zero<X>(),
                balance_y: coin::zero<Y>(),
                mint_cap,
                burn_cap,
                freeze_cap,
            }
        );
        move_to<PairEventHolder<X, Y>>(
            &resource_signer,
            PairEventHolder {
                add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
                remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
                swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
            }
        );
        // pair created event
        let token_x = type_info::type_name<X>();
        let token_y = type_info::type_name<Y>();
        event::emit_event<PairCreatedEvent>(
            &mut swap_info.pair_created,
            PairCreatedEvent {
                user: sender_addr,
                token_x,
                token_y
            }
        );
        // create LP CoinStore , which is needed as a lock for minimum_liquidity
        register_lp<X, Y>(&resource_signer);
    }
    public fun register_lp<X, Y>(sender: &signer) {
        coin::register<LPToken<X, Y>>(sender);
    }
    public fun is_pair_created<X, Y>(): bool {
        exists<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT)
    }
    /// Obtain the LP token balance of `addr`.
    /// This method can only be used to check other users' balance.
    public fun lp_balance<X, Y>(addr: address): u64 {
        coin::balance<LPToken<X, Y>>(addr)
    }
    /// Get the total supply of LP Tokens
    public fun total_lp_supply<X, Y>(): u128 {
        option::get_with_default(
            &coin::supply<LPToken<X, Y>>(),
            0u128
        )
    }
    /// Get the current reserves of T0 and T1 with the latest updated timestamp
    public fun token_reserves<X, Y>(): (u64, u64, u64) acquires TokenPairReserve {
        let reserve = borrow_global<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        (
            reserve.reserve_x,
            reserve.reserve_y,
            reserve.block_timestamp_last
        )
    }
    /// The amount of balance currently in pools of the liquidity pair
    public fun token_balances<X, Y>(): (u64, u64) acquires TokenPairMetadata {
        let meta =
            borrow_global<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        (
            coin::value(&meta.balance_x),
            coin::value(&meta.balance_y)
        )
    }
    public fun check_or_register_coin_store<X>(sender: &signer) {
        if (!coin::is_account_registered<X>(signer::address_of(sender))) {
            coin::register<X>(sender);
        };
    }
    public fun admin(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.admin
    }
    public fun fee_to(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.fee_to
    }
    // ===================== Update functions ======================
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    public(friend) fun add_liquidity<X, Y>(
        sender: &signer,
        amount_x: u64,
        amount_y: u64
    ): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
        let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = add_liquidity_direct(coin::withdraw<X>(sender, amount_x), coin::withdraw<Y>(sender, amount_y));
        let sender_addr = signer::address_of(sender);
        let lp_amount = coin::value(&coin_lp);
        assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        check_or_register_coin_store<LPToken<X, Y>>(sender);
        coin::deposit(sender_addr, coin_lp);
        coin::deposit(sender_addr, coin_left_x);
        coin::deposit(sender_addr, coin_left_y);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<AddLiquidityEvent<X, Y>>(
            &mut pair_event_holder.add_liquidity,
            AddLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x: a_x,
                amount_y: a_y,
                liquidity: lp_amount,
                fee_amount: (fee_amount as u64),
            }
        );
        (a_x, a_y, lp_amount)
    }
    public(friend) fun add_swap_event<X, Y>(
        sender: &signer,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let sender_addr = signer::address_of(sender);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    public(friend) fun add_swap_event_with_address<X, Y>(
        sender_addr: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    fun add_liquidity_direct<X, Y>(
        x: coin::Coin<X>,
        y: coin::Coin<Y>,
    ): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_x = coin::value(&x);
        let amount_y = coin::value(&y);
        let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
        let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
            (amount_x, amount_y)
        } else {
            let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
            if (amount_y_optimal <= amount_y) {
                (amount_x, amount_y_optimal)
            } else {
                let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
                assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
                (amount_x_optimal, amount_y)
            }
        };
        assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
        assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
        let left_x = coin::extract(&mut x, amount_x - a_x);
        let left_y = coin::extract(&mut y, amount_y - a_y);
        deposit_x<X, Y>(x);
        deposit_y<X, Y>(y);
        let (lp, fee_amount) = mint<X, Y>();
        (a_x, a_y, lp, fee_amount, left_x, left_y)
    }
    /// Remove liquidity to token types.
    public(friend) fun remove_liquidity<X, Y>(
        sender: &signer,
        liquidity: u64,
    ): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
        let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
        let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
        let amount_x = coin::value(&coins_x);
        let amount_y = coin::value(&coins_y);
        check_or_register_coin_store<X>(sender);
        check_or_register_coin_store<Y>(sender);
        let sender_addr = signer::address_of(sender);
        coin::deposit<X>(sender_addr, coins_x);
        coin::deposit<Y>(sender_addr, coins_y);
        // event
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<RemoveLiquidityEvent<X, Y>>(
            &mut pair_event_holder.remove_liquidity,
            RemoveLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x,
                amount_y,
                liquidity,
                fee_amount: (fee_amount as u64)
            }
        );
        (amount_x, amount_y)
    }
    /// Remove liquidity to token types.
    fun remove_liquidity_direct<X, Y>(
        liquidity: coin::Coin<LPToken<X, Y>>,
    ): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        burn<X, Y>(liquidity)
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
        let amount_out = coin::value(&coins_y_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_out
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y_direct<X, Y>(
        coins_in: coin::Coin<X>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<X>(&coins_in);
        deposit_x<X, Y>(coins_in);
        let (rin, rout, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    public(friend) fun swap_x_to_exact_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_x_to_exact_y_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_in
    }
    public(friend) fun swap_x_to_exact_y_direct<X, Y>(
        coins_in: coin::Coin<X>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_x<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_y_to_x_direct<X, Y>(coins);
        let amount_out = coin::value<X>(&coins_x_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_out
    }
    public(friend) fun swap_y_to_exact_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_y_to_exact_x_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_in
    }
    public(friend) fun swap_y_to_exact_x_direct<X, Y>(
        coins_in: coin::Coin<Y>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_y<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x_direct<X, Y>(
        coins_in: coin::Coin<Y>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<Y>(&coins_in);
        deposit_y<X, Y>(coins_in);
        let (rout, rin, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    fun swap<X, Y>(
        amount_x_out: u64,
        amount_y_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        assert!(amount_x_out < reserves.reserve_x && amount_y_out < reserves.reserve_y, ERROR_INSUFFICIENT_LIQUIDITY);
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let coins_x_out = coin::zero<X>();
        let coins_y_out = coin::zero<Y>();
        if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
        if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
        let (balance_x, balance_y) = token_balances<X, Y>();
        let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
            balance_x - (reserves.reserve_x - amount_x_out)
        } else { 0 };
        let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
            balance_y - (reserves.reserve_y - amount_y_out)
        } else { 0 };
        assert!(amount_x_in > 0 || amount_y_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        let prec = (PRECISION as u128);
        let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
        let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
        let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
        let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
        // No need to use u256 when balance_x_adjusted * balance_y_adjusted and reserve_x_adjusted * reserve_y_adjusted are less than MAX_U128.
        let compare_result = if(balance_x_adjusted > 0 && reserve_x_adjusted > 0 && MAX_U128 / balance_x_adjusted > balance_y_adjusted && MAX_U128 / reserve_x_adjusted > reserve_y_adjusted){
            balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
        }else{
            let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
            let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
            p >= k
        };
        assert!(compare_result, ERROR_K);
        update(balance_x, balance_y, reserves);
        (coins_x_out, coins_y_out)
    }
    /// Mint LP Token.
    /// This low-level function should be called from a contract which performs important safety checks
    fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
        let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_supply = total_lp_supply<X, Y>();
        let liquidity = if (total_supply == 0u128) {
            let sqrt = math128::sqrt(amount_x * amount_y);
            assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            let l = sqrt - MINIMUM_LIQUIDITY;
            // permanently lock the first MINIMUM_LIQUIDITY tokens
            mint_lp_to<X, Y>(RESOURCE_ACCOUNT, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
            l
        } else {
            let liquidity = math128::min(amount_x * total_supply / (reserves.reserve_x as u128), amount_y * total_supply / (reserves.reserve_y as u128));
            assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            liquidity
        };
        let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
        update<X, Y>(balance_x, balance_y, reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (lp, fee_amount)
    }
    fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let liquidity = coin::value(&lp_tokens);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_lp_supply = total_lp_supply<X, Y>();
        let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
        coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
        let w_x = extract_x((amount_x as u64), metadata);
        let w_y = extract_y((amount_y as u64), metadata);
        update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (w_x, w_y, fee_amount)
    }
    fun update<X, Y>(balance_x: u64, balance_y: u64, reserve: &mut TokenPairReserve<X, Y>) {
        let block_timestamp = timestamp::now_seconds();
        reserve.reserve_x = balance_x;
        reserve.reserve_y = balance_y;
        reserve.block_timestamp_last = block_timestamp;
    }
    /// Mint LP Tokens to account
    fun mint_lp_to<X, Y>(
        to: address,
        amount: u64,
        mint_cap: &coin::MintCapability<LPToken<X, Y>>
    ) {
        let coins = coin::mint<LPToken<X, Y>>(amount, mint_cap);
        coin::deposit(to, coins);
    }
    /// Mint LP Tokens to account
    fun mint_lp<X, Y>(amount: u64, mint_cap: &coin::MintCapability<LPToken<X, Y>>): coin::Coin<LPToken<X, Y>> {
        coin::mint<LPToken<X, Y>>(amount, mint_cap)
    }
    fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_x, amount);
    }
    fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_y, amount);
    }
    /// Extract `amount` from this contract
    fun extract_x<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<X> {
        assert!(coin::value<X>(&metadata.balance_x) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_x, amount)
    }
    /// Extract `amount` from this contract
    fun extract_y<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<Y> {
        assert!(coin::value<Y>(&metadata.balance_y) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_y, amount)
    }
    fun mint_fee<X, Y>(reserve_x: u64, reserve_y: u64, metadata: &mut TokenPairMetadata<X, Y>): u64 {
        let fee = 0u64;
        if (metadata.k_last != 0) {
            let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
            let root_k_last = math128::sqrt(metadata.k_last);
            if (root_k > root_k_last) {
                let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
                let denominator = root_k_last * 17u128 + (root_k * 8u128);
                let liquidity = numerator / denominator;
                fee = (liquidity as u64);
                // record fee amount in metadata, in case of fee_to with register.
                if (fee > 0) {
                    let coin = mint_lp(fee, &metadata.mint_cap);
                    coin::merge(&mut metadata.fee_amount, coin);
                }
            };
        };
        fee
    }
    public entry fun set_admin(sender: &signer, new_admin: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.admin = new_admin;
    }
    public entry fun set_fee_to(sender: &signer, new_fee_to: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.fee_to = new_fee_to;
    }
}
module movement::swap_utils {
    use std::string;
    use aptos_std::type_info;
    const EQUAL: u8 = 0;
    const SMALLER: u8 = 1;
    const GREATER: u8 = 2;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 0;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 1;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 2;
    const ERROR_INSUFFICIENT_OUTPOT_AMOUNT: u64 = 3;
    const ERROR_SAME_COIN: u64 = 4;
    public fun get_amount_out(
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let amount_in_with_fee = (amount_in as u128) * 9975u128;
        let numerator = amount_in_with_fee * (reserve_out as u128);
        let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
        ((numerator / denominator) as u64)
    }
    public fun get_amount_in(
        amount_out: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_out > 0, ERROR_INSUFFICIENT_OUTPOT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let numerator = (reserve_in as u128) * (amount_out as u128) * 10000u128;
        let denominator = ((reserve_out as u128) - (amount_out as u128)) * 9975u128;
        (((numerator / denominator) as u64) + 1u64)
    }
    public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
        assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
        assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
    }
    public fun get_token_info<T>(): vector<u8> {
        let type_name = type_info::type_name<T>();
        *string::bytes(&type_name)
    }
}</code>
<code>module movement::swap {
    use std::signer;
    use std::option;
    use std::string;
    use aptos_std::type_info;
    use aptos_std::event;
    use aptos_std::math128;
    use aptos_framework::coin;
    use aptos_framework::timestamp;
    use aptos_framework::account;
    use aptos_framework::resource_account;
    use movement::swap_utils;
    const ZERO_ACCOUNT: address = @0x0;
    const DEFAULT_ADMIN: address = @movement;
    const RESOURCE_ACCOUNT: address = @movement;
    const DEV: address = @dev;
    const MINIMUM_LIQUIDITY: u128 = 1000;
    const MAX_COIN_NAME_LENGTH: u64 = 32;
    // List of errors
    const ERROR_ONLY_ADMIN: u64 = 0;
    const ERROR_ALREADY_INITIALIZED: u64 = 1;
    const ERROR_NOT_CREATOR: u64 = 2;
    const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 4;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 6;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 7;
    const ERROR_INVALID_AMOUNT: u64 = 8;
    const ERROR_TOKENS_NOT_SORTED: u64 = 9;
    const ERROR_INSUFFICIENT_LIQUIDITY_BURNED: u64 = 10;
    const ERROR_INSUFFICIENT_OUTPUT_AMOUNT: u64 = 13;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 14;
    const ERROR_K: u64 = 15;
    const ERROR_X_NOT_REGISTERED: u64 = 16;
    const ERROR_Y_NOT_REGISTERED: u64 = 16;
    const ERROR_NOT_ADMIN: u64 = 17;
    const ERROR_NOT_FEE_TO: u64 = 18;
    const ERROR_NOT_EQUAL_EXACT_AMOUNT: u64 = 19;
    const ERROR_NOT_RESOURCE_ACCOUNT: u64 = 20;
    const ERROR_NO_FEE_WITHDRAW: u64 = 21;
    const PRECISION: u64 = 10000;
    /// Max `u128` value.
    const MAX_U128: u128 = 340282366920938463463374607431768211455;
    /// The LP Token type
    struct LPToken<phantom X, phantom Y> has key {}
    /// Stores the metadata required for the token pairs
    struct TokenPairMetadata<phantom X, phantom Y> has key {
        /// The admin of the token pair
        creator: address,
        /// fee amount , record fee amount which is not withdrawed
        fee_amount: coin::Coin<LPToken<X, Y>>,
        /// It's reserve_x * reserve_y, as of immediately after the most recent liquidity event
        k_last: u128,
        /// T0 token balance
        balance_x: coin::Coin<X>,
        /// T1 token balance
        balance_y: coin::Coin<Y>,
        /// Mint capacity of LP Token
        mint_cap: coin::MintCapability<LPToken<X, Y>>,
        /// Burn capacity of LP Token
        burn_cap: coin::BurnCapability<LPToken<X, Y>>,
        /// Freeze capacity of LP Token
        freeze_cap: coin::FreezeCapability<LPToken<X, Y>>,
    }
    /// Stores the reservation info required for the token pairs
    struct TokenPairReserve<phantom X, phantom Y> has key {
        reserve_x: u64,
        reserve_y: u64,
        block_timestamp_last: u64
    }
    struct SwapInfo has key {
        signer_cap: account::SignerCapability,
        fee_to: address,
        admin: address,
        pair_created: event::EventHandle<PairCreatedEvent>
    }
    struct PairCreatedEvent has drop, store {
        user: address,
        token_x: string::String,
        token_y: string::String
    }
    struct PairEventHolder<phantom X, phantom Y> has key {
        add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
        remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
        swap: event::EventHandle<SwapEvent<X, Y>>
    }
    struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x: u64,
        amount_y: u64,
        liquidity: u64,
        fee_amount: u64
    }
    struct RemoveLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        liquidity: u64,
        amount_x: u64,
        amount_y: u64,
        fee_amount: u64
    }
    struct SwapEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    }
    /*
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     Please use swap_util::sort_token_type<X,Y>()
     before using any function
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    */
    fun init_module(sender: &signer) {
        let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEV);
        let resource_signer = account::create_signer_with_capability(&signer_cap);
        move_to(&resource_signer, SwapInfo {
            signer_cap,
            fee_to: ZERO_ACCOUNT,
            admin: DEFAULT_ADMIN,
            pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
        });
    }
    /// Create the specified coin pair
    public(friend) fun create_pair<X, Y>(
        sender: &signer,
    ) acquires SwapInfo {
        assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
        let lp_name: string::String = string::utf8(b"movement-");
        let name_x = coin::symbol<X>();
        let name_y = coin::symbol<Y>();
        string::append(&mut lp_name, name_x);
        string::append_utf8(&mut lp_name, b"-");
        string::append(&mut lp_name, name_y);
        string::append_utf8(&mut lp_name, b"-LP");
        if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
            lp_name = string::utf8(b"movement LPs");
        };
        // now we init the LP token
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
            &resource_signer,
            lp_name,
            string::utf8(b"Cake-LP"),
            8,
            true
        );
        move_to<TokenPairReserve<X, Y>>(
            &resource_signer,
            TokenPairReserve {
                reserve_x: 0,
                reserve_y: 0,
                block_timestamp_last: 0
            }
        );
        move_to<TokenPairMetadata<X, Y>>(
            &resource_signer,
            TokenPairMetadata {
                creator: sender_addr,
                fee_amount: coin::zero<LPToken<X, Y>>(),
                k_last: 0,
                balance_x: coin::zero<X>(),
                balance_y: coin::zero<Y>(),
                mint_cap,
                burn_cap,
                freeze_cap,
            }
        );
        move_to<PairEventHolder<X, Y>>(
            &resource_signer,
            PairEventHolder {
                add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
                remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
                swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
            }
        );
        // pair created event
        let token_x = type_info::type_name<X>();
        let token_y = type_info::type_name<Y>();
        event::emit_event<PairCreatedEvent>(
            &mut swap_info.pair_created,
            PairCreatedEvent {
                user: sender_addr,
                token_x,
                token_y
            }
        );
        // create LP CoinStore , which is needed as a lock for minimum_liquidity
        register_lp<X, Y>(&resource_signer);
    }
    public fun register_lp<X, Y>(sender: &signer) {
        coin::register<LPToken<X, Y>>(sender);
    }
    public fun is_pair_created<X, Y>(): bool {
        exists<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT)
    }
    /// Obtain the LP token balance of `addr`.
    /// This method can only be used to check other users' balance.
    public fun lp_balance<X, Y>(addr: address): u64 {
        coin::balance<LPToken<X, Y>>(addr)
    }
    /// Get the total supply of LP Tokens
    public fun total_lp_supply<X, Y>(): u128 {
        option::get_with_default(
            &coin::supply<LPToken<X, Y>>(),
            0u128
        )
    }
    /// Get the current reserves of T0 and T1 with the latest updated timestamp
    public fun token_reserves<X, Y>(): (u64, u64, u64) acquires TokenPairReserve {
        let reserve = borrow_global<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        (
            reserve.reserve_x,
            reserve.reserve_y,
            reserve.block_timestamp_last
        )
    }
    /// The amount of balance currently in pools of the liquidity pair
    public fun token_balances<X, Y>(): (u64, u64) acquires TokenPairMetadata {
        let meta =
            borrow_global<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        (
            coin::value(&meta.balance_x),
            coin::value(&meta.balance_y)
        )
    }
    public fun check_or_register_coin_store<X>(sender: &signer) {
        if (!coin::is_account_registered<X>(signer::address_of(sender))) {
            coin::register<X>(sender);
        };
    }
    public fun admin(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.admin
    }
    public fun fee_to(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.fee_to
    }
    // ===================== Update functions ======================
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    public(friend) fun add_liquidity<X, Y>(
        sender: &signer,
        amount_x: u64,
        amount_y: u64
    ): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
        let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = add_liquidity_direct(coin::withdraw<X>(sender, amount_x), coin::withdraw<Y>(sender, amount_y));
        let sender_addr = signer::address_of(sender);
        let lp_amount = coin::value(&coin_lp);
        assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        check_or_register_coin_store<LPToken<X, Y>>(sender);
        coin::deposit(sender_addr, coin_lp);
        coin::deposit(sender_addr, coin_left_x);
        coin::deposit(sender_addr, coin_left_y);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<AddLiquidityEvent<X, Y>>(
            &mut pair_event_holder.add_liquidity,
            AddLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x: a_x,
                amount_y: a_y,
                liquidity: lp_amount,
                fee_amount: (fee_amount as u64),
            }
        );
        (a_x, a_y, lp_amount)
    }
    public(friend) fun add_swap_event<X, Y>(
        sender: &signer,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let sender_addr = signer::address_of(sender);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    public(friend) fun add_swap_event_with_address<X, Y>(
        sender_addr: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    fun add_liquidity_direct<X, Y>(
        x: coin::Coin<X>,
        y: coin::Coin<Y>,
    ): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_x = coin::value(&x);
        let amount_y = coin::value(&y);
        let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
        let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
            (amount_x, amount_y)
        } else {
            let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
            if (amount_y_optimal <= amount_y) {
                (amount_x, amount_y_optimal)
            } else {
                let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
                assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
                (amount_x_optimal, amount_y)
            }
        };
        assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
        assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
        let left_x = coin::extract(&mut x, amount_x - a_x);
        let left_y = coin::extract(&mut y, amount_y - a_y);
        deposit_x<X, Y>(x);
        deposit_y<X, Y>(y);
        let (lp, fee_amount) = mint<X, Y>();
        (a_x, a_y, lp, fee_amount, left_x, left_y)
    }
    /// Remove liquidity to token types.
    public(friend) fun remove_liquidity<X, Y>(
        sender: &signer,
        liquidity: u64,
    ): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
        let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
        let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
        let amount_x = coin::value(&coins_x);
        let amount_y = coin::value(&coins_y);
        check_or_register_coin_store<X>(sender);
        check_or_register_coin_store<Y>(sender);
        let sender_addr = signer::address_of(sender);
        coin::deposit<X>(sender_addr, coins_x);
        coin::deposit<Y>(sender_addr, coins_y);
        // event
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<RemoveLiquidityEvent<X, Y>>(
            &mut pair_event_holder.remove_liquidity,
            RemoveLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x,
                amount_y,
                liquidity,
                fee_amount: (fee_amount as u64)
            }
        );
        (amount_x, amount_y)
    }
    /// Remove liquidity to token types.
    fun remove_liquidity_direct<X, Y>(
        liquidity: coin::Coin<LPToken<X, Y>>,
    ): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        burn<X, Y>(liquidity)
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
        let amount_out = coin::value(&coins_y_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_out
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y_direct<X, Y>(
        coins_in: coin::Coin<X>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<X>(&coins_in);
        deposit_x<X, Y>(coins_in);
        let (rin, rout, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    public(friend) fun swap_x_to_exact_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_x_to_exact_y_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_in
    }
    public(friend) fun swap_x_to_exact_y_direct<X, Y>(
        coins_in: coin::Coin<X>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_x<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_y_to_x_direct<X, Y>(coins);
        let amount_out = coin::value<X>(&coins_x_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_out
    }
    public(friend) fun swap_y_to_exact_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_y_to_exact_x_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_in
    }
    public(friend) fun swap_y_to_exact_x_direct<X, Y>(
        coins_in: coin::Coin<Y>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_y<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x_direct<X, Y>(
        coins_in: coin::Coin<Y>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<Y>(&coins_in);
        deposit_y<X, Y>(coins_in);
        let (rout, rin, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    fun swap<X, Y>(
        amount_x_out: u64,
        amount_y_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        assert!(amount_x_out < reserves.reserve_x && amount_y_out < reserves.reserve_y, ERROR_INSUFFICIENT_LIQUIDITY);
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let coins_x_out = coin::zero<X>();
        let coins_y_out = coin::zero<Y>();
        if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
        if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
        let (balance_x, balance_y) = token_balances<X, Y>();
        let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
            balance_x - (reserves.reserve_x - amount_x_out)
        } else { 0 };
        let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
            balance_y - (reserves.reserve_y - amount_y_out)
        } else { 0 };
        assert!(amount_x_in > 0 || amount_y_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        let prec = (PRECISION as u128);
        let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
        let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
        let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
        let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
        // No need to use u256 when balance_x_adjusted * balance_y_adjusted and reserve_x_adjusted * reserve_y_adjusted are less than MAX_U128.
        let compare_result = if(balance_x_adjusted > 0 && reserve_x_adjusted > 0 && MAX_U128 / balance_x_adjusted > balance_y_adjusted && MAX_U128 / reserve_x_adjusted > reserve_y_adjusted){
            balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
        }else{
            let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
            let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
            p >= k
        };
        assert!(compare_result, ERROR_K);
        update(balance_x, balance_y, reserves);
        (coins_x_out, coins_y_out)
    }
    /// Mint LP Token.
    /// This low-level function should be called from a contract which performs important safety checks
    fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
        let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_supply = total_lp_supply<X, Y>();
        let liquidity = if (total_supply == 0u128) {
            let sqrt = math128::sqrt(amount_x * amount_y);
            assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            let l = sqrt - MINIMUM_LIQUIDITY;
            // permanently lock the first MINIMUM_LIQUIDITY tokens
            mint_lp_to<X, Y>(RESOURCE_ACCOUNT, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
            l
        } else {
            let liquidity = math128::min(amount_x * total_supply / (reserves.reserve_x as u128), amount_y * total_supply / (reserves.reserve_y as u128));
            assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            liquidity
        };
        let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
        update<X, Y>(balance_x, balance_y, reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (lp, fee_amount)
    }
    fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let liquidity = coin::value(&lp_tokens);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_lp_supply = total_lp_supply<X, Y>();
        let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
        coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
        let w_x = extract_x((amount_x as u64), metadata);
        let w_y = extract_y((amount_y as u64), metadata);
        update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (w_x, w_y, fee_amount)
    }
    fun update<X, Y>(balance_x: u64, balance_y: u64, reserve: &mut TokenPairReserve<X, Y>) {
        let block_timestamp = timestamp::now_seconds();
        reserve.reserve_x = balance_x;
        reserve.reserve_y = balance_y;
        reserve.block_timestamp_last = block_timestamp;
    }
    /// Mint LP Tokens to account
    fun mint_lp_to<X, Y>(
        to: address,
        amount: u64,
        mint_cap: &coin::MintCapability<LPToken<X, Y>>
    ) {
        let coins = coin::mint<LPToken<X, Y>>(amount, mint_cap);
        coin::deposit(to, coins);
    }
    /// Mint LP Tokens to account
    fun mint_lp<X, Y>(amount: u64, mint_cap: &coin::MintCapability<LPToken<X, Y>>): coin::Coin<LPToken<X, Y>> {
        coin::mint<LPToken<X, Y>>(amount, mint_cap)
    }
    fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_x, amount);
    }
    fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_y, amount);
    }
    /// Extract `amount` from this contract
    fun extract_x<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<X> {
        assert!(coin::value<X>(&metadata.balance_x) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_x, amount)
    }
    /// Extract `amount` from this contract
    fun extract_y<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<Y> {
        assert!(coin::value<Y>(&metadata.balance_y) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_y, amount)
    }
    fun mint_fee<X, Y>(reserve_x: u64, reserve_y: u64, metadata: &mut TokenPairMetadata<X, Y>): u64 {
        let fee = 0u64;
        if (metadata.k_last != 0) {
            let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
            let root_k_last = math128::sqrt(metadata.k_last);
            if (root_k > root_k_last) {
                let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
                let denominator = root_k_last * 17u128 + (root_k * 8u128);
                let liquidity = numerator / denominator;
                fee = (liquidity as u64);
                // record fee amount in metadata, in case of fee_to with register.
                if (fee > 0) {
                    let coin = mint_lp(fee, &metadata.mint_cap);
                    coin::merge(&mut metadata.fee_amount, coin);
                }
            };
        };
        fee
    }
    public entry fun set_admin(sender: &signer, new_admin: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.admin = new_admin;
    }
    public entry fun set_fee_to(sender: &signer, new_fee_to: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.fee_to = new_fee_to;
    }
}
module movement::swap_utils {
    use std::string;
    use aptos_std::type_info;
    const EQUAL: u8 = 0;
    const SMALLER: u8 = 1;
    const GREATER: u8 = 2;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 0;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 1;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 2;
    const ERROR_INSUFFICIENT_OUTPOT_AMOUNT: u64 = 3;
    const ERROR_SAME_COIN: u64 = 4;
    public fun get_amount_out(
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let amount_in_with_fee = (amount_in as u128) * 9975u128;
        let numerator = amount_in_with_fee * (reserve_out as u128);
        let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
        ((numerator / denominator) as u64)
    }
    public fun get_amount_in(
        amount_out: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_out > 0, ERROR_INSUFFICIENT_OUTPOT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let numerator = (reserve_in as u128) * (amount_out as u128) * 10000u128;
        let denominator = ((reserve_out as u128) - (amount_out as u128)) * 9975u128;
        (((numerator / denominator) as u64) + 1u64)
    }
    public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
        assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
        assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
    }
    public fun get_token_info<T>(): vector<u8> {
        let type_name = type_info::type_name<T>();
        *string::bytes(&type_name)
    }
}</code>
module movement::swap {
    use std::signer;
    use std::option;
    use std::string;
    use aptos_std::type_info;
    use aptos_std::event;
    use aptos_std::math128;
    use aptos_framework::coin;
    use aptos_framework::timestamp;
    use aptos_framework::account;
    use aptos_framework::resource_account;
    use movement::swap_utils;
    const ZERO_ACCOUNT: address = @0x0;
    const DEFAULT_ADMIN: address = @movement;
    const RESOURCE_ACCOUNT: address = @movement;
    const DEV: address = @dev;
    const MINIMUM_LIQUIDITY: u128 = 1000;
    const MAX_COIN_NAME_LENGTH: u64 = 32;
    // List of errors
    const ERROR_ONLY_ADMIN: u64 = 0;
    const ERROR_ALREADY_INITIALIZED: u64 = 1;
    const ERROR_NOT_CREATOR: u64 = 2;
    const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 4;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 6;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 7;
    const ERROR_INVALID_AMOUNT: u64 = 8;
    const ERROR_TOKENS_NOT_SORTED: u64 = 9;
    const ERROR_INSUFFICIENT_LIQUIDITY_BURNED: u64 = 10;
    const ERROR_INSUFFICIENT_OUTPUT_AMOUNT: u64 = 13;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 14;
    const ERROR_K: u64 = 15;
    const ERROR_X_NOT_REGISTERED: u64 = 16;
    const ERROR_Y_NOT_REGISTERED: u64 = 16;
    const ERROR_NOT_ADMIN: u64 = 17;
    const ERROR_NOT_FEE_TO: u64 = 18;
    const ERROR_NOT_EQUAL_EXACT_AMOUNT: u64 = 19;
    const ERROR_NOT_RESOURCE_ACCOUNT: u64 = 20;
    const ERROR_NO_FEE_WITHDRAW: u64 = 21;
    const PRECISION: u64 = 10000;
    /// Max `u128` value.
    const MAX_U128: u128 = 340282366920938463463374607431768211455;
    /// The LP Token type
    struct LPToken<phantom X, phantom Y> has key {}
    /// Stores the metadata required for the token pairs
    struct TokenPairMetadata<phantom X, phantom Y> has key {
        /// The admin of the token pair
        creator: address,
        /// fee amount , record fee amount which is not withdrawed
        fee_amount: coin::Coin<LPToken<X, Y>>,
        /// It's reserve_x * reserve_y, as of immediately after the most recent liquidity event
        k_last: u128,
        /// T0 token balance
        balance_x: coin::Coin<X>,
        /// T1 token balance
        balance_y: coin::Coin<Y>,
        /// Mint capacity of LP Token
        mint_cap: coin::MintCapability<LPToken<X, Y>>,
        /// Burn capacity of LP Token
        burn_cap: coin::BurnCapability<LPToken<X, Y>>,
        /// Freeze capacity of LP Token
        freeze_cap: coin::FreezeCapability<LPToken<X, Y>>,
    }
    /// Stores the reservation info required for the token pairs
    struct TokenPairReserve<phantom X, phantom Y> has key {
        reserve_x: u64,
        reserve_y: u64,
        block_timestamp_last: u64
    }
    struct SwapInfo has key {
        signer_cap: account::SignerCapability,
        fee_to: address,
        admin: address,
        pair_created: event::EventHandle<PairCreatedEvent>
    }
    struct PairCreatedEvent has drop, store {
        user: address,
        token_x: string::String,
        token_y: string::String
    }
    struct PairEventHolder<phantom X, phantom Y> has key {
        add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
        remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
        swap: event::EventHandle<SwapEvent<X, Y>>
    }
    struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x: u64,
        amount_y: u64,
        liquidity: u64,
        fee_amount: u64
    }
    struct RemoveLiquidityEvent<phantom X, phantom Y> has drop, store {
        user: address,
        liquidity: u64,
        amount_x: u64,
        amount_y: u64,
        fee_amount: u64
    }
    struct SwapEvent<phantom X, phantom Y> has drop, store {
        user: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    }
    /*
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     Please use swap_util::sort_token_type<X,Y>()
     before using any function
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    */
    fun init_module(sender: &signer) {
        let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEV);
        let resource_signer = account::create_signer_with_capability(&signer_cap);
        move_to(&resource_signer, SwapInfo {
            signer_cap,
            fee_to: ZERO_ACCOUNT,
            admin: DEFAULT_ADMIN,
            pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
        });
    }
    /// Create the specified coin pair
    public(friend) fun create_pair<X, Y>(
        sender: &signer,
    ) acquires SwapInfo {
        assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
        let lp_name: string::String = string::utf8(b"movement-");
        let name_x = coin::symbol<X>();
        let name_y = coin::symbol<Y>();
        string::append(&mut lp_name, name_x);
        string::append_utf8(&mut lp_name, b"-");
        string::append(&mut lp_name, name_y);
        string::append_utf8(&mut lp_name, b"-LP");
        if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
            lp_name = string::utf8(b"movement LPs");
        };
        // now we init the LP token
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
            &resource_signer,
            lp_name,
            string::utf8(b"Cake-LP"),
            8,
            true
        );
        move_to<TokenPairReserve<X, Y>>(
            &resource_signer,
            TokenPairReserve {
                reserve_x: 0,
                reserve_y: 0,
                block_timestamp_last: 0
            }
        );
        move_to<TokenPairMetadata<X, Y>>(
            &resource_signer,
            TokenPairMetadata {
                creator: sender_addr,
                fee_amount: coin::zero<LPToken<X, Y>>(),
                k_last: 0,
                balance_x: coin::zero<X>(),
                balance_y: coin::zero<Y>(),
                mint_cap,
                burn_cap,
                freeze_cap,
            }
        );
        move_to<PairEventHolder<X, Y>>(
            &resource_signer,
            PairEventHolder {
                add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
                remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X, Y>>(&resource_signer),
                swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
            }
        );
        // pair created event
        let token_x = type_info::type_name<X>();
        let token_y = type_info::type_name<Y>();
        event::emit_event<PairCreatedEvent>(
            &mut swap_info.pair_created,
            PairCreatedEvent {
                user: sender_addr,
                token_x,
                token_y
            }
        );
        // create LP CoinStore , which is needed as a lock for minimum_liquidity
        register_lp<X, Y>(&resource_signer);
    }
    public fun register_lp<X, Y>(sender: &signer) {
        coin::register<LPToken<X, Y>>(sender);
    }
    public fun is_pair_created<X, Y>(): bool {
        exists<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT)
    }
    /// Obtain the LP token balance of `addr`.
    /// This method can only be used to check other users' balance.
    public fun lp_balance<X, Y>(addr: address): u64 {
        coin::balance<LPToken<X, Y>>(addr)
    }
    /// Get the total supply of LP Tokens
    public fun total_lp_supply<X, Y>(): u128 {
        option::get_with_default(
            &coin::supply<LPToken<X, Y>>(),
            0u128
        )
    }
    /// Get the current reserves of T0 and T1 with the latest updated timestamp
    public fun token_reserves<X, Y>(): (u64, u64, u64) acquires TokenPairReserve {
        let reserve = borrow_global<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        (
            reserve.reserve_x,
            reserve.reserve_y,
            reserve.block_timestamp_last
        )
    }
    /// The amount of balance currently in pools of the liquidity pair
    public fun token_balances<X, Y>(): (u64, u64) acquires TokenPairMetadata {
        let meta =
            borrow_global<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        (
            coin::value(&meta.balance_x),
            coin::value(&meta.balance_y)
        )
    }
    public fun check_or_register_coin_store<X>(sender: &signer) {
        if (!coin::is_account_registered<X>(signer::address_of(sender))) {
            coin::register<X>(sender);
        };
    }
    public fun admin(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.admin
    }
    public fun fee_to(): address acquires SwapInfo {
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        swap_info.fee_to
    }
    // ===================== Update functions ======================
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    public(friend) fun add_liquidity<X, Y>(
        sender: &signer,
        amount_x: u64,
        amount_y: u64
    ): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
        let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) = add_liquidity_direct(coin::withdraw<X>(sender, amount_x), coin::withdraw<Y>(sender, amount_y));
        let sender_addr = signer::address_of(sender);
        let lp_amount = coin::value(&coin_lp);
        assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        check_or_register_coin_store<LPToken<X, Y>>(sender);
        coin::deposit(sender_addr, coin_lp);
        coin::deposit(sender_addr, coin_left_x);
        coin::deposit(sender_addr, coin_left_y);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<AddLiquidityEvent<X, Y>>(
            &mut pair_event_holder.add_liquidity,
            AddLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x: a_x,
                amount_y: a_y,
                liquidity: lp_amount,
                fee_amount: (fee_amount as u64),
            }
        );
        (a_x, a_y, lp_amount)
    }
    public(friend) fun add_swap_event<X, Y>(
        sender: &signer,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let sender_addr = signer::address_of(sender);
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    public(friend) fun add_swap_event_with_address<X, Y>(
        sender_addr: address,
        amount_x_in: u64,
        amount_y_in: u64,
        amount_x_out: u64,
        amount_y_out: u64
    ) acquires PairEventHolder {
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<SwapEvent<X, Y>>(
            &mut pair_event_holder.swap,
            SwapEvent<X, Y> {
                user: sender_addr,
                amount_x_in,
                amount_y_in,
                amount_x_out,
                amount_y_out
            }
        );
    }
    /// Add more liquidity to token types. This method explicitly assumes the
    /// min of both tokens are 0.
    fun add_liquidity_direct<X, Y>(
        x: coin::Coin<X>,
        y: coin::Coin<Y>,
    ): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_x = coin::value(&x);
        let amount_y = coin::value(&y);
        let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
        let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
            (amount_x, amount_y)
        } else {
            let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
            if (amount_y_optimal <= amount_y) {
                (amount_x, amount_y_optimal)
            } else {
                let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
                assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
                (amount_x_optimal, amount_y)
            }
        };
        assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
        assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
        let left_x = coin::extract(&mut x, amount_x - a_x);
        let left_y = coin::extract(&mut y, amount_y - a_y);
        deposit_x<X, Y>(x);
        deposit_y<X, Y>(y);
        let (lp, fee_amount) = mint<X, Y>();
        (a_x, a_y, lp, fee_amount, left_x, left_y)
    }
    /// Remove liquidity to token types.
    public(friend) fun remove_liquidity<X, Y>(
        sender: &signer,
        liquidity: u64,
    ): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
        let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
        let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
        let amount_x = coin::value(&coins_x);
        let amount_y = coin::value(&coins_y);
        check_or_register_coin_store<X>(sender);
        check_or_register_coin_store<Y>(sender);
        let sender_addr = signer::address_of(sender);
        coin::deposit<X>(sender_addr, coins_x);
        coin::deposit<Y>(sender_addr, coins_y);
        // event
        let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(RESOURCE_ACCOUNT);
        event::emit_event<RemoveLiquidityEvent<X, Y>>(
            &mut pair_event_holder.remove_liquidity,
            RemoveLiquidityEvent<X, Y> {
                user: sender_addr,
                amount_x,
                amount_y,
                liquidity,
                fee_amount: (fee_amount as u64)
            }
        );
        (amount_x, amount_y)
    }
    /// Remove liquidity to token types.
    fun remove_liquidity_direct<X, Y>(
        liquidity: coin::Coin<LPToken<X, Y>>,
    ): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        burn<X, Y>(liquidity)
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
        let amount_out = coin::value(&coins_y_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_out
    }
    /// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_x_to_y_direct<X, Y>(
        coins_in: coin::Coin<X>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<X>(&coins_in);
        deposit_x<X, Y>(coins_in);
        let (rin, rout, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    public(friend) fun swap_x_to_exact_y<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<X>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_x_to_exact_y_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<Y>(sender);
        coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
        coin::deposit(to, coins_y_out);
        amount_in
    }
    public(friend) fun swap_x_to_exact_y_direct<X, Y>(
        coins_in: coin::Coin<X>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_x<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
        assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_exact_y_to_x_direct<X, Y>(coins);
        let amount_out = coin::value<X>(&coins_x_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_out
    }
    public(friend) fun swap_y_to_exact_x<X, Y>(
        sender: &signer,
        amount_in: u64,
        amount_out: u64,
        to: address
    ): u64 acquires TokenPairReserve, TokenPairMetadata {
        let coins_in = coin::withdraw<Y>(sender, amount_in);
        let (coins_x_out, coins_y_out) = swap_y_to_exact_x_direct<X, Y>(coins_in, amount_out);
        check_or_register_coin_store<X>(sender);
        coin::deposit(to, coins_x_out);
        coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
        amount_in
    }
    public(friend) fun swap_y_to_exact_x_direct<X, Y>(
        coins_in: coin::Coin<Y>, amount_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        deposit_y<X, Y>(coins_in);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    /// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
    public(friend) fun swap_exact_y_to_x_direct<X, Y>(
        coins_in: coin::Coin<Y>
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        let amount_in = coin::value<Y>(&coins_in);
        deposit_y<X, Y>(coins_in);
        let (rout, rin, _) = token_reserves<X, Y>();
        let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
        let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
        assert!(coin::value<Y>(&coins_y_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        (coins_x_out, coins_y_out)
    }
    fun swap<X, Y>(
        amount_x_out: u64,
        amount_y_out: u64
    ): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
        assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        assert!(amount_x_out < reserves.reserve_x && amount_y_out < reserves.reserve_y, ERROR_INSUFFICIENT_LIQUIDITY);
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let coins_x_out = coin::zero<X>();
        let coins_y_out = coin::zero<Y>();
        if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
        if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
        let (balance_x, balance_y) = token_balances<X, Y>();
        let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
            balance_x - (reserves.reserve_x - amount_x_out)
        } else { 0 };
        let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
            balance_y - (reserves.reserve_y - amount_y_out)
        } else { 0 };
        assert!(amount_x_in > 0 || amount_y_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        let prec = (PRECISION as u128);
        let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
        let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
        let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
        let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
        // No need to use u256 when balance_x_adjusted * balance_y_adjusted and reserve_x_adjusted * reserve_y_adjusted are less than MAX_U128.
        let compare_result = if(balance_x_adjusted > 0 && reserve_x_adjusted > 0 && MAX_U128 / balance_x_adjusted > balance_y_adjusted && MAX_U128 / reserve_x_adjusted > reserve_y_adjusted){
            balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
        }else{
            let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
            let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
            p >= k
        };
        assert!(compare_result, ERROR_K);
        update(balance_x, balance_y, reserves);
        (coins_x_out, coins_y_out)
    }
    /// Mint LP Token.
    /// This low-level function should be called from a contract which performs important safety checks
    fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
        let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_supply = total_lp_supply<X, Y>();
        let liquidity = if (total_supply == 0u128) {
            let sqrt = math128::sqrt(amount_x * amount_y);
            assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            let l = sqrt - MINIMUM_LIQUIDITY;
            // permanently lock the first MINIMUM_LIQUIDITY tokens
            mint_lp_to<X, Y>(RESOURCE_ACCOUNT, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
            l
        } else {
            let liquidity = math128::min(amount_x * total_supply / (reserves.reserve_x as u128), amount_y * total_supply / (reserves.reserve_y as u128));
            assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
            liquidity
        };
        let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
        update<X, Y>(balance_x, balance_y, reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (lp, fee_amount)
    }
    fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
        let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
        let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
        let liquidity = coin::value(&lp_tokens);
        let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
        //Need to add fee amount which have not been mint.
        let total_lp_supply = total_lp_supply<X, Y>();
        let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
        assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
        coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
        let w_x = extract_x((amount_x as u64), metadata);
        let w_y = extract_y((amount_y as u64), metadata);
        update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
        metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
        (w_x, w_y, fee_amount)
    }
    fun update<X, Y>(balance_x: u64, balance_y: u64, reserve: &mut TokenPairReserve<X, Y>) {
        let block_timestamp = timestamp::now_seconds();
        reserve.reserve_x = balance_x;
        reserve.reserve_y = balance_y;
        reserve.block_timestamp_last = block_timestamp;
    }
    /// Mint LP Tokens to account
    fun mint_lp_to<X, Y>(
        to: address,
        amount: u64,
        mint_cap: &coin::MintCapability<LPToken<X, Y>>
    ) {
        let coins = coin::mint<LPToken<X, Y>>(amount, mint_cap);
        coin::deposit(to, coins);
    }
    /// Mint LP Tokens to account
    fun mint_lp<X, Y>(amount: u64, mint_cap: &coin::MintCapability<LPToken<X, Y>>): coin::Coin<LPToken<X, Y>> {
        coin::mint<LPToken<X, Y>>(amount, mint_cap)
    }
    fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_x, amount);
    }
    fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
        let metadata =
            borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
        coin::merge(&mut metadata.balance_y, amount);
    }
    /// Extract `amount` from this contract
    fun extract_x<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<X> {
        assert!(coin::value<X>(&metadata.balance_x) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_x, amount)
    }
    /// Extract `amount` from this contract
    fun extract_y<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<Y> {
        assert!(coin::value<Y>(&metadata.balance_y) > amount, ERROR_INSUFFICIENT_AMOUNT);
        coin::extract(&mut metadata.balance_y, amount)
    }
    fun mint_fee<X, Y>(reserve_x: u64, reserve_y: u64, metadata: &mut TokenPairMetadata<X, Y>): u64 {
        let fee = 0u64;
        if (metadata.k_last != 0) {
            let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
            let root_k_last = math128::sqrt(metadata.k_last);
            if (root_k > root_k_last) {
                let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
                let denominator = root_k_last * 17u128 + (root_k * 8u128);
                let liquidity = numerator / denominator;
                fee = (liquidity as u64);
                // record fee amount in metadata, in case of fee_to with register.
                if (fee > 0) {
                    let coin = mint_lp(fee, &metadata.mint_cap);
                    coin::merge(&mut metadata.fee_amount, coin);
                }
            };
        };
        fee
    }
    public entry fun set_admin(sender: &signer, new_admin: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.admin = new_admin;
    }
    public entry fun set_fee_to(sender: &signer, new_fee_to: address) acquires SwapInfo {
        let sender_addr = signer::address_of(sender);
        let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
        assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
        swap_info.fee_to = new_fee_to;
    }
}
module movement::swap_utils {
    use std::string;
    use aptos_std::type_info;
    const EQUAL: u8 = 0;
    const SMALLER: u8 = 1;
    const GREATER: u8 = 2;
    const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 0;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 1;
    const ERROR_INSUFFICIENT_AMOUNT: u64 = 2;
    const ERROR_INSUFFICIENT_OUTPOT_AMOUNT: u64 = 3;
    const ERROR_SAME_COIN: u64 = 4;
    public fun get_amount_out(
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let amount_in_with_fee = (amount_in as u128) * 9975u128;
        let numerator = amount_in_with_fee * (reserve_out as u128);
        let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
        ((numerator / denominator) as u64)
    }
    public fun get_amount_in(
        amount_out: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        assert!(amount_out > 0, ERROR_INSUFFICIENT_OUTPOT_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        let numerator = (reserve_in as u128) * (amount_out as u128) * 10000u128;
        let denominator = ((reserve_out as u128) - (amount_out as u128)) * 9975u128;
        (((numerator / denominator) as u64) + 1u64)
    }
    public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
        assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
        assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        (((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
    }
    public fun get_token_info<T>(): vector<u8> {
        let type_name = type_info::type_name<T>();
        *string::bytes(&type_name)
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/03-pump4fun
Pump4Fun
Pump4Fun
Start
Start
How Pump4fun Work   Fair Launch
Start
Create a Fungible Assets
Start
Initialize Liquidity in Pump4fun
Start
AMM & Swap Tokens
Start
How Pump4fun Work   Fair Launch
Start
How Pump4fun Work   Fair Launch
Start
How Pump4fun Work   Fair Launch
How Pump4fun Work   Fair Launch
Start
Start
Create a Fungible Assets
Start
Create a Fungible Assets
Start
Create a Fungible Assets
Create a Fungible Assets
Start
Start
Initialize Liquidity in Pump4fun
Start
Initialize Liquidity in Pump4fun
Start
Initialize Liquidity in Pump4fun
Initialize Liquidity in Pump4fun
Start
Start
AMM & Swap Tokens
Start
AMM & Swap Tokens
Start
AMM & Swap Tokens
AMM & Swap Tokens
Start
Start

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/03-pump4fun/01-how-pump4fun-work-fair-launch
How Pump4fun Work
How Pump4fun Work
On This Page
Summary
What is Pump4fun?
How Does Pump4fun Work?
Why Does Pump4fun Matter?
Key Features and User Flow
Typical User Flow:
Functions We Will Build
Conclusion
Summary
Pump4fun is a user-friendly DeFi platform that simplifies token creation and liquidity management on the blockchain. It allows users to easily create custom tokens, manage liquidity, and interact with decentralized exchanges. The platform aims to democratize access to DeFi by automating complex processes, making it accessible to both beginners and experienced users in the crypto space.
What is Pump4fun?
Pump4fun
is an innovative decentralized finance (DeFi) platform designed to make token creation and liquidity management more accessible and efficient for users. It aims to simplify the process of launching and managing tokens on the blockchain.
How Does Pump4fun Work?
Pump4fun operates on a blockchain network, allowing users to create their own tokens, manage liquidity, and interact with decentralized exchanges (DEXs) in a user-friendly manner. The platform automates many complex processes that typically require deep technical knowledge.
Why Does Pump4fun Matter?
Pump4fun matters because it democratizes token creation and management. It allows individuals and small projects to participate in the DeFi ecosystem without needing extensive blockchain development skills. This opens up new opportunities for innovation and participation in the crypto space.
Key Features and User Flow
Token Creation:
Users can easily create their own tokens with customizable parameters.
Liquidity Management:
The platform helps in adding and managing liquidity for the created tokens.
DEX Integration:
Tokens can be automatically listed on decentralized exchanges when certain conditions are met.
User-Friendly Interface:
The entire process is designed to be intuitive, even for blockchain beginners.
Typical User Flow:
User connects their wallet to Pump4fun
They choose to create a new token, setting parameters like name, symbol, and supply
The platform guides them through adding initial liquidity
Users can monitor their token's performance and manage liquidity
When predefined goals are met, the token can be automatically listed on supported DEXs
Functions We Will Build
create_token:
A function to mint new tokens with user-defined parameters
add_liquidity_curve:
Functionality to add liquidity to Curve, a popular decentralized exchange
add_to_dex:
A feature to automatically list tokens on various decentralized exchanges when certain requirements are met
These functions will form the core of Pump4fun's functionality, enabling users to go from token creation to active trading with minimal technical barriers.
Conclusion
Pump4fun is set to revolutionize how we interact with token creation and management in the DeFi space. By simplifying complex processes and providing an intuitive platform, it opens up new possibilities for both novice and experienced users in the blockchain world.
On This Page
Summary
What is Pump4fun?
How Does Pump4fun Work?
Why Does Pump4fun Matter?
Key Features and User Flow
Typical User Flow:
Functions We Will Build
Conclusion
On This Page
Summary
What is Pump4fun?
How Does Pump4fun Work?
Why Does Pump4fun Matter?
Key Features and User Flow
Typical User Flow:
Functions We Will Build
Conclusion
			On This Page
			On This Page
			Summary
What is Pump4fun?
How Does Pump4fun Work?
Why Does Pump4fun Matter?
Key Features and User Flow
Typical User Flow:
Functions We Will Build
Conclusion
			Summary
			Summary
			Summary
			Summary
			What is Pump4fun?
			What is Pump4fun?
			What is Pump4fun?
			What is Pump4fun?
			How Does Pump4fun Work?
			How Does Pump4fun Work?
			How Does Pump4fun Work?
			How Does Pump4fun Work?
			Why Does Pump4fun Matter?
			Why Does Pump4fun Matter?
			Why Does Pump4fun Matter?
			Why Does Pump4fun Matter?
			Key Features and User Flow
			Key Features and User Flow
			Key Features and User Flow
			Key Features and User Flow
			Typical User Flow:
			Typical User Flow:
			Typical User Flow:
			Typical User Flow:
			Functions We Will Build
			Functions We Will Build
			Functions We Will Build
			Functions We Will Build
			Conclusion
			Conclusion
			Conclusion
			Conclusion
			Summary
Pump4fun is a user-friendly DeFi platform that simplifies token creation and liquidity management on the blockchain. It allows users to easily create custom tokens, manage liquidity, and interact with decentralized exchanges. The platform aims to democratize access to DeFi by automating complex processes, making it accessible to both beginners and experienced users in the crypto space.
What is Pump4fun?
Pump4fun
is an innovative decentralized finance (DeFi) platform designed to make token creation and liquidity management more accessible and efficient for users. It aims to simplify the process of launching and managing tokens on the blockchain.
How Does Pump4fun Work?
Pump4fun operates on a blockchain network, allowing users to create their own tokens, manage liquidity, and interact with decentralized exchanges (DEXs) in a user-friendly manner. The platform automates many complex processes that typically require deep technical knowledge.
Why Does Pump4fun Matter?
Pump4fun matters because it democratizes token creation and management. It allows individuals and small projects to participate in the DeFi ecosystem without needing extensive blockchain development skills. This opens up new opportunities for innovation and participation in the crypto space.
Key Features and User Flow
Token Creation:
Users can easily create their own tokens with customizable parameters.
Liquidity Management:
The platform helps in adding and managing liquidity for the created tokens.
DEX Integration:
Tokens can be automatically listed on decentralized exchanges when certain conditions are met.
User-Friendly Interface:
The entire process is designed to be intuitive, even for blockchain beginners.
Typical User Flow:
User connects their wallet to Pump4fun
They choose to create a new token, setting parameters like name, symbol, and supply
The platform guides them through adding initial liquidity
Users can monitor their token's performance and manage liquidity
When predefined goals are met, the token can be automatically listed on supported DEXs
Functions We Will Build
create_token:
A function to mint new tokens with user-defined parameters
add_liquidity_curve:
Functionality to add liquidity to Curve, a popular decentralized exchange
add_to_dex:
A feature to automatically list tokens on various decentralized exchanges when certain requirements are met
These functions will form the core of Pump4fun's functionality, enabling users to go from token creation to active trading with minimal technical barriers.
Conclusion
Pump4fun is set to revolutionize how we interact with token creation and management in the DeFi space. By simplifying complex processes and providing an intuitive platform, it opens up new possibilities for both novice and experienced users in the blockchain world.
			Summary
Pump4fun is a user-friendly DeFi platform that simplifies token creation and liquidity management on the blockchain. It allows users to easily create custom tokens, manage liquidity, and interact with decentralized exchanges. The platform aims to democratize access to DeFi by automating complex processes, making it accessible to both beginners and experienced users in the crypto space.
What is Pump4fun?
Pump4fun
is an innovative decentralized finance (DeFi) platform designed to make token creation and liquidity management more accessible and efficient for users. It aims to simplify the process of launching and managing tokens on the blockchain.
How Does Pump4fun Work?
Pump4fun operates on a blockchain network, allowing users to create their own tokens, manage liquidity, and interact with decentralized exchanges (DEXs) in a user-friendly manner. The platform automates many complex processes that typically require deep technical knowledge.
Why Does Pump4fun Matter?
Pump4fun matters because it democratizes token creation and management. It allows individuals and small projects to participate in the DeFi ecosystem without needing extensive blockchain development skills. This opens up new opportunities for innovation and participation in the crypto space.
Key Features and User Flow
Token Creation:
Users can easily create their own tokens with customizable parameters.
Liquidity Management:
The platform helps in adding and managing liquidity for the created tokens.
DEX Integration:
Tokens can be automatically listed on decentralized exchanges when certain conditions are met.
User-Friendly Interface:
The entire process is designed to be intuitive, even for blockchain beginners.
Typical User Flow:
User connects their wallet to Pump4fun
They choose to create a new token, setting parameters like name, symbol, and supply
The platform guides them through adding initial liquidity
Users can monitor their token's performance and manage liquidity
When predefined goals are met, the token can be automatically listed on supported DEXs
Functions We Will Build
create_token:
A function to mint new tokens with user-defined parameters
add_liquidity_curve:
Functionality to add liquidity to Curve, a popular decentralized exchange
add_to_dex:
A feature to automatically list tokens on various decentralized exchanges when certain requirements are met
These functions will form the core of Pump4fun's functionality, enabling users to go from token creation to active trading with minimal technical barriers.
Conclusion
Pump4fun is set to revolutionize how we interact with token creation and management in the DeFi space. By simplifying complex processes and providing an intuitive platform, it opens up new possibilities for both novice and experienced users in the blockchain world.
			Summary
Pump4fun is a user-friendly DeFi platform that simplifies token creation and liquidity management on the blockchain. It allows users to easily create custom tokens, manage liquidity, and interact with decentralized exchanges. The platform aims to democratize access to DeFi by automating complex processes, making it accessible to both beginners and experienced users in the crypto space.
What is Pump4fun?
Pump4fun
is an innovative decentralized finance (DeFi) platform designed to make token creation and liquidity management more accessible and efficient for users. It aims to simplify the process of launching and managing tokens on the blockchain.
How Does Pump4fun Work?
Pump4fun operates on a blockchain network, allowing users to create their own tokens, manage liquidity, and interact with decentralized exchanges (DEXs) in a user-friendly manner. The platform automates many complex processes that typically require deep technical knowledge.
Why Does Pump4fun Matter?
Pump4fun matters because it democratizes token creation and management. It allows individuals and small projects to participate in the DeFi ecosystem without needing extensive blockchain development skills. This opens up new opportunities for innovation and participation in the crypto space.
Key Features and User Flow
Token Creation:
Users can easily create their own tokens with customizable parameters.
Liquidity Management:
The platform helps in adding and managing liquidity for the created tokens.
DEX Integration:
Tokens can be automatically listed on decentralized exchanges when certain conditions are met.
User-Friendly Interface:
The entire process is designed to be intuitive, even for blockchain beginners.
Typical User Flow:
User connects their wallet to Pump4fun
They choose to create a new token, setting parameters like name, symbol, and supply
The platform guides them through adding initial liquidity
Users can monitor their token's performance and manage liquidity
When predefined goals are met, the token can be automatically listed on supported DEXs
Functions We Will Build
create_token:
A function to mint new tokens with user-defined parameters
add_liquidity_curve:
Functionality to add liquidity to Curve, a popular decentralized exchange
add_to_dex:
A feature to automatically list tokens on various decentralized exchanges when certain requirements are met
These functions will form the core of Pump4fun's functionality, enabling users to go from token creation to active trading with minimal technical barriers.
Conclusion
Pump4fun is set to revolutionize how we interact with token creation and management in the DeFi space. By simplifying complex processes and providing an intuitive platform, it opens up new possibilities for both novice and experienced users in the blockchain world.
		Summary
		Summary
		Pump4fun is a user-friendly DeFi platform that simplifies token creation and liquidity management on the blockchain. It allows users to easily create custom tokens, manage liquidity, and interact with decentralized exchanges. The platform aims to democratize access to DeFi by automating complex processes, making it accessible to both beginners and experienced users in the crypto space.
		Pump4fun is a user-friendly DeFi platform that simplifies token creation and liquidity management on the blockchain. It allows users to easily create custom tokens, manage liquidity, and interact with decentralized exchanges. The platform aims to democratize access to DeFi by automating complex processes, making it accessible to both beginners and experienced users in the crypto space.
	What is Pump4fun?
	What is Pump4fun?
	Pump4fun
is an innovative decentralized finance (DeFi) platform designed to make token creation and liquidity management more accessible and efficient for users. It aims to simplify the process of launching and managing tokens on the blockchain.
	Pump4fun
	Pump4fun
	is an innovative decentralized finance (DeFi) platform designed to make token creation and liquidity management more accessible and efficient for users. It aims to simplify the process of launching and managing tokens on the blockchain.
	How Does Pump4fun Work?
	How Does Pump4fun Work?
	Pump4fun operates on a blockchain network, allowing users to create their own tokens, manage liquidity, and interact with decentralized exchanges (DEXs) in a user-friendly manner. The platform automates many complex processes that typically require deep technical knowledge.
	Pump4fun operates on a blockchain network, allowing users to create their own tokens, manage liquidity, and interact with decentralized exchanges (DEXs) in a user-friendly manner. The platform automates many complex processes that typically require deep technical knowledge.
	Why Does Pump4fun Matter?
	Why Does Pump4fun Matter?
	Pump4fun matters because it democratizes token creation and management. It allows individuals and small projects to participate in the DeFi ecosystem without needing extensive blockchain development skills. This opens up new opportunities for innovation and participation in the crypto space.
	Pump4fun matters because it democratizes token creation and management. It allows individuals and small projects to participate in the DeFi ecosystem without needing extensive blockchain development skills. This opens up new opportunities for innovation and participation in the crypto space.
	Key Features and User Flow
	Key Features and User Flow
	Token Creation:
Users can easily create their own tokens with customizable parameters.
Liquidity Management:
The platform helps in adding and managing liquidity for the created tokens.
DEX Integration:
Tokens can be automatically listed on decentralized exchanges when certain conditions are met.
User-Friendly Interface:
The entire process is designed to be intuitive, even for blockchain beginners.
	Token Creation:
Users can easily create their own tokens with customizable parameters.
	Token Creation:
	Token Creation:
	Users can easily create their own tokens with customizable parameters.
	Liquidity Management:
The platform helps in adding and managing liquidity for the created tokens.
	Liquidity Management:
	Liquidity Management:
	The platform helps in adding and managing liquidity for the created tokens.
	DEX Integration:
Tokens can be automatically listed on decentralized exchanges when certain conditions are met.
	DEX Integration:
	DEX Integration:
	Tokens can be automatically listed on decentralized exchanges when certain conditions are met.
	User-Friendly Interface:
The entire process is designed to be intuitive, even for blockchain beginners.
	User-Friendly Interface:
	User-Friendly Interface:
	The entire process is designed to be intuitive, even for blockchain beginners.
	Typical User Flow:
	Typical User Flow:
	User connects their wallet to Pump4fun
They choose to create a new token, setting parameters like name, symbol, and supply
The platform guides them through adding initial liquidity
Users can monitor their token's performance and manage liquidity
When predefined goals are met, the token can be automatically listed on supported DEXs
	User connects their wallet to Pump4fun
	User connects their wallet to Pump4fun
	They choose to create a new token, setting parameters like name, symbol, and supply
	They choose to create a new token, setting parameters like name, symbol, and supply
	The platform guides them through adding initial liquidity
	The platform guides them through adding initial liquidity
	Users can monitor their token's performance and manage liquidity
	Users can monitor their token's performance and manage liquidity
	When predefined goals are met, the token can be automatically listed on supported DEXs
	When predefined goals are met, the token can be automatically listed on supported DEXs
	Functions We Will Build
	Functions We Will Build
	create_token:
A function to mint new tokens with user-defined parameters
add_liquidity_curve:
Functionality to add liquidity to Curve, a popular decentralized exchange
add_to_dex:
A feature to automatically list tokens on various decentralized exchanges when certain requirements are met
	create_token:
A function to mint new tokens with user-defined parameters
	create_token:
	create_token:
	A function to mint new tokens with user-defined parameters
	add_liquidity_curve:
Functionality to add liquidity to Curve, a popular decentralized exchange
	add_liquidity_curve:
	add_liquidity_curve:
	Functionality to add liquidity to Curve, a popular decentralized exchange
	add_to_dex:
A feature to automatically list tokens on various decentralized exchanges when certain requirements are met
	add_to_dex:
	add_to_dex:
	A feature to automatically list tokens on various decentralized exchanges when certain requirements are met
	These functions will form the core of Pump4fun's functionality, enabling users to go from token creation to active trading with minimal technical barriers.
	These functions will form the core of Pump4fun's functionality, enabling users to go from token creation to active trading with minimal technical barriers.
	Conclusion
	Conclusion
	Pump4fun is set to revolutionize how we interact with token creation and management in the DeFi space. By simplifying complex processes and providing an intuitive platform, it opens up new possibilities for both novice and experienced users in the blockchain world.
	Pump4fun is set to revolutionize how we interact with token creation and management in the DeFi space. By simplifying complex processes and providing an intuitive platform, it opens up new possibilities for both novice and experienced users in the blockchain world.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/03-pump4fun/02-create-a-fungible-assets
Create a Fungible Assets
Create a Fungible Assets
On This Page
Overview
Admin Configuration
Create Token & Buy
Create Token
Initializing a Fungible Asset Store
Mint & Deposit Tokens
Fungible Asset Controller
Admin Fee
Full Code
Overview
In this article, we will use the knowledge we've learned about Coins and Fungible Assets to create a function that allows people to easily create an FA, and the admin (platform owner) will receive an amount of $MOVE as fees. In this example, we will use 0.1 MOVE as the fee for creating a token on MOVE.
Admin Configuration
We will need an admin to control or receive fees when users create tokens, and to manage functions that only the admin can execute. Here, we will initialize a resource that contains information about the Fee and admin address.
struct AppConfig has key {
    fees: u64,
    admin: address
}
fun init_module(sender: &signer) {
    let admin_addr = signer::address_of(sender);
    move_to(sender, AppConfig {
        fees: 10_000_000, // 1 APT = 100_000_000 octas
        admin: admin_addr,
    });
}
The
init_module
function is a module initialization function, called when the module is deployed. It has the following characteristics:
Parameter: Takes a parameter
sender
of type
&signer
, representing the module deployer.
Function: Initializes and stores an
AppConfig
structure in the deployer's storage.
Specifically:
Gets the address of the deployer using
signer::address_of(sender)
.
Creates an instance of
AppConfig
with:
Fees set to 10,000,000 octas (equivalent to 0.1 APT).
Admin address set to the deployer's address.
Uses
move_to
to store
AppConfig
in the deployer's storage.
This function sets up the initial configuration for the application, including the fee amount and admin address, which will be used to manage token creation and fee collection as described in the overview.
Create Token & Buy
Create Token
Next, we will initialize a Function to help users easily create a token.
/// Creates a new token and buys an initial amount for the sender.
///
/// @param sender: The signer creating the token and making the initial purchase.
/// @param name: The name of the token.
/// @param symbol: The symbol or ticker of the token.
/// @param icon_uri: The URI for the token's icon.
/// @param project_url: The URL of the project associated with the token.
/// @param amount: The initial amount of tokens to mint and buy.
///
/// This function creates a new fungible asset (token) with the given parameters,
/// mints the specified amount, and transfers it to the sender. It also handles
/// the fee payment to the admin as configured in the AppConfig resource.
///
/// Acquires: AppConfig - to access the fee information and admin address.
public entry fun create_token_and_buy(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    icon_uri: string::String,
    project_url: string::String,
    amount: u64
) acquires AppConfig {
    // Implementation details go here
}
The
create_token_and_buy
function is a public function that allows users to create and buy a new token.
Purpose:
Create a new token and buy an initial amount for the sender.
Parameters:
sender
: The signer creating the token and executing the initial purchase transaction.
name
: The name of the token.
symbol
: The symbol or code of the token.
icon_uri
: The URI for the token's icon.
project_url
: The URL of the project related to the token.
amount
: The initial amount of tokens to create and buy.
Main functions:
Create a new fungible asset with the provided parameters.
Mint the specified amount of tokens.
Transfer the created tokens to the sender.
Handle the fee payment to the admin according to the configuration in the AppConfig resource.
Important features:
Uses the keyword
acquires AppConfig
to access information about fees and admin address.
Is an
entry
function, allowing it to be called directly from outside the module.
This function provides a simple and direct way for users to create their own tokens on the platform, while ensuring that appropriate fees are collected and transferred to the system admin.
Initializing a Fungible Asset Store
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
let object_signer = object::generate_signer(&constructor_ref);
primary_fungible_store::create_primary_store_enabled_fungible_asset(
    &constructor_ref,
    option::some(1_000_000_000), // Total supply
    name,                        // Token Name
    symbol,                      // Token Symbol
    8,                           // Decimals
    icon_uri,                    // Icon URI (ex: https://icon.jpg)
    project_url                  // Project URL
);
This code snippet describes a part of the function to initialize a Fungible Asset on the Move platform. This is an important part of the process of creating a new token. Let's analyze each step:
Create a named object:
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
This line creates a new object with a name based on the provided 'name' parameter.
Create a signer for the object:
let object_signer = object::generate_signer(&constructor_ref);
Creates a 'signer' for the new object, allowing operations to be performed on behalf of this object.
Create Fungible Asset:
primary_fungible_store::create_primary_store_enabled_fungible_asset(...)
This is the main step to create the token. This function takes the following parameters:
Constructor reference
Total supply: 1,000,000,000 (can be adjusted)
Token name
Token symbol
Decimals: 8
Icon URI
Project URL
This code creates a new Fungible Asset with the specified attributes, allowing users to create their own tokens with specific parameters. It also sets up the primary store for the token, enabling efficient storage and management of the token.
Mint & Deposit Tokens
let fa = fungible_asset::mint(&controller.mint_ref, amount);
primary_fungible_store::deposit(signer::address_of(account), fa);
Based on the selected code snippet, I can describe the functionality as follows:
This code snippet performs two important steps in the process of creating and distributing tokens:
Create (mint) tokens:
let fa = fungible_asset::mint(&controller.mint_ref, amount);
This function creates a new amount of tokens (fungible asset) based on the specified amount. It uses the mint reference (mint_ref) from the controller to perform the token creation.
Deposit tokens into the account:
primary_fungible_store::deposit(signer::address_of(account), fa);
This function deposits the newly created tokens (fa) into the user's account. The account address is obtained from the account object using
signer::address_of(account)
.
The purpose of this function is to allow users to create a new amount of tokens and immediately deposit them into their account. This helps users to initialize and own tokens easily and quickly.
This function is an important part of the token creation process, allowing users not only to define the token's attributes (as seen in previous sections with parameters like name, symbol, icon_uri, project_url) but also to create and own a specific amount of tokens right from the start.
Fungible Asset Controller
In the article about Object and Fungible Asset, we learned about FA Abilities such as MintRef, BurnRef, TransferRef. So we will also use them to apply to this Function to initialize a resource object containing these Abilities for the FA we just created.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FAController has key {
    dev_address: address,
    mint_ref: MintRef,
    burn_ref: BurnRef,
    transfer_ref: TransferRef,
}
// Setup token controller
move_to(&object_signer, FAController {
    dev_address: sender_addr,
    mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
    burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
    transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
});
Admin Fee
Another issue is that when initializing a token, the platform admin needs to receive a corresponding fee. For this, we can use AptosCoin to use the Native coin of the Platform, which in this case will be $MOVE on the Movement Network.
let app_config = borrow_global<AppConfig>(@movement);
let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
coin::deposit<AptosCoin>(app_config.admin, coins);
This function performs the following steps:
Access the application configuration (AppConfig) from the Movement address to get information about fees and admin address
Withdraw an amount of coins (AptosCoin) from the sender's account based on the configured fee
Deposit the withdrawn coins into the admin's account
Note that this function uses AptosCoin, but in the context of the Movement Network, this will correspond to $MOVE, which is the native coin of the platform.
Full Code
module movement::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    const DECIMAIL :u8 = 8;
    const MAX_SUPPLY: u128 = 1_000_000_000;
    const FEE: u64 = 10_000_000;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE, // 0.1 APT = 100_000_000 octas
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        amount: u64
    ) acquires AppConfig, FAController {
        let app_config = borrow_global<AppConfig>(@movement);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, coins);
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some(1_000_000_000),
            name,
            symbol,
            DECIMAIL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        mint_tokens(sender, fa_obj, amount);
    }
    /// Mint tokens to an account
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
}
On This Page
Overview
Admin Configuration
Create Token & Buy
Create Token
Initializing a Fungible Asset Store
Mint & Deposit Tokens
Fungible Asset Controller
Admin Fee
Full Code
On This Page
Overview
Admin Configuration
Create Token & Buy
Create Token
Initializing a Fungible Asset Store
Mint & Deposit Tokens
Fungible Asset Controller
Admin Fee
Full Code
			On This Page
			On This Page
			Overview
Admin Configuration
Create Token & Buy
Create Token
Initializing a Fungible Asset Store
Mint & Deposit Tokens
Fungible Asset Controller
Admin Fee
Full Code
			Overview
			Overview
			Overview
			Overview
			Admin Configuration
			Admin Configuration
			Admin Configuration
			Admin Configuration
			Create Token & Buy
Create Token
Initializing a Fungible Asset Store
Mint & Deposit Tokens
Fungible Asset Controller
Admin Fee
			Create Token & Buy
			Create Token & Buy
			Create Token & Buy
			Create Token
Initializing a Fungible Asset Store
Mint & Deposit Tokens
Fungible Asset Controller
Admin Fee
			Create Token
			Create Token
			Create Token
			Create Token
			Initializing a Fungible Asset Store
			Initializing a Fungible Asset Store
			Initializing a Fungible Asset Store
			Initializing a Fungible Asset Store
			Mint & Deposit Tokens
			Mint & Deposit Tokens
			Mint & Deposit Tokens
			Mint & Deposit Tokens
			Fungible Asset Controller
			Fungible Asset Controller
			Fungible Asset Controller
			Fungible Asset Controller
			Admin Fee
			Admin Fee
			Admin Fee
			Admin Fee
			Full Code
			Full Code
			Full Code
			Full Code
			Overview
In this article, we will use the knowledge we've learned about Coins and Fungible Assets to create a function that allows people to easily create an FA, and the admin (platform owner) will receive an amount of $MOVE as fees. In this example, we will use 0.1 MOVE as the fee for creating a token on MOVE.
Admin Configuration
We will need an admin to control or receive fees when users create tokens, and to manage functions that only the admin can execute. Here, we will initialize a resource that contains information about the Fee and admin address.
struct AppConfig has key {
    fees: u64,
    admin: address
}
fun init_module(sender: &signer) {
    let admin_addr = signer::address_of(sender);
    move_to(sender, AppConfig {
        fees: 10_000_000, // 1 APT = 100_000_000 octas
        admin: admin_addr,
    });
}
The
init_module
function is a module initialization function, called when the module is deployed. It has the following characteristics:
Parameter: Takes a parameter
sender
of type
&signer
, representing the module deployer.
Function: Initializes and stores an
AppConfig
structure in the deployer's storage.
Specifically:
Gets the address of the deployer using
signer::address_of(sender)
.
Creates an instance of
AppConfig
with:
Fees set to 10,000,000 octas (equivalent to 0.1 APT).
Admin address set to the deployer's address.
Uses
move_to
to store
AppConfig
in the deployer's storage.
This function sets up the initial configuration for the application, including the fee amount and admin address, which will be used to manage token creation and fee collection as described in the overview.
Create Token & Buy
Create Token
Next, we will initialize a Function to help users easily create a token.
/// Creates a new token and buys an initial amount for the sender.
///
/// @param sender: The signer creating the token and making the initial purchase.
/// @param name: The name of the token.
/// @param symbol: The symbol or ticker of the token.
/// @param icon_uri: The URI for the token's icon.
/// @param project_url: The URL of the project associated with the token.
/// @param amount: The initial amount of tokens to mint and buy.
///
/// This function creates a new fungible asset (token) with the given parameters,
/// mints the specified amount, and transfers it to the sender. It also handles
/// the fee payment to the admin as configured in the AppConfig resource.
///
/// Acquires: AppConfig - to access the fee information and admin address.
public entry fun create_token_and_buy(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    icon_uri: string::String,
    project_url: string::String,
    amount: u64
) acquires AppConfig {
    // Implementation details go here
}
The
create_token_and_buy
function is a public function that allows users to create and buy a new token.
Purpose:
Create a new token and buy an initial amount for the sender.
Parameters:
sender
: The signer creating the token and executing the initial purchase transaction.
name
: The name of the token.
symbol
: The symbol or code of the token.
icon_uri
: The URI for the token's icon.
project_url
: The URL of the project related to the token.
amount
: The initial amount of tokens to create and buy.
Main functions:
Create a new fungible asset with the provided parameters.
Mint the specified amount of tokens.
Transfer the created tokens to the sender.
Handle the fee payment to the admin according to the configuration in the AppConfig resource.
Important features:
Uses the keyword
acquires AppConfig
to access information about fees and admin address.
Is an
entry
function, allowing it to be called directly from outside the module.
This function provides a simple and direct way for users to create their own tokens on the platform, while ensuring that appropriate fees are collected and transferred to the system admin.
Initializing a Fungible Asset Store
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
let object_signer = object::generate_signer(&constructor_ref);
primary_fungible_store::create_primary_store_enabled_fungible_asset(
    &constructor_ref,
    option::some(1_000_000_000), // Total supply
    name,                        // Token Name
    symbol,                      // Token Symbol
    8,                           // Decimals
    icon_uri,                    // Icon URI (ex: https://icon.jpg)
    project_url                  // Project URL
);
This code snippet describes a part of the function to initialize a Fungible Asset on the Move platform. This is an important part of the process of creating a new token. Let's analyze each step:
Create a named object:
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
This line creates a new object with a name based on the provided 'name' parameter.
Create a signer for the object:
let object_signer = object::generate_signer(&constructor_ref);
Creates a 'signer' for the new object, allowing operations to be performed on behalf of this object.
Create Fungible Asset:
primary_fungible_store::create_primary_store_enabled_fungible_asset(...)
This is the main step to create the token. This function takes the following parameters:
Constructor reference
Total supply: 1,000,000,000 (can be adjusted)
Token name
Token symbol
Decimals: 8
Icon URI
Project URL
This code creates a new Fungible Asset with the specified attributes, allowing users to create their own tokens with specific parameters. It also sets up the primary store for the token, enabling efficient storage and management of the token.
Mint & Deposit Tokens
let fa = fungible_asset::mint(&controller.mint_ref, amount);
primary_fungible_store::deposit(signer::address_of(account), fa);
Based on the selected code snippet, I can describe the functionality as follows:
This code snippet performs two important steps in the process of creating and distributing tokens:
Create (mint) tokens:
let fa = fungible_asset::mint(&controller.mint_ref, amount);
This function creates a new amount of tokens (fungible asset) based on the specified amount. It uses the mint reference (mint_ref) from the controller to perform the token creation.
Deposit tokens into the account:
primary_fungible_store::deposit(signer::address_of(account), fa);
This function deposits the newly created tokens (fa) into the user's account. The account address is obtained from the account object using
signer::address_of(account)
.
The purpose of this function is to allow users to create a new amount of tokens and immediately deposit them into their account. This helps users to initialize and own tokens easily and quickly.
This function is an important part of the token creation process, allowing users not only to define the token's attributes (as seen in previous sections with parameters like name, symbol, icon_uri, project_url) but also to create and own a specific amount of tokens right from the start.
Fungible Asset Controller
In the article about Object and Fungible Asset, we learned about FA Abilities such as MintRef, BurnRef, TransferRef. So we will also use them to apply to this Function to initialize a resource object containing these Abilities for the FA we just created.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FAController has key {
    dev_address: address,
    mint_ref: MintRef,
    burn_ref: BurnRef,
    transfer_ref: TransferRef,
}
// Setup token controller
move_to(&object_signer, FAController {
    dev_address: sender_addr,
    mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
    burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
    transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
});
Admin Fee
Another issue is that when initializing a token, the platform admin needs to receive a corresponding fee. For this, we can use AptosCoin to use the Native coin of the Platform, which in this case will be $MOVE on the Movement Network.
let app_config = borrow_global<AppConfig>(@movement);
let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
coin::deposit<AptosCoin>(app_config.admin, coins);
This function performs the following steps:
Access the application configuration (AppConfig) from the Movement address to get information about fees and admin address
Withdraw an amount of coins (AptosCoin) from the sender's account based on the configured fee
Deposit the withdrawn coins into the admin's account
Note that this function uses AptosCoin, but in the context of the Movement Network, this will correspond to $MOVE, which is the native coin of the platform.
Full Code
module movement::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    const DECIMAIL :u8 = 8;
    const MAX_SUPPLY: u128 = 1_000_000_000;
    const FEE: u64 = 10_000_000;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE, // 0.1 APT = 100_000_000 octas
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        amount: u64
    ) acquires AppConfig, FAController {
        let app_config = borrow_global<AppConfig>(@movement);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, coins);
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some(1_000_000_000),
            name,
            symbol,
            DECIMAIL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        mint_tokens(sender, fa_obj, amount);
    }
    /// Mint tokens to an account
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
}
			Overview
In this article, we will use the knowledge we've learned about Coins and Fungible Assets to create a function that allows people to easily create an FA, and the admin (platform owner) will receive an amount of $MOVE as fees. In this example, we will use 0.1 MOVE as the fee for creating a token on MOVE.
Admin Configuration
We will need an admin to control or receive fees when users create tokens, and to manage functions that only the admin can execute. Here, we will initialize a resource that contains information about the Fee and admin address.
struct AppConfig has key {
    fees: u64,
    admin: address
}
fun init_module(sender: &signer) {
    let admin_addr = signer::address_of(sender);
    move_to(sender, AppConfig {
        fees: 10_000_000, // 1 APT = 100_000_000 octas
        admin: admin_addr,
    });
}
The
init_module
function is a module initialization function, called when the module is deployed. It has the following characteristics:
Parameter: Takes a parameter
sender
of type
&signer
, representing the module deployer.
Function: Initializes and stores an
AppConfig
structure in the deployer's storage.
Specifically:
Gets the address of the deployer using
signer::address_of(sender)
.
Creates an instance of
AppConfig
with:
Fees set to 10,000,000 octas (equivalent to 0.1 APT).
Admin address set to the deployer's address.
Uses
move_to
to store
AppConfig
in the deployer's storage.
This function sets up the initial configuration for the application, including the fee amount and admin address, which will be used to manage token creation and fee collection as described in the overview.
Create Token & Buy
Create Token
Next, we will initialize a Function to help users easily create a token.
/// Creates a new token and buys an initial amount for the sender.
///
/// @param sender: The signer creating the token and making the initial purchase.
/// @param name: The name of the token.
/// @param symbol: The symbol or ticker of the token.
/// @param icon_uri: The URI for the token's icon.
/// @param project_url: The URL of the project associated with the token.
/// @param amount: The initial amount of tokens to mint and buy.
///
/// This function creates a new fungible asset (token) with the given parameters,
/// mints the specified amount, and transfers it to the sender. It also handles
/// the fee payment to the admin as configured in the AppConfig resource.
///
/// Acquires: AppConfig - to access the fee information and admin address.
public entry fun create_token_and_buy(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    icon_uri: string::String,
    project_url: string::String,
    amount: u64
) acquires AppConfig {
    // Implementation details go here
}
The
create_token_and_buy
function is a public function that allows users to create and buy a new token.
Purpose:
Create a new token and buy an initial amount for the sender.
Parameters:
sender
: The signer creating the token and executing the initial purchase transaction.
name
: The name of the token.
symbol
: The symbol or code of the token.
icon_uri
: The URI for the token's icon.
project_url
: The URL of the project related to the token.
amount
: The initial amount of tokens to create and buy.
Main functions:
Create a new fungible asset with the provided parameters.
Mint the specified amount of tokens.
Transfer the created tokens to the sender.
Handle the fee payment to the admin according to the configuration in the AppConfig resource.
Important features:
Uses the keyword
acquires AppConfig
to access information about fees and admin address.
Is an
entry
function, allowing it to be called directly from outside the module.
This function provides a simple and direct way for users to create their own tokens on the platform, while ensuring that appropriate fees are collected and transferred to the system admin.
Initializing a Fungible Asset Store
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
let object_signer = object::generate_signer(&constructor_ref);
primary_fungible_store::create_primary_store_enabled_fungible_asset(
    &constructor_ref,
    option::some(1_000_000_000), // Total supply
    name,                        // Token Name
    symbol,                      // Token Symbol
    8,                           // Decimals
    icon_uri,                    // Icon URI (ex: https://icon.jpg)
    project_url                  // Project URL
);
This code snippet describes a part of the function to initialize a Fungible Asset on the Move platform. This is an important part of the process of creating a new token. Let's analyze each step:
Create a named object:
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
This line creates a new object with a name based on the provided 'name' parameter.
Create a signer for the object:
let object_signer = object::generate_signer(&constructor_ref);
Creates a 'signer' for the new object, allowing operations to be performed on behalf of this object.
Create Fungible Asset:
primary_fungible_store::create_primary_store_enabled_fungible_asset(...)
This is the main step to create the token. This function takes the following parameters:
Constructor reference
Total supply: 1,000,000,000 (can be adjusted)
Token name
Token symbol
Decimals: 8
Icon URI
Project URL
This code creates a new Fungible Asset with the specified attributes, allowing users to create their own tokens with specific parameters. It also sets up the primary store for the token, enabling efficient storage and management of the token.
Mint & Deposit Tokens
let fa = fungible_asset::mint(&controller.mint_ref, amount);
primary_fungible_store::deposit(signer::address_of(account), fa);
Based on the selected code snippet, I can describe the functionality as follows:
This code snippet performs two important steps in the process of creating and distributing tokens:
Create (mint) tokens:
let fa = fungible_asset::mint(&controller.mint_ref, amount);
This function creates a new amount of tokens (fungible asset) based on the specified amount. It uses the mint reference (mint_ref) from the controller to perform the token creation.
Deposit tokens into the account:
primary_fungible_store::deposit(signer::address_of(account), fa);
This function deposits the newly created tokens (fa) into the user's account. The account address is obtained from the account object using
signer::address_of(account)
.
The purpose of this function is to allow users to create a new amount of tokens and immediately deposit them into their account. This helps users to initialize and own tokens easily and quickly.
This function is an important part of the token creation process, allowing users not only to define the token's attributes (as seen in previous sections with parameters like name, symbol, icon_uri, project_url) but also to create and own a specific amount of tokens right from the start.
Fungible Asset Controller
In the article about Object and Fungible Asset, we learned about FA Abilities such as MintRef, BurnRef, TransferRef. So we will also use them to apply to this Function to initialize a resource object containing these Abilities for the FA we just created.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FAController has key {
    dev_address: address,
    mint_ref: MintRef,
    burn_ref: BurnRef,
    transfer_ref: TransferRef,
}
// Setup token controller
move_to(&object_signer, FAController {
    dev_address: sender_addr,
    mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
    burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
    transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
});
Admin Fee
Another issue is that when initializing a token, the platform admin needs to receive a corresponding fee. For this, we can use AptosCoin to use the Native coin of the Platform, which in this case will be $MOVE on the Movement Network.
let app_config = borrow_global<AppConfig>(@movement);
let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
coin::deposit<AptosCoin>(app_config.admin, coins);
This function performs the following steps:
Access the application configuration (AppConfig) from the Movement address to get information about fees and admin address
Withdraw an amount of coins (AptosCoin) from the sender's account based on the configured fee
Deposit the withdrawn coins into the admin's account
Note that this function uses AptosCoin, but in the context of the Movement Network, this will correspond to $MOVE, which is the native coin of the platform.
Full Code
module movement::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    const DECIMAIL :u8 = 8;
    const MAX_SUPPLY: u128 = 1_000_000_000;
    const FEE: u64 = 10_000_000;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE, // 0.1 APT = 100_000_000 octas
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        amount: u64
    ) acquires AppConfig, FAController {
        let app_config = borrow_global<AppConfig>(@movement);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, coins);
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some(1_000_000_000),
            name,
            symbol,
            DECIMAIL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        mint_tokens(sender, fa_obj, amount);
    }
    /// Mint tokens to an account
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
}
			Overview
In this article, we will use the knowledge we've learned about Coins and Fungible Assets to create a function that allows people to easily create an FA, and the admin (platform owner) will receive an amount of $MOVE as fees. In this example, we will use 0.1 MOVE as the fee for creating a token on MOVE.
Admin Configuration
We will need an admin to control or receive fees when users create tokens, and to manage functions that only the admin can execute. Here, we will initialize a resource that contains information about the Fee and admin address.
struct AppConfig has key {
    fees: u64,
    admin: address
}
fun init_module(sender: &signer) {
    let admin_addr = signer::address_of(sender);
    move_to(sender, AppConfig {
        fees: 10_000_000, // 1 APT = 100_000_000 octas
        admin: admin_addr,
    });
}
The
init_module
function is a module initialization function, called when the module is deployed. It has the following characteristics:
Parameter: Takes a parameter
sender
of type
&signer
, representing the module deployer.
Function: Initializes and stores an
AppConfig
structure in the deployer's storage.
Specifically:
Gets the address of the deployer using
signer::address_of(sender)
.
Creates an instance of
AppConfig
with:
Fees set to 10,000,000 octas (equivalent to 0.1 APT).
Admin address set to the deployer's address.
Uses
move_to
to store
AppConfig
in the deployer's storage.
This function sets up the initial configuration for the application, including the fee amount and admin address, which will be used to manage token creation and fee collection as described in the overview.
Create Token & Buy
Create Token
Next, we will initialize a Function to help users easily create a token.
/// Creates a new token and buys an initial amount for the sender.
///
/// @param sender: The signer creating the token and making the initial purchase.
/// @param name: The name of the token.
/// @param symbol: The symbol or ticker of the token.
/// @param icon_uri: The URI for the token's icon.
/// @param project_url: The URL of the project associated with the token.
/// @param amount: The initial amount of tokens to mint and buy.
///
/// This function creates a new fungible asset (token) with the given parameters,
/// mints the specified amount, and transfers it to the sender. It also handles
/// the fee payment to the admin as configured in the AppConfig resource.
///
/// Acquires: AppConfig - to access the fee information and admin address.
public entry fun create_token_and_buy(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    icon_uri: string::String,
    project_url: string::String,
    amount: u64
) acquires AppConfig {
    // Implementation details go here
}
The
create_token_and_buy
function is a public function that allows users to create and buy a new token.
Purpose:
Create a new token and buy an initial amount for the sender.
Parameters:
sender
: The signer creating the token and executing the initial purchase transaction.
name
: The name of the token.
symbol
: The symbol or code of the token.
icon_uri
: The URI for the token's icon.
project_url
: The URL of the project related to the token.
amount
: The initial amount of tokens to create and buy.
Main functions:
Create a new fungible asset with the provided parameters.
Mint the specified amount of tokens.
Transfer the created tokens to the sender.
Handle the fee payment to the admin according to the configuration in the AppConfig resource.
Important features:
Uses the keyword
acquires AppConfig
to access information about fees and admin address.
Is an
entry
function, allowing it to be called directly from outside the module.
This function provides a simple and direct way for users to create their own tokens on the platform, while ensuring that appropriate fees are collected and transferred to the system admin.
Initializing a Fungible Asset Store
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
let object_signer = object::generate_signer(&constructor_ref);
primary_fungible_store::create_primary_store_enabled_fungible_asset(
    &constructor_ref,
    option::some(1_000_000_000), // Total supply
    name,                        // Token Name
    symbol,                      // Token Symbol
    8,                           // Decimals
    icon_uri,                    // Icon URI (ex: https://icon.jpg)
    project_url                  // Project URL
);
This code snippet describes a part of the function to initialize a Fungible Asset on the Move platform. This is an important part of the process of creating a new token. Let's analyze each step:
Create a named object:
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
This line creates a new object with a name based on the provided 'name' parameter.
Create a signer for the object:
let object_signer = object::generate_signer(&constructor_ref);
Creates a 'signer' for the new object, allowing operations to be performed on behalf of this object.
Create Fungible Asset:
primary_fungible_store::create_primary_store_enabled_fungible_asset(...)
This is the main step to create the token. This function takes the following parameters:
Constructor reference
Total supply: 1,000,000,000 (can be adjusted)
Token name
Token symbol
Decimals: 8
Icon URI
Project URL
This code creates a new Fungible Asset with the specified attributes, allowing users to create their own tokens with specific parameters. It also sets up the primary store for the token, enabling efficient storage and management of the token.
Mint & Deposit Tokens
let fa = fungible_asset::mint(&controller.mint_ref, amount);
primary_fungible_store::deposit(signer::address_of(account), fa);
Based on the selected code snippet, I can describe the functionality as follows:
This code snippet performs two important steps in the process of creating and distributing tokens:
Create (mint) tokens:
let fa = fungible_asset::mint(&controller.mint_ref, amount);
This function creates a new amount of tokens (fungible asset) based on the specified amount. It uses the mint reference (mint_ref) from the controller to perform the token creation.
Deposit tokens into the account:
primary_fungible_store::deposit(signer::address_of(account), fa);
This function deposits the newly created tokens (fa) into the user's account. The account address is obtained from the account object using
signer::address_of(account)
.
The purpose of this function is to allow users to create a new amount of tokens and immediately deposit them into their account. This helps users to initialize and own tokens easily and quickly.
This function is an important part of the token creation process, allowing users not only to define the token's attributes (as seen in previous sections with parameters like name, symbol, icon_uri, project_url) but also to create and own a specific amount of tokens right from the start.
Fungible Asset Controller
In the article about Object and Fungible Asset, we learned about FA Abilities such as MintRef, BurnRef, TransferRef. So we will also use them to apply to this Function to initialize a resource object containing these Abilities for the FA we just created.
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FAController has key {
    dev_address: address,
    mint_ref: MintRef,
    burn_ref: BurnRef,
    transfer_ref: TransferRef,
}
// Setup token controller
move_to(&object_signer, FAController {
    dev_address: sender_addr,
    mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
    burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
    transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
});
Admin Fee
Another issue is that when initializing a token, the platform admin needs to receive a corresponding fee. For this, we can use AptosCoin to use the Native coin of the Platform, which in this case will be $MOVE on the Movement Network.
let app_config = borrow_global<AppConfig>(@movement);
let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
coin::deposit<AptosCoin>(app_config.admin, coins);
This function performs the following steps:
Access the application configuration (AppConfig) from the Movement address to get information about fees and admin address
Withdraw an amount of coins (AptosCoin) from the sender's account based on the configured fee
Deposit the withdrawn coins into the admin's account
Note that this function uses AptosCoin, but in the context of the Movement Network, this will correspond to $MOVE, which is the native coin of the platform.
Full Code
module movement::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    const DECIMAIL :u8 = 8;
    const MAX_SUPPLY: u128 = 1_000_000_000;
    const FEE: u64 = 10_000_000;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE, // 0.1 APT = 100_000_000 octas
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        amount: u64
    ) acquires AppConfig, FAController {
        let app_config = borrow_global<AppConfig>(@movement);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, coins);
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some(1_000_000_000),
            name,
            symbol,
            DECIMAIL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        mint_tokens(sender, fa_obj, amount);
    }
    /// Mint tokens to an account
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
}
		Overview
		Overview
		In this article, we will use the knowledge we've learned about Coins and Fungible Assets to create a function that allows people to easily create an FA, and the admin (platform owner) will receive an amount of $MOVE as fees. In this example, we will use 0.1 MOVE as the fee for creating a token on MOVE.
		In this article, we will use the knowledge we've learned about Coins and Fungible Assets to create a function that allows people to easily create an FA, and the admin (platform owner) will receive an amount of $MOVE as fees. In this example, we will use 0.1 MOVE as the fee for creating a token on MOVE.
	Admin Configuration
	Admin Configuration
	We will need an admin to control or receive fees when users create tokens, and to manage functions that only the admin can execute. Here, we will initialize a resource that contains information about the Fee and admin address.
	We will need an admin to control or receive fees when users create tokens, and to manage functions that only the admin can execute. Here, we will initialize a resource that contains information about the Fee and admin address.
	<code>struct AppConfig has key {
    fees: u64,
    admin: address
}
fun init_module(sender: &signer) {
    let admin_addr = signer::address_of(sender);
    move_to(sender, AppConfig {
        fees: 10_000_000, // 1 APT = 100_000_000 octas
        admin: admin_addr,
    });
}</code>
	<code>struct AppConfig has key {
    fees: u64,
    admin: address
}
fun init_module(sender: &signer) {
    let admin_addr = signer::address_of(sender);
    move_to(sender, AppConfig {
        fees: 10_000_000, // 1 APT = 100_000_000 octas
        admin: admin_addr,
    });
}</code>
	struct AppConfig has key {
    fees: u64,
    admin: address
}
fun init_module(sender: &signer) {
    let admin_addr = signer::address_of(sender);
    move_to(sender, AppConfig {
        fees: 10_000_000, // 1 APT = 100_000_000 octas
        admin: admin_addr,
    });
}
	The
init_module
function is a module initialization function, called when the module is deployed. It has the following characteristics:
	The
	<code>init_module</code>
	init_module
	function is a module initialization function, called when the module is deployed. It has the following characteristics:
	Parameter: Takes a parameter
sender
of type
&signer
, representing the module deployer.
Function: Initializes and stores an
AppConfig
structure in the deployer's storage.
Specifically:
Gets the address of the deployer using
signer::address_of(sender)
.
Creates an instance of
AppConfig
with:
Fees set to 10,000,000 octas (equivalent to 0.1 APT).
Admin address set to the deployer's address.
Uses
move_to
to store
AppConfig
in the deployer's storage.
	Parameter: Takes a parameter
sender
of type
&signer
, representing the module deployer.
	Parameter: Takes a parameter
	<code>sender</code>
	sender
	of type
	<code>&signer</code>
	&signer
	, representing the module deployer.
	Function: Initializes and stores an
AppConfig
structure in the deployer's storage.
	Function: Initializes and stores an
	<code>AppConfig</code>
	AppConfig
	structure in the deployer's storage.
	Specifically:
Gets the address of the deployer using
signer::address_of(sender)
.
Creates an instance of
AppConfig
with:
Fees set to 10,000,000 octas (equivalent to 0.1 APT).
Admin address set to the deployer's address.
Uses
move_to
to store
AppConfig
in the deployer's storage.
	Specifically:
	Gets the address of the deployer using
signer::address_of(sender)
.
Creates an instance of
AppConfig
with:
Fees set to 10,000,000 octas (equivalent to 0.1 APT).
Admin address set to the deployer's address.
Uses
move_to
to store
AppConfig
in the deployer's storage.
	Gets the address of the deployer using
signer::address_of(sender)
.
	Gets the address of the deployer using
	<code>signer::address_of(sender)</code>
	signer::address_of(sender)
	.
	Creates an instance of
AppConfig
with:
Fees set to 10,000,000 octas (equivalent to 0.1 APT).
Admin address set to the deployer's address.
	Creates an instance of
	<code>AppConfig</code>
	AppConfig
	with:
	Fees set to 10,000,000 octas (equivalent to 0.1 APT).
Admin address set to the deployer's address.
	Fees set to 10,000,000 octas (equivalent to 0.1 APT).
	Fees set to 10,000,000 octas (equivalent to 0.1 APT).
	Admin address set to the deployer's address.
	Admin address set to the deployer's address.
	Uses
move_to
to store
AppConfig
in the deployer's storage.
	Uses
	<code>move_to</code>
	move_to
	to store
	<code>AppConfig</code>
	AppConfig
	in the deployer's storage.
	This function sets up the initial configuration for the application, including the fee amount and admin address, which will be used to manage token creation and fee collection as described in the overview.
	This function sets up the initial configuration for the application, including the fee amount and admin address, which will be used to manage token creation and fee collection as described in the overview.
	Create Token & Buy
	Create Token & Buy
		Create Token
		Create Token
		Next, we will initialize a Function to help users easily create a token.
		Next, we will initialize a Function to help users easily create a token.
		<code>/// Creates a new token and buys an initial amount for the sender.
///
/// @param sender: The signer creating the token and making the initial purchase.
/// @param name: The name of the token.
/// @param symbol: The symbol or ticker of the token.
/// @param icon_uri: The URI for the token's icon.
/// @param project_url: The URL of the project associated with the token.
/// @param amount: The initial amount of tokens to mint and buy.
///
/// This function creates a new fungible asset (token) with the given parameters,
/// mints the specified amount, and transfers it to the sender. It also handles
/// the fee payment to the admin as configured in the AppConfig resource.
///
/// Acquires: AppConfig - to access the fee information and admin address.
public entry fun create_token_and_buy(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    icon_uri: string::String,
    project_url: string::String,
    amount: u64
) acquires AppConfig {
    // Implementation details go here
}</code>
		<code>/// Creates a new token and buys an initial amount for the sender.
///
/// @param sender: The signer creating the token and making the initial purchase.
/// @param name: The name of the token.
/// @param symbol: The symbol or ticker of the token.
/// @param icon_uri: The URI for the token's icon.
/// @param project_url: The URL of the project associated with the token.
/// @param amount: The initial amount of tokens to mint and buy.
///
/// This function creates a new fungible asset (token) with the given parameters,
/// mints the specified amount, and transfers it to the sender. It also handles
/// the fee payment to the admin as configured in the AppConfig resource.
///
/// Acquires: AppConfig - to access the fee information and admin address.
public entry fun create_token_and_buy(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    icon_uri: string::String,
    project_url: string::String,
    amount: u64
) acquires AppConfig {
    // Implementation details go here
}</code>
		/// Creates a new token and buys an initial amount for the sender.
///
/// @param sender: The signer creating the token and making the initial purchase.
/// @param name: The name of the token.
/// @param symbol: The symbol or ticker of the token.
/// @param icon_uri: The URI for the token's icon.
/// @param project_url: The URL of the project associated with the token.
/// @param amount: The initial amount of tokens to mint and buy.
///
/// This function creates a new fungible asset (token) with the given parameters,
/// mints the specified amount, and transfers it to the sender. It also handles
/// the fee payment to the admin as configured in the AppConfig resource.
///
/// Acquires: AppConfig - to access the fee information and admin address.
public entry fun create_token_and_buy(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    icon_uri: string::String,
    project_url: string::String,
    amount: u64
) acquires AppConfig {
    // Implementation details go here
}
		The
create_token_and_buy
function is a public function that allows users to create and buy a new token.
		The
		<code>create_token_and_buy</code>
		create_token_and_buy
		function is a public function that allows users to create and buy a new token.
		Purpose:
Create a new token and buy an initial amount for the sender.
Parameters:
sender
: The signer creating the token and executing the initial purchase transaction.
name
: The name of the token.
symbol
: The symbol or code of the token.
icon_uri
: The URI for the token's icon.
project_url
: The URL of the project related to the token.
amount
: The initial amount of tokens to create and buy.
Main functions:
Create a new fungible asset with the provided parameters.
Mint the specified amount of tokens.
Transfer the created tokens to the sender.
Handle the fee payment to the admin according to the configuration in the AppConfig resource.
Important features:
Uses the keyword
acquires AppConfig
to access information about fees and admin address.
Is an
entry
function, allowing it to be called directly from outside the module.
		Purpose:
Create a new token and buy an initial amount for the sender.
		Purpose:
		Purpose:
		Create a new token and buy an initial amount for the sender.
		Parameters:
sender
: The signer creating the token and executing the initial purchase transaction.
name
: The name of the token.
symbol
: The symbol or code of the token.
icon_uri
: The URI for the token's icon.
project_url
: The URL of the project related to the token.
amount
: The initial amount of tokens to create and buy.
		Parameters:
		Parameters:
		sender
: The signer creating the token and executing the initial purchase transaction.
name
: The name of the token.
symbol
: The symbol or code of the token.
icon_uri
: The URI for the token's icon.
project_url
: The URL of the project related to the token.
amount
: The initial amount of tokens to create and buy.
		sender
: The signer creating the token and executing the initial purchase transaction.
		<code>sender</code>
		sender
		: The signer creating the token and executing the initial purchase transaction.
		name
: The name of the token.
		<code>name</code>
		name
		: The name of the token.
		symbol
: The symbol or code of the token.
		<code>symbol</code>
		symbol
		: The symbol or code of the token.
		icon_uri
: The URI for the token's icon.
		<code>icon_uri</code>
		icon_uri
		: The URI for the token's icon.
		project_url
: The URL of the project related to the token.
		<code>project_url</code>
		project_url
		: The URL of the project related to the token.
		amount
: The initial amount of tokens to create and buy.
		<code>amount</code>
		amount
		: The initial amount of tokens to create and buy.
		Main functions:
Create a new fungible asset with the provided parameters.
Mint the specified amount of tokens.
Transfer the created tokens to the sender.
Handle the fee payment to the admin according to the configuration in the AppConfig resource.
		Main functions:
		Main functions:
		Create a new fungible asset with the provided parameters.
Mint the specified amount of tokens.
Transfer the created tokens to the sender.
Handle the fee payment to the admin according to the configuration in the AppConfig resource.
		Create a new fungible asset with the provided parameters.
		Create a new fungible asset with the provided parameters.
		Mint the specified amount of tokens.
		Mint the specified amount of tokens.
		Transfer the created tokens to the sender.
		Transfer the created tokens to the sender.
		Handle the fee payment to the admin according to the configuration in the AppConfig resource.
		Handle the fee payment to the admin according to the configuration in the AppConfig resource.
		Important features:
Uses the keyword
acquires AppConfig
to access information about fees and admin address.
Is an
entry
function, allowing it to be called directly from outside the module.
		Important features:
		Important features:
		Uses the keyword
acquires AppConfig
to access information about fees and admin address.
Is an
entry
function, allowing it to be called directly from outside the module.
		Uses the keyword
acquires AppConfig
to access information about fees and admin address.
		Uses the keyword
		<code>acquires AppConfig</code>
		acquires AppConfig
		to access information about fees and admin address.
		Is an
entry
function, allowing it to be called directly from outside the module.
		Is an
		<code>entry</code>
		entry
		function, allowing it to be called directly from outside the module.
		This function provides a simple and direct way for users to create their own tokens on the platform, while ensuring that appropriate fees are collected and transferred to the system admin.
		This function provides a simple and direct way for users to create their own tokens on the platform, while ensuring that appropriate fees are collected and transferred to the system admin.
		Initializing a Fungible Asset Store
		Initializing a Fungible Asset Store
		<code>let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
let object_signer = object::generate_signer(&constructor_ref);
primary_fungible_store::create_primary_store_enabled_fungible_asset(
    &constructor_ref,
    option::some(1_000_000_000), // Total supply
    name,                        // Token Name
    symbol,                      // Token Symbol
    8,                           // Decimals
    icon_uri,                    // Icon URI (ex: https://icon.jpg)
    project_url                  // Project URL
);</code>
		<code>let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
let object_signer = object::generate_signer(&constructor_ref);
primary_fungible_store::create_primary_store_enabled_fungible_asset(
    &constructor_ref,
    option::some(1_000_000_000), // Total supply
    name,                        // Token Name
    symbol,                      // Token Symbol
    8,                           // Decimals
    icon_uri,                    // Icon URI (ex: https://icon.jpg)
    project_url                  // Project URL
);</code>
		let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
let object_signer = object::generate_signer(&constructor_ref);
primary_fungible_store::create_primary_store_enabled_fungible_asset(
    &constructor_ref,
    option::some(1_000_000_000), // Total supply
    name,                        // Token Name
    symbol,                      // Token Symbol
    8,                           // Decimals
    icon_uri,                    // Icon URI (ex: https://icon.jpg)
    project_url                  // Project URL
);
		This code snippet describes a part of the function to initialize a Fungible Asset on the Move platform. This is an important part of the process of creating a new token. Let's analyze each step:
		This code snippet describes a part of the function to initialize a Fungible Asset on the Move platform. This is an important part of the process of creating a new token. Let's analyze each step:
		Create a named object:
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
This line creates a new object with a name based on the provided 'name' parameter.
Create a signer for the object:
let object_signer = object::generate_signer(&constructor_ref);
Creates a 'signer' for the new object, allowing operations to be performed on behalf of this object.
Create Fungible Asset:
primary_fungible_store::create_primary_store_enabled_fungible_asset(...)
This is the main step to create the token. This function takes the following parameters:
		Create a named object:
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
This line creates a new object with a name based on the provided 'name' parameter.
		Create a named object:
		<code>let constructor_ref = object::create_named_object(sender, *string::bytes(&name));</code>
		let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
		This line creates a new object with a name based on the provided 'name' parameter.
		Create a signer for the object:
let object_signer = object::generate_signer(&constructor_ref);
Creates a 'signer' for the new object, allowing operations to be performed on behalf of this object.
		Create a signer for the object:
		<code>let object_signer = object::generate_signer(&constructor_ref);</code>
		let object_signer = object::generate_signer(&constructor_ref);
		Creates a 'signer' for the new object, allowing operations to be performed on behalf of this object.
		Create Fungible Asset:
primary_fungible_store::create_primary_store_enabled_fungible_asset(...)
This is the main step to create the token. This function takes the following parameters:
		Create Fungible Asset:
		<code>primary_fungible_store::create_primary_store_enabled_fungible_asset(...)</code>
		primary_fungible_store::create_primary_store_enabled_fungible_asset(...)
		This is the main step to create the token. This function takes the following parameters:
		Constructor reference
Total supply: 1,000,000,000 (can be adjusted)
Token name
Token symbol
Decimals: 8
Icon URI
Project URL
		Constructor reference
		Constructor reference
		Total supply: 1,000,000,000 (can be adjusted)
		Total supply: 1,000,000,000 (can be adjusted)
		Token name
		Token name
		Token symbol
		Token symbol
		Decimals: 8
		Decimals: 8
		Icon URI
		Icon URI
		Project URL
		Project URL
		This code creates a new Fungible Asset with the specified attributes, allowing users to create their own tokens with specific parameters. It also sets up the primary store for the token, enabling efficient storage and management of the token.
		This code creates a new Fungible Asset with the specified attributes, allowing users to create their own tokens with specific parameters. It also sets up the primary store for the token, enabling efficient storage and management of the token.
		Mint & Deposit Tokens
		Mint & Deposit Tokens
		<code>let fa = fungible_asset::mint(&controller.mint_ref, amount);
primary_fungible_store::deposit(signer::address_of(account), fa);</code>
		<code>let fa = fungible_asset::mint(&controller.mint_ref, amount);
primary_fungible_store::deposit(signer::address_of(account), fa);</code>
		let fa = fungible_asset::mint(&controller.mint_ref, amount);
primary_fungible_store::deposit(signer::address_of(account), fa);
		Based on the selected code snippet, I can describe the functionality as follows:
		Based on the selected code snippet, I can describe the functionality as follows:
		This code snippet performs two important steps in the process of creating and distributing tokens:
		This code snippet performs two important steps in the process of creating and distributing tokens:
		Create (mint) tokens:
let fa = fungible_asset::mint(&controller.mint_ref, amount);
This function creates a new amount of tokens (fungible asset) based on the specified amount. It uses the mint reference (mint_ref) from the controller to perform the token creation.
Deposit tokens into the account:
primary_fungible_store::deposit(signer::address_of(account), fa);
This function deposits the newly created tokens (fa) into the user's account. The account address is obtained from the account object using
signer::address_of(account)
.
		Create (mint) tokens:
let fa = fungible_asset::mint(&controller.mint_ref, amount);
This function creates a new amount of tokens (fungible asset) based on the specified amount. It uses the mint reference (mint_ref) from the controller to perform the token creation.
		Create (mint) tokens:
		<code>let fa = fungible_asset::mint(&controller.mint_ref, amount);</code>
		let fa = fungible_asset::mint(&controller.mint_ref, amount);
		This function creates a new amount of tokens (fungible asset) based on the specified amount. It uses the mint reference (mint_ref) from the controller to perform the token creation.
		Deposit tokens into the account:
primary_fungible_store::deposit(signer::address_of(account), fa);
This function deposits the newly created tokens (fa) into the user's account. The account address is obtained from the account object using
signer::address_of(account)
.
		Deposit tokens into the account:
		<code>primary_fungible_store::deposit(signer::address_of(account), fa);</code>
		primary_fungible_store::deposit(signer::address_of(account), fa);
		This function deposits the newly created tokens (fa) into the user's account. The account address is obtained from the account object using
		<code>signer::address_of(account)</code>
		signer::address_of(account)
		.
		The purpose of this function is to allow users to create a new amount of tokens and immediately deposit them into their account. This helps users to initialize and own tokens easily and quickly.
		The purpose of this function is to allow users to create a new amount of tokens and immediately deposit them into their account. This helps users to initialize and own tokens easily and quickly.
		This function is an important part of the token creation process, allowing users not only to define the token's attributes (as seen in previous sections with parameters like name, symbol, icon_uri, project_url) but also to create and own a specific amount of tokens right from the start.
		This function is an important part of the token creation process, allowing users not only to define the token's attributes (as seen in previous sections with parameters like name, symbol, icon_uri, project_url) but also to create and own a specific amount of tokens right from the start.
		Fungible Asset Controller
		Fungible Asset Controller
		In the article about Object and Fungible Asset, we learned about FA Abilities such as MintRef, BurnRef, TransferRef. So we will also use them to apply to this Function to initialize a resource object containing these Abilities for the FA we just created.
		In the article about Object and Fungible Asset, we learned about FA Abilities such as MintRef, BurnRef, TransferRef. So we will also use them to apply to this Function to initialize a resource object containing these Abilities for the FA we just created.
		<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FAController has key {
    dev_address: address,
    mint_ref: MintRef,
    burn_ref: BurnRef,
    transfer_ref: TransferRef,
}
// Setup token controller
move_to(&object_signer, FAController {
    dev_address: sender_addr,
    mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
    burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
    transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
});</code>
		<code>#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FAController has key {
    dev_address: address,
    mint_ref: MintRef,
    burn_ref: BurnRef,
    transfer_ref: TransferRef,
}
// Setup token controller
move_to(&object_signer, FAController {
    dev_address: sender_addr,
    mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
    burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
    transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
});</code>
		#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FAController has key {
    dev_address: address,
    mint_ref: MintRef,
    burn_ref: BurnRef,
    transfer_ref: TransferRef,
}
// Setup token controller
move_to(&object_signer, FAController {
    dev_address: sender_addr,
    mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
    burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
    transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
});
		Admin Fee
		Admin Fee
		Another issue is that when initializing a token, the platform admin needs to receive a corresponding fee. For this, we can use AptosCoin to use the Native coin of the Platform, which in this case will be $MOVE on the Movement Network.
		Another issue is that when initializing a token, the platform admin needs to receive a corresponding fee. For this, we can use AptosCoin to use the Native coin of the Platform, which in this case will be $MOVE on the Movement Network.
		<code>let app_config = borrow_global<AppConfig>(@movement);
let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
coin::deposit<AptosCoin>(app_config.admin, coins);</code>
		<code>let app_config = borrow_global<AppConfig>(@movement);
let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
coin::deposit<AptosCoin>(app_config.admin, coins);</code>
		let app_config = borrow_global<AppConfig>(@movement);
let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
coin::deposit<AptosCoin>(app_config.admin, coins);
		This function performs the following steps:
		This function performs the following steps:
		Access the application configuration (AppConfig) from the Movement address to get information about fees and admin address
Withdraw an amount of coins (AptosCoin) from the sender's account based on the configured fee
Deposit the withdrawn coins into the admin's account
		Access the application configuration (AppConfig) from the Movement address to get information about fees and admin address
		Access the application configuration (AppConfig) from the Movement address to get information about fees and admin address
		Withdraw an amount of coins (AptosCoin) from the sender's account based on the configured fee
		Withdraw an amount of coins (AptosCoin) from the sender's account based on the configured fee
		Deposit the withdrawn coins into the admin's account
		Deposit the withdrawn coins into the admin's account
		Note that this function uses AptosCoin, but in the context of the Movement Network, this will correspond to $MOVE, which is the native coin of the platform.
		Note that this function uses AptosCoin, but in the context of the Movement Network, this will correspond to $MOVE, which is the native coin of the platform.
	Full Code
	Full Code
	<code>module movement::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    const DECIMAIL :u8 = 8;
    const MAX_SUPPLY: u128 = 1_000_000_000;
    const FEE: u64 = 10_000_000;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE, // 0.1 APT = 100_000_000 octas
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        amount: u64
    ) acquires AppConfig, FAController {
        let app_config = borrow_global<AppConfig>(@movement);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, coins);
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some(1_000_000_000),
            name,
            symbol,
            DECIMAIL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        mint_tokens(sender, fa_obj, amount);
    }
    /// Mint tokens to an account
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
}</code>
	<code>module movement::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    const DECIMAIL :u8 = 8;
    const MAX_SUPPLY: u128 = 1_000_000_000;
    const FEE: u64 = 10_000_000;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE, // 0.1 APT = 100_000_000 octas
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        amount: u64
    ) acquires AppConfig, FAController {
        let app_config = borrow_global<AppConfig>(@movement);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, coins);
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some(1_000_000_000),
            name,
            symbol,
            DECIMAIL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        mint_tokens(sender, fa_obj, amount);
    }
    /// Mint tokens to an account
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
}</code>
	module movement::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    const DECIMAIL :u8 = 8;
    const MAX_SUPPLY: u128 = 1_000_000_000;
    const FEE: u64 = 10_000_000;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE, // 0.1 APT = 100_000_000 octas
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        amount: u64
    ) acquires AppConfig, FAController {
        let app_config = borrow_global<AppConfig>(@movement);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, coins);
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some(1_000_000_000),
            name,
            symbol,
            DECIMAIL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        mint_tokens(sender, fa_obj, amount);
    }
    /// Mint tokens to an account
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/03-pump4fun/03-initialize-liquidity-in-pump4fun
Initialize Liquidity in Pump4fun
Initialize Liquidity in Pump4fun
On This Page
Summary
Overview
Initialize Pool
Create & Buy Token Complete
Summary
This page explains how to initialize liquidity in a Pump4fun system, focusing on creating a liquidity pool for a custom token pair and Move token. Key points include:
Definition of the LiquidityPool struct with fields for token and Move reserves, token address, owner, and signer capability
Step-by-step process to initialize a liquidity pool using the initialize_liquidity_pool function
Creation of a resource account for the pool
Registration of Move coin storage for the pool
Minting of custom tokens and transfer of Move tokens to the pool
Initialization of the LiquidityPool structure with provided data
The function's role in setting up infrastructure for decentralized exchanges or DeFi protocols
Overview
After successfully initializing the token, we will now use the token and Move Token that were used to purchase tokens to initialize the Pool for the above Token Pair.
struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
The LiquidityPool struct includes the following fields:
token_reserve: The amount of tokens in the pool
apt_reserve: The amount of Move in the pool
token_address: The address of the token metadata
owner: The address of the pool owner
signer_cap: The ability to sign transactions for the pool
To initialize a liquidity pool using this structure, you need to create an initialization function with corresponding parameters. For example:
fun initialize_liquidity_pool(
    sender: &signer,
    token: Object<Metadata>,
    move_amount: u64,
    token_amount: u64
) acquires FAController {
    let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
    // Register APT coin store for pool
    if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
        coin::register<AptosCoin>(&pool_signer);
    };
    // Mint tokens to pool
    mint_tokens(&pool_signer, token, token_amount);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(signer::address_of(&pool_signer), apt_coins);
    // Initialize LP
    move_to(&pool_signer, LiquidityPool {
        token_reserve: token_amount,
        move_reserve: move_amount,
        token_address: token,
        owner: signer::address_of(sender),
        signer_cap,
    });
}
I will describe in more detail the
initialize_liquidity_pool
function and its features:
General purpose:
This function is designed to initialize a liquidity pool for a custom token pair and Move token. The main purpose is to create a foundation for exchange and provide liquidity in the system.
Step-by-step details:
Create resource account
let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
Use
account::create_resource_account
to create a new resource account for the pool
Create a pool_signer and signer_cap to manage the pool
Register Move coin storage:
// Register APT coin store for pool
if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
    coin::register<AptosCoin>(&pool_signer);
};
Check if the pool has already registered AptosCoin storage
If not, register AptosCoin storage for the pool
// Mint tokens to pool
mint_tokens(&pool_signer, token, token_amount);
// Transfer APT to pool
let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(signer::address_of(&pool_signer), apt_coins);
Mint custom token:
Use the
mint_tokens
function to create and add custom tokens to the pool
The token amount is determined by the
token_amount
parameter
Transfer Move token:
Withdraw Move tokens from the sender's account
Transfer this amount of Move tokens to the pool's account
// Initialize LP
move_to(&pool_signer, LiquidityPool {
    token_reserve: token_amount,
    move_reserve: move_amount,
    token_address: token,
    owner: signer::address_of(sender),
    signer_cap,
});
Initialize LiquidityPool:
Create a new LiquidityPool structure
Store information about the amount of tokens and Move, token address, owner, and signing capability
Use
move_to
to save this structure to the pool's storage
This function plays a crucial role in setting up the infrastructure for a decentralized exchange (DEX) or a DeFi protocol, allowing users to create initial liquidity for a token-Move pair.
Initialize Pool
After completing the function to initialize the Pool, we will call it immediately after successfully initializing the token. I want to set the default initial value so that 1 Move can be exchanged for 50,000 Tokens. Subsequently, the price will be calculated based on the pool.
const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
const APT_DECIMALS: u8 = 8;
const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
// Calculate total tokens to be created
let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
Create & Buy Token Complete
module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
    const APT_DECIMALS: u8 = 8;
    const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of APT in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // APT from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register APT coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer APT to pool
        let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), apt_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
}
On This Page
Summary
Overview
Initialize Pool
Create & Buy Token Complete
On This Page
Summary
Overview
Initialize Pool
Create & Buy Token Complete
			On This Page
			On This Page
			Summary
Overview
Initialize Pool
Create & Buy Token Complete
			Summary
			Summary
			Summary
			Summary
			Overview
			Overview
			Overview
			Overview
			Initialize Pool
			Initialize Pool
			Initialize Pool
			Initialize Pool
			Create & Buy Token Complete
			Create & Buy Token Complete
			Create & Buy Token Complete
			Create & Buy Token Complete
			Summary
This page explains how to initialize liquidity in a Pump4fun system, focusing on creating a liquidity pool for a custom token pair and Move token. Key points include:
Definition of the LiquidityPool struct with fields for token and Move reserves, token address, owner, and signer capability
Step-by-step process to initialize a liquidity pool using the initialize_liquidity_pool function
Creation of a resource account for the pool
Registration of Move coin storage for the pool
Minting of custom tokens and transfer of Move tokens to the pool
Initialization of the LiquidityPool structure with provided data
The function's role in setting up infrastructure for decentralized exchanges or DeFi protocols
Overview
After successfully initializing the token, we will now use the token and Move Token that were used to purchase tokens to initialize the Pool for the above Token Pair.
struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
The LiquidityPool struct includes the following fields:
token_reserve: The amount of tokens in the pool
apt_reserve: The amount of Move in the pool
token_address: The address of the token metadata
owner: The address of the pool owner
signer_cap: The ability to sign transactions for the pool
To initialize a liquidity pool using this structure, you need to create an initialization function with corresponding parameters. For example:
fun initialize_liquidity_pool(
    sender: &signer,
    token: Object<Metadata>,
    move_amount: u64,
    token_amount: u64
) acquires FAController {
    let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
    // Register APT coin store for pool
    if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
        coin::register<AptosCoin>(&pool_signer);
    };
    // Mint tokens to pool
    mint_tokens(&pool_signer, token, token_amount);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(signer::address_of(&pool_signer), apt_coins);
    // Initialize LP
    move_to(&pool_signer, LiquidityPool {
        token_reserve: token_amount,
        move_reserve: move_amount,
        token_address: token,
        owner: signer::address_of(sender),
        signer_cap,
    });
}
I will describe in more detail the
initialize_liquidity_pool
function and its features:
General purpose:
This function is designed to initialize a liquidity pool for a custom token pair and Move token. The main purpose is to create a foundation for exchange and provide liquidity in the system.
Step-by-step details:
Create resource account
let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
Use
account::create_resource_account
to create a new resource account for the pool
Create a pool_signer and signer_cap to manage the pool
Register Move coin storage:
// Register APT coin store for pool
if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
    coin::register<AptosCoin>(&pool_signer);
};
Check if the pool has already registered AptosCoin storage
If not, register AptosCoin storage for the pool
// Mint tokens to pool
mint_tokens(&pool_signer, token, token_amount);
// Transfer APT to pool
let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(signer::address_of(&pool_signer), apt_coins);
Mint custom token:
Use the
mint_tokens
function to create and add custom tokens to the pool
The token amount is determined by the
token_amount
parameter
Transfer Move token:
Withdraw Move tokens from the sender's account
Transfer this amount of Move tokens to the pool's account
// Initialize LP
move_to(&pool_signer, LiquidityPool {
    token_reserve: token_amount,
    move_reserve: move_amount,
    token_address: token,
    owner: signer::address_of(sender),
    signer_cap,
});
Initialize LiquidityPool:
Create a new LiquidityPool structure
Store information about the amount of tokens and Move, token address, owner, and signing capability
Use
move_to
to save this structure to the pool's storage
This function plays a crucial role in setting up the infrastructure for a decentralized exchange (DEX) or a DeFi protocol, allowing users to create initial liquidity for a token-Move pair.
Initialize Pool
After completing the function to initialize the Pool, we will call it immediately after successfully initializing the token. I want to set the default initial value so that 1 Move can be exchanged for 50,000 Tokens. Subsequently, the price will be calculated based on the pool.
const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
const APT_DECIMALS: u8 = 8;
const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
// Calculate total tokens to be created
let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
Create & Buy Token Complete
module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
    const APT_DECIMALS: u8 = 8;
    const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of APT in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // APT from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register APT coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer APT to pool
        let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), apt_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
}
			Summary
This page explains how to initialize liquidity in a Pump4fun system, focusing on creating a liquidity pool for a custom token pair and Move token. Key points include:
Definition of the LiquidityPool struct with fields for token and Move reserves, token address, owner, and signer capability
Step-by-step process to initialize a liquidity pool using the initialize_liquidity_pool function
Creation of a resource account for the pool
Registration of Move coin storage for the pool
Minting of custom tokens and transfer of Move tokens to the pool
Initialization of the LiquidityPool structure with provided data
The function's role in setting up infrastructure for decentralized exchanges or DeFi protocols
Overview
After successfully initializing the token, we will now use the token and Move Token that were used to purchase tokens to initialize the Pool for the above Token Pair.
struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
The LiquidityPool struct includes the following fields:
token_reserve: The amount of tokens in the pool
apt_reserve: The amount of Move in the pool
token_address: The address of the token metadata
owner: The address of the pool owner
signer_cap: The ability to sign transactions for the pool
To initialize a liquidity pool using this structure, you need to create an initialization function with corresponding parameters. For example:
fun initialize_liquidity_pool(
    sender: &signer,
    token: Object<Metadata>,
    move_amount: u64,
    token_amount: u64
) acquires FAController {
    let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
    // Register APT coin store for pool
    if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
        coin::register<AptosCoin>(&pool_signer);
    };
    // Mint tokens to pool
    mint_tokens(&pool_signer, token, token_amount);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(signer::address_of(&pool_signer), apt_coins);
    // Initialize LP
    move_to(&pool_signer, LiquidityPool {
        token_reserve: token_amount,
        move_reserve: move_amount,
        token_address: token,
        owner: signer::address_of(sender),
        signer_cap,
    });
}
I will describe in more detail the
initialize_liquidity_pool
function and its features:
General purpose:
This function is designed to initialize a liquidity pool for a custom token pair and Move token. The main purpose is to create a foundation for exchange and provide liquidity in the system.
Step-by-step details:
Create resource account
let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
Use
account::create_resource_account
to create a new resource account for the pool
Create a pool_signer and signer_cap to manage the pool
Register Move coin storage:
// Register APT coin store for pool
if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
    coin::register<AptosCoin>(&pool_signer);
};
Check if the pool has already registered AptosCoin storage
If not, register AptosCoin storage for the pool
// Mint tokens to pool
mint_tokens(&pool_signer, token, token_amount);
// Transfer APT to pool
let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(signer::address_of(&pool_signer), apt_coins);
Mint custom token:
Use the
mint_tokens
function to create and add custom tokens to the pool
The token amount is determined by the
token_amount
parameter
Transfer Move token:
Withdraw Move tokens from the sender's account
Transfer this amount of Move tokens to the pool's account
// Initialize LP
move_to(&pool_signer, LiquidityPool {
    token_reserve: token_amount,
    move_reserve: move_amount,
    token_address: token,
    owner: signer::address_of(sender),
    signer_cap,
});
Initialize LiquidityPool:
Create a new LiquidityPool structure
Store information about the amount of tokens and Move, token address, owner, and signing capability
Use
move_to
to save this structure to the pool's storage
This function plays a crucial role in setting up the infrastructure for a decentralized exchange (DEX) or a DeFi protocol, allowing users to create initial liquidity for a token-Move pair.
Initialize Pool
After completing the function to initialize the Pool, we will call it immediately after successfully initializing the token. I want to set the default initial value so that 1 Move can be exchanged for 50,000 Tokens. Subsequently, the price will be calculated based on the pool.
const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
const APT_DECIMALS: u8 = 8;
const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
// Calculate total tokens to be created
let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
Create & Buy Token Complete
module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
    const APT_DECIMALS: u8 = 8;
    const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of APT in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // APT from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register APT coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer APT to pool
        let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), apt_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
}
			Summary
This page explains how to initialize liquidity in a Pump4fun system, focusing on creating a liquidity pool for a custom token pair and Move token. Key points include:
Definition of the LiquidityPool struct with fields for token and Move reserves, token address, owner, and signer capability
Step-by-step process to initialize a liquidity pool using the initialize_liquidity_pool function
Creation of a resource account for the pool
Registration of Move coin storage for the pool
Minting of custom tokens and transfer of Move tokens to the pool
Initialization of the LiquidityPool structure with provided data
The function's role in setting up infrastructure for decentralized exchanges or DeFi protocols
Overview
After successfully initializing the token, we will now use the token and Move Token that were used to purchase tokens to initialize the Pool for the above Token Pair.
struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
The LiquidityPool struct includes the following fields:
token_reserve: The amount of tokens in the pool
apt_reserve: The amount of Move in the pool
token_address: The address of the token metadata
owner: The address of the pool owner
signer_cap: The ability to sign transactions for the pool
To initialize a liquidity pool using this structure, you need to create an initialization function with corresponding parameters. For example:
fun initialize_liquidity_pool(
    sender: &signer,
    token: Object<Metadata>,
    move_amount: u64,
    token_amount: u64
) acquires FAController {
    let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
    // Register APT coin store for pool
    if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
        coin::register<AptosCoin>(&pool_signer);
    };
    // Mint tokens to pool
    mint_tokens(&pool_signer, token, token_amount);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(signer::address_of(&pool_signer), apt_coins);
    // Initialize LP
    move_to(&pool_signer, LiquidityPool {
        token_reserve: token_amount,
        move_reserve: move_amount,
        token_address: token,
        owner: signer::address_of(sender),
        signer_cap,
    });
}
I will describe in more detail the
initialize_liquidity_pool
function and its features:
General purpose:
This function is designed to initialize a liquidity pool for a custom token pair and Move token. The main purpose is to create a foundation for exchange and provide liquidity in the system.
Step-by-step details:
Create resource account
let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
Use
account::create_resource_account
to create a new resource account for the pool
Create a pool_signer and signer_cap to manage the pool
Register Move coin storage:
// Register APT coin store for pool
if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
    coin::register<AptosCoin>(&pool_signer);
};
Check if the pool has already registered AptosCoin storage
If not, register AptosCoin storage for the pool
// Mint tokens to pool
mint_tokens(&pool_signer, token, token_amount);
// Transfer APT to pool
let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(signer::address_of(&pool_signer), apt_coins);
Mint custom token:
Use the
mint_tokens
function to create and add custom tokens to the pool
The token amount is determined by the
token_amount
parameter
Transfer Move token:
Withdraw Move tokens from the sender's account
Transfer this amount of Move tokens to the pool's account
// Initialize LP
move_to(&pool_signer, LiquidityPool {
    token_reserve: token_amount,
    move_reserve: move_amount,
    token_address: token,
    owner: signer::address_of(sender),
    signer_cap,
});
Initialize LiquidityPool:
Create a new LiquidityPool structure
Store information about the amount of tokens and Move, token address, owner, and signing capability
Use
move_to
to save this structure to the pool's storage
This function plays a crucial role in setting up the infrastructure for a decentralized exchange (DEX) or a DeFi protocol, allowing users to create initial liquidity for a token-Move pair.
Initialize Pool
After completing the function to initialize the Pool, we will call it immediately after successfully initializing the token. I want to set the default initial value so that 1 Move can be exchanged for 50,000 Tokens. Subsequently, the price will be calculated based on the pool.
const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
const APT_DECIMALS: u8 = 8;
const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
// Calculate total tokens to be created
let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
Create & Buy Token Complete
module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
    const APT_DECIMALS: u8 = 8;
    const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of APT in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // APT from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register APT coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer APT to pool
        let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), apt_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
}
		Summary
		Summary
		This page explains how to initialize liquidity in a Pump4fun system, focusing on creating a liquidity pool for a custom token pair and Move token. Key points include:
		This page explains how to initialize liquidity in a Pump4fun system, focusing on creating a liquidity pool for a custom token pair and Move token. Key points include:
		Definition of the LiquidityPool struct with fields for token and Move reserves, token address, owner, and signer capability
Step-by-step process to initialize a liquidity pool using the initialize_liquidity_pool function
Creation of a resource account for the pool
Registration of Move coin storage for the pool
Minting of custom tokens and transfer of Move tokens to the pool
Initialization of the LiquidityPool structure with provided data
The function's role in setting up infrastructure for decentralized exchanges or DeFi protocols
		Definition of the LiquidityPool struct with fields for token and Move reserves, token address, owner, and signer capability
		Definition of the LiquidityPool struct with fields for token and Move reserves, token address, owner, and signer capability
		Step-by-step process to initialize a liquidity pool using the initialize_liquidity_pool function
		Step-by-step process to initialize a liquidity pool using the initialize_liquidity_pool function
		Creation of a resource account for the pool
		Creation of a resource account for the pool
		Registration of Move coin storage for the pool
		Registration of Move coin storage for the pool
		Minting of custom tokens and transfer of Move tokens to the pool
		Minting of custom tokens and transfer of Move tokens to the pool
		Initialization of the LiquidityPool structure with provided data
		Initialization of the LiquidityPool structure with provided data
		The function's role in setting up infrastructure for decentralized exchanges or DeFi protocols
		The function's role in setting up infrastructure for decentralized exchanges or DeFi protocols
	Overview
	Overview
	After successfully initializing the token, we will now use the token and Move Token that were used to purchase tokens to initialize the Pool for the above Token Pair.
	After successfully initializing the token, we will now use the token and Move Token that were used to purchase tokens to initialize the Pool for the above Token Pair.
	<code>struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }</code>
	<code>struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }</code>
	struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
	The LiquidityPool struct includes the following fields:
	The LiquidityPool struct includes the following fields:
	token_reserve: The amount of tokens in the pool
apt_reserve: The amount of Move in the pool
token_address: The address of the token metadata
owner: The address of the pool owner
signer_cap: The ability to sign transactions for the pool
	token_reserve: The amount of tokens in the pool
	token_reserve: The amount of tokens in the pool
	apt_reserve: The amount of Move in the pool
	apt_reserve: The amount of Move in the pool
	token_address: The address of the token metadata
	token_address: The address of the token metadata
	owner: The address of the pool owner
	owner: The address of the pool owner
	signer_cap: The ability to sign transactions for the pool
	signer_cap: The ability to sign transactions for the pool
	To initialize a liquidity pool using this structure, you need to create an initialization function with corresponding parameters. For example:
	To initialize a liquidity pool using this structure, you need to create an initialization function with corresponding parameters. For example:
	<code>fun initialize_liquidity_pool(
    sender: &signer,
    token: Object<Metadata>,
    move_amount: u64,
    token_amount: u64
) acquires FAController {
    let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
    // Register APT coin store for pool
    if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
        coin::register<AptosCoin>(&pool_signer);
    };
    // Mint tokens to pool
    mint_tokens(&pool_signer, token, token_amount);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(signer::address_of(&pool_signer), apt_coins);
    // Initialize LP
    move_to(&pool_signer, LiquidityPool {
        token_reserve: token_amount,
        move_reserve: move_amount,
        token_address: token,
        owner: signer::address_of(sender),
        signer_cap,
    });
}</code>
	<code>fun initialize_liquidity_pool(
    sender: &signer,
    token: Object<Metadata>,
    move_amount: u64,
    token_amount: u64
) acquires FAController {
    let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
    // Register APT coin store for pool
    if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
        coin::register<AptosCoin>(&pool_signer);
    };
    // Mint tokens to pool
    mint_tokens(&pool_signer, token, token_amount);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(signer::address_of(&pool_signer), apt_coins);
    // Initialize LP
    move_to(&pool_signer, LiquidityPool {
        token_reserve: token_amount,
        move_reserve: move_amount,
        token_address: token,
        owner: signer::address_of(sender),
        signer_cap,
    });
}</code>
	fun initialize_liquidity_pool(
    sender: &signer,
    token: Object<Metadata>,
    move_amount: u64,
    token_amount: u64
) acquires FAController {
    let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
    // Register APT coin store for pool
    if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
        coin::register<AptosCoin>(&pool_signer);
    };
    // Mint tokens to pool
    mint_tokens(&pool_signer, token, token_amount);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(signer::address_of(&pool_signer), apt_coins);
    // Initialize LP
    move_to(&pool_signer, LiquidityPool {
        token_reserve: token_amount,
        move_reserve: move_amount,
        token_address: token,
        owner: signer::address_of(sender),
        signer_cap,
    });
}
	I will describe in more detail the
initialize_liquidity_pool
function and its features:
	I will describe in more detail the
	<code>initialize_liquidity_pool</code>
	initialize_liquidity_pool
	function and its features:
	General purpose:
	General purpose:
	General purpose:
	This function is designed to initialize a liquidity pool for a custom token pair and Move token. The main purpose is to create a foundation for exchange and provide liquidity in the system.
	This function is designed to initialize a liquidity pool for a custom token pair and Move token. The main purpose is to create a foundation for exchange and provide liquidity in the system.
	Step-by-step details:
	Step-by-step details:
	Step-by-step details:
	Create resource account
	Create resource account
	Create resource account
	<code>let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");</code>
	<code>let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");</code>
	let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
	Use
account::create_resource_account
to create a new resource account for the pool
Create a pool_signer and signer_cap to manage the pool
	Use
account::create_resource_account
to create a new resource account for the pool
	Use
	<code>account::create_resource_account</code>
	account::create_resource_account
	to create a new resource account for the pool
	Create a pool_signer and signer_cap to manage the pool
	Create a pool_signer and signer_cap to manage the pool
	Register Move coin storage:
	Register Move coin storage:
	Register Move coin storage:
	<code>// Register APT coin store for pool
if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
    coin::register<AptosCoin>(&pool_signer);
};</code>
	<code>// Register APT coin store for pool
if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
    coin::register<AptosCoin>(&pool_signer);
};</code>
	// Register APT coin store for pool
if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
    coin::register<AptosCoin>(&pool_signer);
};
	Check if the pool has already registered AptosCoin storage
If not, register AptosCoin storage for the pool
	Check if the pool has already registered AptosCoin storage
	Check if the pool has already registered AptosCoin storage
	If not, register AptosCoin storage for the pool
	If not, register AptosCoin storage for the pool
	<code>// Mint tokens to pool
mint_tokens(&pool_signer, token, token_amount);
// Transfer APT to pool
let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(signer::address_of(&pool_signer), apt_coins);</code>
	<code>// Mint tokens to pool
mint_tokens(&pool_signer, token, token_amount);
// Transfer APT to pool
let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(signer::address_of(&pool_signer), apt_coins);</code>
	// Mint tokens to pool
mint_tokens(&pool_signer, token, token_amount);
// Transfer APT to pool
let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(signer::address_of(&pool_signer), apt_coins);
	Mint custom token:
Use the
mint_tokens
function to create and add custom tokens to the pool
The token amount is determined by the
token_amount
parameter
Transfer Move token:
Withdraw Move tokens from the sender's account
Transfer this amount of Move tokens to the pool's account
	Mint custom token:
Use the
mint_tokens
function to create and add custom tokens to the pool
The token amount is determined by the
token_amount
parameter
	Mint custom token:
	Use the
mint_tokens
function to create and add custom tokens to the pool
The token amount is determined by the
token_amount
parameter
	Use the
mint_tokens
function to create and add custom tokens to the pool
	Use the
	<code>mint_tokens</code>
	mint_tokens
	function to create and add custom tokens to the pool
	The token amount is determined by the
token_amount
parameter
	The token amount is determined by the
	<code>token_amount</code>
	token_amount
	parameter
	Transfer Move token:
Withdraw Move tokens from the sender's account
Transfer this amount of Move tokens to the pool's account
	Transfer Move token:
	Withdraw Move tokens from the sender's account
Transfer this amount of Move tokens to the pool's account
	Withdraw Move tokens from the sender's account
	Withdraw Move tokens from the sender's account
	Transfer this amount of Move tokens to the pool's account
	Transfer this amount of Move tokens to the pool's account
	<code>// Initialize LP
move_to(&pool_signer, LiquidityPool {
    token_reserve: token_amount,
    move_reserve: move_amount,
    token_address: token,
    owner: signer::address_of(sender),
    signer_cap,
});</code>
	<code>// Initialize LP
move_to(&pool_signer, LiquidityPool {
    token_reserve: token_amount,
    move_reserve: move_amount,
    token_address: token,
    owner: signer::address_of(sender),
    signer_cap,
});</code>
	// Initialize LP
move_to(&pool_signer, LiquidityPool {
    token_reserve: token_amount,
    move_reserve: move_amount,
    token_address: token,
    owner: signer::address_of(sender),
    signer_cap,
});
	Initialize LiquidityPool:
	Initialize LiquidityPool:
	Create a new LiquidityPool structure
Store information about the amount of tokens and Move, token address, owner, and signing capability
Use
move_to
to save this structure to the pool's storage
	Create a new LiquidityPool structure
	Create a new LiquidityPool structure
	Store information about the amount of tokens and Move, token address, owner, and signing capability
	Store information about the amount of tokens and Move, token address, owner, and signing capability
	Use
move_to
to save this structure to the pool's storage
	Use
	<code>move_to</code>
	move_to
	to save this structure to the pool's storage
	This function plays a crucial role in setting up the infrastructure for a decentralized exchange (DEX) or a DeFi protocol, allowing users to create initial liquidity for a token-Move pair.
	This function plays a crucial role in setting up the infrastructure for a decentralized exchange (DEX) or a DeFi protocol, allowing users to create initial liquidity for a token-Move pair.
	Initialize Pool
	Initialize Pool
	After completing the function to initialize the Pool, we will call it immediately after successfully initializing the token. I want to set the default initial value so that 1 Move can be exchanged for 50,000 Tokens. Subsequently, the price will be calculated based on the pool.
	After completing the function to initialize the Pool, we will call it immediately after successfully initializing the token. I want to set the default initial value so that 1 Move can be exchanged for 50,000 Tokens. Subsequently, the price will be calculated based on the pool.
	<code>const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
const APT_DECIMALS: u8 = 8;
const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
// Calculate total tokens to be created
let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);</code>
	<code>const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
const APT_DECIMALS: u8 = 8;
const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
// Calculate total tokens to be created
let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);</code>
	const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
const APT_DECIMALS: u8 = 8;
const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
// Calculate total tokens to be created
let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
	Create & Buy Token Complete
	Create & Buy Token Complete
	<code>module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
    const APT_DECIMALS: u8 = 8;
    const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of APT in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // APT from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register APT coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer APT to pool
        let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), apt_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
}</code>
	<code>module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
    const APT_DECIMALS: u8 = 8;
    const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of APT in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // APT from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register APT coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer APT to pool
        let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), apt_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
}</code>
	module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
    const APT_DECIMALS: u8 = 8;
    const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of APT in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) / (APT_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // APT from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register APT coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer APT to pool
        let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), apt_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/03-pump4fun/04-amm-and-swap-tokens
AMM & Swap Tokens
AMM & Swap Tokens
On This Page
Summary
Overview
1. swap_move_to_token
2. swap_token_to_move
3. get_output_amount
4. get_token_output_amount (View Function)
5. get_apt_output_amount (View Function)
6. get_pool_info (View Function)
FullCode
Summary
AMM (Automated Market Maker) and Constant Product Formula are used to create swap pairs
Swap mechanism allows users to exchange MOVE for tokens and vice versa
Key functions include swap_move_to_token, swap_token_to_move, and get_output_amount
View functions provide previews of swap outcomes and pool information
A 0.3% fee is applied to all swap transactions
Pool reserves are dynamically updated after each swap to maintain balance
The contract ensures efficient and transparent execution of swap transactions
Overview
In this section, we have thoroughly examined the Swap mechanism. We use AMM (Automated Market Maker) or Constant Product Formula to create a swap pair, with prices dependent on the quantity of tokens in the pool.
// Swap APT for tokens
public entry fun swap_move_to_token(
    sender: &signer,
    pool: Object<Metadata>,
    move_amount: u64
) acquires LiquidityPool {
    assert!(move_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate output tokens
    let token_out = get_output_amount(
        move_amount,
        lp.move_reserve,
        lp.token_reserve
    );
    assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(pool_addr, apt_coins);
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer tokens to user
    primary_fungible_store::transfer(
        &pool_signer,
        lp.token_address,
        signer::address_of(sender),
        token_out
    );
    // Update reserves
    lp.move_reserve = lp.move_reserve + move_amount;
    lp.token_reserve = lp.token_reserve - token_out;
}
// Swap tokens for APT
public entry fun swap_token_to_move(
    sender: &signer,
    pool: Object<Metadata>,
    token_amount: u64
) acquires LiquidityPool {
    assert!(token_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate APT output
    let apt_out = get_output_amount(
        token_amount,
        lp.token_reserve,
        lp.move_reserve
    );
    assert!(apt_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer tokens to pool
    primary_fungible_store::transfer(
        sender,
        lp.token_address,
        pool_addr,
        token_amount
    );
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer APT to user
    coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), apt_out);
    // Update reserves
    lp.token_reserve = lp.token_reserve + token_amount;
    lp.move_reserve = lp.move_reserve - apt_out;
}
// Calculate output amount based on AMM formula
fun get_output_amount(
    input_amount: u64,
    input_reserve: u64,
    output_reserve: u64
): u64 {
    let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
    let numerator = input_amount_with_fee * (output_reserve as u128);
    let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
    ((numerator / denominator) as u64)
}
// View Functions
/// Returns the amount of tokens you would receive for the given APT amount
#[view]
public fun get_token_output_amount(
    move_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
}
/// Returns the amount of APT you would receive for the given token amount
#[view]
public fun get_apt_output_amount(
    token_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
}
/// Returns the current pool reserves (token_reserve, move_reserve)
#[view]
public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    (lp.token_reserve, lp.move_reserve)
}
Based on the code above, we can describe the main functions related to token swapping as follows:
swap_move_to_token
: Allows users to exchange MOVE for tokens. This function takes the sender's address, pool object, and the amount of MOVE to swap.
swap_token_to_move
: The reverse of the above function, allowing users to exchange tokens for MOVE. It takes similar parameters, but instead of MOVE amount, it takes the amount of tokens to swap.
get_output_amount
: An internal function that calculates the output token amount based on the AMM (Automated Market Maker) formula, accounting for a 0.3% fee.
get_token_output_amount
: A view function that allows users to preview the amount of tokens they would receive when swapping a specific amount of MOVE.
get_apt_output_amount
: Similar to the above, this view function allows users to preview the amount of MOVE they would receive when swapping a specific amount of tokens.
get_pool_info
: A view function that returns information about the pool's reserves, including the current amounts of tokens and MOVE in the pool.
These functions are not directly related to creating new tokens. Instead, they focus on managing and executing swap transactions between MOVE and an existing token in a liquidity pool. To create a new token, you would need different functions related to token creation and management.
1. swap_move_to_token
Purpose: Allows users to exchange APT MOVE for tokens in the pool.
Input: Sender's address, pool object, and the amount of MOVE to swap.
Checks if the MOVE amount is greater than 0 and calculates the output token amount.
Transfers MOVE from the user to the pool.
Transfers tokens from the pool to the user.
Updates the pool's reserves.
2. swap_token_to_move
Purpose: Allows users to exchange tokens for MOVE from the pool.
Input: Sender's address, pool object, and the amount of tokens to swap.
Checks if the token amount is greater than 0 and calculates the output MOVE amount.
Transfers tokens from the user to the pool.
Transfers MOVE from the pool to the user.
Updates the pool's reserves.
3. get_output_amount
Purpose: Calculates the output token amount based on the AMM formula.
Uses the Constant Product Formula with a 0.3% fee.
Ensures accurate calculation to maintain balance in the pool.
4. get_token_output_amount (View Function)
Purpose: Allows users to preview the amount of tokens they would receive when swapping MOVE.
Helps users estimate the swap result before executing the transaction.
5. get_apt_output_amount (View Function)
Purpose: Allows users to preview the amount of MOVE they would receive when swapping tokens.
Similar to the above, helps users estimate the reverse swap result.
6. get_pool_info (View Function)
Purpose: Provides information about the current state of the pool.
Returns the current amounts of tokens and MOVE in the pool.
Helps users and other applications monitor and analyze the pool's state.
All these functions work together to create a complete DEX contract, allowing users to execute swap transactions and query pool information efficiently and transparently.
FullCode
module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_MOVE: u64 = 5_000_000_000_000;
    const MOVE_DECIMALS: u8 = 8;
    const MOVE_MULTIPLIER: u64 = 100_000_000; // 10^8 for MOVE decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of MOVE in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_MOVE as u128) / (MOVE_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // MOVE from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register MOVE coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), move_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
    // Swap MOVE for tokens
    public entry fun swap_move_to_token(
        sender: &signer,
        pool: Object<Metadata>,
        move_amount: u64
    ) acquires LiquidityPool {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate output tokens
        let token_out = get_output_amount(
            move_amount,
            lp.move_reserve,
            lp.token_reserve
        );
        assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(pool_addr, move_coins);
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer tokens to user
        primary_fungible_store::transfer(
            &pool_signer,
            lp.token_address,
            signer::address_of(sender),
            token_out
        );
        // Update reserves
        lp.move_reserve = lp.move_reserve + move_amount;
        lp.token_reserve = lp.token_reserve - token_out;
    }
    // Swap tokens for MOVE
    public entry fun swap_token_to_move(
        sender: &signer,
        pool: Object<Metadata>,
        token_amount: u64
    ) acquires LiquidityPool {
        assert!(token_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate MOVE output
        let move_out = get_output_amount(
            token_amount,
            lp.token_reserve,
            lp.move_reserve
        );
        assert!(move_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer tokens to pool
        primary_fungible_store::transfer(
            sender,
            lp.token_address,
            pool_addr,
            token_amount
        );
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer MOVE to user
        coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), move_out);
        // Update reserves
        lp.token_reserve = lp.token_reserve + token_amount;
        lp.move_reserve = lp.move_reserve - move_out;
    }
    // Calculate output amount based on AMM formula
    fun get_output_amount(
        input_amount: u64,
        input_reserve: u64,
        output_reserve: u64
    ): u64 {
        let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
        let numerator = input_amount_with_fee * (output_reserve as u128);
        let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
        ((numerator / denominator) as u64)
    }
    // View Functions
    /// Returns the amount of tokens you would receive for the given MOVE amount
    #[view]
    public fun get_token_output_amount(
        move_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
    }
    /// Returns the amount of MOVE you would receive for the given token amount
    #[view]
    public fun get_move_output_amount(
        token_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
    }
    /// Returns the current pool reserves (token_reserve, move_reserve)
    #[view]
    public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        (lp.token_reserve, lp.move_reserve)
    }
}
On This Page
Summary
Overview
1. swap_move_to_token
2. swap_token_to_move
3. get_output_amount
4. get_token_output_amount (View Function)
5. get_apt_output_amount (View Function)
6. get_pool_info (View Function)
FullCode
On This Page
Summary
Overview
1. swap_move_to_token
2. swap_token_to_move
3. get_output_amount
4. get_token_output_amount (View Function)
5. get_apt_output_amount (View Function)
6. get_pool_info (View Function)
FullCode
			On This Page
			On This Page
			Summary
Overview
1. swap_move_to_token
2. swap_token_to_move
3. get_output_amount
4. get_token_output_amount (View Function)
5. get_apt_output_amount (View Function)
6. get_pool_info (View Function)
FullCode
			Summary
			Summary
			Summary
			Summary
			Overview
1. swap_move_to_token
2. swap_token_to_move
3. get_output_amount
4. get_token_output_amount (View Function)
5. get_apt_output_amount (View Function)
6. get_pool_info (View Function)
			Overview
			Overview
			Overview
			1. swap_move_to_token
2. swap_token_to_move
3. get_output_amount
4. get_token_output_amount (View Function)
5. get_apt_output_amount (View Function)
6. get_pool_info (View Function)
			1. swap_move_to_token
			1. swap_move_to_token
			1. swap_move_to_token
			1. swap_move_to_token
			2. swap_token_to_move
			2. swap_token_to_move
			2. swap_token_to_move
			2. swap_token_to_move
			3. get_output_amount
			3. get_output_amount
			3. get_output_amount
			3. get_output_amount
			4. get_token_output_amount (View Function)
			4. get_token_output_amount (View Function)
			4. get_token_output_amount (View Function)
			4. get_token_output_amount (View Function)
			5. get_apt_output_amount (View Function)
			5. get_apt_output_amount (View Function)
			5. get_apt_output_amount (View Function)
			5. get_apt_output_amount (View Function)
			6. get_pool_info (View Function)
			6. get_pool_info (View Function)
			6. get_pool_info (View Function)
			6. get_pool_info (View Function)
			FullCode
			FullCode
			FullCode
			FullCode
			Summary
AMM (Automated Market Maker) and Constant Product Formula are used to create swap pairs
Swap mechanism allows users to exchange MOVE for tokens and vice versa
Key functions include swap_move_to_token, swap_token_to_move, and get_output_amount
View functions provide previews of swap outcomes and pool information
A 0.3% fee is applied to all swap transactions
Pool reserves are dynamically updated after each swap to maintain balance
The contract ensures efficient and transparent execution of swap transactions
Overview
In this section, we have thoroughly examined the Swap mechanism. We use AMM (Automated Market Maker) or Constant Product Formula to create a swap pair, with prices dependent on the quantity of tokens in the pool.
// Swap APT for tokens
public entry fun swap_move_to_token(
    sender: &signer,
    pool: Object<Metadata>,
    move_amount: u64
) acquires LiquidityPool {
    assert!(move_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate output tokens
    let token_out = get_output_amount(
        move_amount,
        lp.move_reserve,
        lp.token_reserve
    );
    assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(pool_addr, apt_coins);
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer tokens to user
    primary_fungible_store::transfer(
        &pool_signer,
        lp.token_address,
        signer::address_of(sender),
        token_out
    );
    // Update reserves
    lp.move_reserve = lp.move_reserve + move_amount;
    lp.token_reserve = lp.token_reserve - token_out;
}
// Swap tokens for APT
public entry fun swap_token_to_move(
    sender: &signer,
    pool: Object<Metadata>,
    token_amount: u64
) acquires LiquidityPool {
    assert!(token_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate APT output
    let apt_out = get_output_amount(
        token_amount,
        lp.token_reserve,
        lp.move_reserve
    );
    assert!(apt_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer tokens to pool
    primary_fungible_store::transfer(
        sender,
        lp.token_address,
        pool_addr,
        token_amount
    );
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer APT to user
    coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), apt_out);
    // Update reserves
    lp.token_reserve = lp.token_reserve + token_amount;
    lp.move_reserve = lp.move_reserve - apt_out;
}
// Calculate output amount based on AMM formula
fun get_output_amount(
    input_amount: u64,
    input_reserve: u64,
    output_reserve: u64
): u64 {
    let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
    let numerator = input_amount_with_fee * (output_reserve as u128);
    let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
    ((numerator / denominator) as u64)
}
// View Functions
/// Returns the amount of tokens you would receive for the given APT amount
#[view]
public fun get_token_output_amount(
    move_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
}
/// Returns the amount of APT you would receive for the given token amount
#[view]
public fun get_apt_output_amount(
    token_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
}
/// Returns the current pool reserves (token_reserve, move_reserve)
#[view]
public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    (lp.token_reserve, lp.move_reserve)
}
Based on the code above, we can describe the main functions related to token swapping as follows:
swap_move_to_token
: Allows users to exchange MOVE for tokens. This function takes the sender's address, pool object, and the amount of MOVE to swap.
swap_token_to_move
: The reverse of the above function, allowing users to exchange tokens for MOVE. It takes similar parameters, but instead of MOVE amount, it takes the amount of tokens to swap.
get_output_amount
: An internal function that calculates the output token amount based on the AMM (Automated Market Maker) formula, accounting for a 0.3% fee.
get_token_output_amount
: A view function that allows users to preview the amount of tokens they would receive when swapping a specific amount of MOVE.
get_apt_output_amount
: Similar to the above, this view function allows users to preview the amount of MOVE they would receive when swapping a specific amount of tokens.
get_pool_info
: A view function that returns information about the pool's reserves, including the current amounts of tokens and MOVE in the pool.
These functions are not directly related to creating new tokens. Instead, they focus on managing and executing swap transactions between MOVE and an existing token in a liquidity pool. To create a new token, you would need different functions related to token creation and management.
1. swap_move_to_token
Purpose: Allows users to exchange APT MOVE for tokens in the pool.
Input: Sender's address, pool object, and the amount of MOVE to swap.
Checks if the MOVE amount is greater than 0 and calculates the output token amount.
Transfers MOVE from the user to the pool.
Transfers tokens from the pool to the user.
Updates the pool's reserves.
2. swap_token_to_move
Purpose: Allows users to exchange tokens for MOVE from the pool.
Input: Sender's address, pool object, and the amount of tokens to swap.
Checks if the token amount is greater than 0 and calculates the output MOVE amount.
Transfers tokens from the user to the pool.
Transfers MOVE from the pool to the user.
Updates the pool's reserves.
3. get_output_amount
Purpose: Calculates the output token amount based on the AMM formula.
Uses the Constant Product Formula with a 0.3% fee.
Ensures accurate calculation to maintain balance in the pool.
4. get_token_output_amount (View Function)
Purpose: Allows users to preview the amount of tokens they would receive when swapping MOVE.
Helps users estimate the swap result before executing the transaction.
5. get_apt_output_amount (View Function)
Purpose: Allows users to preview the amount of MOVE they would receive when swapping tokens.
Similar to the above, helps users estimate the reverse swap result.
6. get_pool_info (View Function)
Purpose: Provides information about the current state of the pool.
Returns the current amounts of tokens and MOVE in the pool.
Helps users and other applications monitor and analyze the pool's state.
All these functions work together to create a complete DEX contract, allowing users to execute swap transactions and query pool information efficiently and transparently.
FullCode
module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_MOVE: u64 = 5_000_000_000_000;
    const MOVE_DECIMALS: u8 = 8;
    const MOVE_MULTIPLIER: u64 = 100_000_000; // 10^8 for MOVE decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of MOVE in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_MOVE as u128) / (MOVE_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // MOVE from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register MOVE coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), move_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
    // Swap MOVE for tokens
    public entry fun swap_move_to_token(
        sender: &signer,
        pool: Object<Metadata>,
        move_amount: u64
    ) acquires LiquidityPool {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate output tokens
        let token_out = get_output_amount(
            move_amount,
            lp.move_reserve,
            lp.token_reserve
        );
        assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(pool_addr, move_coins);
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer tokens to user
        primary_fungible_store::transfer(
            &pool_signer,
            lp.token_address,
            signer::address_of(sender),
            token_out
        );
        // Update reserves
        lp.move_reserve = lp.move_reserve + move_amount;
        lp.token_reserve = lp.token_reserve - token_out;
    }
    // Swap tokens for MOVE
    public entry fun swap_token_to_move(
        sender: &signer,
        pool: Object<Metadata>,
        token_amount: u64
    ) acquires LiquidityPool {
        assert!(token_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate MOVE output
        let move_out = get_output_amount(
            token_amount,
            lp.token_reserve,
            lp.move_reserve
        );
        assert!(move_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer tokens to pool
        primary_fungible_store::transfer(
            sender,
            lp.token_address,
            pool_addr,
            token_amount
        );
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer MOVE to user
        coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), move_out);
        // Update reserves
        lp.token_reserve = lp.token_reserve + token_amount;
        lp.move_reserve = lp.move_reserve - move_out;
    }
    // Calculate output amount based on AMM formula
    fun get_output_amount(
        input_amount: u64,
        input_reserve: u64,
        output_reserve: u64
    ): u64 {
        let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
        let numerator = input_amount_with_fee * (output_reserve as u128);
        let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
        ((numerator / denominator) as u64)
    }
    // View Functions
    /// Returns the amount of tokens you would receive for the given MOVE amount
    #[view]
    public fun get_token_output_amount(
        move_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
    }
    /// Returns the amount of MOVE you would receive for the given token amount
    #[view]
    public fun get_move_output_amount(
        token_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
    }
    /// Returns the current pool reserves (token_reserve, move_reserve)
    #[view]
    public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        (lp.token_reserve, lp.move_reserve)
    }
}
			Summary
AMM (Automated Market Maker) and Constant Product Formula are used to create swap pairs
Swap mechanism allows users to exchange MOVE for tokens and vice versa
Key functions include swap_move_to_token, swap_token_to_move, and get_output_amount
View functions provide previews of swap outcomes and pool information
A 0.3% fee is applied to all swap transactions
Pool reserves are dynamically updated after each swap to maintain balance
The contract ensures efficient and transparent execution of swap transactions
Overview
In this section, we have thoroughly examined the Swap mechanism. We use AMM (Automated Market Maker) or Constant Product Formula to create a swap pair, with prices dependent on the quantity of tokens in the pool.
// Swap APT for tokens
public entry fun swap_move_to_token(
    sender: &signer,
    pool: Object<Metadata>,
    move_amount: u64
) acquires LiquidityPool {
    assert!(move_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate output tokens
    let token_out = get_output_amount(
        move_amount,
        lp.move_reserve,
        lp.token_reserve
    );
    assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(pool_addr, apt_coins);
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer tokens to user
    primary_fungible_store::transfer(
        &pool_signer,
        lp.token_address,
        signer::address_of(sender),
        token_out
    );
    // Update reserves
    lp.move_reserve = lp.move_reserve + move_amount;
    lp.token_reserve = lp.token_reserve - token_out;
}
// Swap tokens for APT
public entry fun swap_token_to_move(
    sender: &signer,
    pool: Object<Metadata>,
    token_amount: u64
) acquires LiquidityPool {
    assert!(token_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate APT output
    let apt_out = get_output_amount(
        token_amount,
        lp.token_reserve,
        lp.move_reserve
    );
    assert!(apt_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer tokens to pool
    primary_fungible_store::transfer(
        sender,
        lp.token_address,
        pool_addr,
        token_amount
    );
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer APT to user
    coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), apt_out);
    // Update reserves
    lp.token_reserve = lp.token_reserve + token_amount;
    lp.move_reserve = lp.move_reserve - apt_out;
}
// Calculate output amount based on AMM formula
fun get_output_amount(
    input_amount: u64,
    input_reserve: u64,
    output_reserve: u64
): u64 {
    let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
    let numerator = input_amount_with_fee * (output_reserve as u128);
    let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
    ((numerator / denominator) as u64)
}
// View Functions
/// Returns the amount of tokens you would receive for the given APT amount
#[view]
public fun get_token_output_amount(
    move_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
}
/// Returns the amount of APT you would receive for the given token amount
#[view]
public fun get_apt_output_amount(
    token_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
}
/// Returns the current pool reserves (token_reserve, move_reserve)
#[view]
public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    (lp.token_reserve, lp.move_reserve)
}
Based on the code above, we can describe the main functions related to token swapping as follows:
swap_move_to_token
: Allows users to exchange MOVE for tokens. This function takes the sender's address, pool object, and the amount of MOVE to swap.
swap_token_to_move
: The reverse of the above function, allowing users to exchange tokens for MOVE. It takes similar parameters, but instead of MOVE amount, it takes the amount of tokens to swap.
get_output_amount
: An internal function that calculates the output token amount based on the AMM (Automated Market Maker) formula, accounting for a 0.3% fee.
get_token_output_amount
: A view function that allows users to preview the amount of tokens they would receive when swapping a specific amount of MOVE.
get_apt_output_amount
: Similar to the above, this view function allows users to preview the amount of MOVE they would receive when swapping a specific amount of tokens.
get_pool_info
: A view function that returns information about the pool's reserves, including the current amounts of tokens and MOVE in the pool.
These functions are not directly related to creating new tokens. Instead, they focus on managing and executing swap transactions between MOVE and an existing token in a liquidity pool. To create a new token, you would need different functions related to token creation and management.
1. swap_move_to_token
Purpose: Allows users to exchange APT MOVE for tokens in the pool.
Input: Sender's address, pool object, and the amount of MOVE to swap.
Checks if the MOVE amount is greater than 0 and calculates the output token amount.
Transfers MOVE from the user to the pool.
Transfers tokens from the pool to the user.
Updates the pool's reserves.
2. swap_token_to_move
Purpose: Allows users to exchange tokens for MOVE from the pool.
Input: Sender's address, pool object, and the amount of tokens to swap.
Checks if the token amount is greater than 0 and calculates the output MOVE amount.
Transfers tokens from the user to the pool.
Transfers MOVE from the pool to the user.
Updates the pool's reserves.
3. get_output_amount
Purpose: Calculates the output token amount based on the AMM formula.
Uses the Constant Product Formula with a 0.3% fee.
Ensures accurate calculation to maintain balance in the pool.
4. get_token_output_amount (View Function)
Purpose: Allows users to preview the amount of tokens they would receive when swapping MOVE.
Helps users estimate the swap result before executing the transaction.
5. get_apt_output_amount (View Function)
Purpose: Allows users to preview the amount of MOVE they would receive when swapping tokens.
Similar to the above, helps users estimate the reverse swap result.
6. get_pool_info (View Function)
Purpose: Provides information about the current state of the pool.
Returns the current amounts of tokens and MOVE in the pool.
Helps users and other applications monitor and analyze the pool's state.
All these functions work together to create a complete DEX contract, allowing users to execute swap transactions and query pool information efficiently and transparently.
FullCode
module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_MOVE: u64 = 5_000_000_000_000;
    const MOVE_DECIMALS: u8 = 8;
    const MOVE_MULTIPLIER: u64 = 100_000_000; // 10^8 for MOVE decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of MOVE in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_MOVE as u128) / (MOVE_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // MOVE from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register MOVE coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), move_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
    // Swap MOVE for tokens
    public entry fun swap_move_to_token(
        sender: &signer,
        pool: Object<Metadata>,
        move_amount: u64
    ) acquires LiquidityPool {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate output tokens
        let token_out = get_output_amount(
            move_amount,
            lp.move_reserve,
            lp.token_reserve
        );
        assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(pool_addr, move_coins);
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer tokens to user
        primary_fungible_store::transfer(
            &pool_signer,
            lp.token_address,
            signer::address_of(sender),
            token_out
        );
        // Update reserves
        lp.move_reserve = lp.move_reserve + move_amount;
        lp.token_reserve = lp.token_reserve - token_out;
    }
    // Swap tokens for MOVE
    public entry fun swap_token_to_move(
        sender: &signer,
        pool: Object<Metadata>,
        token_amount: u64
    ) acquires LiquidityPool {
        assert!(token_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate MOVE output
        let move_out = get_output_amount(
            token_amount,
            lp.token_reserve,
            lp.move_reserve
        );
        assert!(move_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer tokens to pool
        primary_fungible_store::transfer(
            sender,
            lp.token_address,
            pool_addr,
            token_amount
        );
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer MOVE to user
        coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), move_out);
        // Update reserves
        lp.token_reserve = lp.token_reserve + token_amount;
        lp.move_reserve = lp.move_reserve - move_out;
    }
    // Calculate output amount based on AMM formula
    fun get_output_amount(
        input_amount: u64,
        input_reserve: u64,
        output_reserve: u64
    ): u64 {
        let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
        let numerator = input_amount_with_fee * (output_reserve as u128);
        let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
        ((numerator / denominator) as u64)
    }
    // View Functions
    /// Returns the amount of tokens you would receive for the given MOVE amount
    #[view]
    public fun get_token_output_amount(
        move_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
    }
    /// Returns the amount of MOVE you would receive for the given token amount
    #[view]
    public fun get_move_output_amount(
        token_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
    }
    /// Returns the current pool reserves (token_reserve, move_reserve)
    #[view]
    public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        (lp.token_reserve, lp.move_reserve)
    }
}
			Summary
AMM (Automated Market Maker) and Constant Product Formula are used to create swap pairs
Swap mechanism allows users to exchange MOVE for tokens and vice versa
Key functions include swap_move_to_token, swap_token_to_move, and get_output_amount
View functions provide previews of swap outcomes and pool information
A 0.3% fee is applied to all swap transactions
Pool reserves are dynamically updated after each swap to maintain balance
The contract ensures efficient and transparent execution of swap transactions
Overview
In this section, we have thoroughly examined the Swap mechanism. We use AMM (Automated Market Maker) or Constant Product Formula to create a swap pair, with prices dependent on the quantity of tokens in the pool.
// Swap APT for tokens
public entry fun swap_move_to_token(
    sender: &signer,
    pool: Object<Metadata>,
    move_amount: u64
) acquires LiquidityPool {
    assert!(move_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate output tokens
    let token_out = get_output_amount(
        move_amount,
        lp.move_reserve,
        lp.token_reserve
    );
    assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(pool_addr, apt_coins);
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer tokens to user
    primary_fungible_store::transfer(
        &pool_signer,
        lp.token_address,
        signer::address_of(sender),
        token_out
    );
    // Update reserves
    lp.move_reserve = lp.move_reserve + move_amount;
    lp.token_reserve = lp.token_reserve - token_out;
}
// Swap tokens for APT
public entry fun swap_token_to_move(
    sender: &signer,
    pool: Object<Metadata>,
    token_amount: u64
) acquires LiquidityPool {
    assert!(token_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate APT output
    let apt_out = get_output_amount(
        token_amount,
        lp.token_reserve,
        lp.move_reserve
    );
    assert!(apt_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer tokens to pool
    primary_fungible_store::transfer(
        sender,
        lp.token_address,
        pool_addr,
        token_amount
    );
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer APT to user
    coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), apt_out);
    // Update reserves
    lp.token_reserve = lp.token_reserve + token_amount;
    lp.move_reserve = lp.move_reserve - apt_out;
}
// Calculate output amount based on AMM formula
fun get_output_amount(
    input_amount: u64,
    input_reserve: u64,
    output_reserve: u64
): u64 {
    let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
    let numerator = input_amount_with_fee * (output_reserve as u128);
    let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
    ((numerator / denominator) as u64)
}
// View Functions
/// Returns the amount of tokens you would receive for the given APT amount
#[view]
public fun get_token_output_amount(
    move_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
}
/// Returns the amount of APT you would receive for the given token amount
#[view]
public fun get_apt_output_amount(
    token_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
}
/// Returns the current pool reserves (token_reserve, move_reserve)
#[view]
public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    (lp.token_reserve, lp.move_reserve)
}
Based on the code above, we can describe the main functions related to token swapping as follows:
swap_move_to_token
: Allows users to exchange MOVE for tokens. This function takes the sender's address, pool object, and the amount of MOVE to swap.
swap_token_to_move
: The reverse of the above function, allowing users to exchange tokens for MOVE. It takes similar parameters, but instead of MOVE amount, it takes the amount of tokens to swap.
get_output_amount
: An internal function that calculates the output token amount based on the AMM (Automated Market Maker) formula, accounting for a 0.3% fee.
get_token_output_amount
: A view function that allows users to preview the amount of tokens they would receive when swapping a specific amount of MOVE.
get_apt_output_amount
: Similar to the above, this view function allows users to preview the amount of MOVE they would receive when swapping a specific amount of tokens.
get_pool_info
: A view function that returns information about the pool's reserves, including the current amounts of tokens and MOVE in the pool.
These functions are not directly related to creating new tokens. Instead, they focus on managing and executing swap transactions between MOVE and an existing token in a liquidity pool. To create a new token, you would need different functions related to token creation and management.
1. swap_move_to_token
Purpose: Allows users to exchange APT MOVE for tokens in the pool.
Input: Sender's address, pool object, and the amount of MOVE to swap.
Checks if the MOVE amount is greater than 0 and calculates the output token amount.
Transfers MOVE from the user to the pool.
Transfers tokens from the pool to the user.
Updates the pool's reserves.
2. swap_token_to_move
Purpose: Allows users to exchange tokens for MOVE from the pool.
Input: Sender's address, pool object, and the amount of tokens to swap.
Checks if the token amount is greater than 0 and calculates the output MOVE amount.
Transfers tokens from the user to the pool.
Transfers MOVE from the pool to the user.
Updates the pool's reserves.
3. get_output_amount
Purpose: Calculates the output token amount based on the AMM formula.
Uses the Constant Product Formula with a 0.3% fee.
Ensures accurate calculation to maintain balance in the pool.
4. get_token_output_amount (View Function)
Purpose: Allows users to preview the amount of tokens they would receive when swapping MOVE.
Helps users estimate the swap result before executing the transaction.
5. get_apt_output_amount (View Function)
Purpose: Allows users to preview the amount of MOVE they would receive when swapping tokens.
Similar to the above, helps users estimate the reverse swap result.
6. get_pool_info (View Function)
Purpose: Provides information about the current state of the pool.
Returns the current amounts of tokens and MOVE in the pool.
Helps users and other applications monitor and analyze the pool's state.
All these functions work together to create a complete DEX contract, allowing users to execute swap transactions and query pool information efficiently and transparently.
FullCode
module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_MOVE: u64 = 5_000_000_000_000;
    const MOVE_DECIMALS: u8 = 8;
    const MOVE_MULTIPLIER: u64 = 100_000_000; // 10^8 for MOVE decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of MOVE in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_MOVE as u128) / (MOVE_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // MOVE from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register MOVE coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), move_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
    // Swap MOVE for tokens
    public entry fun swap_move_to_token(
        sender: &signer,
        pool: Object<Metadata>,
        move_amount: u64
    ) acquires LiquidityPool {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate output tokens
        let token_out = get_output_amount(
            move_amount,
            lp.move_reserve,
            lp.token_reserve
        );
        assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(pool_addr, move_coins);
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer tokens to user
        primary_fungible_store::transfer(
            &pool_signer,
            lp.token_address,
            signer::address_of(sender),
            token_out
        );
        // Update reserves
        lp.move_reserve = lp.move_reserve + move_amount;
        lp.token_reserve = lp.token_reserve - token_out;
    }
    // Swap tokens for MOVE
    public entry fun swap_token_to_move(
        sender: &signer,
        pool: Object<Metadata>,
        token_amount: u64
    ) acquires LiquidityPool {
        assert!(token_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate MOVE output
        let move_out = get_output_amount(
            token_amount,
            lp.token_reserve,
            lp.move_reserve
        );
        assert!(move_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer tokens to pool
        primary_fungible_store::transfer(
            sender,
            lp.token_address,
            pool_addr,
            token_amount
        );
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer MOVE to user
        coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), move_out);
        // Update reserves
        lp.token_reserve = lp.token_reserve + token_amount;
        lp.move_reserve = lp.move_reserve - move_out;
    }
    // Calculate output amount based on AMM formula
    fun get_output_amount(
        input_amount: u64,
        input_reserve: u64,
        output_reserve: u64
    ): u64 {
        let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
        let numerator = input_amount_with_fee * (output_reserve as u128);
        let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
        ((numerator / denominator) as u64)
    }
    // View Functions
    /// Returns the amount of tokens you would receive for the given MOVE amount
    #[view]
    public fun get_token_output_amount(
        move_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
    }
    /// Returns the amount of MOVE you would receive for the given token amount
    #[view]
    public fun get_move_output_amount(
        token_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
    }
    /// Returns the current pool reserves (token_reserve, move_reserve)
    #[view]
    public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        (lp.token_reserve, lp.move_reserve)
    }
}
		Summary
		Summary
		AMM (Automated Market Maker) and Constant Product Formula are used to create swap pairs
Swap mechanism allows users to exchange MOVE for tokens and vice versa
Key functions include swap_move_to_token, swap_token_to_move, and get_output_amount
View functions provide previews of swap outcomes and pool information
A 0.3% fee is applied to all swap transactions
Pool reserves are dynamically updated after each swap to maintain balance
The contract ensures efficient and transparent execution of swap transactions
		AMM (Automated Market Maker) and Constant Product Formula are used to create swap pairs
		AMM (Automated Market Maker) and Constant Product Formula are used to create swap pairs
		Swap mechanism allows users to exchange MOVE for tokens and vice versa
		Swap mechanism allows users to exchange MOVE for tokens and vice versa
		Key functions include swap_move_to_token, swap_token_to_move, and get_output_amount
		Key functions include swap_move_to_token, swap_token_to_move, and get_output_amount
		View functions provide previews of swap outcomes and pool information
		View functions provide previews of swap outcomes and pool information
		A 0.3% fee is applied to all swap transactions
		A 0.3% fee is applied to all swap transactions
		Pool reserves are dynamically updated after each swap to maintain balance
		Pool reserves are dynamically updated after each swap to maintain balance
		The contract ensures efficient and transparent execution of swap transactions
		The contract ensures efficient and transparent execution of swap transactions
	Overview
	Overview
	In this section, we have thoroughly examined the Swap mechanism. We use AMM (Automated Market Maker) or Constant Product Formula to create a swap pair, with prices dependent on the quantity of tokens in the pool.
	In this section, we have thoroughly examined the Swap mechanism. We use AMM (Automated Market Maker) or Constant Product Formula to create a swap pair, with prices dependent on the quantity of tokens in the pool.
	<code>// Swap APT for tokens
public entry fun swap_move_to_token(
    sender: &signer,
    pool: Object<Metadata>,
    move_amount: u64
) acquires LiquidityPool {
    assert!(move_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate output tokens
    let token_out = get_output_amount(
        move_amount,
        lp.move_reserve,
        lp.token_reserve
    );
    assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(pool_addr, apt_coins);
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer tokens to user
    primary_fungible_store::transfer(
        &pool_signer,
        lp.token_address,
        signer::address_of(sender),
        token_out
    );
    // Update reserves
    lp.move_reserve = lp.move_reserve + move_amount;
    lp.token_reserve = lp.token_reserve - token_out;
}
// Swap tokens for APT
public entry fun swap_token_to_move(
    sender: &signer,
    pool: Object<Metadata>,
    token_amount: u64
) acquires LiquidityPool {
    assert!(token_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate APT output
    let apt_out = get_output_amount(
        token_amount,
        lp.token_reserve,
        lp.move_reserve
    );
    assert!(apt_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer tokens to pool
    primary_fungible_store::transfer(
        sender,
        lp.token_address,
        pool_addr,
        token_amount
    );
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer APT to user
    coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), apt_out);
    // Update reserves
    lp.token_reserve = lp.token_reserve + token_amount;
    lp.move_reserve = lp.move_reserve - apt_out;
}
// Calculate output amount based on AMM formula
fun get_output_amount(
    input_amount: u64,
    input_reserve: u64,
    output_reserve: u64
): u64 {
    let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
    let numerator = input_amount_with_fee * (output_reserve as u128);
    let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
    ((numerator / denominator) as u64)
}
// View Functions
/// Returns the amount of tokens you would receive for the given APT amount
#[view]
public fun get_token_output_amount(
    move_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
}
/// Returns the amount of APT you would receive for the given token amount
#[view]
public fun get_apt_output_amount(
    token_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
}
/// Returns the current pool reserves (token_reserve, move_reserve)
#[view]
public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    (lp.token_reserve, lp.move_reserve)
}</code>
	<code>// Swap APT for tokens
public entry fun swap_move_to_token(
    sender: &signer,
    pool: Object<Metadata>,
    move_amount: u64
) acquires LiquidityPool {
    assert!(move_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate output tokens
    let token_out = get_output_amount(
        move_amount,
        lp.move_reserve,
        lp.token_reserve
    );
    assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(pool_addr, apt_coins);
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer tokens to user
    primary_fungible_store::transfer(
        &pool_signer,
        lp.token_address,
        signer::address_of(sender),
        token_out
    );
    // Update reserves
    lp.move_reserve = lp.move_reserve + move_amount;
    lp.token_reserve = lp.token_reserve - token_out;
}
// Swap tokens for APT
public entry fun swap_token_to_move(
    sender: &signer,
    pool: Object<Metadata>,
    token_amount: u64
) acquires LiquidityPool {
    assert!(token_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate APT output
    let apt_out = get_output_amount(
        token_amount,
        lp.token_reserve,
        lp.move_reserve
    );
    assert!(apt_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer tokens to pool
    primary_fungible_store::transfer(
        sender,
        lp.token_address,
        pool_addr,
        token_amount
    );
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer APT to user
    coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), apt_out);
    // Update reserves
    lp.token_reserve = lp.token_reserve + token_amount;
    lp.move_reserve = lp.move_reserve - apt_out;
}
// Calculate output amount based on AMM formula
fun get_output_amount(
    input_amount: u64,
    input_reserve: u64,
    output_reserve: u64
): u64 {
    let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
    let numerator = input_amount_with_fee * (output_reserve as u128);
    let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
    ((numerator / denominator) as u64)
}
// View Functions
/// Returns the amount of tokens you would receive for the given APT amount
#[view]
public fun get_token_output_amount(
    move_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
}
/// Returns the amount of APT you would receive for the given token amount
#[view]
public fun get_apt_output_amount(
    token_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
}
/// Returns the current pool reserves (token_reserve, move_reserve)
#[view]
public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    (lp.token_reserve, lp.move_reserve)
}</code>
	// Swap APT for tokens
public entry fun swap_move_to_token(
    sender: &signer,
    pool: Object<Metadata>,
    move_amount: u64
) acquires LiquidityPool {
    assert!(move_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate output tokens
    let token_out = get_output_amount(
        move_amount,
        lp.move_reserve,
        lp.token_reserve
    );
    assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer APT to pool
    let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
    coin::deposit(pool_addr, apt_coins);
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer tokens to user
    primary_fungible_store::transfer(
        &pool_signer,
        lp.token_address,
        signer::address_of(sender),
        token_out
    );
    // Update reserves
    lp.move_reserve = lp.move_reserve + move_amount;
    lp.token_reserve = lp.token_reserve - token_out;
}
// Swap tokens for APT
public entry fun swap_token_to_move(
    sender: &signer,
    pool: Object<Metadata>,
    token_amount: u64
) acquires LiquidityPool {
    assert!(token_amount > 0, ERR_ZERO_AMOUNT);
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global_mut<LiquidityPool>(pool_addr);
    // Calculate APT output
    let apt_out = get_output_amount(
        token_amount,
        lp.token_reserve,
        lp.move_reserve
    );
    assert!(apt_out > 0, INSUFFICIENT_LIQUIDITY);
    // Transfer tokens to pool
    primary_fungible_store::transfer(
        sender,
        lp.token_address,
        pool_addr,
        token_amount
    );
    let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
    // Transfer APT to user
    coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), apt_out);
    // Update reserves
    lp.token_reserve = lp.token_reserve + token_amount;
    lp.move_reserve = lp.move_reserve - apt_out;
}
// Calculate output amount based on AMM formula
fun get_output_amount(
    input_amount: u64,
    input_reserve: u64,
    output_reserve: u64
): u64 {
    let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
    let numerator = input_amount_with_fee * (output_reserve as u128);
    let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
    ((numerator / denominator) as u64)
}
// View Functions
/// Returns the amount of tokens you would receive for the given APT amount
#[view]
public fun get_token_output_amount(
    move_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
}
/// Returns the amount of APT you would receive for the given token amount
#[view]
public fun get_apt_output_amount(
    token_amount: u64,
    pool: Object<Metadata>
): u64 acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
}
/// Returns the current pool reserves (token_reserve, move_reserve)
#[view]
public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
    let pool_addr = object::object_address(&pool);
    let lp = borrow_global<LiquidityPool>(pool_addr);
    (lp.token_reserve, lp.move_reserve)
}
	Based on the code above, we can describe the main functions related to token swapping as follows:
	Based on the code above, we can describe the main functions related to token swapping as follows:
	swap_move_to_token
: Allows users to exchange MOVE for tokens. This function takes the sender's address, pool object, and the amount of MOVE to swap.
swap_token_to_move
: The reverse of the above function, allowing users to exchange tokens for MOVE. It takes similar parameters, but instead of MOVE amount, it takes the amount of tokens to swap.
get_output_amount
: An internal function that calculates the output token amount based on the AMM (Automated Market Maker) formula, accounting for a 0.3% fee.
get_token_output_amount
: A view function that allows users to preview the amount of tokens they would receive when swapping a specific amount of MOVE.
get_apt_output_amount
: Similar to the above, this view function allows users to preview the amount of MOVE they would receive when swapping a specific amount of tokens.
get_pool_info
: A view function that returns information about the pool's reserves, including the current amounts of tokens and MOVE in the pool.
	swap_move_to_token
: Allows users to exchange MOVE for tokens. This function takes the sender's address, pool object, and the amount of MOVE to swap.
	swap_move_to_token
	swap_move_to_token
	: Allows users to exchange MOVE for tokens. This function takes the sender's address, pool object, and the amount of MOVE to swap.
	swap_token_to_move
: The reverse of the above function, allowing users to exchange tokens for MOVE. It takes similar parameters, but instead of MOVE amount, it takes the amount of tokens to swap.
	swap_token_to_move
	swap_token_to_move
	: The reverse of the above function, allowing users to exchange tokens for MOVE. It takes similar parameters, but instead of MOVE amount, it takes the amount of tokens to swap.
	get_output_amount
: An internal function that calculates the output token amount based on the AMM (Automated Market Maker) formula, accounting for a 0.3% fee.
	get_output_amount
	get_output_amount
	: An internal function that calculates the output token amount based on the AMM (Automated Market Maker) formula, accounting for a 0.3% fee.
	get_token_output_amount
: A view function that allows users to preview the amount of tokens they would receive when swapping a specific amount of MOVE.
	get_token_output_amount
	get_token_output_amount
	: A view function that allows users to preview the amount of tokens they would receive when swapping a specific amount of MOVE.
	get_apt_output_amount
: Similar to the above, this view function allows users to preview the amount of MOVE they would receive when swapping a specific amount of tokens.
	get_apt_output_amount
	get_apt_output_amount
	: Similar to the above, this view function allows users to preview the amount of MOVE they would receive when swapping a specific amount of tokens.
	get_pool_info
: A view function that returns information about the pool's reserves, including the current amounts of tokens and MOVE in the pool.
	get_pool_info
	get_pool_info
	: A view function that returns information about the pool's reserves, including the current amounts of tokens and MOVE in the pool.
	These functions are not directly related to creating new tokens. Instead, they focus on managing and executing swap transactions between MOVE and an existing token in a liquidity pool. To create a new token, you would need different functions related to token creation and management.
	These functions are not directly related to creating new tokens. Instead, they focus on managing and executing swap transactions between MOVE and an existing token in a liquidity pool. To create a new token, you would need different functions related to token creation and management.
		1. swap_move_to_token
		1. swap_move_to_token
		Purpose: Allows users to exchange APT MOVE for tokens in the pool.
		Purpose: Allows users to exchange APT MOVE for tokens in the pool.
		Input: Sender's address, pool object, and the amount of MOVE to swap.
Checks if the MOVE amount is greater than 0 and calculates the output token amount.
Transfers MOVE from the user to the pool.
Transfers tokens from the pool to the user.
Updates the pool's reserves.
		Input: Sender's address, pool object, and the amount of MOVE to swap.
		Input: Sender's address, pool object, and the amount of MOVE to swap.
		Checks if the MOVE amount is greater than 0 and calculates the output token amount.
		Checks if the MOVE amount is greater than 0 and calculates the output token amount.
		Transfers MOVE from the user to the pool.
		Transfers MOVE from the user to the pool.
		Transfers tokens from the pool to the user.
		Transfers tokens from the pool to the user.
		Updates the pool's reserves.
		Updates the pool's reserves.
		2. swap_token_to_move
		2. swap_token_to_move
		Purpose: Allows users to exchange tokens for MOVE from the pool.
		Purpose: Allows users to exchange tokens for MOVE from the pool.
		Input: Sender's address, pool object, and the amount of tokens to swap.
Checks if the token amount is greater than 0 and calculates the output MOVE amount.
Transfers tokens from the user to the pool.
Transfers MOVE from the pool to the user.
Updates the pool's reserves.
		Input: Sender's address, pool object, and the amount of tokens to swap.
		Input: Sender's address, pool object, and the amount of tokens to swap.
		Checks if the token amount is greater than 0 and calculates the output MOVE amount.
		Checks if the token amount is greater than 0 and calculates the output MOVE amount.
		Transfers tokens from the user to the pool.
		Transfers tokens from the user to the pool.
		Transfers MOVE from the pool to the user.
		Transfers MOVE from the pool to the user.
		Updates the pool's reserves.
		Updates the pool's reserves.
		3. get_output_amount
		3. get_output_amount
		Purpose: Calculates the output token amount based on the AMM formula.
		Purpose: Calculates the output token amount based on the AMM formula.
		Uses the Constant Product Formula with a 0.3% fee.
Ensures accurate calculation to maintain balance in the pool.
		Uses the Constant Product Formula with a 0.3% fee.
		Uses the Constant Product Formula with a 0.3% fee.
		Ensures accurate calculation to maintain balance in the pool.
		Ensures accurate calculation to maintain balance in the pool.
		4. get_token_output_amount (View Function)
		4. get_token_output_amount (View Function)
		Purpose: Allows users to preview the amount of tokens they would receive when swapping MOVE.
		Purpose: Allows users to preview the amount of tokens they would receive when swapping MOVE.
		Helps users estimate the swap result before executing the transaction.
		Helps users estimate the swap result before executing the transaction.
		Helps users estimate the swap result before executing the transaction.
		5. get_apt_output_amount (View Function)
		5. get_apt_output_amount (View Function)
		Purpose: Allows users to preview the amount of MOVE they would receive when swapping tokens.
		Purpose: Allows users to preview the amount of MOVE they would receive when swapping tokens.
		Similar to the above, helps users estimate the reverse swap result.
		Similar to the above, helps users estimate the reverse swap result.
		Similar to the above, helps users estimate the reverse swap result.
		6. get_pool_info (View Function)
		6. get_pool_info (View Function)
		Purpose: Provides information about the current state of the pool.
		Purpose: Provides information about the current state of the pool.
		Returns the current amounts of tokens and MOVE in the pool.
Helps users and other applications monitor and analyze the pool's state.
		Returns the current amounts of tokens and MOVE in the pool.
		Returns the current amounts of tokens and MOVE in the pool.
		Helps users and other applications monitor and analyze the pool's state.
		Helps users and other applications monitor and analyze the pool's state.
		All these functions work together to create a complete DEX contract, allowing users to execute swap transactions and query pool information efficiently and transparently.
		All these functions work together to create a complete DEX contract, allowing users to execute swap transactions and query pool information efficiently and transparently.
	FullCode
	FullCode
	<code>module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_MOVE: u64 = 5_000_000_000_000;
    const MOVE_DECIMALS: u8 = 8;
    const MOVE_MULTIPLIER: u64 = 100_000_000; // 10^8 for MOVE decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of MOVE in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_MOVE as u128) / (MOVE_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // MOVE from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register MOVE coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), move_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
    // Swap MOVE for tokens
    public entry fun swap_move_to_token(
        sender: &signer,
        pool: Object<Metadata>,
        move_amount: u64
    ) acquires LiquidityPool {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate output tokens
        let token_out = get_output_amount(
            move_amount,
            lp.move_reserve,
            lp.token_reserve
        );
        assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(pool_addr, move_coins);
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer tokens to user
        primary_fungible_store::transfer(
            &pool_signer,
            lp.token_address,
            signer::address_of(sender),
            token_out
        );
        // Update reserves
        lp.move_reserve = lp.move_reserve + move_amount;
        lp.token_reserve = lp.token_reserve - token_out;
    }
    // Swap tokens for MOVE
    public entry fun swap_token_to_move(
        sender: &signer,
        pool: Object<Metadata>,
        token_amount: u64
    ) acquires LiquidityPool {
        assert!(token_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate MOVE output
        let move_out = get_output_amount(
            token_amount,
            lp.token_reserve,
            lp.move_reserve
        );
        assert!(move_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer tokens to pool
        primary_fungible_store::transfer(
            sender,
            lp.token_address,
            pool_addr,
            token_amount
        );
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer MOVE to user
        coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), move_out);
        // Update reserves
        lp.token_reserve = lp.token_reserve + token_amount;
        lp.move_reserve = lp.move_reserve - move_out;
    }
    // Calculate output amount based on AMM formula
    fun get_output_amount(
        input_amount: u64,
        input_reserve: u64,
        output_reserve: u64
    ): u64 {
        let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
        let numerator = input_amount_with_fee * (output_reserve as u128);
        let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
        ((numerator / denominator) as u64)
    }
    // View Functions
    /// Returns the amount of tokens you would receive for the given MOVE amount
    #[view]
    public fun get_token_output_amount(
        move_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
    }
    /// Returns the amount of MOVE you would receive for the given token amount
    #[view]
    public fun get_move_output_amount(
        token_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
    }
    /// Returns the current pool reserves (token_reserve, move_reserve)
    #[view]
    public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        (lp.token_reserve, lp.move_reserve)
    }
}</code>
	<code>module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_MOVE: u64 = 5_000_000_000_000;
    const MOVE_DECIMALS: u8 = 8;
    const MOVE_MULTIPLIER: u64 = 100_000_000; // 10^8 for MOVE decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of MOVE in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_MOVE as u128) / (MOVE_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // MOVE from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register MOVE coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), move_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
    // Swap MOVE for tokens
    public entry fun swap_move_to_token(
        sender: &signer,
        pool: Object<Metadata>,
        move_amount: u64
    ) acquires LiquidityPool {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate output tokens
        let token_out = get_output_amount(
            move_amount,
            lp.move_reserve,
            lp.token_reserve
        );
        assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(pool_addr, move_coins);
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer tokens to user
        primary_fungible_store::transfer(
            &pool_signer,
            lp.token_address,
            signer::address_of(sender),
            token_out
        );
        // Update reserves
        lp.move_reserve = lp.move_reserve + move_amount;
        lp.token_reserve = lp.token_reserve - token_out;
    }
    // Swap tokens for MOVE
    public entry fun swap_token_to_move(
        sender: &signer,
        pool: Object<Metadata>,
        token_amount: u64
    ) acquires LiquidityPool {
        assert!(token_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate MOVE output
        let move_out = get_output_amount(
            token_amount,
            lp.token_reserve,
            lp.move_reserve
        );
        assert!(move_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer tokens to pool
        primary_fungible_store::transfer(
            sender,
            lp.token_address,
            pool_addr,
            token_amount
        );
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer MOVE to user
        coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), move_out);
        // Update reserves
        lp.token_reserve = lp.token_reserve + token_amount;
        lp.move_reserve = lp.move_reserve - move_out;
    }
    // Calculate output amount based on AMM formula
    fun get_output_amount(
        input_amount: u64,
        input_reserve: u64,
        output_reserve: u64
    ): u64 {
        let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
        let numerator = input_amount_with_fee * (output_reserve as u128);
        let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
        ((numerator / denominator) as u64)
    }
    // View Functions
    /// Returns the amount of tokens you would receive for the given MOVE amount
    #[view]
    public fun get_token_output_amount(
        move_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
    }
    /// Returns the amount of MOVE you would receive for the given token amount
    #[view]
    public fun get_move_output_amount(
        token_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
    }
    /// Returns the current pool reserves (token_reserve, move_reserve)
    #[view]
    public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        (lp.token_reserve, lp.move_reserve)
    }
}</code>
	module pump4fun::pump_for_fun {
    use std::string;
    use std::option;
    use std::signer;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::coin::{Self};
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::account::{Self, SignerCapability};
    const DECIMAL: u8 = 8;
    const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
    const FEE: u64 = 10_000_000; // 0.1 APT
    const INITIAL_TOKEN_PER_MOVE: u64 = 5_000_000_000_000;
    const MOVE_DECIMALS: u8 = 8;
    const MOVE_MULTIPLIER: u64 = 100_000_000; // 10^8 for MOVE decimals
    // Error codes
    const INSUFFICIENT_LIQUIDITY: u64 = 1;
    const INVALID_AMOUNT: u64 = 2;
    const ERR_NOT_OWNER: u64 = 3;
    const ERR_ZERO_AMOUNT: u64 = 4;
    const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
    struct AppConfig has key {
        fees: u64,
        admin: address,
    }
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FAController has key {
        dev_address: address,
        mint_ref: MintRef,
        burn_ref: BurnRef,
        transfer_ref: TransferRef,
    }
    struct LiquidityPool has key {
        token_reserve: u64,
        move_reserve: u64,
        token_address: Object<Metadata>,
        owner: address,
        signer_cap: SignerCapability,
    }
    fun init_module(sender: &signer) {
        let admin_addr = signer::address_of(sender);
        move_to(sender, AppConfig {
            fees: FEE,
            admin: admin_addr,
        });
    }
    public entry fun create_token_and_buy(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        icon_uri: string::String,
        project_url: string::String,
        move_amount: u64  // Amount of MOVE in octas (10^8)
    ) acquires AppConfig, FAController {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let app_config = borrow_global<AppConfig>(@pump4fun);
        let admin_addr = app_config.admin;
        let sender_addr = signer::address_of(sender);
        // Collect token creation fee
        let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
        coin::deposit<AptosCoin>(admin_addr, fee_coins);
        // Create new token
        let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
        let object_signer = object::generate_signer(&constructor_ref);
        // Initialize token
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some((MAX_SUPPLY as u128)),
            name,
            symbol,
            DECIMAL,
            icon_uri,
            project_url
        );
        let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        // Setup token controller
        move_to(&object_signer, FAController {
            dev_address: sender_addr,
            mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
            burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
            transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
        });
        // Calculate total tokens to be created
        let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_MOVE as u128) / (MOVE_MULTIPLIER as u128);
        assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128), ERR_MAX_SUPPLY_EXCEEDED);
        // Mint tokens to user
        mint_tokens(sender, fa_obj, (user_token_amount as u64));
        // Create and initialize Liquidity Pool with same amount
        initialize_liquidity_pool(
            sender,
            fa_obj,
            move_amount,  // MOVE from user
            (user_token_amount as u64) // Same amount of tokens for pool
        );
    }
    fun mint_tokens(
        account: &signer,
        token: Object<Metadata>,
        amount: u64,
    ) acquires FAController {
        let token_addr = object::object_address(&token);
        let controller = borrow_global<FAController>(token_addr);
        let fa = fungible_asset::mint(&controller.mint_ref, amount);
        primary_fungible_store::deposit(signer::address_of(account), fa);
    }
    fun initialize_liquidity_pool(
        sender: &signer,
        token: Object<Metadata>,
        move_amount: u64,
        token_amount: u64
    ) acquires FAController {
        let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
        // Register MOVE coin store for pool
        if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
            coin::register<AptosCoin>(&pool_signer);
        };
        // Mint tokens to pool
        mint_tokens(&pool_signer, token, token_amount);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(signer::address_of(&pool_signer), move_coins);
        // Initialize LP
        move_to(&pool_signer, LiquidityPool {
            token_reserve: token_amount,
            move_reserve: move_amount,
            token_address: token,
            owner: signer::address_of(sender),
            signer_cap,
        });
    }
    // Swap MOVE for tokens
    public entry fun swap_move_to_token(
        sender: &signer,
        pool: Object<Metadata>,
        move_amount: u64
    ) acquires LiquidityPool {
        assert!(move_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate output tokens
        let token_out = get_output_amount(
            move_amount,
            lp.move_reserve,
            lp.token_reserve
        );
        assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer MOVE to pool
        let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
        coin::deposit(pool_addr, move_coins);
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer tokens to user
        primary_fungible_store::transfer(
            &pool_signer,
            lp.token_address,
            signer::address_of(sender),
            token_out
        );
        // Update reserves
        lp.move_reserve = lp.move_reserve + move_amount;
        lp.token_reserve = lp.token_reserve - token_out;
    }
    // Swap tokens for MOVE
    public entry fun swap_token_to_move(
        sender: &signer,
        pool: Object<Metadata>,
        token_amount: u64
    ) acquires LiquidityPool {
        assert!(token_amount > 0, ERR_ZERO_AMOUNT);
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global_mut<LiquidityPool>(pool_addr);
        // Calculate MOVE output
        let move_out = get_output_amount(
            token_amount,
            lp.token_reserve,
            lp.move_reserve
        );
        assert!(move_out > 0, INSUFFICIENT_LIQUIDITY);
        // Transfer tokens to pool
        primary_fungible_store::transfer(
            sender,
            lp.token_address,
            pool_addr,
            token_amount
        );
        let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
        // Transfer MOVE to user
        coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), move_out);
        // Update reserves
        lp.token_reserve = lp.token_reserve + token_amount;
        lp.move_reserve = lp.move_reserve - move_out;
    }
    // Calculate output amount based on AMM formula
    fun get_output_amount(
        input_amount: u64,
        input_reserve: u64,
        output_reserve: u64
    ): u64 {
        let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
        let numerator = input_amount_with_fee * (output_reserve as u128);
        let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
        ((numerator / denominator) as u64)
    }
    // View Functions
    /// Returns the amount of tokens you would receive for the given MOVE amount
    #[view]
    public fun get_token_output_amount(
        move_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
    }
    /// Returns the amount of MOVE you would receive for the given token amount
    #[view]
    public fun get_move_output_amount(
        token_amount: u64,
        pool: Object<Metadata>
    ): u64 acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
    }
    /// Returns the current pool reserves (token_reserve, move_reserve)
    #[view]
    public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
        let pool_addr = object::object_address(&pool);
        let lp = borrow_global<LiquidityPool>(pool_addr);
        (lp.token_reserve, lp.move_reserve)
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/04-lending-and-borrowing
Lending & Borrowing
Lending & Borrowing
Start
Start
What is lending & borrowing in Web3 domain?
Start
The types of Lending Pool
Start
Initialize Wrap Coin
Start
Utils & Errors Handling
Start
Initialize & Managed Lending Pool
Start
What is lending & borrowing in Web3 domain?
Start
What is lending & borrowing in Web3 domain?
Start
What is lending & borrowing in Web3 domain?
What is lending & borrowing in Web3 domain?
Start
Start
The types of Lending Pool
Start
The types of Lending Pool
Start
The types of Lending Pool
The types of Lending Pool
Start
Start
Initialize Wrap Coin
Start
Initialize Wrap Coin
Start
Initialize Wrap Coin
Initialize Wrap Coin
Start
Start
Utils & Errors Handling
Start
Utils & Errors Handling
Start
Utils & Errors Handling
Utils & Errors Handling
Start
Start
Initialize & Managed Lending Pool
Start
Initialize & Managed Lending Pool
Start
Initialize & Managed Lending Pool
Initialize & Managed Lending Pool
Start
Start

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/04-lending-and-borrowing/01-what-is-lending-and-borrowing-in-web3-domain
What is lending & borrowing in Web3 domain?
What is lending & borrowing in Web3 domain?
On This Page
Overview
Multiple Liquidity Pools
Detailed Operating Mechanism
1. Creating the Liquidity Pools
2. Borrowing Process
3. During the Loan Period
4. Loan Completion
Common Use Cases
1. Borrowing for Investment (Leverage)
2. Borrowing for Payments
3. Lending for Passive Income
Overview
DeFi Lending & Borrowing is a fully automated cryptocurrency lending and borrowing system that operates on the blockchain. Let's understand in detail how it works through specific examples.
Multiple Liquidity Pools
Modern DeFi platforms typically offer multiple liquidity pools for different cryptocurrencies. Users can choose to lend or borrow various assets like USDT, ETH, BTC, and other supported tokens. Each pool operates independently with its own:
Interest rates based on supply and demand
Collateral requirements and ratios
Total liquidity and utilization rates
Detailed Operating Mechanism
Let's look at examples across different pools:
1. Creating the Liquidity Pools
Alice can deposit different assets into various pools:
1000 USDT into the USDT pool
10 ETH into the ETH pool
0.5 BTC into the BTC pool
2. Borrowing Process
Bob can borrow from any available pool based on his needs
He can use ETH as collateral to borrow USDT (cross-collateral)
Or use BTC to borrow ETH, and so on
Each pool has its own collateral ratio requirements
3. During the Loan Period
Interest rates vary between different pools
Each pool has its own minimum collateral ratio
If collateral value drops below the safe ratio, Bob must:
Add more collateral, or
Repay part of the loan to maintain the safe ratio
4. Loan Completion
Bob repays the borrowed amount + interest
The smart contract automatically returns the collateralized assets
Lenders receive their share of interest based on their contribution to the pool
Common Use Cases
1. Borrowing for Investment (Leverage)
Bob believes ETH price will increase. Instead of selling ETH, Bob collateralizes ETH to borrow USDT and buy more ETH.
2. Borrowing for Payments
Carol urgently needs USDT but doesn't want to sell BTC. She can collateralize BTC to borrow USDT, then repay when she has the money.
3. Lending for Passive Income
Alice wants to generate income from her crypto holdings. She can distribute her assets across different pools to optimize returns and diversify risk.
In the following articles, we will learn how to build a simple smart contract to implement the basic functions of a multi-pool lending platform like this.
On This Page
Overview
Multiple Liquidity Pools
Detailed Operating Mechanism
1. Creating the Liquidity Pools
2. Borrowing Process
3. During the Loan Period
4. Loan Completion
Common Use Cases
1. Borrowing for Investment (Leverage)
2. Borrowing for Payments
3. Lending for Passive Income
On This Page
Overview
Multiple Liquidity Pools
Detailed Operating Mechanism
1. Creating the Liquidity Pools
2. Borrowing Process
3. During the Loan Period
4. Loan Completion
Common Use Cases
1. Borrowing for Investment (Leverage)
2. Borrowing for Payments
3. Lending for Passive Income
			On This Page
			On This Page
			Overview
Multiple Liquidity Pools
Detailed Operating Mechanism
1. Creating the Liquidity Pools
2. Borrowing Process
3. During the Loan Period
4. Loan Completion
Common Use Cases
1. Borrowing for Investment (Leverage)
2. Borrowing for Payments
3. Lending for Passive Income
			Overview
			Overview
			Overview
			Overview
			Multiple Liquidity Pools
			Multiple Liquidity Pools
			Multiple Liquidity Pools
			Multiple Liquidity Pools
			Detailed Operating Mechanism
1. Creating the Liquidity Pools
2. Borrowing Process
3. During the Loan Period
4. Loan Completion
			Detailed Operating Mechanism
			Detailed Operating Mechanism
			Detailed Operating Mechanism
			1. Creating the Liquidity Pools
2. Borrowing Process
3. During the Loan Period
4. Loan Completion
			1. Creating the Liquidity Pools
			1. Creating the Liquidity Pools
			1. Creating the Liquidity Pools
			1. Creating the Liquidity Pools
			2. Borrowing Process
			2. Borrowing Process
			2. Borrowing Process
			2. Borrowing Process
			3. During the Loan Period
			3. During the Loan Period
			3. During the Loan Period
			3. During the Loan Period
			4. Loan Completion
			4. Loan Completion
			4. Loan Completion
			4. Loan Completion
			Common Use Cases
1. Borrowing for Investment (Leverage)
2. Borrowing for Payments
3. Lending for Passive Income
			Common Use Cases
			Common Use Cases
			Common Use Cases
			1. Borrowing for Investment (Leverage)
2. Borrowing for Payments
3. Lending for Passive Income
			1. Borrowing for Investment (Leverage)
			1. Borrowing for Investment (Leverage)
			1. Borrowing for Investment (Leverage)
			1. Borrowing for Investment (Leverage)
			2. Borrowing for Payments
			2. Borrowing for Payments
			2. Borrowing for Payments
			2. Borrowing for Payments
			3. Lending for Passive Income
			3. Lending for Passive Income
			3. Lending for Passive Income
			3. Lending for Passive Income
			Overview
DeFi Lending & Borrowing is a fully automated cryptocurrency lending and borrowing system that operates on the blockchain. Let's understand in detail how it works through specific examples.
Multiple Liquidity Pools
Modern DeFi platforms typically offer multiple liquidity pools for different cryptocurrencies. Users can choose to lend or borrow various assets like USDT, ETH, BTC, and other supported tokens. Each pool operates independently with its own:
Interest rates based on supply and demand
Collateral requirements and ratios
Total liquidity and utilization rates
Detailed Operating Mechanism
Let's look at examples across different pools:
1. Creating the Liquidity Pools
Alice can deposit different assets into various pools:
1000 USDT into the USDT pool
10 ETH into the ETH pool
0.5 BTC into the BTC pool
2. Borrowing Process
Bob can borrow from any available pool based on his needs
He can use ETH as collateral to borrow USDT (cross-collateral)
Or use BTC to borrow ETH, and so on
Each pool has its own collateral ratio requirements
3. During the Loan Period
Interest rates vary between different pools
Each pool has its own minimum collateral ratio
If collateral value drops below the safe ratio, Bob must:
Add more collateral, or
Repay part of the loan to maintain the safe ratio
4. Loan Completion
Bob repays the borrowed amount + interest
The smart contract automatically returns the collateralized assets
Lenders receive their share of interest based on their contribution to the pool
Common Use Cases
1. Borrowing for Investment (Leverage)
Bob believes ETH price will increase. Instead of selling ETH, Bob collateralizes ETH to borrow USDT and buy more ETH.
2. Borrowing for Payments
Carol urgently needs USDT but doesn't want to sell BTC. She can collateralize BTC to borrow USDT, then repay when she has the money.
3. Lending for Passive Income
Alice wants to generate income from her crypto holdings. She can distribute her assets across different pools to optimize returns and diversify risk.
In the following articles, we will learn how to build a simple smart contract to implement the basic functions of a multi-pool lending platform like this.
			Overview
DeFi Lending & Borrowing is a fully automated cryptocurrency lending and borrowing system that operates on the blockchain. Let's understand in detail how it works through specific examples.
Multiple Liquidity Pools
Modern DeFi platforms typically offer multiple liquidity pools for different cryptocurrencies. Users can choose to lend or borrow various assets like USDT, ETH, BTC, and other supported tokens. Each pool operates independently with its own:
Interest rates based on supply and demand
Collateral requirements and ratios
Total liquidity and utilization rates
Detailed Operating Mechanism
Let's look at examples across different pools:
1. Creating the Liquidity Pools
Alice can deposit different assets into various pools:
1000 USDT into the USDT pool
10 ETH into the ETH pool
0.5 BTC into the BTC pool
2. Borrowing Process
Bob can borrow from any available pool based on his needs
He can use ETH as collateral to borrow USDT (cross-collateral)
Or use BTC to borrow ETH, and so on
Each pool has its own collateral ratio requirements
3. During the Loan Period
Interest rates vary between different pools
Each pool has its own minimum collateral ratio
If collateral value drops below the safe ratio, Bob must:
Add more collateral, or
Repay part of the loan to maintain the safe ratio
4. Loan Completion
Bob repays the borrowed amount + interest
The smart contract automatically returns the collateralized assets
Lenders receive their share of interest based on their contribution to the pool
Common Use Cases
1. Borrowing for Investment (Leverage)
Bob believes ETH price will increase. Instead of selling ETH, Bob collateralizes ETH to borrow USDT and buy more ETH.
2. Borrowing for Payments
Carol urgently needs USDT but doesn't want to sell BTC. She can collateralize BTC to borrow USDT, then repay when she has the money.
3. Lending for Passive Income
Alice wants to generate income from her crypto holdings. She can distribute her assets across different pools to optimize returns and diversify risk.
In the following articles, we will learn how to build a simple smart contract to implement the basic functions of a multi-pool lending platform like this.
			Overview
DeFi Lending & Borrowing is a fully automated cryptocurrency lending and borrowing system that operates on the blockchain. Let's understand in detail how it works through specific examples.
Multiple Liquidity Pools
Modern DeFi platforms typically offer multiple liquidity pools for different cryptocurrencies. Users can choose to lend or borrow various assets like USDT, ETH, BTC, and other supported tokens. Each pool operates independently with its own:
Interest rates based on supply and demand
Collateral requirements and ratios
Total liquidity and utilization rates
Detailed Operating Mechanism
Let's look at examples across different pools:
1. Creating the Liquidity Pools
Alice can deposit different assets into various pools:
1000 USDT into the USDT pool
10 ETH into the ETH pool
0.5 BTC into the BTC pool
2. Borrowing Process
Bob can borrow from any available pool based on his needs
He can use ETH as collateral to borrow USDT (cross-collateral)
Or use BTC to borrow ETH, and so on
Each pool has its own collateral ratio requirements
3. During the Loan Period
Interest rates vary between different pools
Each pool has its own minimum collateral ratio
If collateral value drops below the safe ratio, Bob must:
Add more collateral, or
Repay part of the loan to maintain the safe ratio
4. Loan Completion
Bob repays the borrowed amount + interest
The smart contract automatically returns the collateralized assets
Lenders receive their share of interest based on their contribution to the pool
Common Use Cases
1. Borrowing for Investment (Leverage)
Bob believes ETH price will increase. Instead of selling ETH, Bob collateralizes ETH to borrow USDT and buy more ETH.
2. Borrowing for Payments
Carol urgently needs USDT but doesn't want to sell BTC. She can collateralize BTC to borrow USDT, then repay when she has the money.
3. Lending for Passive Income
Alice wants to generate income from her crypto holdings. She can distribute her assets across different pools to optimize returns and diversify risk.
In the following articles, we will learn how to build a simple smart contract to implement the basic functions of a multi-pool lending platform like this.
		Overview
		Overview
		DeFi Lending & Borrowing is a fully automated cryptocurrency lending and borrowing system that operates on the blockchain. Let's understand in detail how it works through specific examples.
		DeFi Lending & Borrowing is a fully automated cryptocurrency lending and borrowing system that operates on the blockchain. Let's understand in detail how it works through specific examples.
	Multiple Liquidity Pools
	Multiple Liquidity Pools
	Modern DeFi platforms typically offer multiple liquidity pools for different cryptocurrencies. Users can choose to lend or borrow various assets like USDT, ETH, BTC, and other supported tokens. Each pool operates independently with its own:
	Modern DeFi platforms typically offer multiple liquidity pools for different cryptocurrencies. Users can choose to lend or borrow various assets like USDT, ETH, BTC, and other supported tokens. Each pool operates independently with its own:
	Interest rates based on supply and demand
Collateral requirements and ratios
Total liquidity and utilization rates
	Interest rates based on supply and demand
	Interest rates based on supply and demand
	Collateral requirements and ratios
	Collateral requirements and ratios
	Total liquidity and utilization rates
	Total liquidity and utilization rates
	Detailed Operating Mechanism
	Detailed Operating Mechanism
	Let's look at examples across different pools:
	Let's look at examples across different pools:
		1. Creating the Liquidity Pools
		1. Creating the Liquidity Pools
		Alice can deposit different assets into various pools:
		Alice can deposit different assets into various pools:
		1000 USDT into the USDT pool
10 ETH into the ETH pool
0.5 BTC into the BTC pool
		1000 USDT into the USDT pool
		1000 USDT into the USDT pool
		10 ETH into the ETH pool
		10 ETH into the ETH pool
		0.5 BTC into the BTC pool
		0.5 BTC into the BTC pool
		2. Borrowing Process
		2. Borrowing Process
		Bob can borrow from any available pool based on his needs
He can use ETH as collateral to borrow USDT (cross-collateral)
Or use BTC to borrow ETH, and so on
Each pool has its own collateral ratio requirements
		Bob can borrow from any available pool based on his needs
		Bob can borrow from any available pool based on his needs
		He can use ETH as collateral to borrow USDT (cross-collateral)
		He can use ETH as collateral to borrow USDT (cross-collateral)
		Or use BTC to borrow ETH, and so on
		Or use BTC to borrow ETH, and so on
		Each pool has its own collateral ratio requirements
		Each pool has its own collateral ratio requirements
		3. During the Loan Period
		3. During the Loan Period
		Interest rates vary between different pools
Each pool has its own minimum collateral ratio
If collateral value drops below the safe ratio, Bob must:
Add more collateral, or
Repay part of the loan to maintain the safe ratio
		Interest rates vary between different pools
		Interest rates vary between different pools
		Each pool has its own minimum collateral ratio
		Each pool has its own minimum collateral ratio
		If collateral value drops below the safe ratio, Bob must:
		If collateral value drops below the safe ratio, Bob must:
		Add more collateral, or
		Add more collateral, or
		Repay part of the loan to maintain the safe ratio
		Repay part of the loan to maintain the safe ratio
		4. Loan Completion
		4. Loan Completion
		Bob repays the borrowed amount + interest
The smart contract automatically returns the collateralized assets
Lenders receive their share of interest based on their contribution to the pool
		Bob repays the borrowed amount + interest
		Bob repays the borrowed amount + interest
		The smart contract automatically returns the collateralized assets
		The smart contract automatically returns the collateralized assets
		Lenders receive their share of interest based on their contribution to the pool
		Lenders receive their share of interest based on their contribution to the pool
	Common Use Cases
	Common Use Cases
		1. Borrowing for Investment (Leverage)
		1. Borrowing for Investment (Leverage)
		Bob believes ETH price will increase. Instead of selling ETH, Bob collateralizes ETH to borrow USDT and buy more ETH.
		Bob believes ETH price will increase. Instead of selling ETH, Bob collateralizes ETH to borrow USDT and buy more ETH.
		2. Borrowing for Payments
		2. Borrowing for Payments
		Carol urgently needs USDT but doesn't want to sell BTC. She can collateralize BTC to borrow USDT, then repay when she has the money.
		Carol urgently needs USDT but doesn't want to sell BTC. She can collateralize BTC to borrow USDT, then repay when she has the money.
		3. Lending for Passive Income
		3. Lending for Passive Income
		Alice wants to generate income from her crypto holdings. She can distribute her assets across different pools to optimize returns and diversify risk.
		Alice wants to generate income from her crypto holdings. She can distribute her assets across different pools to optimize returns and diversify risk.
		In the following articles, we will learn how to build a simple smart contract to implement the basic functions of a multi-pool lending platform like this.
		In the following articles, we will learn how to build a simple smart contract to implement the basic functions of a multi-pool lending platform like this.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/04-lending-and-borrowing/02-the-types-of-lending-pool
The types of Lending Pool
The types of Lending Pool
On This Page
Understanding Lending Pools and Guide to Building a DeFi Lending Platform
Overview
What is a Lending Pool?
Common Types of Lending Pools
1. Main Pool - Basic Pool
2. Isolated Pool - Independent Pool
3. Leverage Pool
Important Considerations When Designing Lending Pools
Understanding Lending Pools and Guide to Building a DeFi Lending Platform
Overview
In this series of articles, we will dive deep into understanding and building a decentralized lending platform (DeFi Lending Platform). Before we start coding, we need to understand the basic concepts of Lending Pools and how they work.
What is a Lending Pool?
A Lending Pool is a liquidity pool where users can deposit tokens for lending, and others can borrow these tokens. This is the foundation of DeFi lending applications like Aave, Compound.
Common Types of Lending Pools
1. Main Pool - Basic Pool
This is the most common type of pool in DeFi, with these characteristics:
Users can deposit multiple types of tokens
Uses an overcollateralized lending model
Interest rates are automatically calculated based on supply and demand
Collateral ratio typically ranges from 50-75% for security
2. Isolated Pool - Independent Pool
This type of pool is designed to minimize risk:
Each pool supports only a specific token pair
Risks are isolated, not affecting other pools
Suitable for new tokens or high-risk assets
Parameters like collateral ratio and interest rates can be customized
3. Leverage Pool
This pool is designed for professional traders:
Allows high leverage borrowing (up to 10x)
Direct integration with DEX
Has automatic liquidation mechanisms to protect the pool
Suitable for complex trading strategies
Important Considerations When Designing Lending Pools
| Factor | Main Pool | Isolated Pool | Leverage Pool |
| --- | --- | --- | --- |
| Risk Level | Medium | Low | High |
| Collateral Ratio | 50-75% | Customizable | 10-50% |
| Complexity | Low | Medium | High |
In the following articles, we will delve into implementing each type of pool, starting with the Main Pool - the most basic type. We will learn how to design smart contracts, handle interest rate calculations, and implement necessary security mechanisms.
On This Page
Understanding Lending Pools and Guide to Building a DeFi Lending Platform
Overview
What is a Lending Pool?
Common Types of Lending Pools
1. Main Pool - Basic Pool
2. Isolated Pool - Independent Pool
3. Leverage Pool
Important Considerations When Designing Lending Pools
On This Page
Understanding Lending Pools and Guide to Building a DeFi Lending Platform
Overview
What is a Lending Pool?
Common Types of Lending Pools
1. Main Pool - Basic Pool
2. Isolated Pool - Independent Pool
3. Leverage Pool
Important Considerations When Designing Lending Pools
			On This Page
			On This Page
			Understanding Lending Pools and Guide to Building a DeFi Lending Platform
Overview
What is a Lending Pool?
Common Types of Lending Pools
1. Main Pool - Basic Pool
2. Isolated Pool - Independent Pool
3. Leverage Pool
Important Considerations When Designing Lending Pools
			Understanding Lending Pools and Guide to Building a DeFi Lending Platform
Overview
			Understanding Lending Pools and Guide to Building a DeFi Lending Platform
			Understanding Lending Pools and Guide to Building a DeFi Lending Platform
			Understanding Lending Pools and Guide to Building a DeFi Lending Platform
			Overview
			Overview
			Overview
			Overview
			Overview
			What is a Lending Pool?
			What is a Lending Pool?
			What is a Lending Pool?
			What is a Lending Pool?
			Common Types of Lending Pools
1. Main Pool - Basic Pool
2. Isolated Pool - Independent Pool
3. Leverage Pool
			Common Types of Lending Pools
			Common Types of Lending Pools
			Common Types of Lending Pools
			1. Main Pool - Basic Pool
2. Isolated Pool - Independent Pool
3. Leverage Pool
			1. Main Pool - Basic Pool
			1. Main Pool - Basic Pool
			1. Main Pool - Basic Pool
			1. Main Pool - Basic Pool
			2. Isolated Pool - Independent Pool
			2. Isolated Pool - Independent Pool
			2. Isolated Pool - Independent Pool
			2. Isolated Pool - Independent Pool
			3. Leverage Pool
			3. Leverage Pool
			3. Leverage Pool
			3. Leverage Pool
			Important Considerations When Designing Lending Pools
			Important Considerations When Designing Lending Pools
			Important Considerations When Designing Lending Pools
			Important Considerations When Designing Lending Pools
			Understanding Lending Pools and Guide to Building a DeFi Lending Platform
Overview
In this series of articles, we will dive deep into understanding and building a decentralized lending platform (DeFi Lending Platform). Before we start coding, we need to understand the basic concepts of Lending Pools and how they work.
What is a Lending Pool?
A Lending Pool is a liquidity pool where users can deposit tokens for lending, and others can borrow these tokens. This is the foundation of DeFi lending applications like Aave, Compound.
Common Types of Lending Pools
1. Main Pool - Basic Pool
This is the most common type of pool in DeFi, with these characteristics:
Users can deposit multiple types of tokens
Uses an overcollateralized lending model
Interest rates are automatically calculated based on supply and demand
Collateral ratio typically ranges from 50-75% for security
2. Isolated Pool - Independent Pool
This type of pool is designed to minimize risk:
Each pool supports only a specific token pair
Risks are isolated, not affecting other pools
Suitable for new tokens or high-risk assets
Parameters like collateral ratio and interest rates can be customized
3. Leverage Pool
This pool is designed for professional traders:
Allows high leverage borrowing (up to 10x)
Direct integration with DEX
Has automatic liquidation mechanisms to protect the pool
Suitable for complex trading strategies
Important Considerations When Designing Lending Pools
| Factor | Main Pool | Isolated Pool | Leverage Pool |
| --- | --- | --- | --- |
| Risk Level | Medium | Low | High |
| Collateral Ratio | 50-75% | Customizable | 10-50% |
| Complexity | Low | Medium | High |
In the following articles, we will delve into implementing each type of pool, starting with the Main Pool - the most basic type. We will learn how to design smart contracts, handle interest rate calculations, and implement necessary security mechanisms.
			Understanding Lending Pools and Guide to Building a DeFi Lending Platform
Overview
In this series of articles, we will dive deep into understanding and building a decentralized lending platform (DeFi Lending Platform). Before we start coding, we need to understand the basic concepts of Lending Pools and how they work.
What is a Lending Pool?
A Lending Pool is a liquidity pool where users can deposit tokens for lending, and others can borrow these tokens. This is the foundation of DeFi lending applications like Aave, Compound.
Common Types of Lending Pools
1. Main Pool - Basic Pool
This is the most common type of pool in DeFi, with these characteristics:
Users can deposit multiple types of tokens
Uses an overcollateralized lending model
Interest rates are automatically calculated based on supply and demand
Collateral ratio typically ranges from 50-75% for security
2. Isolated Pool - Independent Pool
This type of pool is designed to minimize risk:
Each pool supports only a specific token pair
Risks are isolated, not affecting other pools
Suitable for new tokens or high-risk assets
Parameters like collateral ratio and interest rates can be customized
3. Leverage Pool
This pool is designed for professional traders:
Allows high leverage borrowing (up to 10x)
Direct integration with DEX
Has automatic liquidation mechanisms to protect the pool
Suitable for complex trading strategies
Important Considerations When Designing Lending Pools
| Factor | Main Pool | Isolated Pool | Leverage Pool |
| --- | --- | --- | --- |
| Risk Level | Medium | Low | High |
| Collateral Ratio | 50-75% | Customizable | 10-50% |
| Complexity | Low | Medium | High |
In the following articles, we will delve into implementing each type of pool, starting with the Main Pool - the most basic type. We will learn how to design smart contracts, handle interest rate calculations, and implement necessary security mechanisms.
			Understanding Lending Pools and Guide to Building a DeFi Lending Platform
Overview
In this series of articles, we will dive deep into understanding and building a decentralized lending platform (DeFi Lending Platform). Before we start coding, we need to understand the basic concepts of Lending Pools and how they work.
What is a Lending Pool?
A Lending Pool is a liquidity pool where users can deposit tokens for lending, and others can borrow these tokens. This is the foundation of DeFi lending applications like Aave, Compound.
Common Types of Lending Pools
1. Main Pool - Basic Pool
This is the most common type of pool in DeFi, with these characteristics:
Users can deposit multiple types of tokens
Uses an overcollateralized lending model
Interest rates are automatically calculated based on supply and demand
Collateral ratio typically ranges from 50-75% for security
2. Isolated Pool - Independent Pool
This type of pool is designed to minimize risk:
Each pool supports only a specific token pair
Risks are isolated, not affecting other pools
Suitable for new tokens or high-risk assets
Parameters like collateral ratio and interest rates can be customized
3. Leverage Pool
This pool is designed for professional traders:
Allows high leverage borrowing (up to 10x)
Direct integration with DEX
Has automatic liquidation mechanisms to protect the pool
Suitable for complex trading strategies
Important Considerations When Designing Lending Pools
| Factor | Main Pool | Isolated Pool | Leverage Pool |
| --- | --- | --- | --- |
| Risk Level | Medium | Low | High |
| Collateral Ratio | 50-75% | Customizable | 10-50% |
| Complexity | Low | Medium | High |
In the following articles, we will delve into implementing each type of pool, starting with the Main Pool - the most basic type. We will learn how to design smart contracts, handle interest rate calculations, and implement necessary security mechanisms.
	Understanding Lending Pools and Guide to Building a DeFi Lending Platform
	Understanding Lending Pools and Guide to Building a DeFi Lending Platform
		Overview
		Overview
		In this series of articles, we will dive deep into understanding and building a decentralized lending platform (DeFi Lending Platform). Before we start coding, we need to understand the basic concepts of Lending Pools and how they work.
		In this series of articles, we will dive deep into understanding and building a decentralized lending platform (DeFi Lending Platform). Before we start coding, we need to understand the basic concepts of Lending Pools and how they work.
	What is a Lending Pool?
	What is a Lending Pool?
	A Lending Pool is a liquidity pool where users can deposit tokens for lending, and others can borrow these tokens. This is the foundation of DeFi lending applications like Aave, Compound.
	A Lending Pool is a liquidity pool where users can deposit tokens for lending, and others can borrow these tokens. This is the foundation of DeFi lending applications like Aave, Compound.
	Common Types of Lending Pools
	Common Types of Lending Pools
		1. Main Pool - Basic Pool
		1. Main Pool - Basic Pool
		This is the most common type of pool in DeFi, with these characteristics:
		This is the most common type of pool in DeFi, with these characteristics:
		Users can deposit multiple types of tokens
Uses an overcollateralized lending model
Interest rates are automatically calculated based on supply and demand
Collateral ratio typically ranges from 50-75% for security
		Users can deposit multiple types of tokens
		Users can deposit multiple types of tokens
		Uses an overcollateralized lending model
		Uses an overcollateralized lending model
		Interest rates are automatically calculated based on supply and demand
		Interest rates are automatically calculated based on supply and demand
		Collateral ratio typically ranges from 50-75% for security
		Collateral ratio typically ranges from 50-75% for security
		2. Isolated Pool - Independent Pool
		2. Isolated Pool - Independent Pool
		This type of pool is designed to minimize risk:
		This type of pool is designed to minimize risk:
		Each pool supports only a specific token pair
Risks are isolated, not affecting other pools
Suitable for new tokens or high-risk assets
Parameters like collateral ratio and interest rates can be customized
		Each pool supports only a specific token pair
		Each pool supports only a specific token pair
		Risks are isolated, not affecting other pools
		Risks are isolated, not affecting other pools
		Suitable for new tokens or high-risk assets
		Suitable for new tokens or high-risk assets
		Parameters like collateral ratio and interest rates can be customized
		Parameters like collateral ratio and interest rates can be customized
		3. Leverage Pool
		3. Leverage Pool
		This pool is designed for professional traders:
		This pool is designed for professional traders:
		Allows high leverage borrowing (up to 10x)
Direct integration with DEX
Has automatic liquidation mechanisms to protect the pool
Suitable for complex trading strategies
		Allows high leverage borrowing (up to 10x)
		Allows high leverage borrowing (up to 10x)
		Direct integration with DEX
		Direct integration with DEX
		Has automatic liquidation mechanisms to protect the pool
		Has automatic liquidation mechanisms to protect the pool
		Suitable for complex trading strategies
		Suitable for complex trading strategies
	Important Considerations When Designing Lending Pools
	Important Considerations When Designing Lending Pools
	| Factor | Main Pool | Isolated Pool | Leverage Pool |
| --- | --- | --- | --- |
| Risk Level | Medium | Low | High |
| Collateral Ratio | 50-75% | Customizable | 10-50% |
| Complexity | Low | Medium | High |
	| Factor | Main Pool | Isolated Pool | Leverage Pool |
| --- | --- | --- | --- |
| Risk Level | Medium | Low | High |
| Collateral Ratio | 50-75% | Customizable | 10-50% |
| Complexity | Low | Medium | High |
	In the following articles, we will delve into implementing each type of pool, starting with the Main Pool - the most basic type. We will learn how to design smart contracts, handle interest rate calculations, and implement necessary security mechanisms.
	In the following articles, we will delve into implementing each type of pool, starting with the Main Pool - the most basic type. We will learn how to design smart contracts, handle interest rate calculations, and implement necessary security mechanisms.

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/04-lending-and-borrowing/03-initialize-wrap-coin
Initialize Wrap Coin
Initialize Wrap Coin
On This Page
What is Wrap Coin?
Overview
How it Works
Role in Lending & Borrowing
Risks to Consider
Overview
Module Structure
Structs
Token Types
Capability Struct
Functions
Initialize Function
Mint Function
Role in Lending Platform
Usage Example
Full Code
What is Wrap Coin?
Overview
A wrapped coin is a cryptocurrency token issued on a blockchain that is backed one-to-one by another cryptocurrency. The most common examples are WETH (Wrapped ETH) and WBTC (Wrapped Bitcoin).
How it Works
Wrapping process:
Users send their original cryptocurrency to a specialized smart contract (custodian), which then issues an equivalent amount of wrapped tokens.
1:1 ratio:
One WETH equals one ETH, one WBTC equals one BTC. This ratio remains constant.
Unwrap:
Users can exchange their wrapped tokens back to receive the original coins at any time.
Role in Lending & Borrowing
Wrapped coins serve an essential function in decentralized lending platforms (DeFi lending platforms):
Compatibility:
Wrapped tokens enable coins from one blockchain to be used on another blockchain. For example: WBTC allows Bitcoin usage on Ethereum DeFi.
Flexible collateral:
Users can use wrapped tokens as collateral to borrow other tokens.
Yield farming:
Wrapped tokens can be used in farming strategies to generate additional profits.
Risks to Consider
Risks from smart contracts managing wrapped tokens
Dependence on custodians holding the original assets
Gas fees for wrapping/unwrapping tokens
Wrapped coins are a vital tool in the DeFi ecosystem, especially in lending and borrowing, enhancing flexibility and efficiency for decentralized financial transactions.
Overview
Module
movement::all_tokens
is an important part of the lending platform, responsible for managing and initializing tokens used in the lending system. This module allows:
Initialization of new tokens (like WBTC, WETH)
Management of token minting
Setting up limits and control permissions
Module Structure
Structs
Token Types
struct WBTC has key, store {}
struct WETH has key, store {}
Represents the types of wrapped tokens (WBTC, WETH)
Has
key
and
store
abilities for storage and transfer capabilities
Capability Struct
struct Cap<phantom CoinType> has key {
    mint_cap: coin::MintCapability<CoinType>,
    freeze_cap: coin::FreezeCapability<CoinType>,
    burn_cap: coin::BurnCapability<CoinType>,
}
Manages capabilities for each token type
Generic type allows use with different token types
Includes mint, freeze, and burn token capabilities
Functions
Initialize Function
public entry fun intialize<CoinType>(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    decimals: u8,
    monitor_supply: bool
)
Purpose:
Initialize a new token type in the system
Only admin has permission to execute
Create and store token capabilities
Implementation steps:
Verify caller is admin
Register token for caller
Initialize token with basic parameters
Store capabilities in storage
Mint Function
public fun mint<CoinType>(
    sender: &signer,
    amount: u64
)
Purpose:
Create (mint) a quantity of tokens for an address
Ensure mint limits and register tokens for recipient
Implementation steps:
Check mint amount doesn't exceed MAX_PER_MINT
Get mint capability from admin address
Mint new tokens
Check and register token for recipient if needed
Transfer minted tokens to recipient's account
Role in Lending Platform
Token Management:
Serves as the foundation for creating and managing tokens used in the platform
Security:
Ensures only admin can initialize tokens and manage capabilities
Supply Control:
Limits the amount of tokens minted each time to ensure safety
Automation:
Automatically registers tokens for users when necessary
Usage Example
// Initialize WBTC token
intialize<WBTC>(
    admin_signer,
    string::utf8(b"Wrapped Bitcoin"),
    string::utf8(b"WBTC"),
    8,
    true
);
// Mint WBTC for an address
mint<WBTC>(user_signer, 50_000);
Full Code
module movement::all_tokens {
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    use std::string;
    use movement::errors;
    use movement::utils;
    // Constants
    const MAX_PER_MINT: u64 = 100_000;
    struct WBTC has key, store {}
    struct WETH has key, store {}
    struct Cap<phantom CoinType> has key {
        mint_cap: coin::MintCapability<CoinType>,
        freeze_cap: coin::FreezeCapability<CoinType>,
        burn_cap: coin::BurnCapability<CoinType>,
    }
    public entry fun intialize<CoinType>(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        decimals: u8,
        monitor_supply: bool
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        managed_coin::register<CoinType>(sender);
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<CoinType>(
            sender,
            name,
            symbol,
            decimals,
            monitor_supply
        );
        move_to(sender, Cap<CoinType>{
            mint_cap,
            freeze_cap,
            burn_cap
        });
    }
    public fun mint<CoinType>(
        sender: &signer,
        amount: u64
    ) acquires Cap {
        assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
        let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
        let minted_coins = coin::mint<CoinType>(amount, &cap.mint_cap);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), minted_coins);
    }
}
On This Page
What is Wrap Coin?
Overview
How it Works
Role in Lending & Borrowing
Risks to Consider
Overview
Module Structure
Structs
Token Types
Capability Struct
Functions
Initialize Function
Mint Function
Role in Lending Platform
Usage Example
Full Code
On This Page
What is Wrap Coin?
Overview
How it Works
Role in Lending & Borrowing
Risks to Consider
Overview
Module Structure
Structs
Token Types
Capability Struct
Functions
Initialize Function
Mint Function
Role in Lending Platform
Usage Example
Full Code
			On This Page
			On This Page
			What is Wrap Coin?
Overview
How it Works
Role in Lending & Borrowing
Risks to Consider
Overview
Module Structure
Structs
Token Types
Capability Struct
Functions
Initialize Function
Mint Function
Role in Lending Platform
Usage Example
Full Code
			What is Wrap Coin?
Overview
			What is Wrap Coin?
			What is Wrap Coin?
			What is Wrap Coin?
			Overview
			Overview
			Overview
			Overview
			Overview
			How it Works
			How it Works
			How it Works
			How it Works
			Role in Lending & Borrowing
			Role in Lending & Borrowing
			Role in Lending & Borrowing
			Role in Lending & Borrowing
			Risks to Consider
			Risks to Consider
			Risks to Consider
			Risks to Consider
			Overview
			Overview
			Overview
			Overview
			Module Structure
Structs
Token Types
Capability Struct
			Module Structure
			Module Structure
			Module Structure
			Structs
Token Types
Capability Struct
			Structs
			Structs
			Structs
			Structs
			Token Types
			Token Types
			Token Types
			Token Types
			Capability Struct
			Capability Struct
			Capability Struct
			Capability Struct
			Functions
Initialize Function
Mint Function
			Functions
			Functions
			Functions
			Initialize Function
Mint Function
			Initialize Function
			Initialize Function
			Initialize Function
			Initialize Function
			Mint Function
			Mint Function
			Mint Function
			Mint Function
			Role in Lending Platform
			Role in Lending Platform
			Role in Lending Platform
			Role in Lending Platform
			Usage Example
			Usage Example
			Usage Example
			Usage Example
			Full Code
			Full Code
			Full Code
			Full Code
			What is Wrap Coin?
Overview
A wrapped coin is a cryptocurrency token issued on a blockchain that is backed one-to-one by another cryptocurrency. The most common examples are WETH (Wrapped ETH) and WBTC (Wrapped Bitcoin).
How it Works
Wrapping process:
Users send their original cryptocurrency to a specialized smart contract (custodian), which then issues an equivalent amount of wrapped tokens.
1:1 ratio:
One WETH equals one ETH, one WBTC equals one BTC. This ratio remains constant.
Unwrap:
Users can exchange their wrapped tokens back to receive the original coins at any time.
Role in Lending & Borrowing
Wrapped coins serve an essential function in decentralized lending platforms (DeFi lending platforms):
Compatibility:
Wrapped tokens enable coins from one blockchain to be used on another blockchain. For example: WBTC allows Bitcoin usage on Ethereum DeFi.
Flexible collateral:
Users can use wrapped tokens as collateral to borrow other tokens.
Yield farming:
Wrapped tokens can be used in farming strategies to generate additional profits.
Risks to Consider
Risks from smart contracts managing wrapped tokens
Dependence on custodians holding the original assets
Gas fees for wrapping/unwrapping tokens
Wrapped coins are a vital tool in the DeFi ecosystem, especially in lending and borrowing, enhancing flexibility and efficiency for decentralized financial transactions.
Overview
Module
movement::all_tokens
is an important part of the lending platform, responsible for managing and initializing tokens used in the lending system. This module allows:
Initialization of new tokens (like WBTC, WETH)
Management of token minting
Setting up limits and control permissions
Module Structure
Structs
Token Types
struct WBTC has key, store {}
struct WETH has key, store {}
Represents the types of wrapped tokens (WBTC, WETH)
Has
key
and
store
abilities for storage and transfer capabilities
Capability Struct
struct Cap<phantom CoinType> has key {
    mint_cap: coin::MintCapability<CoinType>,
    freeze_cap: coin::FreezeCapability<CoinType>,
    burn_cap: coin::BurnCapability<CoinType>,
}
Manages capabilities for each token type
Generic type allows use with different token types
Includes mint, freeze, and burn token capabilities
Functions
Initialize Function
public entry fun intialize<CoinType>(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    decimals: u8,
    monitor_supply: bool
)
Purpose:
Initialize a new token type in the system
Only admin has permission to execute
Create and store token capabilities
Implementation steps:
Verify caller is admin
Register token for caller
Initialize token with basic parameters
Store capabilities in storage
Mint Function
public fun mint<CoinType>(
    sender: &signer,
    amount: u64
)
Purpose:
Create (mint) a quantity of tokens for an address
Ensure mint limits and register tokens for recipient
Implementation steps:
Check mint amount doesn't exceed MAX_PER_MINT
Get mint capability from admin address
Mint new tokens
Check and register token for recipient if needed
Transfer minted tokens to recipient's account
Role in Lending Platform
Token Management:
Serves as the foundation for creating and managing tokens used in the platform
Security:
Ensures only admin can initialize tokens and manage capabilities
Supply Control:
Limits the amount of tokens minted each time to ensure safety
Automation:
Automatically registers tokens for users when necessary
Usage Example
// Initialize WBTC token
intialize<WBTC>(
    admin_signer,
    string::utf8(b"Wrapped Bitcoin"),
    string::utf8(b"WBTC"),
    8,
    true
);
// Mint WBTC for an address
mint<WBTC>(user_signer, 50_000);
Full Code
module movement::all_tokens {
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    use std::string;
    use movement::errors;
    use movement::utils;
    // Constants
    const MAX_PER_MINT: u64 = 100_000;
    struct WBTC has key, store {}
    struct WETH has key, store {}
    struct Cap<phantom CoinType> has key {
        mint_cap: coin::MintCapability<CoinType>,
        freeze_cap: coin::FreezeCapability<CoinType>,
        burn_cap: coin::BurnCapability<CoinType>,
    }
    public entry fun intialize<CoinType>(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        decimals: u8,
        monitor_supply: bool
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        managed_coin::register<CoinType>(sender);
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<CoinType>(
            sender,
            name,
            symbol,
            decimals,
            monitor_supply
        );
        move_to(sender, Cap<CoinType>{
            mint_cap,
            freeze_cap,
            burn_cap
        });
    }
    public fun mint<CoinType>(
        sender: &signer,
        amount: u64
    ) acquires Cap {
        assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
        let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
        let minted_coins = coin::mint<CoinType>(amount, &cap.mint_cap);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), minted_coins);
    }
}
			What is Wrap Coin?
Overview
A wrapped coin is a cryptocurrency token issued on a blockchain that is backed one-to-one by another cryptocurrency. The most common examples are WETH (Wrapped ETH) and WBTC (Wrapped Bitcoin).
How it Works
Wrapping process:
Users send their original cryptocurrency to a specialized smart contract (custodian), which then issues an equivalent amount of wrapped tokens.
1:1 ratio:
One WETH equals one ETH, one WBTC equals one BTC. This ratio remains constant.
Unwrap:
Users can exchange their wrapped tokens back to receive the original coins at any time.
Role in Lending & Borrowing
Wrapped coins serve an essential function in decentralized lending platforms (DeFi lending platforms):
Compatibility:
Wrapped tokens enable coins from one blockchain to be used on another blockchain. For example: WBTC allows Bitcoin usage on Ethereum DeFi.
Flexible collateral:
Users can use wrapped tokens as collateral to borrow other tokens.
Yield farming:
Wrapped tokens can be used in farming strategies to generate additional profits.
Risks to Consider
Risks from smart contracts managing wrapped tokens
Dependence on custodians holding the original assets
Gas fees for wrapping/unwrapping tokens
Wrapped coins are a vital tool in the DeFi ecosystem, especially in lending and borrowing, enhancing flexibility and efficiency for decentralized financial transactions.
Overview
Module
movement::all_tokens
is an important part of the lending platform, responsible for managing and initializing tokens used in the lending system. This module allows:
Initialization of new tokens (like WBTC, WETH)
Management of token minting
Setting up limits and control permissions
Module Structure
Structs
Token Types
struct WBTC has key, store {}
struct WETH has key, store {}
Represents the types of wrapped tokens (WBTC, WETH)
Has
key
and
store
abilities for storage and transfer capabilities
Capability Struct
struct Cap<phantom CoinType> has key {
    mint_cap: coin::MintCapability<CoinType>,
    freeze_cap: coin::FreezeCapability<CoinType>,
    burn_cap: coin::BurnCapability<CoinType>,
}
Manages capabilities for each token type
Generic type allows use with different token types
Includes mint, freeze, and burn token capabilities
Functions
Initialize Function
public entry fun intialize<CoinType>(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    decimals: u8,
    monitor_supply: bool
)
Purpose:
Initialize a new token type in the system
Only admin has permission to execute
Create and store token capabilities
Implementation steps:
Verify caller is admin
Register token for caller
Initialize token with basic parameters
Store capabilities in storage
Mint Function
public fun mint<CoinType>(
    sender: &signer,
    amount: u64
)
Purpose:
Create (mint) a quantity of tokens for an address
Ensure mint limits and register tokens for recipient
Implementation steps:
Check mint amount doesn't exceed MAX_PER_MINT
Get mint capability from admin address
Mint new tokens
Check and register token for recipient if needed
Transfer minted tokens to recipient's account
Role in Lending Platform
Token Management:
Serves as the foundation for creating and managing tokens used in the platform
Security:
Ensures only admin can initialize tokens and manage capabilities
Supply Control:
Limits the amount of tokens minted each time to ensure safety
Automation:
Automatically registers tokens for users when necessary
Usage Example
// Initialize WBTC token
intialize<WBTC>(
    admin_signer,
    string::utf8(b"Wrapped Bitcoin"),
    string::utf8(b"WBTC"),
    8,
    true
);
// Mint WBTC for an address
mint<WBTC>(user_signer, 50_000);
Full Code
module movement::all_tokens {
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    use std::string;
    use movement::errors;
    use movement::utils;
    // Constants
    const MAX_PER_MINT: u64 = 100_000;
    struct WBTC has key, store {}
    struct WETH has key, store {}
    struct Cap<phantom CoinType> has key {
        mint_cap: coin::MintCapability<CoinType>,
        freeze_cap: coin::FreezeCapability<CoinType>,
        burn_cap: coin::BurnCapability<CoinType>,
    }
    public entry fun intialize<CoinType>(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        decimals: u8,
        monitor_supply: bool
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        managed_coin::register<CoinType>(sender);
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<CoinType>(
            sender,
            name,
            symbol,
            decimals,
            monitor_supply
        );
        move_to(sender, Cap<CoinType>{
            mint_cap,
            freeze_cap,
            burn_cap
        });
    }
    public fun mint<CoinType>(
        sender: &signer,
        amount: u64
    ) acquires Cap {
        assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
        let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
        let minted_coins = coin::mint<CoinType>(amount, &cap.mint_cap);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), minted_coins);
    }
}
			What is Wrap Coin?
Overview
A wrapped coin is a cryptocurrency token issued on a blockchain that is backed one-to-one by another cryptocurrency. The most common examples are WETH (Wrapped ETH) and WBTC (Wrapped Bitcoin).
How it Works
Wrapping process:
Users send their original cryptocurrency to a specialized smart contract (custodian), which then issues an equivalent amount of wrapped tokens.
1:1 ratio:
One WETH equals one ETH, one WBTC equals one BTC. This ratio remains constant.
Unwrap:
Users can exchange their wrapped tokens back to receive the original coins at any time.
Role in Lending & Borrowing
Wrapped coins serve an essential function in decentralized lending platforms (DeFi lending platforms):
Compatibility:
Wrapped tokens enable coins from one blockchain to be used on another blockchain. For example: WBTC allows Bitcoin usage on Ethereum DeFi.
Flexible collateral:
Users can use wrapped tokens as collateral to borrow other tokens.
Yield farming:
Wrapped tokens can be used in farming strategies to generate additional profits.
Risks to Consider
Risks from smart contracts managing wrapped tokens
Dependence on custodians holding the original assets
Gas fees for wrapping/unwrapping tokens
Wrapped coins are a vital tool in the DeFi ecosystem, especially in lending and borrowing, enhancing flexibility and efficiency for decentralized financial transactions.
Overview
Module
movement::all_tokens
is an important part of the lending platform, responsible for managing and initializing tokens used in the lending system. This module allows:
Initialization of new tokens (like WBTC, WETH)
Management of token minting
Setting up limits and control permissions
Module Structure
Structs
Token Types
struct WBTC has key, store {}
struct WETH has key, store {}
Represents the types of wrapped tokens (WBTC, WETH)
Has
key
and
store
abilities for storage and transfer capabilities
Capability Struct
struct Cap<phantom CoinType> has key {
    mint_cap: coin::MintCapability<CoinType>,
    freeze_cap: coin::FreezeCapability<CoinType>,
    burn_cap: coin::BurnCapability<CoinType>,
}
Manages capabilities for each token type
Generic type allows use with different token types
Includes mint, freeze, and burn token capabilities
Functions
Initialize Function
public entry fun intialize<CoinType>(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    decimals: u8,
    monitor_supply: bool
)
Purpose:
Initialize a new token type in the system
Only admin has permission to execute
Create and store token capabilities
Implementation steps:
Verify caller is admin
Register token for caller
Initialize token with basic parameters
Store capabilities in storage
Mint Function
public fun mint<CoinType>(
    sender: &signer,
    amount: u64
)
Purpose:
Create (mint) a quantity of tokens for an address
Ensure mint limits and register tokens for recipient
Implementation steps:
Check mint amount doesn't exceed MAX_PER_MINT
Get mint capability from admin address
Mint new tokens
Check and register token for recipient if needed
Transfer minted tokens to recipient's account
Role in Lending Platform
Token Management:
Serves as the foundation for creating and managing tokens used in the platform
Security:
Ensures only admin can initialize tokens and manage capabilities
Supply Control:
Limits the amount of tokens minted each time to ensure safety
Automation:
Automatically registers tokens for users when necessary
Usage Example
// Initialize WBTC token
intialize<WBTC>(
    admin_signer,
    string::utf8(b"Wrapped Bitcoin"),
    string::utf8(b"WBTC"),
    8,
    true
);
// Mint WBTC for an address
mint<WBTC>(user_signer, 50_000);
Full Code
module movement::all_tokens {
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    use std::string;
    use movement::errors;
    use movement::utils;
    // Constants
    const MAX_PER_MINT: u64 = 100_000;
    struct WBTC has key, store {}
    struct WETH has key, store {}
    struct Cap<phantom CoinType> has key {
        mint_cap: coin::MintCapability<CoinType>,
        freeze_cap: coin::FreezeCapability<CoinType>,
        burn_cap: coin::BurnCapability<CoinType>,
    }
    public entry fun intialize<CoinType>(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        decimals: u8,
        monitor_supply: bool
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        managed_coin::register<CoinType>(sender);
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<CoinType>(
            sender,
            name,
            symbol,
            decimals,
            monitor_supply
        );
        move_to(sender, Cap<CoinType>{
            mint_cap,
            freeze_cap,
            burn_cap
        });
    }
    public fun mint<CoinType>(
        sender: &signer,
        amount: u64
    ) acquires Cap {
        assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
        let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
        let minted_coins = coin::mint<CoinType>(amount, &cap.mint_cap);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), minted_coins);
    }
}
	What is Wrap Coin?
	What is Wrap Coin?
		Overview
		Overview
		A wrapped coin is a cryptocurrency token issued on a blockchain that is backed one-to-one by another cryptocurrency. The most common examples are WETH (Wrapped ETH) and WBTC (Wrapped Bitcoin).
		A wrapped coin is a cryptocurrency token issued on a blockchain that is backed one-to-one by another cryptocurrency. The most common examples are WETH (Wrapped ETH) and WBTC (Wrapped Bitcoin).
	How it Works
	How it Works
	Wrapping process:
Users send their original cryptocurrency to a specialized smart contract (custodian), which then issues an equivalent amount of wrapped tokens.
1:1 ratio:
One WETH equals one ETH, one WBTC equals one BTC. This ratio remains constant.
Unwrap:
Users can exchange their wrapped tokens back to receive the original coins at any time.
	Wrapping process:
Users send their original cryptocurrency to a specialized smart contract (custodian), which then issues an equivalent amount of wrapped tokens.
	Wrapping process:
	Wrapping process:
	Users send their original cryptocurrency to a specialized smart contract (custodian), which then issues an equivalent amount of wrapped tokens.
	1:1 ratio:
One WETH equals one ETH, one WBTC equals one BTC. This ratio remains constant.
	1:1 ratio:
	1:1 ratio:
	One WETH equals one ETH, one WBTC equals one BTC. This ratio remains constant.
	Unwrap:
Users can exchange their wrapped tokens back to receive the original coins at any time.
	Unwrap:
	Unwrap:
	Users can exchange their wrapped tokens back to receive the original coins at any time.
	Role in Lending & Borrowing
	Role in Lending & Borrowing
	Wrapped coins serve an essential function in decentralized lending platforms (DeFi lending platforms):
	Wrapped coins serve an essential function in decentralized lending platforms (DeFi lending platforms):
	Compatibility:
Wrapped tokens enable coins from one blockchain to be used on another blockchain. For example: WBTC allows Bitcoin usage on Ethereum DeFi.
Flexible collateral:
Users can use wrapped tokens as collateral to borrow other tokens.
Yield farming:
Wrapped tokens can be used in farming strategies to generate additional profits.
	Compatibility:
Wrapped tokens enable coins from one blockchain to be used on another blockchain. For example: WBTC allows Bitcoin usage on Ethereum DeFi.
	Compatibility:
	Compatibility:
	Wrapped tokens enable coins from one blockchain to be used on another blockchain. For example: WBTC allows Bitcoin usage on Ethereum DeFi.
	Flexible collateral:
Users can use wrapped tokens as collateral to borrow other tokens.
	Flexible collateral:
	Flexible collateral:
	Users can use wrapped tokens as collateral to borrow other tokens.
	Yield farming:
Wrapped tokens can be used in farming strategies to generate additional profits.
	Yield farming:
	Yield farming:
	Wrapped tokens can be used in farming strategies to generate additional profits.
	Risks to Consider
	Risks to Consider
	Risks from smart contracts managing wrapped tokens
Dependence on custodians holding the original assets
Gas fees for wrapping/unwrapping tokens
	Risks from smart contracts managing wrapped tokens
	Risks from smart contracts managing wrapped tokens
	Dependence on custodians holding the original assets
	Dependence on custodians holding the original assets
	Gas fees for wrapping/unwrapping tokens
	Gas fees for wrapping/unwrapping tokens
	Wrapped coins are a vital tool in the DeFi ecosystem, especially in lending and borrowing, enhancing flexibility and efficiency for decentralized financial transactions.
	Wrapped coins are a vital tool in the DeFi ecosystem, especially in lending and borrowing, enhancing flexibility and efficiency for decentralized financial transactions.
	Overview
	Overview
	Module
movement::all_tokens
is an important part of the lending platform, responsible for managing and initializing tokens used in the lending system. This module allows:
	Module
	<code>movement::all_tokens</code>
	movement::all_tokens
	is an important part of the lending platform, responsible for managing and initializing tokens used in the lending system. This module allows:
	Initialization of new tokens (like WBTC, WETH)
Management of token minting
Setting up limits and control permissions
	Initialization of new tokens (like WBTC, WETH)
	Initialization of new tokens (like WBTC, WETH)
	Management of token minting
	Management of token minting
	Setting up limits and control permissions
	Setting up limits and control permissions
	Module Structure
	Module Structure
		Structs
		Structs
		Token Types
		Token Types
		<code>struct WBTC has key, store {}
struct WETH has key, store {}</code>
		<code>struct WBTC has key, store {}
struct WETH has key, store {}</code>
		struct WBTC has key, store {}
struct WETH has key, store {}
		Represents the types of wrapped tokens (WBTC, WETH)
Has
key
and
store
abilities for storage and transfer capabilities
		Represents the types of wrapped tokens (WBTC, WETH)
		Represents the types of wrapped tokens (WBTC, WETH)
		Has
key
and
store
abilities for storage and transfer capabilities
		Has
		<code>key</code>
		key
		and
		<code>store</code>
		store
		abilities for storage and transfer capabilities
		Capability Struct
		Capability Struct
		<code>struct Cap<phantom CoinType> has key {
    mint_cap: coin::MintCapability<CoinType>,
    freeze_cap: coin::FreezeCapability<CoinType>,
    burn_cap: coin::BurnCapability<CoinType>,
}</code>
		<code>struct Cap<phantom CoinType> has key {
    mint_cap: coin::MintCapability<CoinType>,
    freeze_cap: coin::FreezeCapability<CoinType>,
    burn_cap: coin::BurnCapability<CoinType>,
}</code>
		struct Cap<phantom CoinType> has key {
    mint_cap: coin::MintCapability<CoinType>,
    freeze_cap: coin::FreezeCapability<CoinType>,
    burn_cap: coin::BurnCapability<CoinType>,
}
		Manages capabilities for each token type
Generic type allows use with different token types
Includes mint, freeze, and burn token capabilities
		Manages capabilities for each token type
		Manages capabilities for each token type
		Generic type allows use with different token types
		Generic type allows use with different token types
		Includes mint, freeze, and burn token capabilities
		Includes mint, freeze, and burn token capabilities
	Functions
	Functions
		Initialize Function
		Initialize Function
		<code>public entry fun intialize<CoinType>(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    decimals: u8,
    monitor_supply: bool
)</code>
		<code>public entry fun intialize<CoinType>(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    decimals: u8,
    monitor_supply: bool
)</code>
		public entry fun intialize<CoinType>(
    sender: &signer,
    name: string::String,
    symbol: string::String,
    decimals: u8,
    monitor_supply: bool
)
		Purpose:
		Purpose:
		Purpose:
		Initialize a new token type in the system
Only admin has permission to execute
Create and store token capabilities
		Initialize a new token type in the system
		Initialize a new token type in the system
		Only admin has permission to execute
		Only admin has permission to execute
		Create and store token capabilities
		Create and store token capabilities
		Implementation steps:
		Implementation steps:
		Implementation steps:
		Verify caller is admin
Register token for caller
Initialize token with basic parameters
Store capabilities in storage
		Verify caller is admin
		Verify caller is admin
		Register token for caller
		Register token for caller
		Initialize token with basic parameters
		Initialize token with basic parameters
		Store capabilities in storage
		Store capabilities in storage
		Mint Function
		Mint Function
		<code>public fun mint<CoinType>(
    sender: &signer,
    amount: u64
)</code>
		<code>public fun mint<CoinType>(
    sender: &signer,
    amount: u64
)</code>
		public fun mint<CoinType>(
    sender: &signer,
    amount: u64
)
		Purpose:
		Purpose:
		Purpose:
		Create (mint) a quantity of tokens for an address
Ensure mint limits and register tokens for recipient
		Create (mint) a quantity of tokens for an address
		Create (mint) a quantity of tokens for an address
		Ensure mint limits and register tokens for recipient
		Ensure mint limits and register tokens for recipient
		Implementation steps:
		Implementation steps:
		Implementation steps:
		Check mint amount doesn't exceed MAX_PER_MINT
Get mint capability from admin address
Mint new tokens
Check and register token for recipient if needed
Transfer minted tokens to recipient's account
		Check mint amount doesn't exceed MAX_PER_MINT
		Check mint amount doesn't exceed MAX_PER_MINT
		Get mint capability from admin address
		Get mint capability from admin address
		Mint new tokens
		Mint new tokens
		Check and register token for recipient if needed
		Check and register token for recipient if needed
		Transfer minted tokens to recipient's account
		Transfer minted tokens to recipient's account
	Role in Lending Platform
	Role in Lending Platform
	Token Management:
Serves as the foundation for creating and managing tokens used in the platform
Security:
Ensures only admin can initialize tokens and manage capabilities
Supply Control:
Limits the amount of tokens minted each time to ensure safety
Automation:
Automatically registers tokens for users when necessary
	Token Management:
Serves as the foundation for creating and managing tokens used in the platform
	Token Management:
	Token Management:
	Serves as the foundation for creating and managing tokens used in the platform
	Security:
Ensures only admin can initialize tokens and manage capabilities
	Security:
	Security:
	Ensures only admin can initialize tokens and manage capabilities
	Supply Control:
Limits the amount of tokens minted each time to ensure safety
	Supply Control:
	Supply Control:
	Limits the amount of tokens minted each time to ensure safety
	Automation:
Automatically registers tokens for users when necessary
	Automation:
	Automation:
	Automatically registers tokens for users when necessary
	Usage Example
	Usage Example
	<code>// Initialize WBTC token
intialize<WBTC>(
    admin_signer,
    string::utf8(b"Wrapped Bitcoin"),
    string::utf8(b"WBTC"),
    8,
    true
);
// Mint WBTC for an address
mint<WBTC>(user_signer, 50_000);</code>
	<code>// Initialize WBTC token
intialize<WBTC>(
    admin_signer,
    string::utf8(b"Wrapped Bitcoin"),
    string::utf8(b"WBTC"),
    8,
    true
);
// Mint WBTC for an address
mint<WBTC>(user_signer, 50_000);</code>
	// Initialize WBTC token
intialize<WBTC>(
    admin_signer,
    string::utf8(b"Wrapped Bitcoin"),
    string::utf8(b"WBTC"),
    8,
    true
);
// Mint WBTC for an address
mint<WBTC>(user_signer, 50_000);
	Full Code
	Full Code
	<code>module movement::all_tokens {
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    use std::string;
    use movement::errors;
    use movement::utils;
    // Constants
    const MAX_PER_MINT: u64 = 100_000;
    struct WBTC has key, store {}
    struct WETH has key, store {}
    struct Cap<phantom CoinType> has key {
        mint_cap: coin::MintCapability<CoinType>,
        freeze_cap: coin::FreezeCapability<CoinType>,
        burn_cap: coin::BurnCapability<CoinType>,
    }
    public entry fun intialize<CoinType>(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        decimals: u8,
        monitor_supply: bool
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        managed_coin::register<CoinType>(sender);
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<CoinType>(
            sender,
            name,
            symbol,
            decimals,
            monitor_supply
        );
        move_to(sender, Cap<CoinType>{
            mint_cap,
            freeze_cap,
            burn_cap
        });
    }
    public fun mint<CoinType>(
        sender: &signer,
        amount: u64
    ) acquires Cap {
        assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
        let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
        let minted_coins = coin::mint<CoinType>(amount, &cap.mint_cap);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), minted_coins);
    }
}</code>
	<code>module movement::all_tokens {
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    use std::string;
    use movement::errors;
    use movement::utils;
    // Constants
    const MAX_PER_MINT: u64 = 100_000;
    struct WBTC has key, store {}
    struct WETH has key, store {}
    struct Cap<phantom CoinType> has key {
        mint_cap: coin::MintCapability<CoinType>,
        freeze_cap: coin::FreezeCapability<CoinType>,
        burn_cap: coin::BurnCapability<CoinType>,
    }
    public entry fun intialize<CoinType>(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        decimals: u8,
        monitor_supply: bool
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        managed_coin::register<CoinType>(sender);
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<CoinType>(
            sender,
            name,
            symbol,
            decimals,
            monitor_supply
        );
        move_to(sender, Cap<CoinType>{
            mint_cap,
            freeze_cap,
            burn_cap
        });
    }
    public fun mint<CoinType>(
        sender: &signer,
        amount: u64
    ) acquires Cap {
        assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
        let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
        let minted_coins = coin::mint<CoinType>(amount, &cap.mint_cap);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), minted_coins);
    }
}</code>
	module movement::all_tokens {
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    use std::string;
    use movement::errors;
    use movement::utils;
    // Constants
    const MAX_PER_MINT: u64 = 100_000;
    struct WBTC has key, store {}
    struct WETH has key, store {}
    struct Cap<phantom CoinType> has key {
        mint_cap: coin::MintCapability<CoinType>,
        freeze_cap: coin::FreezeCapability<CoinType>,
        burn_cap: coin::BurnCapability<CoinType>,
    }
    public entry fun intialize<CoinType>(
        sender: &signer,
        name: string::String,
        symbol: string::String,
        decimals: u8,
        monitor_supply: bool
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        managed_coin::register<CoinType>(sender);
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<CoinType>(
            sender,
            name,
            symbol,
            decimals,
            monitor_supply
        );
        move_to(sender, Cap<CoinType>{
            mint_cap,
            freeze_cap,
            burn_cap
        });
    }
    public fun mint<CoinType>(
        sender: &signer,
        amount: u64
    ) acquires Cap {
        assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
        let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
        let minted_coins = coin::mint<CoinType>(amount, &cap.mint_cap);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), minted_coins);
    }
}

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/04-lending-and-borrowing/04-utils-and-errors-handling
Utils & Errors Handling
Utils & Errors Handling
On This Page
Detailed Guide on Errors and Utils Modules in Movement Platform
1. Module movement::errors
1.1 Error Code Definition and Management
1.2 Getter Functions and Usage
2. Module movement::utils
2.1 Admin Address Management
2.2 Admin Verification
3. Platform Integration Guide
3.1 Verification and Access Control
3.2 Accessing Capabilities
3.3 Best Practices in Error Handling
4. Benefits and Best Practices
Detailed Guide on Errors and Utils Modules in Movement Platform
1. Module movement::errors
This module plays a crucial role in managing and handling errors in the system. Centralizing error management makes the code easier to maintain and debug.
1.1 Error Code Definition and Management
Error codes are defined in hexadecimal format, making them easy to categorize and extend:
// Errors related to token minting
const E_MINT_BEYOND: u64 = 0x00001;     // Minting amount exceeds allowed limit
const E_INVALID_ADDRESS: u64 = 0x00002;  // Invalid wallet address
const E_NOT_ADMIN: u64 = 0x00003;        // User does not have admin privileges
1.2 Getter Functions and Usage
The module provides getter functions to safely retrieve error codes:
// Public getter functions for error codes
public fun get_e_not_admin(): u64
public fun get_e_mint_beyond(): u64
public fun get_e_invalid_address(): u64
Purpose and Benefits:
Provides a unified interface to access error codes, avoiding hardcoding
Makes code easier to maintain and upgrade when error codes need to be changed
Centralizes error management in one place, making tracking and debugging easier
Ensures consistency in error handling across the codebase
Usage Guide:
// Example 1: Check admin privileges
if (!is_admin(sender)) {
    abort errors::get_e_not_admin()
};
// Example 2: Check mint limit with custom error message
assert!(
    amount <= MAX_MINT_AMOUNT,
    errors::get_e_mint_beyond()
);
2. Module movement::utils
The utils module provides utilities and helper functions frequently used in the platform. Centralizing utility functions helps maintain DRY (Don't Repeat Yourself) principles and improves maintainability.
2.1 Admin Address Management
Function to retrieve and validate admin address:
// Returns the platform's admin address
public fun admin_address(): address {
    @movement  // Address is hardcoded to ensure security
}
Returns the admin address (@movement) - this address is used for permission management
Used to verify permissions and access important system capabilities
Ensures consistency when accessing admin address across the codebase
2.2 Admin Verification
Function to check admin privileges:
// Check if a signer is an admin
public fun is_admin(sender: &signer): bool {
    signer::address_of(sender) == @movement
}
Checks if the caller is an admin through their address
Compares the sender's address with the defined admin address
Used before important operations requiring admin privileges
3. Platform Integration Guide
3.1 Verification and Access Control
Example of using modules in functions requiring admin privileges:
public fun mint_tokens(sender: &signer, amount: u64) {
    // Check admin privileges
    assert!(utils::is_admin(sender), errors::get_e_not_admin());
    // Check mint limit
    assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
    // Continue with mint logic if conditions are met
    // ...
}
3.2 Accessing Capabilities
Example of using admin address to access capabilities:
// Get capability from admin address to perform important operations
let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
// Use capability to perform operation
do_something_with_cap(cap);
3.3 Best Practices in Error Handling
public fun transfer_tokens(
    sender: &signer,
    recipient: address,
    amount: u64
) {
    // Check valid address
    assert!(recipient != @0x0, errors::get_e_invalid_address());
    // Check amount
    assert!(amount > 0, errors::get_e_invalid_amount());
    // Perform transfer if all conditions are ok
    // ...
}
4. Benefits and Best Practices
Code Centralization and Management
Error codes are centrally managed in one place, easy to maintain
Easy to add/modify new error codes without affecting existing code
Admin logic is centralized in utils, ensuring consistency
Reduces code duplication and increases reusability
Enhanced Security
Consistent admin privilege checking across the codebase
Clear error codes that can be easily tracked and debugged
Capability pattern ensures only admin can perform important operations
Validation is performed systematically
Extensibility and Maintainability
Easy to add new error codes as the platform grows
Utils can be extended with new utility functions without affecting existing code
Easy to update error handling logic when needed
Code is highly modular, easy to test and maintain
On This Page
Detailed Guide on Errors and Utils Modules in Movement Platform
1. Module movement::errors
1.1 Error Code Definition and Management
1.2 Getter Functions and Usage
2. Module movement::utils
2.1 Admin Address Management
2.2 Admin Verification
3. Platform Integration Guide
3.1 Verification and Access Control
3.2 Accessing Capabilities
3.3 Best Practices in Error Handling
4. Benefits and Best Practices
On This Page
Detailed Guide on Errors and Utils Modules in Movement Platform
1. Module movement::errors
1.1 Error Code Definition and Management
1.2 Getter Functions and Usage
2. Module movement::utils
2.1 Admin Address Management
2.2 Admin Verification
3. Platform Integration Guide
3.1 Verification and Access Control
3.2 Accessing Capabilities
3.3 Best Practices in Error Handling
4. Benefits and Best Practices
			On This Page
			On This Page
			Detailed Guide on Errors and Utils Modules in Movement Platform
1. Module movement::errors
1.1 Error Code Definition and Management
1.2 Getter Functions and Usage
2. Module movement::utils
2.1 Admin Address Management
2.2 Admin Verification
3. Platform Integration Guide
3.1 Verification and Access Control
3.2 Accessing Capabilities
3.3 Best Practices in Error Handling
4. Benefits and Best Practices
			Detailed Guide on Errors and Utils Modules in Movement Platform
			Detailed Guide on Errors and Utils Modules in Movement Platform
			Detailed Guide on Errors and Utils Modules in Movement Platform
			Detailed Guide on Errors and Utils Modules in Movement Platform
			1. Module movement::errors
1.1 Error Code Definition and Management
1.2 Getter Functions and Usage
			1. Module movement::errors
			1. Module movement::errors
			1. Module movement::errors
			1.1 Error Code Definition and Management
1.2 Getter Functions and Usage
			1.1 Error Code Definition and Management
			1.1 Error Code Definition and Management
			1.1 Error Code Definition and Management
			1.1 Error Code Definition and Management
			1.2 Getter Functions and Usage
			1.2 Getter Functions and Usage
			1.2 Getter Functions and Usage
			1.2 Getter Functions and Usage
			2. Module movement::utils
2.1 Admin Address Management
2.2 Admin Verification
			2. Module movement::utils
			2. Module movement::utils
			2. Module movement::utils
			2.1 Admin Address Management
2.2 Admin Verification
			2.1 Admin Address Management
			2.1 Admin Address Management
			2.1 Admin Address Management
			2.1 Admin Address Management
			2.2 Admin Verification
			2.2 Admin Verification
			2.2 Admin Verification
			2.2 Admin Verification
			3. Platform Integration Guide
3.1 Verification and Access Control
3.2 Accessing Capabilities
3.3 Best Practices in Error Handling
			3. Platform Integration Guide
			3. Platform Integration Guide
			3. Platform Integration Guide
			3.1 Verification and Access Control
3.2 Accessing Capabilities
3.3 Best Practices in Error Handling
			3.1 Verification and Access Control
			3.1 Verification and Access Control
			3.1 Verification and Access Control
			3.1 Verification and Access Control
			3.2 Accessing Capabilities
			3.2 Accessing Capabilities
			3.2 Accessing Capabilities
			3.2 Accessing Capabilities
			3.3 Best Practices in Error Handling
			3.3 Best Practices in Error Handling
			3.3 Best Practices in Error Handling
			3.3 Best Practices in Error Handling
			4. Benefits and Best Practices
			4. Benefits and Best Practices
			4. Benefits and Best Practices
			4. Benefits and Best Practices
			Detailed Guide on Errors and Utils Modules in Movement Platform
1. Module movement::errors
This module plays a crucial role in managing and handling errors in the system. Centralizing error management makes the code easier to maintain and debug.
1.1 Error Code Definition and Management
Error codes are defined in hexadecimal format, making them easy to categorize and extend:
// Errors related to token minting
const E_MINT_BEYOND: u64 = 0x00001;     // Minting amount exceeds allowed limit
const E_INVALID_ADDRESS: u64 = 0x00002;  // Invalid wallet address
const E_NOT_ADMIN: u64 = 0x00003;        // User does not have admin privileges
1.2 Getter Functions and Usage
The module provides getter functions to safely retrieve error codes:
// Public getter functions for error codes
public fun get_e_not_admin(): u64
public fun get_e_mint_beyond(): u64
public fun get_e_invalid_address(): u64
Purpose and Benefits:
Provides a unified interface to access error codes, avoiding hardcoding
Makes code easier to maintain and upgrade when error codes need to be changed
Centralizes error management in one place, making tracking and debugging easier
Ensures consistency in error handling across the codebase
Usage Guide:
// Example 1: Check admin privileges
if (!is_admin(sender)) {
    abort errors::get_e_not_admin()
};
// Example 2: Check mint limit with custom error message
assert!(
    amount <= MAX_MINT_AMOUNT,
    errors::get_e_mint_beyond()
);
2. Module movement::utils
The utils module provides utilities and helper functions frequently used in the platform. Centralizing utility functions helps maintain DRY (Don't Repeat Yourself) principles and improves maintainability.
2.1 Admin Address Management
Function to retrieve and validate admin address:
// Returns the platform's admin address
public fun admin_address(): address {
    @movement  // Address is hardcoded to ensure security
}
Returns the admin address (@movement) - this address is used for permission management
Used to verify permissions and access important system capabilities
Ensures consistency when accessing admin address across the codebase
2.2 Admin Verification
Function to check admin privileges:
// Check if a signer is an admin
public fun is_admin(sender: &signer): bool {
    signer::address_of(sender) == @movement
}
Checks if the caller is an admin through their address
Compares the sender's address with the defined admin address
Used before important operations requiring admin privileges
3. Platform Integration Guide
3.1 Verification and Access Control
Example of using modules in functions requiring admin privileges:
public fun mint_tokens(sender: &signer, amount: u64) {
    // Check admin privileges
    assert!(utils::is_admin(sender), errors::get_e_not_admin());
    // Check mint limit
    assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
    // Continue with mint logic if conditions are met
    // ...
}
3.2 Accessing Capabilities
Example of using admin address to access capabilities:
// Get capability from admin address to perform important operations
let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
// Use capability to perform operation
do_something_with_cap(cap);
3.3 Best Practices in Error Handling
public fun transfer_tokens(
    sender: &signer,
    recipient: address,
    amount: u64
) {
    // Check valid address
    assert!(recipient != @0x0, errors::get_e_invalid_address());
    // Check amount
    assert!(amount > 0, errors::get_e_invalid_amount());
    // Perform transfer if all conditions are ok
    // ...
}
4. Benefits and Best Practices
Code Centralization and Management
Error codes are centrally managed in one place, easy to maintain
Easy to add/modify new error codes without affecting existing code
Admin logic is centralized in utils, ensuring consistency
Reduces code duplication and increases reusability
Enhanced Security
Consistent admin privilege checking across the codebase
Clear error codes that can be easily tracked and debugged
Capability pattern ensures only admin can perform important operations
Validation is performed systematically
Extensibility and Maintainability
Easy to add new error codes as the platform grows
Utils can be extended with new utility functions without affecting existing code
Easy to update error handling logic when needed
Code is highly modular, easy to test and maintain
			Detailed Guide on Errors and Utils Modules in Movement Platform
1. Module movement::errors
This module plays a crucial role in managing and handling errors in the system. Centralizing error management makes the code easier to maintain and debug.
1.1 Error Code Definition and Management
Error codes are defined in hexadecimal format, making them easy to categorize and extend:
// Errors related to token minting
const E_MINT_BEYOND: u64 = 0x00001;     // Minting amount exceeds allowed limit
const E_INVALID_ADDRESS: u64 = 0x00002;  // Invalid wallet address
const E_NOT_ADMIN: u64 = 0x00003;        // User does not have admin privileges
1.2 Getter Functions and Usage
The module provides getter functions to safely retrieve error codes:
// Public getter functions for error codes
public fun get_e_not_admin(): u64
public fun get_e_mint_beyond(): u64
public fun get_e_invalid_address(): u64
Purpose and Benefits:
Provides a unified interface to access error codes, avoiding hardcoding
Makes code easier to maintain and upgrade when error codes need to be changed
Centralizes error management in one place, making tracking and debugging easier
Ensures consistency in error handling across the codebase
Usage Guide:
// Example 1: Check admin privileges
if (!is_admin(sender)) {
    abort errors::get_e_not_admin()
};
// Example 2: Check mint limit with custom error message
assert!(
    amount <= MAX_MINT_AMOUNT,
    errors::get_e_mint_beyond()
);
2. Module movement::utils
The utils module provides utilities and helper functions frequently used in the platform. Centralizing utility functions helps maintain DRY (Don't Repeat Yourself) principles and improves maintainability.
2.1 Admin Address Management
Function to retrieve and validate admin address:
// Returns the platform's admin address
public fun admin_address(): address {
    @movement  // Address is hardcoded to ensure security
}
Returns the admin address (@movement) - this address is used for permission management
Used to verify permissions and access important system capabilities
Ensures consistency when accessing admin address across the codebase
2.2 Admin Verification
Function to check admin privileges:
// Check if a signer is an admin
public fun is_admin(sender: &signer): bool {
    signer::address_of(sender) == @movement
}
Checks if the caller is an admin through their address
Compares the sender's address with the defined admin address
Used before important operations requiring admin privileges
3. Platform Integration Guide
3.1 Verification and Access Control
Example of using modules in functions requiring admin privileges:
public fun mint_tokens(sender: &signer, amount: u64) {
    // Check admin privileges
    assert!(utils::is_admin(sender), errors::get_e_not_admin());
    // Check mint limit
    assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
    // Continue with mint logic if conditions are met
    // ...
}
3.2 Accessing Capabilities
Example of using admin address to access capabilities:
// Get capability from admin address to perform important operations
let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
// Use capability to perform operation
do_something_with_cap(cap);
3.3 Best Practices in Error Handling
public fun transfer_tokens(
    sender: &signer,
    recipient: address,
    amount: u64
) {
    // Check valid address
    assert!(recipient != @0x0, errors::get_e_invalid_address());
    // Check amount
    assert!(amount > 0, errors::get_e_invalid_amount());
    // Perform transfer if all conditions are ok
    // ...
}
4. Benefits and Best Practices
Code Centralization and Management
Error codes are centrally managed in one place, easy to maintain
Easy to add/modify new error codes without affecting existing code
Admin logic is centralized in utils, ensuring consistency
Reduces code duplication and increases reusability
Enhanced Security
Consistent admin privilege checking across the codebase
Clear error codes that can be easily tracked and debugged
Capability pattern ensures only admin can perform important operations
Validation is performed systematically
Extensibility and Maintainability
Easy to add new error codes as the platform grows
Utils can be extended with new utility functions without affecting existing code
Easy to update error handling logic when needed
Code is highly modular, easy to test and maintain
			Detailed Guide on Errors and Utils Modules in Movement Platform
1. Module movement::errors
This module plays a crucial role in managing and handling errors in the system. Centralizing error management makes the code easier to maintain and debug.
1.1 Error Code Definition and Management
Error codes are defined in hexadecimal format, making them easy to categorize and extend:
// Errors related to token minting
const E_MINT_BEYOND: u64 = 0x00001;     // Minting amount exceeds allowed limit
const E_INVALID_ADDRESS: u64 = 0x00002;  // Invalid wallet address
const E_NOT_ADMIN: u64 = 0x00003;        // User does not have admin privileges
1.2 Getter Functions and Usage
The module provides getter functions to safely retrieve error codes:
// Public getter functions for error codes
public fun get_e_not_admin(): u64
public fun get_e_mint_beyond(): u64
public fun get_e_invalid_address(): u64
Purpose and Benefits:
Provides a unified interface to access error codes, avoiding hardcoding
Makes code easier to maintain and upgrade when error codes need to be changed
Centralizes error management in one place, making tracking and debugging easier
Ensures consistency in error handling across the codebase
Usage Guide:
// Example 1: Check admin privileges
if (!is_admin(sender)) {
    abort errors::get_e_not_admin()
};
// Example 2: Check mint limit with custom error message
assert!(
    amount <= MAX_MINT_AMOUNT,
    errors::get_e_mint_beyond()
);
2. Module movement::utils
The utils module provides utilities and helper functions frequently used in the platform. Centralizing utility functions helps maintain DRY (Don't Repeat Yourself) principles and improves maintainability.
2.1 Admin Address Management
Function to retrieve and validate admin address:
// Returns the platform's admin address
public fun admin_address(): address {
    @movement  // Address is hardcoded to ensure security
}
Returns the admin address (@movement) - this address is used for permission management
Used to verify permissions and access important system capabilities
Ensures consistency when accessing admin address across the codebase
2.2 Admin Verification
Function to check admin privileges:
// Check if a signer is an admin
public fun is_admin(sender: &signer): bool {
    signer::address_of(sender) == @movement
}
Checks if the caller is an admin through their address
Compares the sender's address with the defined admin address
Used before important operations requiring admin privileges
3. Platform Integration Guide
3.1 Verification and Access Control
Example of using modules in functions requiring admin privileges:
public fun mint_tokens(sender: &signer, amount: u64) {
    // Check admin privileges
    assert!(utils::is_admin(sender), errors::get_e_not_admin());
    // Check mint limit
    assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
    // Continue with mint logic if conditions are met
    // ...
}
3.2 Accessing Capabilities
Example of using admin address to access capabilities:
// Get capability from admin address to perform important operations
let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
// Use capability to perform operation
do_something_with_cap(cap);
3.3 Best Practices in Error Handling
public fun transfer_tokens(
    sender: &signer,
    recipient: address,
    amount: u64
) {
    // Check valid address
    assert!(recipient != @0x0, errors::get_e_invalid_address());
    // Check amount
    assert!(amount > 0, errors::get_e_invalid_amount());
    // Perform transfer if all conditions are ok
    // ...
}
4. Benefits and Best Practices
Code Centralization and Management
Error codes are centrally managed in one place, easy to maintain
Easy to add/modify new error codes without affecting existing code
Admin logic is centralized in utils, ensuring consistency
Reduces code duplication and increases reusability
Enhanced Security
Consistent admin privilege checking across the codebase
Clear error codes that can be easily tracked and debugged
Capability pattern ensures only admin can perform important operations
Validation is performed systematically
Extensibility and Maintainability
Easy to add new error codes as the platform grows
Utils can be extended with new utility functions without affecting existing code
Easy to update error handling logic when needed
Code is highly modular, easy to test and maintain
	Detailed Guide on Errors and Utils Modules in Movement Platform
	Detailed Guide on Errors and Utils Modules in Movement Platform
	1. Module movement::errors
	1. Module movement::errors
	This module plays a crucial role in managing and handling errors in the system. Centralizing error management makes the code easier to maintain and debug.
	This module plays a crucial role in managing and handling errors in the system. Centralizing error management makes the code easier to maintain and debug.
		1.1 Error Code Definition and Management
		1.1 Error Code Definition and Management
		Error codes are defined in hexadecimal format, making them easy to categorize and extend:
		Error codes are defined in hexadecimal format, making them easy to categorize and extend:
		<code>// Errors related to token minting
const E_MINT_BEYOND: u64 = 0x00001;     // Minting amount exceeds allowed limit
const E_INVALID_ADDRESS: u64 = 0x00002;  // Invalid wallet address
const E_NOT_ADMIN: u64 = 0x00003;        // User does not have admin privileges</code>
		<code>// Errors related to token minting
const E_MINT_BEYOND: u64 = 0x00001;     // Minting amount exceeds allowed limit
const E_INVALID_ADDRESS: u64 = 0x00002;  // Invalid wallet address
const E_NOT_ADMIN: u64 = 0x00003;        // User does not have admin privileges</code>
		// Errors related to token minting
const E_MINT_BEYOND: u64 = 0x00001;     // Minting amount exceeds allowed limit
const E_INVALID_ADDRESS: u64 = 0x00002;  // Invalid wallet address
const E_NOT_ADMIN: u64 = 0x00003;        // User does not have admin privileges
		1.2 Getter Functions and Usage
		1.2 Getter Functions and Usage
		The module provides getter functions to safely retrieve error codes:
		The module provides getter functions to safely retrieve error codes:
		<code>// Public getter functions for error codes
public fun get_e_not_admin(): u64
public fun get_e_mint_beyond(): u64
public fun get_e_invalid_address(): u64</code>
		<code>// Public getter functions for error codes
public fun get_e_not_admin(): u64
public fun get_e_mint_beyond(): u64
public fun get_e_invalid_address(): u64</code>
		// Public getter functions for error codes
public fun get_e_not_admin(): u64
public fun get_e_mint_beyond(): u64
public fun get_e_invalid_address(): u64
		Purpose and Benefits:
		Purpose and Benefits:
		Purpose and Benefits:
		Provides a unified interface to access error codes, avoiding hardcoding
Makes code easier to maintain and upgrade when error codes need to be changed
Centralizes error management in one place, making tracking and debugging easier
Ensures consistency in error handling across the codebase
		Provides a unified interface to access error codes, avoiding hardcoding
		Provides a unified interface to access error codes, avoiding hardcoding
		Makes code easier to maintain and upgrade when error codes need to be changed
		Makes code easier to maintain and upgrade when error codes need to be changed
		Centralizes error management in one place, making tracking and debugging easier
		Centralizes error management in one place, making tracking and debugging easier
		Ensures consistency in error handling across the codebase
		Ensures consistency in error handling across the codebase
		Usage Guide:
		Usage Guide:
		Usage Guide:
		<code>// Example 1: Check admin privileges
if (!is_admin(sender)) {
    abort errors::get_e_not_admin()
};
// Example 2: Check mint limit with custom error message
assert!(
    amount <= MAX_MINT_AMOUNT,
    errors::get_e_mint_beyond()
);</code>
		<code>// Example 1: Check admin privileges
if (!is_admin(sender)) {
    abort errors::get_e_not_admin()
};
// Example 2: Check mint limit with custom error message
assert!(
    amount <= MAX_MINT_AMOUNT,
    errors::get_e_mint_beyond()
);</code>
		// Example 1: Check admin privileges
if (!is_admin(sender)) {
    abort errors::get_e_not_admin()
};
// Example 2: Check mint limit with custom error message
assert!(
    amount <= MAX_MINT_AMOUNT,
    errors::get_e_mint_beyond()
);
	2. Module movement::utils
	2. Module movement::utils
	The utils module provides utilities and helper functions frequently used in the platform. Centralizing utility functions helps maintain DRY (Don't Repeat Yourself) principles and improves maintainability.
	The utils module provides utilities and helper functions frequently used in the platform. Centralizing utility functions helps maintain DRY (Don't Repeat Yourself) principles and improves maintainability.
		2.1 Admin Address Management
		2.1 Admin Address Management
		Function to retrieve and validate admin address:
		Function to retrieve and validate admin address:
		<code>// Returns the platform's admin address
public fun admin_address(): address {
    @movement  // Address is hardcoded to ensure security
}</code>
		<code>// Returns the platform's admin address
public fun admin_address(): address {
    @movement  // Address is hardcoded to ensure security
}</code>
		// Returns the platform's admin address
public fun admin_address(): address {
    @movement  // Address is hardcoded to ensure security
}
		Returns the admin address (@movement) - this address is used for permission management
Used to verify permissions and access important system capabilities
Ensures consistency when accessing admin address across the codebase
		Returns the admin address (@movement) - this address is used for permission management
		Returns the admin address (@movement) - this address is used for permission management
		Used to verify permissions and access important system capabilities
		Used to verify permissions and access important system capabilities
		Ensures consistency when accessing admin address across the codebase
		Ensures consistency when accessing admin address across the codebase
		2.2 Admin Verification
		2.2 Admin Verification
		Function to check admin privileges:
		Function to check admin privileges:
		<code>// Check if a signer is an admin
public fun is_admin(sender: &signer): bool {
    signer::address_of(sender) == @movement
}</code>
		<code>// Check if a signer is an admin
public fun is_admin(sender: &signer): bool {
    signer::address_of(sender) == @movement
}</code>
		// Check if a signer is an admin
public fun is_admin(sender: &signer): bool {
    signer::address_of(sender) == @movement
}
		Checks if the caller is an admin through their address
Compares the sender's address with the defined admin address
Used before important operations requiring admin privileges
		Checks if the caller is an admin through their address
		Checks if the caller is an admin through their address
		Compares the sender's address with the defined admin address
		Compares the sender's address with the defined admin address
		Used before important operations requiring admin privileges
		Used before important operations requiring admin privileges
	3. Platform Integration Guide
	3. Platform Integration Guide
		3.1 Verification and Access Control
		3.1 Verification and Access Control
		Example of using modules in functions requiring admin privileges:
		Example of using modules in functions requiring admin privileges:
		<code>public fun mint_tokens(sender: &signer, amount: u64) {
    // Check admin privileges
    assert!(utils::is_admin(sender), errors::get_e_not_admin());
    // Check mint limit
    assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
    // Continue with mint logic if conditions are met
    // ...
}</code>
		<code>public fun mint_tokens(sender: &signer, amount: u64) {
    // Check admin privileges
    assert!(utils::is_admin(sender), errors::get_e_not_admin());
    // Check mint limit
    assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
    // Continue with mint logic if conditions are met
    // ...
}</code>
		public fun mint_tokens(sender: &signer, amount: u64) {
    // Check admin privileges
    assert!(utils::is_admin(sender), errors::get_e_not_admin());
    // Check mint limit
    assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
    // Continue with mint logic if conditions are met
    // ...
}
		3.2 Accessing Capabilities
		3.2 Accessing Capabilities
		Example of using admin address to access capabilities:
		Example of using admin address to access capabilities:
		<code>// Get capability from admin address to perform important operations
let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
// Use capability to perform operation
do_something_with_cap(cap);</code>
		<code>// Get capability from admin address to perform important operations
let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
// Use capability to perform operation
do_something_with_cap(cap);</code>
		// Get capability from admin address to perform important operations
let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
// Use capability to perform operation
do_something_with_cap(cap);
		3.3 Best Practices in Error Handling
		3.3 Best Practices in Error Handling
		<code>public fun transfer_tokens(
    sender: &signer,
    recipient: address,
    amount: u64
) {
    // Check valid address
    assert!(recipient != @0x0, errors::get_e_invalid_address());
    // Check amount
    assert!(amount > 0, errors::get_e_invalid_amount());
    // Perform transfer if all conditions are ok
    // ...
}</code>
		<code>public fun transfer_tokens(
    sender: &signer,
    recipient: address,
    amount: u64
) {
    // Check valid address
    assert!(recipient != @0x0, errors::get_e_invalid_address());
    // Check amount
    assert!(amount > 0, errors::get_e_invalid_amount());
    // Perform transfer if all conditions are ok
    // ...
}</code>
		public fun transfer_tokens(
    sender: &signer,
    recipient: address,
    amount: u64
) {
    // Check valid address
    assert!(recipient != @0x0, errors::get_e_invalid_address());
    // Check amount
    assert!(amount > 0, errors::get_e_invalid_amount());
    // Perform transfer if all conditions are ok
    // ...
}
	4. Benefits and Best Practices
	4. Benefits and Best Practices
	Code Centralization and Management
Error codes are centrally managed in one place, easy to maintain
Easy to add/modify new error codes without affecting existing code
Admin logic is centralized in utils, ensuring consistency
Reduces code duplication and increases reusability
Enhanced Security
Consistent admin privilege checking across the codebase
Clear error codes that can be easily tracked and debugged
Capability pattern ensures only admin can perform important operations
Validation is performed systematically
Extensibility and Maintainability
Easy to add new error codes as the platform grows
Utils can be extended with new utility functions without affecting existing code
Easy to update error handling logic when needed
Code is highly modular, easy to test and maintain
	Code Centralization and Management
Error codes are centrally managed in one place, easy to maintain
Easy to add/modify new error codes without affecting existing code
Admin logic is centralized in utils, ensuring consistency
Reduces code duplication and increases reusability
	Code Centralization and Management
	Code Centralization and Management
	Error codes are centrally managed in one place, easy to maintain
Easy to add/modify new error codes without affecting existing code
Admin logic is centralized in utils, ensuring consistency
Reduces code duplication and increases reusability
	Error codes are centrally managed in one place, easy to maintain
	Error codes are centrally managed in one place, easy to maintain
	Easy to add/modify new error codes without affecting existing code
	Easy to add/modify new error codes without affecting existing code
	Admin logic is centralized in utils, ensuring consistency
	Admin logic is centralized in utils, ensuring consistency
	Reduces code duplication and increases reusability
	Reduces code duplication and increases reusability
	Enhanced Security
Consistent admin privilege checking across the codebase
Clear error codes that can be easily tracked and debugged
Capability pattern ensures only admin can perform important operations
Validation is performed systematically
	Enhanced Security
	Enhanced Security
	Consistent admin privilege checking across the codebase
Clear error codes that can be easily tracked and debugged
Capability pattern ensures only admin can perform important operations
Validation is performed systematically
	Consistent admin privilege checking across the codebase
	Consistent admin privilege checking across the codebase
	Clear error codes that can be easily tracked and debugged
	Clear error codes that can be easily tracked and debugged
	Capability pattern ensures only admin can perform important operations
	Capability pattern ensures only admin can perform important operations
	Validation is performed systematically
	Validation is performed systematically
	Extensibility and Maintainability
Easy to add new error codes as the platform grows
Utils can be extended with new utility functions without affecting existing code
Easy to update error handling logic when needed
Code is highly modular, easy to test and maintain
	Extensibility and Maintainability
	Extensibility and Maintainability
	Easy to add new error codes as the platform grows
Utils can be extended with new utility functions without affecting existing code
Easy to update error handling logic when needed
Code is highly modular, easy to test and maintain
	Easy to add new error codes as the platform grows
	Easy to add new error codes as the platform grows
	Utils can be extended with new utility functions without affecting existing code
	Utils can be extended with new utility functions without affecting existing code
	Easy to update error handling logic when needed
	Easy to update error handling logic when needed
	Code is highly modular, easy to test and maintain
	Code is highly modular, easy to test and maintain

================================================================================

URL: https://developer.movementnetwork.xyz/learning-paths/defi/04-lending-and-borrowing/05-initialize-and-managed-lending-pool
Initialize & Managed Lending Pool
Initialize & Managed Lending Pool
On This Page
Pool Module Guide - Lending & Borrowing Platform
1. Pool Structure
1.1 Pool Struct
2. Core Functions
2.1 Pool Initialization
2.2 Token Deposit
2.3 Token Withdrawal
2.4 Token Borrowing
2.5 Token Repayment
FullCode
Pool Module Guide - Lending & Borrowing Platform
1. Pool Structure
1.1 Pool Struct
struct Pool<phantom CoinType> has key, store {
    token: coin::Coin<CoinType>,        // Token stored in the pool
    borrowed_amount: u64,                // Total tokens borrowed
    deposited_amount: u64,               // Total tokens deposited
    supply_rate: u64,                    // Interest rate for depositors
    borrow_rate: u64,                    // Lending interest rate
    supply_index: u64,                   // Accumulation index for depositors
    borrow_index: u64,                   // Accumulation index for borrowers
    updated_at: u64                      // Last update timestamp
}
2. Core Functions
2.1 Pool Initialization
public entry fun inititial<CoinType>(
    sender: &signer,
    supply_rate_init: u64,
    borrow_rate_init: u64
)
Only admin has permission to initialize pool
Set initial interest rates for depositors and borrowers
Initialize initial indices to 1
2.2 Token Deposit
public entry fun deposit<CoinType>(sender: &signer, amount: u64)
Withdraw token from user wallet
Deposit into pool
Update total deposited tokens
public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let coins = coin::withdraw<CoinType>(sender, amount);
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount + amount;
}
Let's analyze each line of the deposit function:
1. Function declaration:
public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside the module
Parameters include sender and token amount
acquires Pool: indicates function will access Pool resource
2. Withdraw tokens from user wallet:
let coins = coin::withdraw<CoinType>(sender, amount);
Use withdraw function from coin module to withdraw tokens from user wallet
3. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
4. Deposit tokens into Pool:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Use deposit function to send tokens to Pool
5. Update amount:
pool.deposited_amount = pool.deposited_amount + amount;
Update total tokens deposited in Pool
2.3 Token Withdrawal
public entry fun withdraw<CoinType>(sender: &signer, amount: u64)
Withdraw tokens from pool
Transfer to user wallet
Update to decrease deposited tokens
public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    let coins = coin::extract<CoinType>(&mut pool.token, amount);
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount - amount;
}
1. Function declaration:
public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside module
Takes 2 parameters: sender (withdrawer) and amount (withdrawal amount)
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
3. Withdraw tokens from Pool:
let coins = coin::extract<CoinType>(&mut pool.token, amount);
Use extract function to take required amount of tokens from Pool
4. Transfer tokens to user wallet:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Use deposit function to transfer tokens to withdrawer's wallet
5. Update Pool balance:
pool.deposited_amount = pool.deposited_amount - amount;
Decrease total tokens deposited in Pool.deposited_amount - amount;
2.4 Token Borrowing
public entry fun borrow<CoinType>(sender: &signer, amount: u64)
Check and register token for borrower if needed
Withdraw tokens from pool and transfer to borrower
Update to increase borrowed token amount
Let's analyze each step of the borrow function:
1. Function declaration:
public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside the module
Takes borrower (sender) and desired borrow amount (amount) as parameters
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool at admin address
3. Withdraw tokens from Pool:
let coins = coin::extract<CoinType>(&mut pool.token, amount);
Use extract function to take required amount of tokens from Pool
4. Check and register token for borrower:
if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
    managed_coin::register<CoinType>(sender);
};
Check if borrower's account is registered for the token
If not, register the token for them
5. Transfer tokens to borrower:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Transfer withdrawn tokens to borrower's wallet
6. Update Pool balance:
pool.borrowed_amount = pool.borrowed_amount + amount;
2.5 Token Repayment
public entry fun repay<CoinType>(account: &signer, amount: u64)
Withdraw tokens from user wallet
Return to pool
Update to decrease debt amount
Let's analyze each line of code in the repay function:
1. Function declaration:
public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool
Public function can be called from outside module
Takes 2 parameters: account (repayer) and amount (repayment amount)
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
3. Withdraw tokens from user wallet:
let coins = coin::withdraw<CoinType>(account, amount);
Withdraw required tokens from repayer's wallet
4. Deposit tokens to Pool:
coin::merge<CoinType>(&mut pool.token, coins);
Merge withdrawn tokens into Pool
5. Update Pool balance:
pool.deposited_amount = pool.deposited_amount + amount;
FullCode
module movement::pool {
    use movement::utils;
    use movement::errors;
    use aptos_framework::timestamp;
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    struct Pool<phantom CoinType> has key, store {
        token: coin::Coin<CoinType>,
        borrowed_amount: u64,
        deposited_amount: u64,
        supply_rate: u64,
        borrow_rate: u64,
        supply_index: u64,
        borrow_index: u64,
        updated_at: u64
    }
    public entry fun inititial<CoinType>(
        sender: &signer,
        supply_rate_init: u64,
        borrow_rate_init: u64
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        move_to(sender, Pool<CoinType>{
            token: coin::zero<CoinType>(),
            borrowed_amount: 0,
            deposited_amount: 0,
            supply_rate: supply_rate_init,
            borrow_rate: borrow_rate_init,
            supply_index: 1,
            borrow_index: 1,
            updated_at: timestamp::now_microseconds()
        });
    }
    public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let coins = coin::withdraw<CoinType>(sender, amount);
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
    public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount - amount;
    }
    public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.borrowed_amount = pool.borrowed_amount + amount;
    }
    public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::withdraw<CoinType>(account, amount);
        coin::merge<CoinType>(&mut pool.token, coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
}
On This Page
Pool Module Guide - Lending & Borrowing Platform
1. Pool Structure
1.1 Pool Struct
2. Core Functions
2.1 Pool Initialization
2.2 Token Deposit
2.3 Token Withdrawal
2.4 Token Borrowing
2.5 Token Repayment
FullCode
On This Page
Pool Module Guide - Lending & Borrowing Platform
1. Pool Structure
1.1 Pool Struct
2. Core Functions
2.1 Pool Initialization
2.2 Token Deposit
2.3 Token Withdrawal
2.4 Token Borrowing
2.5 Token Repayment
FullCode
			On This Page
			On This Page
			Pool Module Guide - Lending & Borrowing Platform
1. Pool Structure
1.1 Pool Struct
2. Core Functions
2.1 Pool Initialization
2.2 Token Deposit
2.3 Token Withdrawal
2.4 Token Borrowing
2.5 Token Repayment
FullCode
			Pool Module Guide - Lending & Borrowing Platform
			Pool Module Guide - Lending & Borrowing Platform
			Pool Module Guide - Lending & Borrowing Platform
			Pool Module Guide - Lending & Borrowing Platform
			1. Pool Structure
1.1 Pool Struct
			1. Pool Structure
			1. Pool Structure
			1. Pool Structure
			1.1 Pool Struct
			1.1 Pool Struct
			1.1 Pool Struct
			1.1 Pool Struct
			1.1 Pool Struct
			2. Core Functions
2.1 Pool Initialization
2.2 Token Deposit
2.3 Token Withdrawal
2.4 Token Borrowing
2.5 Token Repayment
			2. Core Functions
			2. Core Functions
			2. Core Functions
			2.1 Pool Initialization
2.2 Token Deposit
2.3 Token Withdrawal
2.4 Token Borrowing
2.5 Token Repayment
			2.1 Pool Initialization
			2.1 Pool Initialization
			2.1 Pool Initialization
			2.1 Pool Initialization
			2.2 Token Deposit
			2.2 Token Deposit
			2.2 Token Deposit
			2.2 Token Deposit
			2.3 Token Withdrawal
			2.3 Token Withdrawal
			2.3 Token Withdrawal
			2.3 Token Withdrawal
			2.4 Token Borrowing
			2.4 Token Borrowing
			2.4 Token Borrowing
			2.4 Token Borrowing
			2.5 Token Repayment
			2.5 Token Repayment
			2.5 Token Repayment
			2.5 Token Repayment
			FullCode
			FullCode
			FullCode
			FullCode
			Pool Module Guide - Lending & Borrowing Platform
1. Pool Structure
1.1 Pool Struct
struct Pool<phantom CoinType> has key, store {
    token: coin::Coin<CoinType>,        // Token stored in the pool
    borrowed_amount: u64,                // Total tokens borrowed
    deposited_amount: u64,               // Total tokens deposited
    supply_rate: u64,                    // Interest rate for depositors
    borrow_rate: u64,                    // Lending interest rate
    supply_index: u64,                   // Accumulation index for depositors
    borrow_index: u64,                   // Accumulation index for borrowers
    updated_at: u64                      // Last update timestamp
}
2. Core Functions
2.1 Pool Initialization
public entry fun inititial<CoinType>(
    sender: &signer,
    supply_rate_init: u64,
    borrow_rate_init: u64
)
Only admin has permission to initialize pool
Set initial interest rates for depositors and borrowers
Initialize initial indices to 1
2.2 Token Deposit
public entry fun deposit<CoinType>(sender: &signer, amount: u64)
Withdraw token from user wallet
Deposit into pool
Update total deposited tokens
public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let coins = coin::withdraw<CoinType>(sender, amount);
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount + amount;
}
Let's analyze each line of the deposit function:
1. Function declaration:
public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside the module
Parameters include sender and token amount
acquires Pool: indicates function will access Pool resource
2. Withdraw tokens from user wallet:
let coins = coin::withdraw<CoinType>(sender, amount);
Use withdraw function from coin module to withdraw tokens from user wallet
3. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
4. Deposit tokens into Pool:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Use deposit function to send tokens to Pool
5. Update amount:
pool.deposited_amount = pool.deposited_amount + amount;
Update total tokens deposited in Pool
2.3 Token Withdrawal
public entry fun withdraw<CoinType>(sender: &signer, amount: u64)
Withdraw tokens from pool
Transfer to user wallet
Update to decrease deposited tokens
public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    let coins = coin::extract<CoinType>(&mut pool.token, amount);
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount - amount;
}
1. Function declaration:
public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside module
Takes 2 parameters: sender (withdrawer) and amount (withdrawal amount)
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
3. Withdraw tokens from Pool:
let coins = coin::extract<CoinType>(&mut pool.token, amount);
Use extract function to take required amount of tokens from Pool
4. Transfer tokens to user wallet:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Use deposit function to transfer tokens to withdrawer's wallet
5. Update Pool balance:
pool.deposited_amount = pool.deposited_amount - amount;
Decrease total tokens deposited in Pool.deposited_amount - amount;
2.4 Token Borrowing
public entry fun borrow<CoinType>(sender: &signer, amount: u64)
Check and register token for borrower if needed
Withdraw tokens from pool and transfer to borrower
Update to increase borrowed token amount
Let's analyze each step of the borrow function:
1. Function declaration:
public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside the module
Takes borrower (sender) and desired borrow amount (amount) as parameters
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool at admin address
3. Withdraw tokens from Pool:
let coins = coin::extract<CoinType>(&mut pool.token, amount);
Use extract function to take required amount of tokens from Pool
4. Check and register token for borrower:
if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
    managed_coin::register<CoinType>(sender);
};
Check if borrower's account is registered for the token
If not, register the token for them
5. Transfer tokens to borrower:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Transfer withdrawn tokens to borrower's wallet
6. Update Pool balance:
pool.borrowed_amount = pool.borrowed_amount + amount;
2.5 Token Repayment
public entry fun repay<CoinType>(account: &signer, amount: u64)
Withdraw tokens from user wallet
Return to pool
Update to decrease debt amount
Let's analyze each line of code in the repay function:
1. Function declaration:
public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool
Public function can be called from outside module
Takes 2 parameters: account (repayer) and amount (repayment amount)
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
3. Withdraw tokens from user wallet:
let coins = coin::withdraw<CoinType>(account, amount);
Withdraw required tokens from repayer's wallet
4. Deposit tokens to Pool:
coin::merge<CoinType>(&mut pool.token, coins);
Merge withdrawn tokens into Pool
5. Update Pool balance:
pool.deposited_amount = pool.deposited_amount + amount;
FullCode
module movement::pool {
    use movement::utils;
    use movement::errors;
    use aptos_framework::timestamp;
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    struct Pool<phantom CoinType> has key, store {
        token: coin::Coin<CoinType>,
        borrowed_amount: u64,
        deposited_amount: u64,
        supply_rate: u64,
        borrow_rate: u64,
        supply_index: u64,
        borrow_index: u64,
        updated_at: u64
    }
    public entry fun inititial<CoinType>(
        sender: &signer,
        supply_rate_init: u64,
        borrow_rate_init: u64
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        move_to(sender, Pool<CoinType>{
            token: coin::zero<CoinType>(),
            borrowed_amount: 0,
            deposited_amount: 0,
            supply_rate: supply_rate_init,
            borrow_rate: borrow_rate_init,
            supply_index: 1,
            borrow_index: 1,
            updated_at: timestamp::now_microseconds()
        });
    }
    public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let coins = coin::withdraw<CoinType>(sender, amount);
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
    public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount - amount;
    }
    public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.borrowed_amount = pool.borrowed_amount + amount;
    }
    public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::withdraw<CoinType>(account, amount);
        coin::merge<CoinType>(&mut pool.token, coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
}
			Pool Module Guide - Lending & Borrowing Platform
1. Pool Structure
1.1 Pool Struct
struct Pool<phantom CoinType> has key, store {
    token: coin::Coin<CoinType>,        // Token stored in the pool
    borrowed_amount: u64,                // Total tokens borrowed
    deposited_amount: u64,               // Total tokens deposited
    supply_rate: u64,                    // Interest rate for depositors
    borrow_rate: u64,                    // Lending interest rate
    supply_index: u64,                   // Accumulation index for depositors
    borrow_index: u64,                   // Accumulation index for borrowers
    updated_at: u64                      // Last update timestamp
}
2. Core Functions
2.1 Pool Initialization
public entry fun inititial<CoinType>(
    sender: &signer,
    supply_rate_init: u64,
    borrow_rate_init: u64
)
Only admin has permission to initialize pool
Set initial interest rates for depositors and borrowers
Initialize initial indices to 1
2.2 Token Deposit
public entry fun deposit<CoinType>(sender: &signer, amount: u64)
Withdraw token from user wallet
Deposit into pool
Update total deposited tokens
public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let coins = coin::withdraw<CoinType>(sender, amount);
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount + amount;
}
Let's analyze each line of the deposit function:
1. Function declaration:
public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside the module
Parameters include sender and token amount
acquires Pool: indicates function will access Pool resource
2. Withdraw tokens from user wallet:
let coins = coin::withdraw<CoinType>(sender, amount);
Use withdraw function from coin module to withdraw tokens from user wallet
3. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
4. Deposit tokens into Pool:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Use deposit function to send tokens to Pool
5. Update amount:
pool.deposited_amount = pool.deposited_amount + amount;
Update total tokens deposited in Pool
2.3 Token Withdrawal
public entry fun withdraw<CoinType>(sender: &signer, amount: u64)
Withdraw tokens from pool
Transfer to user wallet
Update to decrease deposited tokens
public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    let coins = coin::extract<CoinType>(&mut pool.token, amount);
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount - amount;
}
1. Function declaration:
public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside module
Takes 2 parameters: sender (withdrawer) and amount (withdrawal amount)
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
3. Withdraw tokens from Pool:
let coins = coin::extract<CoinType>(&mut pool.token, amount);
Use extract function to take required amount of tokens from Pool
4. Transfer tokens to user wallet:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Use deposit function to transfer tokens to withdrawer's wallet
5. Update Pool balance:
pool.deposited_amount = pool.deposited_amount - amount;
Decrease total tokens deposited in Pool.deposited_amount - amount;
2.4 Token Borrowing
public entry fun borrow<CoinType>(sender: &signer, amount: u64)
Check and register token for borrower if needed
Withdraw tokens from pool and transfer to borrower
Update to increase borrowed token amount
Let's analyze each step of the borrow function:
1. Function declaration:
public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside the module
Takes borrower (sender) and desired borrow amount (amount) as parameters
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool at admin address
3. Withdraw tokens from Pool:
let coins = coin::extract<CoinType>(&mut pool.token, amount);
Use extract function to take required amount of tokens from Pool
4. Check and register token for borrower:
if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
    managed_coin::register<CoinType>(sender);
};
Check if borrower's account is registered for the token
If not, register the token for them
5. Transfer tokens to borrower:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Transfer withdrawn tokens to borrower's wallet
6. Update Pool balance:
pool.borrowed_amount = pool.borrowed_amount + amount;
2.5 Token Repayment
public entry fun repay<CoinType>(account: &signer, amount: u64)
Withdraw tokens from user wallet
Return to pool
Update to decrease debt amount
Let's analyze each line of code in the repay function:
1. Function declaration:
public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool
Public function can be called from outside module
Takes 2 parameters: account (repayer) and amount (repayment amount)
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
3. Withdraw tokens from user wallet:
let coins = coin::withdraw<CoinType>(account, amount);
Withdraw required tokens from repayer's wallet
4. Deposit tokens to Pool:
coin::merge<CoinType>(&mut pool.token, coins);
Merge withdrawn tokens into Pool
5. Update Pool balance:
pool.deposited_amount = pool.deposited_amount + amount;
FullCode
module movement::pool {
    use movement::utils;
    use movement::errors;
    use aptos_framework::timestamp;
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    struct Pool<phantom CoinType> has key, store {
        token: coin::Coin<CoinType>,
        borrowed_amount: u64,
        deposited_amount: u64,
        supply_rate: u64,
        borrow_rate: u64,
        supply_index: u64,
        borrow_index: u64,
        updated_at: u64
    }
    public entry fun inititial<CoinType>(
        sender: &signer,
        supply_rate_init: u64,
        borrow_rate_init: u64
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        move_to(sender, Pool<CoinType>{
            token: coin::zero<CoinType>(),
            borrowed_amount: 0,
            deposited_amount: 0,
            supply_rate: supply_rate_init,
            borrow_rate: borrow_rate_init,
            supply_index: 1,
            borrow_index: 1,
            updated_at: timestamp::now_microseconds()
        });
    }
    public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let coins = coin::withdraw<CoinType>(sender, amount);
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
    public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount - amount;
    }
    public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.borrowed_amount = pool.borrowed_amount + amount;
    }
    public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::withdraw<CoinType>(account, amount);
        coin::merge<CoinType>(&mut pool.token, coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
}
			Pool Module Guide - Lending & Borrowing Platform
1. Pool Structure
1.1 Pool Struct
struct Pool<phantom CoinType> has key, store {
    token: coin::Coin<CoinType>,        // Token stored in the pool
    borrowed_amount: u64,                // Total tokens borrowed
    deposited_amount: u64,               // Total tokens deposited
    supply_rate: u64,                    // Interest rate for depositors
    borrow_rate: u64,                    // Lending interest rate
    supply_index: u64,                   // Accumulation index for depositors
    borrow_index: u64,                   // Accumulation index for borrowers
    updated_at: u64                      // Last update timestamp
}
2. Core Functions
2.1 Pool Initialization
public entry fun inititial<CoinType>(
    sender: &signer,
    supply_rate_init: u64,
    borrow_rate_init: u64
)
Only admin has permission to initialize pool
Set initial interest rates for depositors and borrowers
Initialize initial indices to 1
2.2 Token Deposit
public entry fun deposit<CoinType>(sender: &signer, amount: u64)
Withdraw token from user wallet
Deposit into pool
Update total deposited tokens
public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let coins = coin::withdraw<CoinType>(sender, amount);
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount + amount;
}
Let's analyze each line of the deposit function:
1. Function declaration:
public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside the module
Parameters include sender and token amount
acquires Pool: indicates function will access Pool resource
2. Withdraw tokens from user wallet:
let coins = coin::withdraw<CoinType>(sender, amount);
Use withdraw function from coin module to withdraw tokens from user wallet
3. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
4. Deposit tokens into Pool:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Use deposit function to send tokens to Pool
5. Update amount:
pool.deposited_amount = pool.deposited_amount + amount;
Update total tokens deposited in Pool
2.3 Token Withdrawal
public entry fun withdraw<CoinType>(sender: &signer, amount: u64)
Withdraw tokens from pool
Transfer to user wallet
Update to decrease deposited tokens
public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    let coins = coin::extract<CoinType>(&mut pool.token, amount);
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount - amount;
}
1. Function declaration:
public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside module
Takes 2 parameters: sender (withdrawer) and amount (withdrawal amount)
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
3. Withdraw tokens from Pool:
let coins = coin::extract<CoinType>(&mut pool.token, amount);
Use extract function to take required amount of tokens from Pool
4. Transfer tokens to user wallet:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Use deposit function to transfer tokens to withdrawer's wallet
5. Update Pool balance:
pool.deposited_amount = pool.deposited_amount - amount;
Decrease total tokens deposited in Pool.deposited_amount - amount;
2.4 Token Borrowing
public entry fun borrow<CoinType>(sender: &signer, amount: u64)
Check and register token for borrower if needed
Withdraw tokens from pool and transfer to borrower
Update to increase borrowed token amount
Let's analyze each step of the borrow function:
1. Function declaration:
public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool
Public function can be called from outside the module
Takes borrower (sender) and desired borrow amount (amount) as parameters
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool at admin address
3. Withdraw tokens from Pool:
let coins = coin::extract<CoinType>(&mut pool.token, amount);
Use extract function to take required amount of tokens from Pool
4. Check and register token for borrower:
if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
    managed_coin::register<CoinType>(sender);
};
Check if borrower's account is registered for the token
If not, register the token for them
5. Transfer tokens to borrower:
coin::deposit<CoinType>(signer::address_of(sender), coins);
Transfer withdrawn tokens to borrower's wallet
6. Update Pool balance:
pool.borrowed_amount = pool.borrowed_amount + amount;
2.5 Token Repayment
public entry fun repay<CoinType>(account: &signer, amount: u64)
Withdraw tokens from user wallet
Return to pool
Update to decrease debt amount
Let's analyze each line of code in the repay function:
1. Function declaration:
public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool
Public function can be called from outside module
Takes 2 parameters: account (repayer) and amount (repayment amount)
acquires Pool: indicates function will access Pool resource
2. Get Pool reference:
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
Get mutable reference to Pool stored at admin address
3. Withdraw tokens from user wallet:
let coins = coin::withdraw<CoinType>(account, amount);
Withdraw required tokens from repayer's wallet
4. Deposit tokens to Pool:
coin::merge<CoinType>(&mut pool.token, coins);
Merge withdrawn tokens into Pool
5. Update Pool balance:
pool.deposited_amount = pool.deposited_amount + amount;
FullCode
module movement::pool {
    use movement::utils;
    use movement::errors;
    use aptos_framework::timestamp;
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    struct Pool<phantom CoinType> has key, store {
        token: coin::Coin<CoinType>,
        borrowed_amount: u64,
        deposited_amount: u64,
        supply_rate: u64,
        borrow_rate: u64,
        supply_index: u64,
        borrow_index: u64,
        updated_at: u64
    }
    public entry fun inititial<CoinType>(
        sender: &signer,
        supply_rate_init: u64,
        borrow_rate_init: u64
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        move_to(sender, Pool<CoinType>{
            token: coin::zero<CoinType>(),
            borrowed_amount: 0,
            deposited_amount: 0,
            supply_rate: supply_rate_init,
            borrow_rate: borrow_rate_init,
            supply_index: 1,
            borrow_index: 1,
            updated_at: timestamp::now_microseconds()
        });
    }
    public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let coins = coin::withdraw<CoinType>(sender, amount);
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
    public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount - amount;
    }
    public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.borrowed_amount = pool.borrowed_amount + amount;
    }
    public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::withdraw<CoinType>(account, amount);
        coin::merge<CoinType>(&mut pool.token, coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
}
	Pool Module Guide - Lending & Borrowing Platform
	Pool Module Guide - Lending & Borrowing Platform
	1. Pool Structure
	1. Pool Structure
		1.1 Pool Struct
		1.1 Pool Struct
		<code>struct Pool<phantom CoinType> has key, store {
    token: coin::Coin<CoinType>,        // Token stored in the pool
    borrowed_amount: u64,                // Total tokens borrowed
    deposited_amount: u64,               // Total tokens deposited
    supply_rate: u64,                    // Interest rate for depositors
    borrow_rate: u64,                    // Lending interest rate
    supply_index: u64,                   // Accumulation index for depositors
    borrow_index: u64,                   // Accumulation index for borrowers
    updated_at: u64                      // Last update timestamp
}</code>
		<code>struct Pool<phantom CoinType> has key, store {
    token: coin::Coin<CoinType>,        // Token stored in the pool
    borrowed_amount: u64,                // Total tokens borrowed
    deposited_amount: u64,               // Total tokens deposited
    supply_rate: u64,                    // Interest rate for depositors
    borrow_rate: u64,                    // Lending interest rate
    supply_index: u64,                   // Accumulation index for depositors
    borrow_index: u64,                   // Accumulation index for borrowers
    updated_at: u64                      // Last update timestamp
}</code>
		struct Pool<phantom CoinType> has key, store {
    token: coin::Coin<CoinType>,        // Token stored in the pool
    borrowed_amount: u64,                // Total tokens borrowed
    deposited_amount: u64,               // Total tokens deposited
    supply_rate: u64,                    // Interest rate for depositors
    borrow_rate: u64,                    // Lending interest rate
    supply_index: u64,                   // Accumulation index for depositors
    borrow_index: u64,                   // Accumulation index for borrowers
    updated_at: u64                      // Last update timestamp
}
	2. Core Functions
	2. Core Functions
		2.1 Pool Initialization
		2.1 Pool Initialization
		<code>public entry fun inititial<CoinType>(
    sender: &signer,
    supply_rate_init: u64,
    borrow_rate_init: u64
)</code>
		<code>public entry fun inititial<CoinType>(
    sender: &signer,
    supply_rate_init: u64,
    borrow_rate_init: u64
)</code>
		public entry fun inititial<CoinType>(
    sender: &signer,
    supply_rate_init: u64,
    borrow_rate_init: u64
)
		Only admin has permission to initialize pool
Set initial interest rates for depositors and borrowers
Initialize initial indices to 1
		Only admin has permission to initialize pool
		Only admin has permission to initialize pool
		Set initial interest rates for depositors and borrowers
		Set initial interest rates for depositors and borrowers
		Initialize initial indices to 1
		Initialize initial indices to 1
		2.2 Token Deposit
		2.2 Token Deposit
		<code>public entry fun deposit<CoinType>(sender: &signer, amount: u64)</code>
		<code>public entry fun deposit<CoinType>(sender: &signer, amount: u64)</code>
		public entry fun deposit<CoinType>(sender: &signer, amount: u64)
		Withdraw token from user wallet
Deposit into pool
Update total deposited tokens
		Withdraw token from user wallet
		Withdraw token from user wallet
		Deposit into pool
		Deposit into pool
		Update total deposited tokens
		Update total deposited tokens
		<code>public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let coins = coin::withdraw<CoinType>(sender, amount);
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount + amount;
}</code>
		<code>public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let coins = coin::withdraw<CoinType>(sender, amount);
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount + amount;
}</code>
		public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let coins = coin::withdraw<CoinType>(sender, amount);
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount + amount;
}
		Let's analyze each line of the deposit function:
		Let's analyze each line of the deposit function:
		1. Function declaration:
		1. Function declaration:
		1. Function declaration:
		<code>public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool</code>
		<code>public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool</code>
		public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool
		Public function can be called from outside the module
Parameters include sender and token amount
acquires Pool: indicates function will access Pool resource
		Public function can be called from outside the module
		Public function can be called from outside the module
		Parameters include sender and token amount
		Parameters include sender and token amount
		acquires Pool: indicates function will access Pool resource
		acquires Pool: indicates function will access Pool resource
		2. Withdraw tokens from user wallet:
		2. Withdraw tokens from user wallet:
		2. Withdraw tokens from user wallet:
		<code>let coins = coin::withdraw<CoinType>(sender, amount);</code>
		<code>let coins = coin::withdraw<CoinType>(sender, amount);</code>
		let coins = coin::withdraw<CoinType>(sender, amount);
		Use withdraw function from coin module to withdraw tokens from user wallet
		Use withdraw function from coin module to withdraw tokens from user wallet
		Use withdraw function from coin module to withdraw tokens from user wallet
		3. Get Pool reference:
		3. Get Pool reference:
		3. Get Pool reference:
		<code>let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());</code>
		<code>let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());</code>
		let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
		Get mutable reference to Pool stored at admin address
		Get mutable reference to Pool stored at admin address
		Get mutable reference to Pool stored at admin address
		4. Deposit tokens into Pool:
		4. Deposit tokens into Pool:
		4. Deposit tokens into Pool:
		<code>coin::deposit<CoinType>(signer::address_of(sender), coins);</code>
		<code>coin::deposit<CoinType>(signer::address_of(sender), coins);</code>
		coin::deposit<CoinType>(signer::address_of(sender), coins);
		Use deposit function to send tokens to Pool
		Use deposit function to send tokens to Pool
		Use deposit function to send tokens to Pool
		5. Update amount:
		5. Update amount:
		5. Update amount:
		<code>pool.deposited_amount = pool.deposited_amount + amount;</code>
		<code>pool.deposited_amount = pool.deposited_amount + amount;</code>
		pool.deposited_amount = pool.deposited_amount + amount;
		Update total tokens deposited in Pool
		Update total tokens deposited in Pool
		Update total tokens deposited in Pool
		2.3 Token Withdrawal
		2.3 Token Withdrawal
		<code>public entry fun withdraw<CoinType>(sender: &signer, amount: u64)</code>
		<code>public entry fun withdraw<CoinType>(sender: &signer, amount: u64)</code>
		public entry fun withdraw<CoinType>(sender: &signer, amount: u64)
		Withdraw tokens from pool
Transfer to user wallet
Update to decrease deposited tokens
		Withdraw tokens from pool
		Withdraw tokens from pool
		Transfer to user wallet
		Transfer to user wallet
		Update to decrease deposited tokens
		Update to decrease deposited tokens
		<code>public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    let coins = coin::extract<CoinType>(&mut pool.token, amount);
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount - amount;
}</code>
		<code>public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    let coins = coin::extract<CoinType>(&mut pool.token, amount);
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount - amount;
}</code>
		public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
    let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
    let coins = coin::extract<CoinType>(&mut pool.token, amount);
    coin::deposit<CoinType>(signer::address_of(sender), coins);
    pool.deposited_amount = pool.deposited_amount - amount;
}
		1. Function declaration:
		1. Function declaration:
		1. Function declaration:
		<code>public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool</code>
		<code>public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool</code>
		public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool
		Public function can be called from outside module
Takes 2 parameters: sender (withdrawer) and amount (withdrawal amount)
acquires Pool: indicates function will access Pool resource
		Public function can be called from outside module
		Public function can be called from outside module
		Takes 2 parameters: sender (withdrawer) and amount (withdrawal amount)
		Takes 2 parameters: sender (withdrawer) and amount (withdrawal amount)
		acquires Pool: indicates function will access Pool resource
		acquires Pool: indicates function will access Pool resource
		2. Get Pool reference:
		2. Get Pool reference:
		2. Get Pool reference:
		<code>let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());</code>
		<code>let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());</code>
		let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
		Get mutable reference to Pool stored at admin address
		Get mutable reference to Pool stored at admin address
		Get mutable reference to Pool stored at admin address
		3. Withdraw tokens from Pool:
		3. Withdraw tokens from Pool:
		3. Withdraw tokens from Pool:
		<code>let coins = coin::extract<CoinType>(&mut pool.token, amount);</code>
		<code>let coins = coin::extract<CoinType>(&mut pool.token, amount);</code>
		let coins = coin::extract<CoinType>(&mut pool.token, amount);
		Use extract function to take required amount of tokens from Pool
		Use extract function to take required amount of tokens from Pool
		Use extract function to take required amount of tokens from Pool
		4. Transfer tokens to user wallet:
		4. Transfer tokens to user wallet:
		4. Transfer tokens to user wallet:
		<code>coin::deposit<CoinType>(signer::address_of(sender), coins);</code>
		<code>coin::deposit<CoinType>(signer::address_of(sender), coins);</code>
		coin::deposit<CoinType>(signer::address_of(sender), coins);
		Use deposit function to transfer tokens to withdrawer's wallet
		Use deposit function to transfer tokens to withdrawer's wallet
		Use deposit function to transfer tokens to withdrawer's wallet
		5. Update Pool balance:
		5. Update Pool balance:
		5. Update Pool balance:
		<code>pool.deposited_amount = pool.deposited_amount - amount;</code>
		<code>pool.deposited_amount = pool.deposited_amount - amount;</code>
		pool.deposited_amount = pool.deposited_amount - amount;
		Decrease total tokens deposited in Pool.deposited_amount - amount;
		Decrease total tokens deposited in Pool.deposited_amount - amount;
		Decrease total tokens deposited in Pool.deposited_amount - amount;
		2.4 Token Borrowing
		2.4 Token Borrowing
		<code>public entry fun borrow<CoinType>(sender: &signer, amount: u64)</code>
		<code>public entry fun borrow<CoinType>(sender: &signer, amount: u64)</code>
		public entry fun borrow<CoinType>(sender: &signer, amount: u64)
		Check and register token for borrower if needed
Withdraw tokens from pool and transfer to borrower
Update to increase borrowed token amount
		Check and register token for borrower if needed
		Check and register token for borrower if needed
		Withdraw tokens from pool and transfer to borrower
		Withdraw tokens from pool and transfer to borrower
		Update to increase borrowed token amount
		Update to increase borrowed token amount
		<code>Let's analyze each step of the borrow function:</code>
		<code>Let's analyze each step of the borrow function:</code>
		Let's analyze each step of the borrow function:
		1. Function declaration:
		1. Function declaration:
		1. Function declaration:
		<code>public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool</code>
		<code>public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool</code>
		public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool
		Public function can be called from outside the module
Takes borrower (sender) and desired borrow amount (amount) as parameters
acquires Pool: indicates function will access Pool resource
		Public function can be called from outside the module
		Public function can be called from outside the module
		Takes borrower (sender) and desired borrow amount (amount) as parameters
		Takes borrower (sender) and desired borrow amount (amount) as parameters
		acquires Pool: indicates function will access Pool resource
		acquires Pool: indicates function will access Pool resource
		2. Get Pool reference:
		2. Get Pool reference:
		2. Get Pool reference:
		<code>let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());</code>
		<code>let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());</code>
		let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
		Get mutable reference to Pool at admin address
		Get mutable reference to Pool at admin address
		Get mutable reference to Pool at admin address
		3. Withdraw tokens from Pool:
		3. Withdraw tokens from Pool:
		3. Withdraw tokens from Pool:
		<code>let coins = coin::extract<CoinType>(&mut pool.token, amount);</code>
		<code>let coins = coin::extract<CoinType>(&mut pool.token, amount);</code>
		let coins = coin::extract<CoinType>(&mut pool.token, amount);
		Use extract function to take required amount of tokens from Pool
		Use extract function to take required amount of tokens from Pool
		Use extract function to take required amount of tokens from Pool
		4. Check and register token for borrower:
		4. Check and register token for borrower:
		4. Check and register token for borrower:
		<code>if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
    managed_coin::register<CoinType>(sender);
};</code>
		<code>if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
    managed_coin::register<CoinType>(sender);
};</code>
		if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
    managed_coin::register<CoinType>(sender);
};
		Check if borrower's account is registered for the token
If not, register the token for them
		Check if borrower's account is registered for the token
		Check if borrower's account is registered for the token
		If not, register the token for them
		If not, register the token for them
		5. Transfer tokens to borrower:
		5. Transfer tokens to borrower:
		5. Transfer tokens to borrower:
		<code>coin::deposit<CoinType>(signer::address_of(sender), coins);</code>
		<code>coin::deposit<CoinType>(signer::address_of(sender), coins);</code>
		coin::deposit<CoinType>(signer::address_of(sender), coins);
		Transfer withdrawn tokens to borrower's wallet
		Transfer withdrawn tokens to borrower's wallet
		Transfer withdrawn tokens to borrower's wallet
		6. Update Pool balance:
		6. Update Pool balance:
		6. Update Pool balance:
		<code>pool.borrowed_amount = pool.borrowed_amount + amount;</code>
		<code>pool.borrowed_amount = pool.borrowed_amount + amount;</code>
		pool.borrowed_amount = pool.borrowed_amount + amount;
		2.5 Token Repayment
		2.5 Token Repayment
		<code>public entry fun repay<CoinType>(account: &signer, amount: u64)</code>
		<code>public entry fun repay<CoinType>(account: &signer, amount: u64)</code>
		public entry fun repay<CoinType>(account: &signer, amount: u64)
		Withdraw tokens from user wallet
Return to pool
Update to decrease debt amount
		Withdraw tokens from user wallet
		Withdraw tokens from user wallet
		Return to pool
		Return to pool
		Update to decrease debt amount
		Update to decrease debt amount
		<code>Let's analyze each line of code in the repay function:</code>
		<code>Let's analyze each line of code in the repay function:</code>
		Let's analyze each line of code in the repay function:
		1. Function declaration:
		1. Function declaration:
		1. Function declaration:
		<code>public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool</code>
		<code>public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool</code>
		public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool
		Public function can be called from outside module
Takes 2 parameters: account (repayer) and amount (repayment amount)
acquires Pool: indicates function will access Pool resource
		Public function can be called from outside module
		Public function can be called from outside module
		Takes 2 parameters: account (repayer) and amount (repayment amount)
		Takes 2 parameters: account (repayer) and amount (repayment amount)
		acquires Pool: indicates function will access Pool resource
		acquires Pool: indicates function will access Pool resource
		2. Get Pool reference:
		2. Get Pool reference:
		2. Get Pool reference:
		<code>let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());</code>
		<code>let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());</code>
		let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
		Get mutable reference to Pool stored at admin address
		Get mutable reference to Pool stored at admin address
		Get mutable reference to Pool stored at admin address
		3. Withdraw tokens from user wallet:
		3. Withdraw tokens from user wallet:
		3. Withdraw tokens from user wallet:
		<code>let coins = coin::withdraw<CoinType>(account, amount);</code>
		<code>let coins = coin::withdraw<CoinType>(account, amount);</code>
		let coins = coin::withdraw<CoinType>(account, amount);
		Withdraw required tokens from repayer's wallet
		Withdraw required tokens from repayer's wallet
		Withdraw required tokens from repayer's wallet
		4. Deposit tokens to Pool:
		4. Deposit tokens to Pool:
		4. Deposit tokens to Pool:
		<code>coin::merge<CoinType>(&mut pool.token, coins);</code>
		<code>coin::merge<CoinType>(&mut pool.token, coins);</code>
		coin::merge<CoinType>(&mut pool.token, coins);
		Merge withdrawn tokens into Pool
		Merge withdrawn tokens into Pool
		Merge withdrawn tokens into Pool
		5. Update Pool balance:
		5. Update Pool balance:
		5. Update Pool balance:
		<code>pool.deposited_amount = pool.deposited_amount + amount;</code>
		<code>pool.deposited_amount = pool.deposited_amount + amount;</code>
		pool.deposited_amount = pool.deposited_amount + amount;
	FullCode
	FullCode
	<code>module movement::pool {
    use movement::utils;
    use movement::errors;
    use aptos_framework::timestamp;
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    struct Pool<phantom CoinType> has key, store {
        token: coin::Coin<CoinType>,
        borrowed_amount: u64,
        deposited_amount: u64,
        supply_rate: u64,
        borrow_rate: u64,
        supply_index: u64,
        borrow_index: u64,
        updated_at: u64
    }
    public entry fun inititial<CoinType>(
        sender: &signer,
        supply_rate_init: u64,
        borrow_rate_init: u64
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        move_to(sender, Pool<CoinType>{
            token: coin::zero<CoinType>(),
            borrowed_amount: 0,
            deposited_amount: 0,
            supply_rate: supply_rate_init,
            borrow_rate: borrow_rate_init,
            supply_index: 1,
            borrow_index: 1,
            updated_at: timestamp::now_microseconds()
        });
    }
    public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let coins = coin::withdraw<CoinType>(sender, amount);
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
    public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount - amount;
    }
    public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.borrowed_amount = pool.borrowed_amount + amount;
    }
    public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::withdraw<CoinType>(account, amount);
        coin::merge<CoinType>(&mut pool.token, coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
}</code>
	<code>module movement::pool {
    use movement::utils;
    use movement::errors;
    use aptos_framework::timestamp;
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    struct Pool<phantom CoinType> has key, store {
        token: coin::Coin<CoinType>,
        borrowed_amount: u64,
        deposited_amount: u64,
        supply_rate: u64,
        borrow_rate: u64,
        supply_index: u64,
        borrow_index: u64,
        updated_at: u64
    }
    public entry fun inititial<CoinType>(
        sender: &signer,
        supply_rate_init: u64,
        borrow_rate_init: u64
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        move_to(sender, Pool<CoinType>{
            token: coin::zero<CoinType>(),
            borrowed_amount: 0,
            deposited_amount: 0,
            supply_rate: supply_rate_init,
            borrow_rate: borrow_rate_init,
            supply_index: 1,
            borrow_index: 1,
            updated_at: timestamp::now_microseconds()
        });
    }
    public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let coins = coin::withdraw<CoinType>(sender, amount);
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
    public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount - amount;
    }
    public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.borrowed_amount = pool.borrowed_amount + amount;
    }
    public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::withdraw<CoinType>(account, amount);
        coin::merge<CoinType>(&mut pool.token, coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
}</code>
	module movement::pool {
    use movement::utils;
    use movement::errors;
    use aptos_framework::timestamp;
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    use std::signer;
    struct Pool<phantom CoinType> has key, store {
        token: coin::Coin<CoinType>,
        borrowed_amount: u64,
        deposited_amount: u64,
        supply_rate: u64,
        borrow_rate: u64,
        supply_index: u64,
        borrow_index: u64,
        updated_at: u64
    }
    public entry fun inititial<CoinType>(
        sender: &signer,
        supply_rate_init: u64,
        borrow_rate_init: u64
    ) {
        assert!(utils::is_admin(sender), errors::get_e_not_admin());
        move_to(sender, Pool<CoinType>{
            token: coin::zero<CoinType>(),
            borrowed_amount: 0,
            deposited_amount: 0,
            supply_rate: supply_rate_init,
            borrow_rate: borrow_rate_init,
            supply_index: 1,
            borrow_index: 1,
            updated_at: timestamp::now_microseconds()
        });
    }
    public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let coins = coin::withdraw<CoinType>(sender, amount);
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
    public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.deposited_amount = pool.deposited_amount - amount;
    }
    public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::extract<CoinType>(&mut pool.token, amount);
        if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
            managed_coin::register<CoinType>(sender);
        };
        coin::deposit<CoinType>(signer::address_of(sender), coins);
        pool.borrowed_amount = pool.borrowed_amount + amount;
    }
    public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool {
        let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
        let coins = coin::withdraw<CoinType>(account, amount);
        coin::merge<CoinType>(&mut pool.token, coins);
        pool.deposited_amount = pool.deposited_amount + amount;
    }
}

================================================================================

